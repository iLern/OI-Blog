<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统实验笔记（三）</title>
      <link href="/2020/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="共享内存通信与消息队列通信"><a href="#共享内存通信与消息队列通信" class="headerlink" title="共享内存通信与消息队列通信"></a>共享内存通信与消息队列通信</h1><h2 id="使用管道进行通信的局限"><a href="#使用管道进行通信的局限" class="headerlink" title="使用管道进行通信的局限"></a>使用管道进行通信的局限</h2><p>只能在有家族关系的进程间进行通信</p><p>大小只有4K，不好传输过大的</p><p>Socket一般用于用户进程间的通信</p><p>IP+端口可以唯一定位一台主机上的一个进程，把IP设定为127.0.0.1，可以实现本机间的两个进程通信</p><p>IPC一般用于系统间的通信</p><p>信号量使用集合的方式进行管理，Semaphores Set</p><p>共享内存 Shared Memory Segment</p><p>消息队列 Message Queue</p><p>管道由操作系统进行管理</p><p>IPC需要自己手工管理</p><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><p><code>shmget()</code>创建一个新的共享内存段 / 关联已有的共享内存段，返回一个共享内存段的ID</p><p><code>shmat()</code>获得共享内存段的地址</p><p><code>shmdt</code> 脱离</p><p>写是覆盖写，读是多次读。</p><p>读多少次都不会影响数据的存在，用于进程间的一对多通信，多个进程先后去读结果是一样的。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h2 id="生成Key"><a href="#生成Key" class="headerlink" title="生成Key"></a>生成Key</h2><p>操作系统中唯一标识共享内存段</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统实验笔记（二）</title>
      <link href="/2020/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>中断被封装成信号，多个不同的中断被封装成一个信号。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">称呼</th></tr></thead><tbody><tr><td style="text-align:center">硬件层次</td><td style="text-align:center">中断</td></tr><tr><td style="text-align:center">操作系统层次</td><td style="text-align:center">信号</td></tr><tr><td style="text-align:center">应用程序层次</td><td style="text-align:center">事件</td></tr></tbody></table></div><p>信号可以用编号、名称表示，名称是编号的宏。</p><p><img src="1.png" alt></p><h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>过滤信号，每个进程都有对signal的mask，滤掉的就忽略，没有滤掉的就响应</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><p><img src="2.png" alt></p><p>返回信号处理程序的入口指针，<code>signal()</code>根据编号设置信号处理程序</p><p><img src="3.JPG" alt></p><p>实际是修改进程PCB中的信号表中的函数指针</p><p><img src="3.png" alt></p><p>注意唤醒的时刻，4和alarm有一秒停顿，alarm和5没有间隔，说明收到信号之后进程被立即唤醒</p><p>信号什么时候到来和<code>signal()</code>没有关系</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h2><p>给某个进程发信号</p><p><img src="4.png" alt></p><p><img src="5.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><p>发9号信号给进程，表示终止进程，不能被拦截或忽略</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><p>杀死自己，返回0</p><h2 id="进程软中断通信"><a href="#进程软中断通信" class="headerlink" title="进程软中断通信"></a>进程软中断通信</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据清洗中空格的处理</title>
      <link href="/2020/11/18/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%AD%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2020/11/18/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%AD%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><code>pandas</code>中使用<code>fillna()</code>或者<code>drop()</code>来填充或丢弃包含空值的行和列，但是<code>pandas</code>只认为<code>numpy.nan</code>是空值，实际情况里可能使用空格等空字符来代表空值，这时需要一些特殊处理</p><a id="more"></a><p>原始数据中存在空格</p><p><img src="1.png" alt="1"></p><p><code>df</code>是一个<code>DataFrame</code>，以<code>DataFrame</code>中的列名为索引可以得到一个<code>Series</code>，其中有一个<code>apply</code>方法可以修改其中的值</p><p><code>apply</code>方法为一个高阶函数，接受一个函数<code>func</code>为参数，对<code>Series</code>中的每个元素调用<code>func</code></p><blockquote><p>“””<br>Invoke function on values of Series.</p><p>Can be ufunc (a NumPy function that applies to the entire Series)<br>or a Python function that only works on single values.</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>func : function<br>   Python function or NumPy ufunc to apply.<br>convert_dtype : bool, default True<br>   Try to find better dtype for elementwise function results. If<br>   False, leave as dtype=object.<br>args : tuple<br>   Positional arguments passed to func after the series value.<br>**kwds<br>   Additional keyword arguments passed to func.</p><h2 id="Returns"><a href="#Returns" class="headerlink" title="Returns"></a>Returns</h2><p>Series or DataFrame<br>   If func returns a Series object the result will be a DataFrame.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><p>Series.map: For element-wise operations.<br>Series.agg: Only perform aggregating type operations.<br>Series.transform: Only perform transforming type operations.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Create a series with typical summer temperatures for each city.</p><blockquote><blockquote><blockquote><p>s = pd.Series([20, 21, 12],<br>…               index=[‘London’, ‘New York’, ‘Helsinki’])<br>s<br>London      20<br>New York    21<br>Helsinki    12<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Square the values by defining a function and passing it as an<br>argument to <code>apply()</code>.</p><blockquote><blockquote><blockquote><p>def square(x):<br>…     return x ** 2<br>s.apply(square)<br>London      400<br>New York    441<br>Helsinki    144<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Square the values by passing an anonymous function as an<br>argument to <code>apply()</code>.</p><blockquote><blockquote><blockquote><p>s.apply(lambda x: x ** 2)<br>London      400<br>New York    441<br>Helsinki    144<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Define a custom function that needs additional positional<br>arguments and pass these additional arguments using the<br><code>args</code> keyword.</p><blockquote><blockquote><blockquote><p>def subtract_custom_value(x, custom_value):<br>…     return x - custom_value</p><p>s.apply(subtract_custom_value, args=(5,))<br>London      15<br>New York    16<br>Helsinki     7<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Define a custom function that takes keyword arguments<br>and pass these arguments to <code>apply</code>.</p><blockquote><blockquote><blockquote><p>def add_custom_values(x, **kwargs):<br>…     for month in kwargs:<br>…         x += kwargs[month]<br>…     return x</p><p>s.apply(add_custom_values, june=30, july=20, august=25)<br>London      95<br>New York    96<br>Helsinki    87<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Use a function from the Numpy library.</p><blockquote><blockquote><blockquote><p>s.apply(np.log)<br>London      2.995732<br>New York    3.044522<br>Helsinki    2.484907<br>dtype: float64<br>“””</p></blockquote></blockquote></blockquote></blockquote><p>了解了<code>apply()</code>函数之后，就可以替换原先的空格为<code>np.nan</code>了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'./newFile.csv'</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># none_score = (df['成绩'].isnull()) | (df['成绩'].apply(lambda x: str(x).isspace()))</span></span><br><span class="line"><span class="comment"># df_null = df[none_score]</span></span><br><span class="line"><span class="comment"># print(df_null)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># df_not_null = df[~none_score]</span></span><br><span class="line"><span class="comment"># data1 = df_not_null</span></span><br><span class="line"><span class="comment"># data1.to_csv('./cleaned_newFile.csv', encoding='utf-8_sig', index=None)</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">'成绩'</span>] = df[<span class="string">'成绩'</span>].apply(<span class="keyword">lambda</span> x: np.nan <span class="keyword">if</span> str(x).isspace() <span class="keyword">else</span> x)</span><br><span class="line">df = df.fillna(<span class="number">0</span>)</span><br><span class="line">df.to_csv(<span class="string">'./cleaned_newFile.csv'</span>, encoding=<span class="string">'utf-8_sig'</span>, index=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure></p><p>清洗之后，原本的空值被替换成了0</p><p><img src="2.png" alt="2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统实验笔记（一）</title>
      <link href="/2020/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h2><p>创建子进程，继承父进程<code>fork()</code>之后的的指令序列，复制父进程的数据部分</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p, x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">      x = <span class="number">200</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is parent, x = %d\n"</span>, x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = <span class="number">300</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is child, x = %d\n"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过汇编语言可以很容易理解<code>fork()</code>具有两个返回值的事情，<code>p = fork()</code>是两条指令，而子进程会执行函数调用<code>call fork</code>之后的所有指令，这样子进程和父进程的<code>p</code>就是不一样的。</p><p>当创建失败时<code>fork()</code>会返回<code>-1</code>，为了鲁棒性应该判断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span><span class="string">"test1.c"</span></span><br><span class="line"><span class="meta">.section</span>.rodata</span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"Hello world"</span></span><br><span class="line"><span class="symbol">.LC1:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is parent, x = %d\n"</span></span><br><span class="line"><span class="symbol">.LC2:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is child, x = %d\n"</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span>main</span><br><span class="line"><span class="meta">.type</span>main, @function</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line">leal<span class="number">4</span>(%esp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">andl$-<span class="number">16</span>, %esp</span><br><span class="line">pushl-<span class="number">4</span>(%ecx)</span><br><span class="line">pushl%ebp</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0x10</span>,<span class="number">0x5</span>,<span class="number">0x2</span>,<span class="number">0x75</span>,<span class="number">0</span></span><br><span class="line">movl%esp, %ebp</span><br><span class="line">pushl%ecx</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0xf</span>,<span class="number">0x3</span>,<span class="number">0x75</span>,<span class="number">0x7c</span>,<span class="number">0x6</span></span><br><span class="line">subl<span class="number">$20</span>, %esp</span><br><span class="line">movl<span class="number">$100</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$12</span>, %esp</span><br><span class="line">pushl$.LC0</span><br><span class="line"><span class="keyword">call</span>puts</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span>fork</span><br><span class="line"></span><br><span class="line"><span class="comment">;子进程会执行的部分</span></span><br><span class="line">movl%eax, -<span class="number">12</span>(%ebp)</span><br><span class="line">cmpl<span class="number">$0</span>, -<span class="number">12</span>(%ebp)</span><br><span class="line"><span class="keyword">je</span>.L2</span><br><span class="line">movl<span class="number">$200</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC1</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="keyword">jmp</span>.L3</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">movl<span class="number">$300</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC2</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">movl<span class="number">$0</span>, %eax</span><br><span class="line">movl-<span class="number">4</span>(%ebp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="meta">.cfi_restore</span> <span class="number">5</span></span><br><span class="line">leal-<span class="number">4</span>(%ecx), %esp</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">.size</span>main, .-main</span><br><span class="line"><span class="meta">.ident</span><span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line"><span class="meta">.section</span>.note.GNU-stack,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>下面的代码会构成怎样的进程树？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br></pre></td></tr></table></figure><h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid()"></a>getpid()</h2><p>获得当前进程的进程号</p><p><code>getppid()</code>获得父进程的进程号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//running to blocked</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is parent, my pid = %d, my child = %d\n"</span>, getpid(), p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is child, my pid = %d, my parent = %d\n"</span>, getpid(), getppid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>发现子进程的父进程编号不对，这是因为在执行子进程之前父进程已经执行结束，此时子进程称为孤儿进程<strong>Orphan Process</strong>，父进程被设置成了1305号进程</p><p><img src="4.png" alt="4"></p><p>查看所有进程发现1305号为upstart进程，用于接管孤儿进程</p><p>但是维基百科上说孤儿进程会被<code>init</code>进程或者<code>systemd</code>进程接管</p><p>想要父进程不那么快结束，可以使用<code>sleep(1)</code>让父进程进入阻塞状态一秒钟</p><p><img src="5.png" alt="5"></p><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><ul><li><p>框架的搭建</p></li><li><p>分别完成两个进程的功能</p></li><li><p>互斥和同步</p></li></ul><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line">  p1 = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print from parent process: %d\n"</span>, i);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      <span class="keyword">char</span> ch2 = <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">while</span> (ch2 &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print from Child process 2: %c\n"</span>, ch2);</span><br><span class="line">        ch2++;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    <span class="keyword">char</span> ch1 = <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch1 &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print from Child process 1: %c\n"</span>, ch1);</span><br><span class="line">      ch1++;</span><br><span class="line"></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区长度为一行，\n表示一行结束，会刷新缓冲区</p><p><code>fflush()</code> 刷新缓冲区</p><p>普通进程只往缓冲区写数据，往屏幕写数据是操作系统的事情</p><p>多个进程的缓冲区共用</p><h3 id="两个进程并发的执行情况"><a href="#两个进程并发的执行情况" class="headerlink" title="两个进程并发的执行情况"></a>两个进程并发的执行情况</h3><p><img src="6.png" alt="6"></p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br></pre></td></tr></table></figure><p>父进程一旦调用了<code>wait()</code>就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，<code>wait()</code>就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，<code>wait()</code>就会一直阻塞在这里，直到有一个出现为止。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>对于一个进程，当其进行结束时，进入<strong>终止状态</strong>，此时操作系统的进程表中还留有子进程的PCB。</p><p><img src="7.PNG" alt></p><p>如果此时父进程没有<code>wait()</code>，PCB将会保留，会导致资源泄露。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_pair</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> fd[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct fd_pair <span class="title">pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//on other architectures</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span> <span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><code>fd</code>参数会被设置成两个文件描述符，<code>f[0]</code>表示读，<code>f[1]</code>表示写</p><p><code>pipe</code>会自动保持同步</p><p>管道面向字节流</p><p>管道只允许单向通信（单工？</p><h3 id="使用管道进行进程间通信"><a href="#使用管道进行进程间通信" class="headerlink" title="使用管道进行进程间通信"></a>使用管道进行进程间通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">  pipe(fd1);</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork Error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2[<span class="number">2</span>];</span><br><span class="line">    pipe(fd2);</span><br><span class="line"></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      <span class="keyword">while</span> (read(fd1[<span class="number">0</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent: got data from child1\n"</span>);</span><br><span class="line">        write(fd2[<span class="number">1</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent: sent data to child2\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      <span class="keyword">while</span> (read(fd2[<span class="number">0</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child2: Got the char, print to the screen\n"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        <span class="keyword">else</span> ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putchar(ch);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child2: Done\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf("child1: Waiting for input: \n");</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> ch = getchar();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child1: Got the char '%c', sent to the parent process\n"</span>, ch);</span><br><span class="line">        write(fd1[<span class="number">1</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"char %c, ascii code %d is invaild\n"</span>, ch, ch);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//printf("child1: Waiting for input: \n");</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三进程并发，父进程拥有两个管道，子进程一负责从键盘读取输入，通过管道1发送给父进程，父进程通过管道2把输入发送给子进程2，子进程2进行大小写转换并输出。</p><p>子进程一进行输入过滤，不符合条件的输入会被忽略。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记-内存管理</title>
      <link href="/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"/>
      <url>/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习笔记-网络层（一）</title>
      <link href="/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Page 0 to Page （）</p><a id="more"></a><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>网络层向运输层提供服务</li><li>网络保证可靠 or 端系统保证可靠</li></ul><h3 id="网络负责可靠交互"><a href="#网络负责可靠交互" class="headerlink" title="网络负责可靠交互"></a>网络负责可靠交互</h3><ul><li>虚电路<ul><li>和电路交换类似，都需要建立连接，有电路交换的特点</li><li>但是电路交换具有排他性，虚电路没有，所以称为<strong>虚</strong>电路</li></ul></li><li>虚电路建立<strong>逻辑上</strong>的连接，分组沿着逻辑上的连接进行分组转发</li></ul><h3 id="网络负责最大努力交互"><a href="#网络负责最大努力交互" class="headerlink" title="网络负责最大努力交互"></a>网络负责最大努力交互</h3><ul><li><p>因特网真正的设计思路</p></li><li><p>不提供服务质量的承诺，只进行最大努力、无连接的<strong>数据报服务</strong></p><ul><li><p>可能出错、丢失、重复、失序</p></li><li><p>出错由ICMP解决</p></li></ul></li></ul><h4 id="尽最大努力交付的好处"><a href="#尽最大努力交付的好处" class="headerlink" title="尽最大努力交付的好处"></a>尽最大努力交付的好处</h4><ul><li>路由器可以比较简单，价格低廉</li><li>运输层负责差错处理、流量控制</li><li>网络的造假大大降低，运行方式灵活，能适用多种应用</li></ul><h3 id="虚电路与数据报的对比"><a href="#虚电路与数据报的对比" class="headerlink" title="虚电路与数据报的对比"></a>虚电路与数据报的对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚电路</th><th style="text-align:center">数据报</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">网络保证可靠通信</td><td style="text-align:center">端系统保证可靠通信</td></tr><tr><td style="text-align:center">连接</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">只有建立连接时使用</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发</td><td style="text-align:center">同一条虚电路的分组按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当节点故障时</td><td style="text-align:center">所有通过故障接待您的虚电路均不能工作</td><td style="text-align:center">出故障的节点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按照顺序到达终点</td><td style="text-align:center">到达顺序不一定按照发送顺序</td></tr><tr><td style="text-align:center">差错处理 / 流量控制</td><td style="text-align:center">可以由网络负责， 也可以由主机负责</td><td style="text-align:center">主机负责</td></tr></tbody></table></div><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="配套使用的三个协议"><a href="#配套使用的三个协议" class="headerlink" title="配套使用的三个协议"></a>配套使用的三个协议</h3><ul><li>地址解析协议 ARP<ul><li>Address Reesolution Protocol</li><li>IP地址转换为MAC地址</li><li>IP协议族的较下层</li></ul></li><li>网际控制报文协议 ICMP<ul><li>Internet Control Message Protocol</li><li>控制信息</li><li>IP协议族的较上层</li></ul></li><li>忘记组管理协议 IGMP<ul><li>Internet Group Management Protocol</li><li>实现多播/组播</li><li>IP协议族的较上层</li></ul></li></ul><h3 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h3><ul><li>扩展<ul><li>转发器 物理层</li><li>网桥 数据链路层</li></ul></li><li>互联<ul><li>路由器 网络层</li><li>桥路器 网桥+ 路由器</li><li>网关 网络层以上</li></ul></li></ul><h3 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h3><p>又称逻辑互联网络，当互联网上的主机进行通信时，好像在一个网络上通信一样，虽然不同物理网络的异构性客观存在，但是被屏蔽掉了，对于用户而言，只能看到像在同一个网络上通信而看不到异构细节。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>32位二进制，四个点分十进制数，每个数取值在0 - 255</li><li>定义为 网络号+主机号</li><li>8位一组</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>A类<ul><li>第一位一定是0，前8位（一个字节）表示网络号，后24位表示主机号（三个字节）</li><li>一个网络中主机数最多有$2^{24} - 2 = 16777214$</li><li>最大网络数$2^7 - 2 = 126$<ul><li>全零作为保留地址，意为本网络，不能指派</li><li>全一作为环回测试地址，不能指派</li></ul></li><li>前8位 1 - 127</li></ul></li><li>B类<ul><li>前两位一定是10，前16位（两个字节）表示网络号，后16位表示主机号（两个字节）</li><li>一个网络中主机数最多有$2^{16} - 2 = 65534$</li><li>最大网络数$2 ^ {14} = 16384$<ul><li>最小网络号为 128.0</li><li>二进制为 1000 0000 . 0000 0000</li></ul></li><li>前8位 128 - 191</li></ul></li><li>C类<ul><li>前三位一定是110，前24位（三个字节）表示网络号，后8位表示主机号（一个字节)</li><li>一个网络中主机数最多有$2^{8} - 2= 254$</li><li>最大网络数$2 ^ {21} = 2097152$<ul><li>最小网络号为 192.0.0</li><li>二进制为 1100 0000 . 0000 0000 . 0000 0000</li></ul></li><li>前8位 192 - 223</li></ul></li><li>D类<ul><li>前四位一定是1110，用于多播地址</li><li>前8位 224 - 239</li></ul></li><li>E类<ul><li>前四位为1111，留作以后使用</li><li>前8位 240 - 255</li></ul></li></ul><p><img src="IMG_1551.PNG" alt="IMG-1551"></p><h4 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h4><p><img src="IMG_1552.PNG" alt="IMG-1552"></p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">用作源地址</th><th style="text-align:center">用作目的地址</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">可</td><td style="text-align:center">不n可</td><td style="text-align:center">本网络的本主机，相当于临时牌照，申请IP地址时使用</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">host-id</td><td style="text-align:center">可</td><td style="text-align:center">不可</td><td style="text-align:center">本网络的某台主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">只在本网络进行广播，所有路由器不进行转发</td></tr><tr><td style="text-align:center">net-id</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">网络外成员对net-id中的的所有成员进行广播</td></tr><tr><td style="text-align:center">127（0111 1111）</td><td style="text-align:center">非全零全一</td><td style="text-align:center">可</td><td style="text-align:center">可</td><td style="text-align:center">本地软件环回测试</td></tr></tbody></table></div><h4 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h4><p>10.0.0.0 ———— 10.255.255.255</p><p>(0000 1010 . 0000 0000 . 0000 0000 . 0000 0000 —— 0000 1010 . 1111 1111 . 1111 1111 . 1111 1111)</p><p>172.16.0.0 ———— 172.131.255.255</p><p>(1010 1100 . 0001 0000 . 0000 0000 . 0000 0000 —— 1010 1100 . 1000 0011 . 1111 1111 . 1111 1111)</p><p>192.168.0.0 ———— 192.168.255.255</p><p>(1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 —— 1100 0000 . 1010 1000 . 1111 1111 . 1111 1111)</p><h4 id="重要特点"><a href="#重要特点" class="headerlink" title="重要特点"></a>重要特点</h4><ul><li>分等级<ul><li>IP地址管理机构分配IP只分配网络号，主机号由网络号管理单位自行分配</li><li>路由器仅仅根据目的主机所连接的网络号来转发分组</li><li>这样就可以大大减少路由表的大小</li><li>找到了网络，再找主机就很容易了</li></ul></li><li>IP地址标志一个主机 / 路由器 / 链路的接口<ul><li>路由器属于不同网络的接口有不同的IP地址</li><li>至少有两个不同的IP地址</li></ul></li><li>网桥连接的若干局域网仍拥有相同的网络号，仍属于同一个网络<ul><li>网桥 / 转发器仅仅是扩展网络</li></ul></li><li>只包含一段线路的网络不指明IP地址</li></ul><h2 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h2><p>这里说硬件地址而不是MAC地址，因为链路层及以下使用的的硬件地址有很多种，其中以太网使用MAC地址</p><p>MAC地址 $\in$ 硬件地址</p><ul><li>路由器转发不改变IP源和目的，但是改变MAC源和目的<ul><li>网桥转发不改变MAC源和目的</li><li>路由器转发改变了链路</li></ul></li><li>数据包中间经过的路由器的IP不会出现在IP数据报的首部中</li><li>虽然首部有源站，但是路由器<strong>仅根据</strong>目的站的IP的网络号进行转发<ul><li>只找到网络就行</li></ul></li></ul><h3 id="地址解析协议-ARP-Address-Resolution-Protocal"><a href="#地址解析协议-ARP-Address-Resolution-Protocal" class="headerlink" title="地址解析协议 ARP Address Resolution Protocal"></a>地址解析协议 ARP Address Resolution Protocal</h3><ul><li>从网络层使用的IP地址解析出链路层使用的硬件地址</li><li>每个主机都有一个ARP Cache，里面有所在<strong>局域网</strong>上的各个主机和路由器的IP地址到硬件地址的映射表<ul><li>IP Address；MAC Address；TTL (Time to live) 使用老化策略，过久不使用的地址会被删除</li><li>能够减少ARP广播的数量</li></ul></li><li>发送过程<ul><li>向本局域网中的主机发送</li><li>有就把目的MAC地址写入MAC帧</li><li>没有就<strong>本地广播</strong>发送一个<strong>ARP请求分组</strong>，目的主机<strong>响应</strong>，把目的主机的MAC地址加入ARP Cache<ul><li><strong>本地广播</strong>：路由器不转发；链路层广播，MAC地址全1</li><li><strong>ARP请求分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 <strong>未知时填零</strong>/ 目标方IP地址；所有主机都会记录下发送方的硬件地址</li><li><strong>ARP响应分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 / 目标方IP地址；是广播实现的一对一通信</li></ul></li><li>如果目的主机和源主机不在同一个局域网，发送主机获得的就不是真正目的主机的MAC地址，而是能通往目的主机的路由器的IP地址。此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或<strong>ARP代理（ARP Proxy）</strong>。</li></ul></li><li>为什么不使用硬件地址进行通信<ul><li>异构网络很多，互相通信需要进行复杂的地址转换</li><li>IP使得所有网络像连接在同一个网络一样，把脏活累活交给ARP去做</li></ul></li></ul><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p><img src="IMG_1554.PNG" alt="ip"></p><p>首部、数据</p><p>首部包括固定部分20字节，可选部分长度不定，总共不超过60字节</p><ul><li>版本 4位<ul><li>0100 IPv4   0110 IPv6</li></ul></li><li>首部长度 4位<ul><li>最大表示15个单位，一个单位4字节，所以首部最长60字节</li></ul></li><li>区分服务 8位</li><li>总长度 16位<ul><li>首部长度 + 数据长度</li><li>单位为字节，因此数据报最大长度为$2^{16} - 1 = 65535$字节</li><li>总长度不能超过MTU</li></ul></li><li>标识 16位<ul><li>长度超过MTU则需要分片</li><li>分片后标识来自同一个数据报</li></ul></li><li>标志 3位<ul><li>目前只有前两位有意义</li><li>最低位是MF（More Fragment），中间一位是DF（Don’t Fragment）<ul><li>MF=0 没有分片了</li><li>DF=0 允许分片</li></ul></li></ul></li><li>片偏移 13位<ul><li>表示某片在原分组中的相对位置</li><li>以8字节为偏移单位，需要乘八，也就是左移三位，正好补上标志部分三位的空缺</li></ul></li><li>生存事件TTL 8位<ul><li>每经过一次路由转发，减少一，变成零了还没到目的就丢弃</li></ul></li><li>协议<ul><li>指出为谁服务，上层协议是什么</li></ul></li><li>首部检验和  16位<ul><li>验证首部在传输中有没有出现差错</li><li>二进制反码求和</li><li>IP不检验数据部分，扔给链路层做</li></ul></li><li>源地址、目的地址 各32位</li><li>可变部分<ul><li>最大40字节，需要使长度为4的整数倍，不足则用零填充</li><li>其实很少用</li></ul></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><p>IP分片不是一件好事情，应该能不分就不分</p><ul><li><p>分片之后有哪些字段会变</p><ul><li>总长度</li><li>报头检验和</li><li>MF位</li><li>片偏移</li></ul></li><li><p>分片的坏处</p><ul><li>效率低</li><li>需要缓存</li><li>防火墙可能会拦截</li></ul></li></ul><h2 id="二进制反码求和"><a href="#二进制反码求和" class="headerlink" title="二进制反码求和"></a>二进制反码求和</h2><ul><li>此反码非计组之反码 （ones’ complement）<ul><li>计组中的反码 正数的反码是本身 负数的反码是符号位不变，其余位取反</li></ul></li><li>逐位取反之后再相加（再取反）</li><li>最高位的进位加在最后一位上 (回卷)<ul><li>这样可以使得先加后取反和先取反后加的结果一样</li></ul></li><li>不依赖大端表示 / 小端表示<ul><li>交换十六位数的字节顺序，得到的结果相同，只是字节顺序也相应发生变化</li></ul></li></ul><h2 id="转发分组的流程"><a href="#转发分组的流程" class="headerlink" title="转发分组的流程"></a>转发分组的流程</h2><h3 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a>特定主机路由</h3><p>将IP数据报发送到特定的某个主机上，而不是发送到网络上就结束了</p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>路由表中的Default项，不在匹配其他任何项时按照默认路由进行转发</p><p>可以减少路由表中的条目数</p><h2 id="划分子网与构造超网"><a href="#划分子网与构造超网" class="headerlink" title="划分子网与构造超网"></a>划分子网与构造超网</h2><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><ul><li>网络号、主机号的两级IP 变为网络号、子网号、主机号的三级IP</li><li>网络号侵占主机号</li><li>因为全零全一不允许使用，每划分一个子网就会废掉两个IP</li><li>子网号的位数不能为0、1、15、16<ul><li>为0则没有划分子网</li><li>为16则没有主机</li><li>为1则网络号要么0要么1，不允许使用</li><li>为15则主机号要么0要么1，不允许使用</li></ul></li><li>定长子网划分、变长子网划分</li></ul><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a><font color="red">一个问题</font></h4><p>一个C类IP，划分为四个子网，分别在全零全一可用 / 不可用的时候损失了多少IP？</p><p>四个子网需要两个位的子网号，剩余六个位的主机号</p><p>网络号为00， 01， 10， 11，全零全一不可用，只剩下01， 10两个网络</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>用于找出IP地址中的子网部分</li><li>前面为1， 主机号部分为0，与IP做按位与运算，可以去掉主机号</li><li>最小IP网络的子网掩码是多少<ul><li>255.255.255.252</li><li>留出两位作为主机号，00， 01， 10， 11个主机，全零全一不让用，只有两台主机，其中一台是路由器</li></ul></li></ul><h3 id="构造超网-无分类编址CIDR-路由聚合"><a href="#构造超网-无分类编址CIDR-路由聚合" class="headerlink" title="构造超网 无分类编址CIDR 路由聚合"></a>构造超网 无分类编址CIDR 路由聚合</h3><p>无分类域间路由选择 Classless Inter-Domain Routing</p><ul><li>取消了传统ABC类网络，改用网络前缀来代替网络号与子网号<ul><li>主机号侵占网络号</li></ul></li><li>又变成两级编址</li><li>可以把多个C类网络合并，相当于侵占网络号</li><li>使用斜线记法，斜线后面表示网络前缀所占的位数<ul><li>数值上对应三级编址中子网掩码的1的位数</li></ul></li><li>仍然使用掩码</li><li>路由表中的一个项目可以表示很多传统分类的路由</li></ul><h4 id="构造超网的规则"><a href="#构造超网的规则" class="headerlink" title="构造超网的规则"></a>构造超网的规则</h4><ul><li>构成超网的地址块数必须是$2^n$</li><li>构成超网的地址快必须连续</li><li>第一个地址的第三字节必须能被块数整除</li></ul><h4 id="一些问题"><a href="#一些问题" class="headerlink" title=" 一些问题"></a><font color="red"> 一些问题</font></h4><ul><li>超网的网络地址能不能是X.Y.33.0？<ul><li>X.Y.00100001.0，发现主机号只有最后一个字节，相当于C类网络，没有聚合，也就不能叫超网</li></ul></li><li>X.Y.32.0 能不能确定网络<ul><li>X.Y.00100000.0，不能确定主机号的零从哪里开始</li><li>必须加上掩码/斜线才能确定网络号</li></ul></li></ul><h2 id="查找路由表"><a href="#查找路由表" class="headerlink" title="查找路由表"></a>查找路由表</h2><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>匹配路由表中最长的那个，因为越长越具体，有特定主机路由就不用网络前缀路由，有网络前缀路由就不用默认路由</p><p>路由器取出IP分组中的目的地址，与前缀对应的掩码进行按位与运算提取到网络号，进行匹配</p><h3 id="二叉线索"><a href="#二叉线索" class="headerlink" title="二叉线索"></a>二叉线索</h3><p>是一棵Trie</p><p>Trie上的前缀是唯一的，进行<strong>唯一前缀匹配</strong></p><p>唯一前缀匹配不等价于网络前缀匹配</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP在IP之上，ICMP报文作为IP报文的数据部分，也要被封装成IP数据报</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>1字节类型，1字节代码，2字节检验和</p><p>4字节ICMP数据部分，长度可变</p><h3 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h3><p>长度为<strong>36字节</strong></p><p>在收到错误的IP数据报后发送，也要封装为IP数据报</p><p>（封装后的IP数据报）数据部分是ICMP的前8字节 + 收到的IP数据报的首部 + 8字节，为TCP / UDP的端口号</p><p>因为要判定端口不可达</p><h4 id="不需要发送ICMP差错报文的几种情况"><a href="#不需要发送ICMP差错报文的几种情况" class="headerlink" title="不需要发送ICMP差错报文的几种情况"></a>不需要发送ICMP差错报文的几种情况</h4><ul><li>不再为ICMP差错报文发送ICMP差错报文 / 禁止套娃</li><li>只对分片中的第一片发送 / 一个错各个错</li><li>多播地址的数据报不发送</li><li>特殊地址（127.0.0.0 / 0.0.0.0）不发送</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>终点不可达<ul><li>某一环无法继续传递，向发送方发送终点不可达</li><li>报文中的数据表示失败的原因</li><li>不可达有五种情况<ul><li>网络不可达</li><li>主机不可达</li><li>协议不可达 //无法向上提交</li><li>端口不可达</li><li>需要分片但DF位为1</li><li>源路由失败</li></ul></li></ul></li><li>时间超过<ul><li>TTL减到0</li><li>某些分片迟迟不来，组装出问题</li></ul></li><li>参数问题<ul><li>头部参数出错，Pointer部分会指出错误的字节位置</li></ul></li><li>源点抑制<ul><li>流量过大，缓存队列溢出，只能丢弃报文，此时发送一个ICMP源点抑制，告知发送方晚点再来</li></ul></li><li>改变路由 / 重定向<ul><li>找不到目的地址</li></ul></li></ul><h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><p>长度为<strong>40字节</strong></p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>回送请求和回答<ul><li>ping</li></ul></li><li>时间戳请求和回答<ul><li>查询当前时间，提供毫秒级的分辨率</li><li>包含三个时间戳 ：Origin时间、Receive时间、transmit时间 （接收方发送回应的时间）</li><li>即使不同步也能计算正确的往返时间</li></ul></li></ul><h3 id="源路由"><a href="#源路由" class="headerlink" title="源路由"></a>源路由</h3><p>从源路由网桥中提到过，指从源点就确定的路由</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><ul><li><strong>ping非常特殊，应用层直接使用网络层，不经过运输层</strong></li></ul><h4 id="trace-route"><a href="#trace-route" class="headerlink" title="trace route"></a>trace route</h4><ul><li><p>发很多次，第一次发TTL是1，第二次发TTL是2，以此类推，每一次路由器都会给出一个超时</p></li><li><p>当到达目的主机时没法发送超时了，此时设置的一个不可达的UDP端口使得目的主机发送终点不可达</p></li><li><p>因此<strong>trace route 用到了运输层</strong></p></li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><ul><li>正确、完整</li><li>计算上简单</li><li>能适应通信量和网络拓扑的变化</li><li>稳定性，路由不应该不停变化</li><li>公平，除了少数优先级高的用户 / 区分服务</li><li>算法应该是最佳的 / 相对概念，特定约束下的较为合理的选择</li></ul><h3 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h3><p>静态路由 简单开销小，但是不能及时适应网络状态变化</p><p>动态路由 复杂开销大，但是能较好适应网络状态的变化</p><p>内部网关协议 IGP AS内部使用</p><p>外部网关协议 EGP AS之间使用</p><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>Autonomous System 自治系统</p><p>把AS内的网络看作一个整体，屏蔽内部细节和采用的路由协议</p><p>一个AS对其他AS表现出一个单一的一致的路由选择策略</p><h3 id="RIP-Route-information-protocol"><a href="#RIP-Route-information-protocol" class="headerlink" title="RIP Route information protocol"></a>RIP Route information protocol</h3><p>是一种内部网关协议</p><p><strong>分布式</strong>的基于<strong>距离向量</strong>的路由选择协议</p><p>每经过一个路由器距离加一，距离向量的距离指的是最短距离 / 经过路由器的数目最少</p><p>RIP简单粗暴的把距离短的路由认为是好的路由，允许一条路径最多包含15个路由器，距离超过15就标记为不可达</p><p><strong>不存在</strong>负载均衡，有两条长度一样的路径也只会走其中一条</p><p>工作方式为每隔固定的一段时间和相邻路由器交换自己的路由表</p><ul><li>三分钟没收到消息就认为不可达，距离设置为16</li><li>收到之后总总是要更新，距离可能增大也可能减小，应该以最新的更新</li></ul><p>能很快收敛 / 所有路由器达到一致</p><ul><li>路由表一致性不等于路由表表项相同</li></ul><p>路由表包括目的网络（大方向） 距离 下一跳路由器（小方向）</p><h4 id="RIP2报文格式"><a href="#RIP2报文格式" class="headerlink" title="RIP2报文格式"></a>RIP2报文格式</h4><p><img src="IMG_1576.PNG" alt></p><p>RIP2要封装到UDP中再封装到IP中，RIP是应用层协议</p><p>四字节首部，路由信息20字节，最多25个，总长度最大4 + 20 * 25 = 504字节，超过则启用新的RIP2报文</p><p>RIP2和RIP1（最大的）的区别是RIP2支持子网</p><p>路由标记表示是否再同一个自治系统中，填写的是自治系统的编码</p><h4 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h4><ul><li>水平分割<ul><li>从某个接口学到的路由不会再发回去，防止了路由环路</li></ul></li><li>毒性逆转<ul><li>当路由信息变成无效后不是直接删除而是设置为不可达并广播出去，可以清楚路由表中无用的路由</li></ul></li><li>触发更新<ul><li>路由信息改变后立即更新并发送给相邻路由器</li></ul></li><li>抑制计时<ul><li>如果一条路由更新的跳数大于路由表已记录的该路由的跳数，那么将会引起该路由进入长达180秒（即6个路由更新周期）的抑制状态阶段。在抑制计时器超时前，路由器不再接收关于这条路由的更新信息。可以用来防止路由环路。</li></ul></li></ul><h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF Open Shortest Path First"></a>OSPF Open Shortest Path First</h3><p>是一种内部网关协议</p><p><strong>分布式</strong>的，基于<strong>链路状态</strong>的路由选择协议</p><p>工作在网络层，在IP之上，直接使用IP数据报进行传送</p><p>使用Djijkstra算法</p><p>需要一张完整的网络图，来跑Dijkstra算法</p><p>所有的路由器都维护一个完整的链路状态数据库 / 全网的拓扑结构图</p><p>所有路由器的数据库都是完全一致的，和RIP中的一致不同</p><p>OSPF收敛很快</p><h4 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h4><ul><li>使用泛洪法向自治系统内的所有路由器发送信息</li><li>发送与本路由器相邻的所有路由器的链路状态<ul><li>与谁相邻，代价是多少</li></ul></li><li>只有链路状态发生变化时，路由器才使用泛洪法向所有路由器发送信息</li></ul><h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>自治系统通常贼大，需要维护的数据库也就会变大，因此在自治系统的基础上进一步划分区域（Area），这样就只需要在区域内泛洪、维护区域的拓扑结构图</p><p>每个区域用一个32位的区域标识符来表示，和IP一样使用点分十进制</p><p>使用层次结构的区域划分，上层的区域叫做主干区域，标识符为 0.0.0.0，主干区域联通下层区域</p><p>位于主干区域中的路由器称为主干路由器（BR）</p><p>位于区域边缘，与其他区域通信的路由器称为区域边界路由器（Area Border Router)</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>数据报很短<ul><li>减少路由信息的通信量，网络最主要的功能还是处理端系统的消息</li><li>不必将长的数据报分片传送，有效减少重传</li></ul></li><li>具有多路径负载均衡</li><li>具有鉴别功能<ul><li>保证了仅在可信的路由器之间交换链路状态信息</li></ul></li><li>支持变长子网划分和CIDR</li><li>每一个链路状态都有一个32位的序号，序号增长不超过五秒钟一次</li><li>每隔一段时间刷新数据库中的链路状态</li><li>互联网规模很大时，OSPF要比RIP好很多，对网络变化的响应很快不存在坏消息传得慢的情况</li></ul><h4 id="指定路由器"><a href="#指定路由器" class="headerlink" title="指定路由器"></a>指定路由器</h4><p>在一个广播性、多路访问的网络中，如果每个路由器都独立进行链路状态更新包的交换，就会产生巨大流量，不好，因此选举出一个村长来进行链路状态信息的交换。</p><p>有DR（Designated Router)）和BDR（Backup Designated Router）</p><h4 id="分组格式"><a href="#分组格式" class="headerlink" title="分组格式"></a>分组格式</h4><p><img src="IMG_1577.PNG" alt></p><ul><li>版本<ul><li>当前版本为2，版本一版本二不兼容</li></ul></li><li>类型<ul><li>Hello<ul><li>每隔十秒交换一次问候分组，从而得知有哪些路由器是可达的</li></ul></li><li>Database Description</li><li>Link State Request</li><li>Link State Update<ul><li>收到更新报文后需要恢复ACK</li></ul></li><li>Link State Acknowledgment</li></ul></li><li>分组长度<ul><li>包括OFSF头部的分组长度</li></ul></li><li>路由器ID<ul><li>在AS中可以唯一表示路由器</li></ul></li><li>区域ID<ul><li>指定分组所属的区域号</li></ul></li><li>校验和<ul><li>用于分组所有内容的校验和</li></ul></li><li>鉴别1<ul><li>0或1，表示不鉴别和使用口令鉴别</li></ul></li><li>鉴别2<ul><li>鉴别1为0时为0，鉴别1为1时为口令</li></ul></li></ul><h3 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP Border Gateway Protocol"></a>BGP Border Gateway Protocol</h3><p>外部网关协议</p><p>目前版本为4</p><p>难以寻找最佳路由，只在AS之间交换可达性信息，找到一条不兜圈子的<strong>比较好</strong>的路由</p><p>基于<strong>路径向量</strong>的路由选择协议</p><p>每个AS至少要有一个BGP发言人，每个发言人都要属于一个AS</p><p>作用于不同AS，但同一个AS中的不同边界路由器也需要建立BGP连接</p><p>BGP支持CIDR</p><p>是应用层协议，使用TCP进行传输</p><ul><li>对于远距离的传输，需要使用TCP保证可靠性</li></ul><h4 id="BGP热土豆路由选择协议"><a href="#BGP热土豆路由选择协议" class="headerlink" title="BGP热土豆路由选择协议"></a>BGP热土豆路由选择协议</h4><p>热马铃薯路由选择（Hot-potato routing）是在当前AS接收到一个数据包后，使其停留在该AS中的时间尽可能短。它尝试减少当前AS的开销，而忽略了网络中其他组成成分的开销。</p><p>将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS。</p><h4 id="AS的分类"><a href="#AS的分类" class="headerlink" title="AS的分类"></a>AS的分类</h4><p>单口AS，只有一个连接可以到达另一个AS，只能是信源或信宿</p><p>多归路过渡AS，有多个连接到达多个AS，但是拒绝传送流量，只能是信源或信宿 / 拒绝通信量穿越的多归属AS</p><p>过渡AS，不允许通信量穿越的多归属AS</p><h4 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h4><p>OPEN 与相邻的另一个BGP发言人建立关系 / 打招呼</p><p>UPDATE 发送某一路由的信息，列出要撤销的多条路由 / 有新闻</p><p>KEEPALIVE  确认打开报文与周期性证实临站关系 / 表明自己还活着 / 只有报文头</p><p>NOTIFICATION 发送检测到的差错 / 不跟你玩了</p><p><img src="IMG_1579.PNG" alt></p><p>标记部分用于鉴别，但是现在没有鉴别方案，全部置为1</p><p>长度为包括首部在内的总长度</p><p>类型为1-4，上述的四种类型</p><h4 id="一个问题-1"><a href="#一个问题-1" class="headerlink" title=" 一个问题 "></a><font color="red"> 一个问题 </font></h4><p><strong>KeepAlive报文在链路层是否需要进行填充？</strong></p><p>KeepAlive只有报文头，16 + 2 + 1 = 19 字节</p><p>作为TCP的数据部分，需要加上TCP的首部 19 + 20 = 39 字节</p><p>作为IP的数据部分，需要加上IP的首部 39 + 20 = 59 字节</p><p>MAC帧在长度小于46字节时才进行填充，因此不需要进行填充</p><p>以太网最短帧长为64字节，减去16字节头部，4字节FCS，数据部分最短46字节</p><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>多输入端口，多输出端口</p><p>作用是转发分组</p><p>路由选择协议生成路由表，路由表生成转发表</p><h3 id="多播特点"><a href="#多播特点" class="headerlink" title="多播特点"></a>多播特点</h3><p>使用组地址，D类地址</p><p>永久组地址</p><p>动态组成员</p><p>使用硬件进行多播</p><h3 id="IP多播地址与以太网多播地址的转换"><a href="#IP多播地址与以太网多播地址的转换" class="headerlink" title="IP多播地址与以太网多播地址的转换"></a>IP多播地址与以太网多播地址的转换</h3><p>01 + 00 + 5e + 0 + 组播IP低23位</p><h4 id="一个例子"><a href="#一个例子" class="headerlink" title=" 一个例子 "></a><font color="red"> 一个例子 </font></h4><p>226.150.47.33</p><p>首先确定D类IP，D类IP从224到239</p><p>写出后三个字节的二进制</p><p>150 = 128 + 16 + 4 + 2 = 1001 0110</p><p>47 = 32 + 16 - 1 = 0011 0000 - 1 = 0010 1111</p><p>33 = 32 + 1 = 0010 0001</p><p>把正数第二字节第一位换成0，因为只要后23位</p><p>0001 0110 = 16</p><p>0010 1111 = 2F</p><p>0010 0001 = 21</p><p>最终结果为 01 00 5e 16 2F 21</p><h3 id="IGMP-Internet-Group-Management-Protocal"><a href="#IGMP-Internet-Group-Management-Protocal" class="headerlink" title="IGMP Internet Group Management Protocal"></a>IGMP Internet Group Management Protocal</h3><p>使路由器知道多播组成员的信息</p><p>看作IP的一个组成部分</p><h4 id="IGMP的本地使用范围"><a href="#IGMP的本地使用范围" class="headerlink" title="IGMP的本地使用范围"></a>IGMP的本地使用范围</h4><p><strong>并非</strong> 在因特网范围内对所有多播组成员进行管理的协议</p><p>IGMP 不知道IP多播组包含的成员数，也不知道这些成员分布在哪些网络上</p><p>IGMP是让连接在本地局域网的多播路由器知道本剧于网上是否有主机参加或退出了多播组</p><h3 id="为什么多播路由选择协议比单播路由选择协议复杂得多"><a href="#为什么多播路由选择协议比单播路由选择协议复杂得多" class="headerlink" title="为什么多播路由选择协议比单播路由选择协议复杂得多"></a>为什么多播路由选择协议比单播路由选择协议复杂得多</h3><p>多播转发必须动态适应多播组成员的变化，而单播通常是在网络拓扑发生变化时才需要更新路由</p><p>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从哪里来到哪里去</p><p>多播数据报可以从没有加入多播组的主机发出，也可以通过没有组成员接入的网络</p><h3 id="IGMP两个阶段及具体措施"><a href="#IGMP两个阶段及具体措施" class="headerlink" title="IGMP两个阶段及具体措施"></a>IGMP两个阶段及具体措施</h3><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>新主机加入多播组，先向该组的多播地址发送IGMP报文，表明自己要加入，多播路由器收到之后将组成员关系转发到因特网上其他多播路由器，以完善多播路径</p><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>周期性探询本地局域网的主机，确认是否是该组的成员，只要有一个响应认为是活跃的，多次没有响应就不再将组成员关系转发给其他路由器</p><h4 id="具体措施"><a href="#具体措施" class="headerlink" title="具体措施"></a>具体措施</h4><p>使用IP多播</p><p>探寻组成员关系时对所有组发送一个请求信息的询问报文（而不是每个组一个）</p><p>主机收到询问后随机选择一个时延进行发送</p><p>如果组内有其他主机发送了，自己就可以不发送了</p><h3 id="多播路由选择的三种方法"><a href="#多播路由选择的三种方法" class="headerlink" title="多播路由选择的三种方法"></a>多播路由选择的三种方法</h3><p>多播路由选择实际上是要构建以源主机为根节点的多播转发树</p><h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>RBP Reverse Path Broadcasting</p><p>洪泛适用于较小的多播组，为了避免兜圈子，使用了反向路径广播Reverse Path Broadcasting的策略</p><p>剪除指发现下游树枝上没有多播组成员时，把它和下游树枝一起在转发树上剪除</p><h4 id="隧道-lt-第一个隧道-gt"><a href="#隧道-lt-第一个隧道-gt" class="headerlink" title="隧道  &lt;第一个隧道&gt; "></a>隧道 <font color="blue"> &lt;第一个隧道&gt; </font></h4><p>把多播报文封装为单播，使用单播通过不支持多播的网络，出来之后再恢复成多播</p><h4 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="　基于核心的发现技术"></a>　基于核心的发现技术</h4><p>对每一个多播组指定一个核心，核心路由器构建转发树</p><h3 id="RPB特点"><a href="#RPB特点" class="headerlink" title="RPB特点"></a>RPB特点</h3><p>路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的：</p><p>若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外 ）</p><p>否 则 ， 就 丢 弃 而 不 转 发。</p><p>如果 存 在 几 条 同 样 长 度 的 最 短 路 径 ， 那 么 只 能 选 择 一 条 最 短 路 径 ， 选 择 的 准 则 就 是 看 这 几 条 最 短 路 径中的相邻路由器谁的 IP 地址最小。 </p><p>最终得出多播转发树，以后就按其转发多播数据报</p><h2 id="VPN-Virtaul-Private-Network"><a href="#VPN-Virtaul-Private-Network" class="headerlink" title="VPN Virtaul Private Network"></a>VPN Virtaul Private Network</h2><p>利用公用的互联网作为本机构各专用网之间的通信载体</p><p>所有通过互联网传送的数据都必须加密</p><p>使用 <strong>隧道技术</strong> 来实现 <font color="blue"> &lt;第二个隧道&gt; </font></p><p><img src="IMG_1580.PNG" alt="IMG_1580"></p><p>机构内部的VPN为内联网（intranet），不同机构共同建立的VPN为外联网（exrtanet）</p><h2 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT Network Address Translation"></a>NAT Network Address Translation</h2><p>专用网中的主机需要与外部进行通信，需要通过NAT路由器将私有地址转换为全球地址</p><p>转换结果需要记录在NAT地址转换表中</p><p>每次通信需要进行两次转换，离开时一次，进入时一次</p><p>对于有$n$个全球IP地址的NAT路由器，最多可以同时有$n$台主机接入到互联网</p><p>专用网内部的主机不能作为服务器</p><p><img src="IMG_1583.PNG" alt="ING_1583"></p><h3 id="NAPT-Network-Address-and-Port-Translation"><a href="#NAPT-Network-Address-and-Port-Translation" class="headerlink" title="NAPT Network Address and Port Translation"></a>NAPT Network Address and Port Translation</h3><p>多个主机公用一个NAT路由器上的全球IP地址</p><p>把专用网内部的不同IP地址转换为相同的全球IP地址，源主机采用的TCP端口号不管相不相同都转换为不同的新的端口号</p><h2 id="MPLS-Multi-Protocol-Label-Switching"><a href="#MPLS-Multi-Protocol-Label-Switching" class="headerlink" title="MPLS Multi Protocol Label Switching"></a>MPLS Multi Protocol Label Switching</h2><p>属于2.5层协议，是IP的一种增强</p><p><strong>多协议</strong> 表示MPLS的上层可以采用多种网络协议、下层可以采用多种链路层协议</p><p><strong>标记</strong> 表示每个分组被打上一个标记，根据标记对分组进行转发</p><blockquote><p>传统的路由决策，路由器需要对网络数据包进行解包，再根据目的IP地址计算归属的FEC。</p><p>而MPLS提出，当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。</p><p>当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。</p></blockquote><p>每类分组会有一个特定的编号</p><h3 id="MPLS特点"><a href="#MPLS特点" class="headerlink" title="MPLS特点"></a>MPLS特点</h3><ul><li>面向连接，标记一旦确定，连接的路径就确定了</li><li>支持流量工程，平衡网络负载</li><li>有效支持VPN</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记-进程同步</title>
      <link href="/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h2><h3 id="About-Critical-Section"><a href="#About-Critical-Section" class="headerlink" title="About Critical Section"></a>About Critical Section</h3><ul><li><p>An atomic action is required in a critical section.</p></li><li><p>When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</p></li><li><p>The critical section is <strong>not</strong> a public section. Each process has its own critical section.</p></li><li>Each process must request permission to enter its critical section. The section of code implementing this request is the <strong>entry section</strong>, the critical section may be followed by an <strong>exit section</strong></li></ul><p><img src="https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG" alt></p><a id="more"></a><h3 id="Solution-of-the-critical-section-problem"><a href="#Solution-of-the-critical-section-problem" class="headerlink" title="Solution of the critical-section problem"></a>Solution of the critical-section problem</h3><ul><li><p>Mutual exclusion 互斥</p><ul><li>If  process $p_i$ is executing its critical section, then no other process can be executing in their critical sections</li></ul></li><li><p>progress 进步？</p><ul><li>If no process is executing in its critical section and some processes with to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which  will enter its critical section next, and this selection cannot be postponed <strong>indefinitely</strong>.</li><li>如果没有进程在执行临界区并且某些进程想要执行他们的临界区，那么只有那些不在他们剩余区的进程可以参与决定谁来执行临界区的筛选，这个选择过程不会无限期推迟。</li></ul></li><li><p>Bounded waiting 有界等待</p><ul><li><p>There exists a bound on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.</p></li><li><pre class="mermaid">    gantt                section Figure1       请求进入临界区            :des1, 1d       等待          :des2, after des1, 3d       被授权进入临界区            :des3, after des2, 5d</pre></li><li><p>如上图，在等待的过程中其他进程被允许进入临界区的次数是有限的</p></li></ul></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p><strong>两个进程</strong>的同步算法，软件实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initicall turn = 0</span></span><br><span class="line"><span class="comment">// turn is a shared variable</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (turn != i); <span class="comment">// only turn == i can this process execute it's critical section</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">//reminder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Satisfies mutual exclusion, but not progress</p><p>机械的规定零号进程一号进程交替进行。</p><p>进程是否有进入临界区的 <strong>意愿</strong> ？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initial flag[0] = flag[1] = false;</span></span><br><span class="line"><span class="comment">//flag[i] == true -&gt; process i ready to enter critical section</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]); <span class="comment">// mutual exclusion</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>不满足 progress ，在<code>flag[i] = true</code>之后，切换到另一个进程<code>flag[j] = true</code>，此时两个进程都想进临界区，但是都在看对方，都不能进入临界区</p><h3 id="Peterson‘s-Solution"><a href="#Peterson‘s-Solution" class="headerlink" title="Peterson‘s Solution"></a>Peterson‘s Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share turn flag[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>最后执行turn等于谁，谁就进入临界区</p><h2 id="Synchronization-Hardware"><a href="#Synchronization-Hardware" class="headerlink" title="Synchronization Hardware"></a>Synchronization Hardware</h2><p>Based on <strong>locking</strong></p><ul><li>Uniprocessors<ul><li>同一时刻指运行一个进程</li><li>disable interrupts 把中断屏蔽即可</li></ul></li><li>special atomic hardware instructions 硬件提供特殊的原子指令<ul><li>原子指令执行期间不允许切换</li><li><code>test memory</code> 查看某内存单元的值</li><li><code>set value</code> 对某内存单元设置为1</li><li><code>swap</code> 交换两个内存单元的值</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    acquire lock</span><br><span class="line">        <span class="comment">//criticla section</span></span><br><span class="line">    release lock</span><br><span class="line">        <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="test-and-set-Instruction"><a href="#test-and-set-Instruction" class="headerlink" title="test_and_set Instruction"></a>test_and_set Instruction</h3><p>做成<strong>一条</strong>机器指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tar 看作一个锁，一堆人去抢这把锁</span></span><br><span class="line"><span class="function">boolean <span class="title">test_and_set</span><span class="params">(boolean *tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> rv = *tar;</span><br><span class="line">    *tar = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">//got the lock or not;</span></span><br><span class="line">    <span class="comment">//flase -&gt; 锁没被锁，自己锁了</span></span><br><span class="line">    <span class="comment">//true -&gt; 已经被锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这条指令加锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutux lock</span></span><br><span class="line"><span class="comment">//锁只是一个普通变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(test_and_set(&amp;lock));</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较倒霉的情况可能不满足有界等待</span></span><br><span class="line"><span class="comment">//几率小，当倒霉处理</span></span><br></pre></td></tr></table></figure></p><h3 id="compare-and-swap-Instruction"><a href="#compare-and-swap-Instruction" class="headerlink" title="compare_and_swap Instruction"></a>compare_and_swap Instruction</h3><p>和<code>test_and_set Instruction</code>做一样的事情，但是实际功能更强。</p><p>用牛刀杀鸡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *value;</span><br><span class="line">    <span class="keyword">if</span> (*value == expected) </span><br><span class="line">        *value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旧值和新值比较</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">//是0就设置为1</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h2><p>Software Tool</p><p>使用原子的<code>acquire()</code>和<code>release()</code>来申请、释放锁，不需要在意底层具体实现方式。</p><ul><li><p>CPU busy waiting 问题</p><ul><li>循环查看锁开没开</li><li>Spinlock 自旋锁</li><li>会浪费CPU的时间</li></ul></li><li><p>更好的办法</p><ul><li>锁可用获得锁</li><li>锁不可用进程挂起</li><li>释放锁时有进程挂起则挑一个唤醒</li><li>没有进程挂起直接释放</li></ul></li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p><p>Synchronization Tool that does not require busy waiting</p><ul><li><p>is an integer</p></li><li><p><code>wait()</code> P 减信号量 请求执行</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//busy wait</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>signal()</code> V 加信号量</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>某个资源的只能被有限的人使用，例如为了保证网络通畅，只允许五个人连接。</p><p>不局限于加锁解锁，可以有一定范围。</p><p>当信号量被限制到二元，则退化（？）为互斥锁。</p><p>生产者 / 消费者问题？</p><p>有界缓冲区问题？</p><p>哲学家就餐问题？如何把这些搞哲学的饿死。</p><p><strong>一个使用信号量解决问题的例子</strong></p><p><img src="1.JPG" alt="figure1"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习笔记-数据链路层</title>
      <link href="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li><p>数据链路层的信道种类</p><ul><li>点对点信道<ul><li>一对一通信</li></ul></li><li>广播信道<ul><li>一对多</li><li>需要专门的协议</li></ul></li></ul></li><li><p>链路与数据链路</p><ul><li>链路指一条无源的点到点的线路</li><li>物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路</li></ul></li><li><p>数据链路层的传输单位是帧 Frame</p></li><li><p>数据链路层解决的三个基本问题</p><ul><li>封装成帧</li><li>透明传输</li><li>差错控制</li></ul></li></ul><a id="more"></a><h2 id="链路层的基本功能"><a href="#链路层的基本功能" class="headerlink" title="链路层的基本功能"></a>链路层的基本功能</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul><li>添加首部尾部进行帧定界 <code>SOH</code> Start_of_header <code>EOT</code> End_of_transmission</li><li>帧定界符是特殊的控制字符</li></ul><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul><li>透明就是不透明</li><li>透明传输使得不用关心下层的传输，所采用的设备只是一个通道的作用</li><li>当传输二进制文件中出现定界符序列时，在这个序列之前添加<code>ESC</code>进行转义</li><li>称为 字节填充 / 字符填充<ul><li>在前面的非归零反相编码 NRZI 中有提到比特位填充 <code>bit_stuffing</code></li></ul></li><li>先转义还是先封装?</li></ul><h3 id="差错控制-差错检测"><a href="#差错控制-差错检测" class="headerlink" title="差错控制 / 差错检测"></a>差错控制 / 差错检测</h3><ul><li>误码率 BER<ul><li>$P_e = \frac{N_e}{N}$</li><li>传错的除以总的</li></ul></li><li>噪声的类型<ul><li>热噪声<ul><li>时刻存在、强度低</li><li>高斯白噪声</li><li>引起随机差错</li></ul></li><li>冲击噪声<ul><li>外界电磁干扰引起、强度高</li><li>闪电</li><li>引起突发错</li></ul></li></ul></li><li>纠错码与检错码<ul><li>纠错码适用于错误出现多的情况，可以由接收方发现错误并纠正</li><li>检错码适用于错误出现较少的地方，例如有线网络，发现出错后不进行纠正，直接抛弃</li></ul></li><li>常用检错码<ul><li>奇偶校验<ul><li>最后添加一个校验位</li><li>统计数据码中1的个数</li></ul></li><li>循环冗余编码CRC<ul><li>有纠错能力，但是数据链路层只用它来检错</li></ul></li></ul></li></ul><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><ul><li>生成多项式<ul><li>除数，长度为生成多项式最高项的次数，翻译为二进制为多项式每一项的系数</li></ul></li><li>FCS<ul><li>帧检验序列</li><li>CRC是生成FCS的一种方法但不是唯一方法</li></ul></li><li>无差错接受<ul><li>凡是接受的帧，都可以以非常接近于1的概率认为它正确的</li><li>也有可能因为噪声，所有的位变成了0，但是概率非常小</li></ul></li></ul><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><ul><li>PPP 既能面向Bit也能面向字节 / 字符</li><li>点对点通信</li><li>只支持全双工</li><li>使用广域网进行串行通信</li></ul><h3 id="需要满足的要求"><a href="#需要满足的要求" class="headerlink" title="需要满足的要求"></a>需要满足的要求</h3><ul><li>简单</li><li>链路层功能<ul><li>封装成帧</li><li>透明性</li><li>差错检测</li></ul></li><li>对上与对下<ul><li>多种网络层协议</li><li>多种类型链路</li></ul></li><li>检测连接状态</li><li>最大传送单元<ul><li>MTU</li><li>不包含帧头帧尾</li><li>发送过程中逐步进行调整</li><li>高层协议根据链路层的MTU进行分片</li></ul></li><li>网络层地址协商</li><li>数据压缩协商</li></ul><h3 id="不需要的功能"><a href="#不需要的功能" class="headerlink" title="不需要的功能"></a>不需要的功能</h3><ul><li><p>纠错</p><ul><li>链路层不要求可靠性</li></ul></li><li><p>流量控制</p><ul><li>流量来自于端系统的进程，进程间通信由TCP协议负责</li></ul></li><li><p>序号</p><ul><li>PPP不保证可靠性</li><li>实际上链路层的传输本就很可靠</li></ul></li><li><p>多点链路</p><ul><li>PPP只支持点对点</li></ul></li><li><p>半双工 / 单工链路</p><p>PPP只支持全双工链路</p></li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>一个将IP数据报封装到串行链路的方法<ul><li>面向字符的异步链路</li><li>面向比特的同步链路</li></ul></li><li>链路控制协议 <code>LCP</code> Link Control Protocol<ul><li>与物理层交互</li></ul></li><li><strong>一套</strong>网络控制协议 <code>NCP</code> Network Control Protocol<ul><li>与网络层交互</li><li>每个协议支持一种不同的网络层协议</li></ul></li></ul><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><ul><li>首部<ul><li>定界符 / 定界字节序列　　0x7E</li><li>AC 固定的两个部分，但是说不准以后会有用</li><li>协议<ul><li>0x0021 信息部分为IP数据报</li><li>0xC021 信息部分位PPP链路控制数据</li><li>0x8021 信息部分位网络控制数据</li></ul></li></ul></li><li>信息部分<ul><li>IP数据报</li></ul></li><li>尾部<ul><li>CRC检验序列<ul><li>从AC开始到信息部分结束</li><li>万一以后AC部分有用呢</li></ul></li><li>定界符 / 定界字节序列        0x7E</li></ul></li></ul><h4 id="字节填充"><a href="#字节填充" class="headerlink" title="　字节填充"></a>　字节填充</h4><ul><li>出现控制字符时，前面添加转义字符0x7D，同时第六个bit取反</li></ul><h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><ul><li>SONET / SDH使用同步传输，同步传输中没有 <strong>字符</strong> 的概念</li><li>0x7E = 0111 1110</li><li>5个连续1之后插一个0，保证不出现连续6个1，就不会出现定界符</li></ul><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><ul><li>使用时钟信号线或前同步序列保证发送端与接收端的时钟保持同步</li><li>以数据帧位单位传输</li></ul><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><ul><li>以字符为单位传输</li><li>每个字符前添加起始位0，后面加停止位1，表示数据的开始和结束</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>连接从下往上建立，从上往下释放</p><ul><li>调制解调器建立物理连接</li><li>PC向路由器发送一系列的LCP分组 （0xC021）建立LCP连接</li><li>NCP给新接入的PC分配一个临时的IP地址</li><li>通信</li><li>NCP释放网络层链接，收回临时IP</li><li>LCP释放数据链路层连接</li><li>释放物理层链接</li></ul><h3 id="挑战握手认证协议-CHAP"><a href="#挑战握手认证协议-CHAP" class="headerlink" title="挑战握手认证协议 CHAP"></a>挑战握手认证协议 CHAP</h3><p>在初始链路建立时完成，也可以在链路建立后的任何时刻进行</p><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ul><li><p>IEEE 局域网标准</p><ul><li>IEEE 802.3     CSMA/CD</li><li>IEEE 802.4     令牌总线</li><li>IEEE 802.5     令牌环</li></ul></li><li><p>局域网的特点</p><ul><li>网络为一个单位所拥有，地理范围和站点数目均有限</li></ul></li><li>局域网的拓扑结构<ul><li>环形    环形令牌网</li><li>总线 <ul><li>两端带有匹配电阻吸收电磁波信号的能量</li><li>CSMA/CD</li></ul></li><li>星形</li><li>树形</li></ul></li><li>共享信道<ul><li>静态划分   不能适用于网络的突发性</li><li>动态接入<ul><li>随机接入    需要解决冲突</li><li>受控接入</li></ul></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>使用<strong>曼彻斯特编码</strong>进行数据传输</p><ul><li>不需要尾部的定界符</li><li>可以在$1 \over 2$处不跳变</li></ul></li><li><p>数据链路层的子层</p><ul><li>LLC Logical Link Control<ul><li>面向上层，与传输媒体无关</li></ul></li><li>MAC Medium Access Control<ul><li>面向下层</li><li>数据帧真正完成封装的位置</li></ul></li><li>MAC 子层的功能<ul><li>数据真的封装/卸装</li><li>帧的寻址和识别</li><li>帧的接受和发送</li><li>链路的管理</li><li>帧的差错控制</li><li>仲裁介质的使用权</li></ul></li></ul></li><li>LLC 子层的功能<ul><li>识别网络层协议，进行封装，加上一个LLC报头</li><li>接收方可识别使用了何种局域网</li><li>以太网一统天下，LLC实际作用不大</li></ul></li></ul><h4 id="为什么说以太网很简便"><a href="#为什么说以太网很简便" class="headerlink" title="为什么说以太网很简便"></a>为什么说以太网很简便</h4><ul><li>无连接</li><li>不编号，不要求对方发回确认</li><li>提供不可靠的最大努力交付，高层发现丢失了一些数据帧并进行重传，但是以太网并不知道这是一个重传的帧，而是完全当作一个新的数据帧来发送</li></ul><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器既有链路层的功能，也有物理层的功能</p><ul><li>适配器的主要功能<ul><li>串行/并行转换</li><li>数据缓存</li><li>安装设备驱动程序（设备与CPU通信的媒介）</li><li>实现以太网协议</li></ul></li></ul><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><ul><li><p>CSMA/CD 是<strong>随机征用型</strong>的介质访问控制方法</p></li><li><p>载波监听 多点接入 with 冲突检测</p><ul><li>载波监听  每个站在发送数据前都要检测总线上是否有其他站在发信息</li><li>多点接入  多个站点连接在一根总线上</li><li>冲突检测  边发送数据边检测信道上的信号电压大小，当发现冲突时做出相应处理</li></ul></li><li><p>Carrier Sense Multiple Access with Collision Detection</p></li><li><p>以帧为单位传输</p><ul><li>存在 IFG Interframe Gap 帧间距</li><li>网络设备和组件在接受一个帧后，需要一段时间恢复为接受下一帧做准备</li><li>IFG 最小为96比特时间</li></ul></li></ul><h3 id="站模型"><a href="#站模型" class="headerlink" title="　站模型"></a>　站模型</h3><p>各个站点相互独立，以固定速率产生数据帧。某个站点一旦产生新帧，即使被阻塞，也不会有新的帧产生，直到发送完毕</p><h3 id="单信道假设"><a href="#单信道假设" class="headerlink" title="单信道假设"></a>单信道假设</h3><p>所有通信都是通过单信道进行，任何时刻仅允许一个站点发送，需要争用发送权</p><h3 id="冲突假设"><a href="#冲突假设" class="headerlink" title="冲突假设"></a>冲突假设</h3><p>若两帧同时发送，则产生冲突，所有站点都能检测冲突，冲突的帧必须重发</p><h3 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h3><p>帧可以在任意时刻发送</p><h3 id="侦听假设"><a href="#侦听假设" class="headerlink" title="　侦听假设"></a>　侦听假设</h3><p>所有站点都可以侦听到当前信道的状态，若忙则等待</p><p>但是当某个站监听到总线是空闲时，可能总线并不是真正空闲，因为信号的传播需要时间，也就是之前提到过的<strong>传播时延</strong></p><p>策略：</p><ul><li>非坚持     忙则不等，过会再来看</li><li>１坚持    一直等待，直到空闲</li><li>Ｐ坚持    以概率为P进行等待</li></ul><h3 id="传播时延对载波侦听的影响"><a href="#传播时延对载波侦听的影响" class="headerlink" title="传播时延对载波侦听的影响"></a>传播时延对载波侦听的影响</h3><p>A在 $t=0$ 时刻发送信号，B在$t = \tau - \delta$ 发送信号，两者信号在 $t = \tau - \frac{\delta}{2}$ 时刻碰撞，B在$t = \tau$时刻检测到碰撞，A在$t=2\tau-\delta$ 时刻检测到碰撞，$\tau$指传播时间。</p><p><img src="IMG_4731.PNG" alt="IMG_4731"></p><p>先发送的一方较后检测到冲突。</p><h3 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h3><ul><li>CSMA/CD不能进行全双工通信，只能进行半双工通信 （而PPP只支持全双工通信）</li><li>每个站在发送数据之后的一段时间内，存在着遭遇碰撞的可能性<ul><li>时间的从长短取决于发送方到接收方的距离</li></ul></li><li>发送的不确定性使得整个以太网的平均通信两远小于以太网的最高数据率<ul><li>以太网不能保证某一时间内一定能把自己的数据帧成功发出去</li></ul></li><li>因此以太网必须轻负载，百分之三十左右</li></ul><h3 id="关于碰撞"><a href="#关于碰撞" class="headerlink" title="关于碰撞"></a>关于碰撞</h3><h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><p>在发送数据后至多 $2\tau$ 时间可以知道是否发生冲突，这段时间称为<strong>争用期</strong>或<strong>碰撞窗口</strong>，经过这段时间后还没有检测到碰撞，则说明本次传输不会发生碰撞</p><ul><li>所有以太网取 $51.2 \mu s$ 作为争用期长度<ul><li>以太网的设计决定了最长的2RTT不会超过 $51.2 \mu s$ </li></ul></li><li>对于 10Mb/s 的以太网，争用期内可以发送 512bit 即 64 字节<ul><li>发生冲突一定是在前64字节以内</li><li>最短的有效帧长为64字节</li></ul></li><li>或者说争用期的长度是512比特时间</li></ul><h4 id="截断二进制指数类型退避算法"><a href="#截断二进制指数类型退避算法" class="headerlink" title="截断二进制指数类型退避算法"></a>截断二进制指数类型退避算法</h4><ul><li>碰撞之后退避一段时间再发送</li><li>基本退避时间是$ 2\tau $ （512比特时间），在此基础上乘以$[0, 1, \dots, (2^k - 1)]$中随机一个数，$k$是重传次数，最大为$10$</li><li>争用期的若干倍数</li><li>重传$16$次还是失败，直接丢弃</li><li>会出现<strong>捕获效应</strong>，越退越倒霉</li></ul><h4 id="碰撞发生后"><a href="#碰撞发生后" class="headerlink" title="碰撞发生后"></a>碰撞发生后</h4><ul><li>检测到碰撞立即停止发送数据，并发送干扰信号，让其他主机知道发生了碰撞</li></ul><p><img src="IMG_4734.PNG" alt="image-4734"></p><ul><li>时间的浪费</li></ul><p><img src="IMG_4735.PNG" alt="image-4735"></p><h3 id="整个发送过程"><a href="#整个发送过程" class="headerlink" title="整个发送过程"></a>整个发送过程</h3><p>准备发送</p><p>​    适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中，准备发送</p><p>检测信道</p><p>​    在96比特时间内（IFG 帧间距）没有检测到信道上有信号，就发送</p><p>发送</p><p>​    发送过程中持续检测信道，若检测到碰撞，就终止发送，并发送干扰信号</p><p>终止发送后</p><p>​    执行指数退避算法，等待$r$ 倍的512比特时间，继续检测信道</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>先听后说，边听边说</p><p>一旦冲突，立即停说</p><p>等待时机，然后再说</p><h2 id="使用广播信道的以太网"><a href="#使用广播信道的以太网" class="headerlink" title="使用广播信道的以太网"></a>使用广播信道的以太网</h2><h3 id="以太网物理设备的演进"><a href="#以太网物理设备的演进" class="headerlink" title="以太网物理设备的演进"></a>以太网物理设备的演进</h3><ul><li>粗同轴电缆       10BASE5<ul><li>10Mbit/s，基带信号，最大段长度500m</li><li>站与站之间大于等于2.5m，网络最大跨度2.5km</li><li>中继器：信号的整形与放大</li><li>收发器：发送、接收、冲突检测、电气隔离</li><li>粗缆以太网的冲突检测不靠网卡进行</li></ul></li><li><p>细同轴电缆       10BASE2</p><ul><li>10Mbit/s，基带信号，最大段长度约等于200m</li><li>没有外置收发器</li><li>冲突检测由网卡完成</li></ul></li><li><p>双绞线              10BASE-T</p><ul><li>使用RJ45连接器</li><li>所有站点与集线器相连接</li><li>集线器：信号放大与整形，是物理层设备</li><li>两个集线器连接时要使用交叉链接法</li><li>帧长度可变，最大1518个字节，其中18个字节的MAC头尾，1500个字节的IP数据报</li></ul></li><li>光纤                 10BASE-F</li></ul><h3 id="RJ45连接头"><a href="#RJ45连接头" class="headerlink" title="RJ45连接头"></a>RJ45连接头</h3><p>锁扣朝上，从左到右编号1-8</p><p><img src="IMG_4796.JPEG" alt="IMG-4976"></p><ul><li>为什么要两发两收<ul><li>传送的是差分信号，用两个信号的差值作为传输的信号，相当于放大，更容易识别</li></ul></li></ul><h3 id="集线器的特点"><a href="#集线器的特点" class="headerlink" title="集线器的特点"></a>集线器的特点</h3><ul><li>逻辑总线</li><li>多借口转发器</li><li>转发比特，不进行碰撞检测<ul><li>工作在物理层</li></ul></li></ul><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><ul><li><p>一些时间</p><ul><li>争用期长度为$2 \tau$，是RTT的两倍</li><li>帧长为$L$</li><li>数据发送率为$C$</li><li>帧的发送时间 / 发送时延 / 传输时延 为$\frac{L}{C} = T_0$</li></ul></li><li><p>发送一帧需要经过若干个争用期，然后经过发送时延和传输时延</p><p><img src="IMG_4795.PNG" alt="IMG-4795"></p></li><li><p>$a = \frac{\tau}{T_0}$，$a$小则说明信道利用率高，$a$大则说明每碰撞一次都会浪费许多信道资源</p></li><li><p>减小连线长度 / 增加帧长</p></li><li><p>理想情况下，极限信道利用率为，此时不发生碰撞</p><script type="math/tex; mode=display">S_{\text{max}} = \frac{T_0}{T_0 + \tau} = \frac{1}{1 + a}</script></li></ul><h2 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h2><ul><li>硬件地址 / 物理地址 / MAC地址</li><li>一个主机多个网卡的话就有多个MAC地址</li><li>MAC地址应当理解为某个接口的标识符</li><li>网卡使用MAC地址检查某个帧是不是发给自己</li></ul><h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><p>最常用的是以太网V2标准的格式，IEEE802.3的格式和V2相差无几，我们研究的重点是以太网的V2协议。</p><p><img src="IMG_4834.PNG" alt="img4834"></p><ul><li><p>类型字段用来表示上一层使用的是什么协议</p><ul><li>不一定是<strong>网络层</strong>，比如PPP协议，PPPoE</li></ul></li><li><p>为什么先是目的地址再是源地址</p><ul><li>方便解析，能快速判断是不是发给自己的</li></ul></li><li><p>在使用VLAN虚拟局域网的时候MAC帧的长度可能会超过1518</p><ul><li>1500字节的数据部分</li><li>目的地址6，源地址6，类型2，FCS 4</li></ul></li><li><p><code>0x0800</code>表示IP，<code>0x0806</code>表示ARP</p></li><li><p>最后的FCS校验全部的内容</p><ul><li>不包含帧定界符，因为使用曼彻斯特编码，时钟周期中间不跳变即标明发送结束，不需要帧定界符</li><li>不需要帧定界符也就不需要使用字节插入来实现透明传输</li></ul></li><li><p>当数据字段的长度小于46字节时，再数据字段后面加入整数字节的填充字段</p><ul><li>MAC层因为没有长度计数，所以MAC层并不知道有填充，填充也不发生在MAC层</li><li>填充发生在网络层或者有长度指征的层</li><li>例如IP协议有一个总长度字段，表示MAC层的真实数据字段</li></ul></li><li><p>如何计算传输效率</p><ul><li>$ \frac{X}{X + 18 + 8 + 12}$</li><li>18字节的控制信息，8字节的前同步码，12字节的帧间隔IFG<ul><li>前同步码是一串规律的01序列，用于告知接收方发送方的时钟序列，最后两个11表示准备发送</li><li>同步传输，所以需要前同步码</li></ul></li></ul></li><li><p>无效的MAC帧</p><ul><li>数据字段长度不在46 ~ 1500字节之间<ul><li>46 + 18 = 64，恰好是可以接受的最短帧长</li><li>参看 CSMA/CD  /  关于碰撞 / 争用期</li></ul></li><li>以太网对于无效的MAC帧直接丢弃，不负责重传，由更高层负责</li><li>无效帧的出现不一定因为发生了碰撞。例如断电。</li></ul></li></ul><h3 id="IEEE-802-3的MAC协议"><a href="#IEEE-802-3的MAC协议" class="headerlink" title="IEEE 802.3的MAC协议"></a>IEEE 802.3的MAC协议</h3><ul><li>区别仅在于，第三个字段是长度<strong>或</strong>类型。长度和类型只能有一个，大于<code>0x6000</code>时表示类型， 小于<code>0x6000</code>时表示长度</li><li>因为长度最大不会超过<code>0x6000</code></li><li>当实际长度与长度字段不同时被视为无效帧</li><li>强行让LLC发挥作用</li></ul><h3 id="无效的MAC帧"><a href="#无效的MAC帧" class="headerlink" title="无效的MAC帧"></a>无效的MAC帧</h3><ul><li>802.3协议中数据字段的长度与长度字段不一致</li><li>帧的长度不是整数个字节</li><li>FCS检测出错</li><li>数据字段的长度不在46 ~ 1500字节之间</li></ul><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><ul><li>使用多个集线器级联</li><li>把多个碰撞域合并成一个碰撞域<ul><li>Collision Domain</li><li>所有可能发生冲突的站点的集合</li><li>冲突域被看作物理层的感念</li></ul></li><li>缺点<ul><li>通信效率会下降，但是使得不同局域网可以通信，扩大了以太网覆盖的地理范围</li><li>总的吞吐量没有提高</li><li>数据率不同的碰撞域连接起来会使得较快的无法发挥出自己的吞吐量</li></ul></li></ul><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><ul><li><p>使用网桥 / 转发器</p><ul><li>根据MAC地址进行转发和过滤</li></ul></li><li><p>过滤通信量、增大吞吐量、划分冲突域 / 碰撞域</p></li><li><p>缺点</p><ul><li>需要存储转发，增加了时延</li><li>转发前执行CSMA/CD算法</li><li>没有流量控制，帧多的时候会导致缓存空间不够，发生帧丢失</li><li>不同MAC子层的网段桥接在一起时延更大</li><li>只适合用户数不太多，通信量不太大的局域网</li></ul></li></ul><h4 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h4><ul><li>广播域<ul><li>数据能广播到的范围，能收到同样广播的设备的集合</li><li>是链路层的概念（冲突域是物理层的概念）</li></ul></li><li>产生于网络拓扑的设计和连接问题</li></ul><h3 id="使用交换机扩展以太网"><a href="#使用交换机扩展以太网" class="headerlink" title="使用交换机扩展以太网"></a>使用交换机扩展以太网</h3><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>目前所有的标准网桥都必须支持透明网桥，源路由网桥为可选配置</p><h3 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h3><p><strong>透明网桥的特点</strong></p><ul><li>使用最多</li><li>“透明”，网桥对于站点来说是看不见的</li><li>即插即用，不需要人工配置转发表<ul><li>需要配置转发表的为静态网桥</li></ul></li><li>网桥的转发表不宜过大，有些旧的地址应该淘汰<ul><li>网络拓扑可能变化</li><li>可能由于更换网卡导致MAC地址变化</li><li>不是所有的站点总是接通电源</li><li>有的站点从不发送数据或者长时间不发送数据</li></ul></li></ul><p><strong>透明网桥的缺点</strong></p><ul><li>不能充分利用网络资源，尤其不能保证最佳路由（由于生成树算法导致相距很近的节点可能需要绕圈子）</li><li>为了防止广播风暴的产生，透明网桥只能使用生成树，不能保证每条路由最佳，也不能进行负载均衡</li></ul><h4 id="网桥自学习算法"><a href="#网桥自学习算法" class="headerlink" title="网桥自学习算法"></a>网桥自学习算法</h4><p>分为自学习和转发两个过程</p><ul><li>每一次转发都可以得知发送站相对于自己的<strong>方向</strong>（源地址、进入的接口、时间）<ul><li>如果之前没有与源地址匹配的项目就插入转发表，若有则更新转发表</li><li>但是帧从接口X进入网桥不代表帧发送站在X的网段上</li></ul></li><li>当转发表中无目的地址时无条件进行转发到所有其他接口，记录下发送站相对于自己的方向</li><li>当目的地址和源地址在网桥的同一方向时不需要转发，直接丢弃，转发表不变<ul><li>一个网桥丢弃帧不代表所有的网桥都会丢弃帧</li></ul></li><li>网桥的转发需要拆帧成帧，集线器转发只是整型、放大</li></ul><h4 id="透明网桥的生成树算法"><a href="#透明网桥的生成树算法" class="headerlink" title="透明网桥的生成树算法"></a>透明网桥的生成树算法</h4><ul><li>为了解决广播风暴的问题</li><li>当拓扑结构中存在环的时候求其中的生成树,消除图中的环路，从而保证两个站点之间只有一条路径。</li><li>最小序号网桥作为生成树的根</li><li>网桥为边，网段为节点</li></ul><h3 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h3><ul><li>发送帧时，详细路由信息放在帧的首部</li><li>发送数据帧之前，先发送<strong>发现帧</strong>，发现帧记录经过的路由，到达目的之后按照记住的路由返回</li><li>源站根据这些路由得到一个最佳路由进行发送</li><li>不再透明</li><li>发现帧还能够帮助源点确定整个网络可以通过的帧的最大长度</li><li>可以实现负载均衡</li><li>可以使用最佳路由</li></ul><h3 id="多接口网桥-以太网交换机"><a href="#多接口网桥-以太网交换机" class="headerlink" title="多接口网桥 / 以太网交换机"></a>多接口网桥 / 以太网交换机</h3><ul><li><p>以太网交换机实质上是一个多接口的网桥，交换机出现之后网桥很快被淘汰了</p><ul><li>Multiport Repeater = Hub</li><li>Multiport Bridge = Switch</li></ul></li><li><p>通常工作在链路层，常被称为第二层交换机</p></li><li><p>交换机本质上和网桥一样</p><ul><li>网桥传统上基于软件，交换机基于硬件<ul><li>由数据转发的逻辑部分和输入输出端口组成（input / output port）</li></ul></li><li>两者<strong>等效</strong>而非<strong>等价</strong></li><li>交换机的和网桥一样缩小了网络的冲突域，一个端口就是一个冲突域<ul><li>一个端口连接一个计算机时，仍采用CSMA/CD的控制方法</li><li>只要网络上的用户不同时访问一个接口，而且是全双工通信，就不会发生冲突</li></ul></li></ul></li><li><p>有的交换机还具有差错控制的功能</p></li><li><p>能够提高带宽</p><p><img src="daikuan.png" alt></p></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>收到一个包时可以知道源MAC的机器连在哪个端口的方向上<ul><li>之前有过这一项就更新，没有就添加</li></ul></li><li>转发包时在转发表中查找目的MAC地址<ul><li>如果有则直接复制到目的端口上</li><li>没有则泛洪到所有端口</li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>以太网交换机的每个接口都直接与主机或者另一个集线器相连</li><li>一般使用全双工的工作方式<ul><li>此时CSMA/CD的单信道假设不再成立</li></ul></li><li>能同时联通多对接口，每一对相互通信的主机都可以无碰撞的传输数据</li><li>和透明网桥一样，即插即用，使用自学习法逐步建立转发表</li><li>因为用硬件实现，转发速度较快</li></ul><h4 id="交换技术的种类"><a href="#交换技术的种类" class="headerlink" title="交换技术的种类"></a>交换技术的种类</h4><ul><li>直通方式<ul><li>只检查包头，把数据包转发到输出端口</li><li>转发速率高，但是会转发错误帧</li></ul></li><li>存储转发方式<ul><li>缓存数据包，进行CRC检验，过滤掉不正确的包</li><li>可以让错误包提前过滤掉，但是牺牲效率</li></ul></li><li>无碎片直通方式<ul><li>只检查数据包的长度够不够64字节，只去除无效帧</li><li>介于以上两者之间，比较平衡的方式</li></ul></li></ul><h2 id="虚拟局域网-VLAN"><a href="#虚拟局域网-VLAN" class="headerlink" title="虚拟局域网 VLAN"></a>虚拟局域网 VLAN</h2><p>由<code>IEEE 802.1Q</code>定义</p><ul><li>一些局域网网段构成的与物理位置无关的逻辑组，这些网段有某些共同的需求</li><li>每个VLAN的帧都有明确的标识符，标明这个帧属于哪个VLAN<ul><li>所以帧长会超过1518</li><li><img src="IMG_1543.PNG" alt="IMG_1543"></li></ul></li><li>虚拟局域网是局域网的一种服务，而非另一种新型的局域网</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>安全性</li><li>降低负载的相互影响</li><li>防止广播风暴</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>VLAN中的每一个站点都可以听到同一个VLAN上的其他站点发出的广播</li><li>不会产生广播风暴</li><li>需要路由器或者第三层交换机</li><li>VLAN的工作站可以在不同的局域网（网段）中，也可以不在同一楼中（地理位置）</li></ul><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><h4 id="根据端口来划分"><a href="#根据端口来划分" class="headerlink" title="根据端口来划分"></a>根据端口来划分</h4><ul><li>物理层</li><li>一个或多个交换机上的几个端口划分为一个逻辑组</li><li>一个集线器上的站点只能属于同一个VLAN</li></ul><h4 id="根据MAC地址来划分"><a href="#根据MAC地址来划分" class="headerlink" title="根据MAC地址来划分"></a>根据MAC地址来划分</h4><ul><li>数据链路层</li><li>可以实现同一广播域内站点的自由移动</li><li>但是需要对大量毫无规律的MAC地址进行操作</li></ul><h4 id="根据网路层来划分"><a href="#根据网路层来划分" class="headerlink" title="根据网路层来划分"></a>根据网路层来划分</h4><ul><li>网络层</li><li>按照站点的IP地址来定义广播域，形成虚拟IP子网</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习笔记</title>
      <link href="/2020/02/22/learn_SQL/"/>
      <url>/2020/02/22/learn_SQL/</url>
      
        <content type="html"><![CDATA[<p>非常粗浅的SQL学习笔记，关于如何<strong>使用</strong>SQL。</p><p>笔记中使用开源的MySQL作为数据管理软件。</p><a id="more"></a><h2 id="MySQL-Client"><a href="#MySQL-Client" class="headerlink" title="MySQL Client"></a>MySQL Client</h2><p>安装好MySQL之后，除了服务器以外，还装上了一个客户端，对于数据库的操作都是由这个客户端提供的。客户端通过TCP连接服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接本地服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h &lt;IP&gt; -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接远程SQL服务器。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">-- 显示全部数据库</span><br><span class="line">CREATE DATABASES test;</span><br><span class="line">-- 创建数据库</span><br><span class="line">DROP DATABASES test;</span><br><span class="line">-- 删除数据库</span><br><span class="line">USE test;</span><br><span class="line">-- 切换到某个数据库</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">-- 显示表</span><br><span class="line">CREATE TABLE students</span><br><span class="line">-- 创建表</span><br><span class="line">DROP TABLE students</span><br><span class="line">-- 删除表</span><br><span class="line"></span><br><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br><span class="line">-- 修改列</span><br><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br><span class="line">-- 删除列</span><br></pre></td></tr></table></figure><p><code>ALTER</code>似乎是Alternate的意思，和键盘上的Alt键一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXIT</span><br><span class="line">-- 退出</span><br></pre></td></tr></table></figure><p>这些都是MySQL的操作，对于不同的数据库系统可能有不同的指令。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt;;</span><br><span class="line"><span class="comment">-- 列出某个表的所有行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出符合条件的所有行</span></span><br><span class="line"><span class="comment">-- 条件运算包括 &gt;= / &lt;= / = / &lt;&gt; / AND / OR / NOT 等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_columns&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出想要的列</span></span><br><span class="line"><span class="comment">-- 可以对列起一个别名方便表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt; </span><br><span class="line"><span class="keyword">WHERE</span> &lt;confition&gt; </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt; &lt;<span class="keyword">DESC</span>&gt;;</span><br><span class="line"><span class="comment">-- DESC可以降序排序，默认是升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;conition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_size_of_page&gt;</span><br><span class="line"><span class="keyword">OFFSET</span> &lt;number_of_offset&gt;;</span><br><span class="line"><span class="comment">-- 从&lt;number_of_offset&gt;开始分页显示，每页最多显示&lt;limit_size_of_page&gt;个</span></span><br><span class="line"><span class="comment">-- 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL内置聚合函数</span></span><br><span class="line">COUNT()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">SUM()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">MAX()</span><br><span class="line"><span class="comment">-- 计算某一列的最大值</span></span><br><span class="line">MIN()</span><br><span class="line"><span class="comment">-- 计算某一列的最小值</span></span><br><span class="line">AVG()</span><br><span class="line"><span class="comment">-- 计算某一列的平均值，该列必须为数值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;num_of_colmns&gt;;</span><br><span class="line"><span class="comment">-- 按照列中的值自动分别计算&lt;function&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接查询</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现减法</title>
      <link href="/2020/01/22/how_to_diff/"/>
      <url>/2020/01/22/how_to_diff/</url>
      
        <content type="html"><![CDATA[<p>对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。</p><p>将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。</p><p>至此就实现了二进制加法。</p><p>每一个全加器只能计算<strong>一位</strong>二进制数，要进行多位二进制数的加法就需要串联多个全加器。</p><a id="more"></a><h2 id="大数减小数"><a href="#大数减小数" class="headerlink" title="大数减小数"></a>大数减小数</h2><p>对于减法而言，不存在进位，但是有借位。</p><p>为了避免借位，提出<strong>补数</strong>的概念</p><blockquote><p>对于一个 $k$ 进制数 $a$ ，从一串 $k$ 中（个数等于 $k$ 进制下 $a$ 的位数）减去 $a$ 得到的数，称为 $a$ 对 $k$ 的补数</p></blockquote><p>提出补数的好处是计算补数的过程不需要借位</p><p>当计算出补数之后，将补数与被减数<strong>相加</strong>，把结果加一，再减去$10^n$，$n$为$a$的位数。</p><p>为什么这样可行？举个例子</p><script type="math/tex; mode=display">\begin{align}   253 - 176 &= 253 - 176 + 1000 - 1000 \\   &= 253 - 176 + 999 + 1 - 1000  \\   &= 253 + (999 - 176) + 1 - 1000\\\end{align}</script><p>二进制的减法与之类似。</p><p>注意到现在式子中唯一的减法其实就是求这个数的补数。</p><p>对于一个二进制数，计算它的补数只需要对其按位取反，也就是它的<strong>反码</strong>(inverse)。</p><p>并且，对于最后一步减法，也是不必真的做的，最高位会自然溢出，作为进位被丢掉。</p><p>至此，大数减小数的减法就实现了。</p><h2 id="表示负数"><a href="#表示负数" class="headerlink" title="表示负数"></a>表示负数</h2><p>首先明确一点，计算机处理的位数是有限的，超过最高位的数将会溢出。</p><h2 id="小数减大数"><a href="#小数减大数" class="headerlink" title="小数减大数"></a>小数减大数</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《编码》笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 《计算机网络-自顶向下方法》 编程作业三 邮件服务器</title>
      <link href="/2019/11/27/Computer-Networking-Lab-3/"/>
      <url>/2019/11/27/Computer-Networking-Lab-3/</url>
      
        <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业三</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>通过完成本实验，您将更加了解SMTP协议。您还将学到使用Python实现标准协议的经验。</p><p>您的任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。您的客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>在某些情况下，接收邮件服务器可能会将您的电子邮件分类为垃圾邮件。当您查找从客户端发送的电子邮件时，请检查垃圾邮件文件夹。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于某些众所周知的原因，本实验不使用Google邮箱，而是使用QQ邮箱。</p><p>基本流程如下</p><ul><li>与QQ邮箱服务器（smtp.qq.com）建立TCP连接，这里为了简单起见，使用非SSL协议的25端口。其他邮件服务器见这篇文章：<a href="https://blog.csdn.net/qq_25046261/article/details/78982080" target="_blank" rel="noopener">常用的邮件服务器名称、地址及SSL/非SSL协议端口号</a>。成功建立连接之后，服务器会返回状态码220表示已就绪。</li><li>发送 HELO 命令，输入自己的账户，开始试图与服务器交互。</li><li>发送 AUTH LOGIN 命令，输入密码。这里的密码指的是<strong>邮件服务器提供的授权码</strong>，而不是平时在web端登录的密码。</li><li>上面提到的用户名和密码都是<strong>经过Base64加密后的结果</strong>。我在这一步卡了很久，最后发现原因是在网上找的Base64加密工具给出的结果是错的，换一个工具就好了。</li><li>登录成功后，服务器会返回状态码235表示成功。</li><li>发送 MAIL FROM 命令，表明发信人，应当与 HELO-AUTH 命令中验证的邮箱保持一致。成功后会收到 <code>250 OK</code>的回复。</li><li>发送 RCPT TO 命令，表明收信人。成功后会收到 <code>250 OK</code> 的回复。</li><li>发送 DATA 命令，表明自己要开始发送信息了。 服务器将返回状态码354 。</li><li>发送邮件内容，最开头要有<code>\r\n</code>，每条信息结尾也要有<code>\r\n</code>，最后要发送一个<code>\r\n.\r\n</code>表明邮件内容的结束。</li><li>发送 QUIT 命令，结束与邮件服务器的连接。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="https://s2.ax1x.com/2019/11/27/QC5J3R.png" alt="yh"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 《计算机网络-自顶向下方法》 编程作业二 UDP ping 程序</title>
      <link href="/2019/11/16/Computer-Networking-Lab-2/"/>
      <url>/2019/11/16/Computer-Networking-Lab-2/</url>
      
        <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业二</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>在这个编程作业中，你将用Python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序，然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第4章中学习ICMP）。此时我们将创建一个非标准（但简单）的基于UDP的ping程序。</p><p>你的ping程序经UDP向目标服务器发送10个ping报文，对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为1秒；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。</p><p>在此作业中，我们给出服务器的完整代码（在配套网站中可以找到。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以不受限制地从服务器代码中剪贴代码行。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>在服务端与客户端建立UDP连接</li><li>循环发送十条信息，在发出和接收的位置分别计时</li><li>每接收到一条回复，把两个时间相减得到RTT</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>在判断超时的时候，<code>socket</code>自带了一个时长限定，当超出这个时间之后会抛出<code>timeout</code>异常。</li><li><code>time.perf_counter()</code>是以秒为单位的计时。</li><li>服务端模拟丢包率为 $30 \%$ ，实际结果与其格外吻合。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>【客户端】<br><img src="https://s2.ax1x.com/2019/11/16/MBnItH.png" alt="cilent"></p><p>【服务端】<br><img src="https://s2.ax1x.com/2019/11/16/MBuShj.md.png" alt="server"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 《计算机网络-自顶向下方法》 编程作业一 Web服务器</title>
      <link href="/2019/11/14/Computer-Networking-Lab-1/"/>
      <url>/2019/11/14/Computer-Networking-Lab-1/</url>
      
        <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业一</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>实现一个最简单的Web服务器，它能够处理一个请求：</p><ul><li>当客户（浏览器）联系时创建一个连接Socket</li><li>从这个连接接收HTTP请求</li><li>解释该请求以确定所请求的特定文件</li><li>从服务器的文件系统获取该文件</li><li>创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行</li><li>经TCP连接向请求的浏览器发送响应。若服务器中不存在请求的文件是，返回一个<code>404 Not Found</code>的差错报文</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>HTTP建立在TCP之上，所以在服务端建立TCP Socket</li><li>HTTP响应报文的首部行需要手写，感觉有点奇怪</li><li>如果不用浏览器，也可以写一个客户端的程序来进行HTTP请求</li><li>对于浏览器，用<code>&lt;ip_address&gt;:&lt;port&gt;/&lt;file&gt;</code>来请求某个文件</li></ul><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="C:\Users\Taisi\Pictures\Saved Pictures\无标题.png" alt="pic"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图匹配学习笔记</title>
      <link href="/2019/11/06/BipartiteGraphLearn/"/>
      <url>/2019/11/06/BipartiteGraphLearn/</url>
      
        <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul><li>二分图一定是一个无向图</li><li>若一个无向图中<strong>不存在</strong>长度为奇数的环，则这个图为二分图</li><li>二分图可以分成两个部分，每部分中的点之间没有边</li></ul><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><ul><li>对于一个二分图，从它的所有边中选出一些，使得任意两条边没有公共端点，这样的边的集合被称为二分图的<strong>匹配</strong></li><li>二分图的匹配并不是唯一的</li><li>在所有的匹配中含边数最多的那一个称为这个二分图的 <strong>最大匹配</strong></li></ul><h3 id="增广路定理"><a href="#增广路定理" class="headerlink" title="增广路定理"></a>增广路定理</h3><p>网络流问题中也存在（类似的）<strong>增广路</strong>的概念。</p><ul><li>对于一个二分图，如果存在一条连接两个非匹配点的路径，使得匹配边与非匹配边交替出现，则这个路径是已知匹配的 <strong>增广路</strong>。</li><li>对于一条增广路而言，如果将其中的匹配边与非匹配边身份互换，可得到一个更大的匹配。</li><li>由上述两条可知，找到最大匹配等价于此时二分图中不存在增广路。</li></ul><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>把二分图画成左边右边两个区域（黑点白点），两个区域中间有一些边，现在要在这些边里选择出一些，使形成一个最大匹配。</p><p>不妨以左边的点从上到下的顺序考虑</p><ul><li>对于左边的第<code>i</code>个点，遍历与之相邻的点<code>neighbor[i][j]</code>（一定在右侧）<ul><li>如果<code>neighbor[i][j]</code>还没有被匹配，那就把这两个点（暂时）匹配上，看左边的第<code>i+1</code>号点。</li><li>如果<code>neighbor[i][j]</code>已经被匹配过了，那就看看之前和<code>neighbor[i][j]</code>匹配的点还能不能匹配其他点（此时视角转换成<code>neighbor[i][j]</code>之前确定的那个匹配点（左边的点），递归进去）。<ul><li>如果<code>neighbor[i][j]</code>之前的匹配点可以换一个匹配对象，就换，把<code>neighbor[i][j]</code>留给现在考虑的<code>i</code>号点，不能换就算了，看<code>j+1</code>号点</li></ul></li><li>如果能找到一个合适的匹配点，就返回<code>true</code>，反之返回<code>false</code></li></ul></li></ul><p>这是一个类似于<code>dfs</code>的过程，被访问的点不应到再被访问一次，所以用一个<code>vis</code> 数组记录<code>dfs</code>过程中的访问情况，注意这里的<strong>访问情况</strong>和<strong>匹配情况</strong>的区别，代码中的<code>vis</code>是访问情况，<code>con_x</code> <code>con_y</code>是匹配情况。所以<code>vis</code>每看一个左边的点就要全部设置为未访问一次。</p><p>理解这个过程之后，发现真的很像相亲……</p><p>有点贪心的意思</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="HDU-2063-过山车"><a href="#HDU-2063-过山车" class="headerlink" title="HDU-2063 过山车"></a>HDU-2063 过山车</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> p[MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>], vis[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> con_x[MAXN * <span class="number">2</span>], con_y[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (con_y[i] == <span class="number">-1</span> || match(con_y[i])) &#123;</span><br><span class="line">                con_x[x] = i;</span><br><span class="line">                con_y[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;n, &amp;m) != EOF &amp;&amp; k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(con_x, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_x));</span><br><span class="line">        <span class="built_in">memset</span>(con_y, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_y));</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="literal">false</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> girl, boy;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girl, &amp;boy);</span><br><span class="line">            p[girl][boy + n] = p[boy + n][girl] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manacher学习笔记</title>
      <link href="/2019/11/04/manacher_learn/"/>
      <url>/2019/11/04/manacher_learn/</url>
      
        <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="Manacher简介"><a href="#Manacher简介" class="headerlink" title="Manacher简介"></a>Manacher简介</h2><p>Manacher算法用于高效解决这样的问题：给定一个长度为 $n$ 的字符串，求其中以每个字符为中心的<strong>回文子串</strong>的长度。</p><h3 id="什么是回文串？"><a href="#什么是回文串？" class="headerlink" title="什么是回文串？"></a>什么是回文串？</h3><p>正着读和反着读都一样的字符串，例如<code>()()</code>不是一个回文串，而<code>())(</code>是一个回文串。</p><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><h3 id="最蠢的那种"><a href="#最蠢的那种" class="headerlink" title="最蠢的那种"></a>最蠢的那种</h3><p>$O(n^2)$ 枚举子串，$O(n)$ 判断是否为回文，总复杂度$O(n^3)$</p><h3 id="稍微好一点"><a href="#稍微好一点" class="headerlink" title="稍微好一点"></a>稍微好一点</h3><p>$O(n)$枚举中心，向两边尽量扩展，复杂度$O(n^2)$</p><h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher 利用了回文串具有的<strong>对称性</strong>来通过之前计算过的子串的信息优化对当前位置的计算。这一点和<a href="https://ilern.github.io/2019/09/26/KMP_learn/">KMP算法</a>可以说异曲同工。</p><p>首先明确最后要通过这个算法得到什么东西。一个数组<code>p</code>，其中<code>p[i]</code>表示以<code>i</code>为中心的最大回文半径。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>最后求出的<code>p</code>数组应当为</p><p><code>p = [1, 1, 2, 1, 4, 1    , 2, 1, 1]</code></p><p>这样知道了最大回文半径，也就能求出以每个字符为中心的最长回文子串长度。</p><p>但是这样的做法不够完善，例如对于<code>baaaab</code>这个字符串，本身是一个回文串，那么最长回文子串自然是它本身，但是按照<code>p</code>数组的定义，这个字符串对应的<code>p</code>应该是<code>[1, 1, 2, 2, 1, 1]</code>，而仅仅通过这个数组是求不出最长回文子串的。</p><p>问题就出在这个串的长度是偶数，在这个串中不存在一个<strong>中心</strong>作为这个子串的中心。</p><p>所以需要进行预处理来使得这个算法支持偶数长的子串。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>个人感觉这一步相当巧妙。</p><p>对于原串，我们在开头插入一个<code>$</code>，在每个字符前后都插入一个<code>#</code>。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>预处理之后结果为</p><p><code>s1 = &quot;$#c#a#b#a#d#a#b#a#e#&quot;</code></p><p>这里的<code>$</code>和<code>#</code>并不是一定用这两个字符，只要是不在原串中出现的字符都可以。</p><p>经过这样的预处理我们发现之前不存在对称中心的问题解决了，偶数长度的子串在新字符串中以<code>#</code>为对称中心，奇数长度的子串在新字符串中还是以原来的对称中心为对称中心，且原字符串的回文子串长度等于新字符串回文半径长度减一。</p><p>添加开头的<code>$</code>是为了更好判断边界，不添加也可以，但是在边界处理上会麻烦一些。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在第二个暴力算法中，还是以<code>s = &quot;cabadabae&quot;</code>为例，假如我们已经知道了以第三位为中心的最大回文半径（相当于知道了以第三位为中心的最长回文子串）和以第五位为中心的最大回文半径，那么在求以第七位为中心的最大回文半径的时候，由于回文串具有<strong>对称</strong>的特性，并且三和七<del>恰好</del>关于五对称，所以可以直接得到（部分）结果。</p><ul><li>以第三位为中心的最长回文子串 <code>c[aba]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[aba]e</code></li></ul><p>所以可以直接从长度为3开始拓展（因为目前为止更后面的信息还不知道）。</p><p>如果换成计算第六位的时候又是怎样的情况呢？六关于五的对称点为四。</p><ul><li>以第二位为中心的最长回文子串 <code>cab[a]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[a]bae</code></li></ul><p>长度只能为1。</p><p>不难发现，在已知当前最长的回文串是以五位中心之后，再往后的位置都可以直接由对称性来得到至少一部分信息。我们利用这些信息，就能很快求出所有的回文子串。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设置两个状态 <code>maxR</code> 和 <code>id</code>，分别表示当前已知的回文子串的最右边界和这个边界所对应的中心。</p><p>设<code>p[i]</code>表示第<code>i</code>个字符为中心时最大回文子串的长度，按照<code>i</code>从大到小的顺序从左向右计算。</p><p>对于每一个即将计算到的<code>i</code>，先计算出关于<code>id</code>的对称点<code>j = id * 2 - i</code>，然后分以下三种情况进行。</p><ul><li>若 $i &gt; maxR$，即这个点不在之前计算过的回文串中，此时我们并不能从之前的计算中获取有用的信息，只能令<code>p[i] = 1</code>，然后从这个位置开始向两边扩展，顺便更新 <code>maxR</code> 和 <code>id</code></li><li>若 $i \leq maxR$ 且 $i + p[j] &lt; maxR$ ​，此时有 <code>p[i] = p[j]</code>，如同上面的第二个例子。</li><li>若 $i \leq maxR$ 且 $i + p[j] \geq maxR$，此时已知的最长回文串覆盖了<code>i</code>这个位置但是没有覆盖<code>j</code>为中心的回文串，此时有<code>p[i] = maxR - i</code>。</li></ul><p>这样确定<code>p[i]</code>最小可能的值然后再尝试向两边扩展即可，其中第二种情况应该是无法继续扩展的。</p><blockquote><p>1、先对字符串进行预处理，两个字符之间加上特殊符号#</p><p>2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）</p><p>3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度</p><p>4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界</p><p>5、最后得到最长回文之后，去掉其中的特殊符号即可</p></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">P3805 【模板】manacher算法</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">11000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[MAXN * <span class="number">2</span> + <span class="number">10</span>], maxR = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"$"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">        ret += <span class="string">"#"</span>;</span><br><span class="line">        ret += c;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sp = preProcess(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; maxR) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = id * <span class="number">2</span> - i;</span><br><span class="line">            p[i] = min(p[j], maxR - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = i - p[i];</span><br><span class="line">        <span class="keyword">int</span> r = i + p[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sp[l] == sp[r]) &#123;</span><br><span class="line">            l--; r++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; maxR) &#123;</span><br><span class="line">                maxR = r;</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p[i] = r - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        maxx = max(maxx, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxx - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTE1ODkyNQ==&amp;mid=2649410225&amp;idx=1&amp;sn=ed045e8edc3c49a436a328e5f0f37a55&amp;chksm=f0b60f53c7c18645b4c04a69ad314723cce94ed56994d6f963c2275a2db8d85f973f15f508e4&amp;mpshare=1&amp;scene=23&amp;srcid=1001JCsBlpxgUWjgixasChNQ#rd" target="_blank" rel="noopener">【面试现场】如何找到字符串中的最长回文子串？</a></p><p><a href="https://oi.men.ci/manacher-notes/" target="_blank" rel="noopener">Manacher 学习笔记 - Menci</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记 - 文件操作</title>
      <link href="/2019/10/30/filepython/"/>
      <url>/2019/10/30/filepython/</url>
      
        <content type="html"><![CDATA[<p>真是令人迷惑</p><a id="more"></a><h3 id="何为文件"><a href="#何为文件" class="headerlink" title="何为文件"></a>何为文件</h3><p>文件可以看作数据的抽象和集合。是数据存储的一种形式，由二进制存储。</p><p><code>Linux</code>认为一切都是文件， 在<code>UNIX</code>系统中，一切资源都被看作是文件，包括硬件设备。<code>UNIX</code>系统把每个硬件都看成是一个文件，称之为<strong>设备文件</strong>。</p><h3 id="文件的类型-展示方式"><a href="#文件的类型-展示方式" class="headerlink" title="文件的类型 / 展示方式"></a>文件的类型 / 展示方式</h3><ul><li><p>文本文件</p><ul><li><p><strong>单一而特定</strong>的编码组成的文件， 例如<code>UTF-8</code>编码。</p></li><li><p>可以看作一个长的字符串。</p></li></ul></li><li><p>二进制文件</p><ul><li><p>直接由<strong>0和1</strong>构成的文件，没有统一的编码格式。一般这样的文件中的0和1是由某种预定的格式组合成的，因此形成了一些特定的文件类型，例如图片的 <code>.png</code>，视频的<code>.avi</code>。</p></li><li><p>这类文件的0和1之上没有统一的编码。</p></li></ul></li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>文件的操作通常遵循 “打开，操作，关闭” 的步骤，关系如下图所示</p><div id="sequence-0"></div><ul><li><p>文件的打开</p><ul><li><p><code>f = open(&lt;file_name&gt;, &lt;open_mode&gt;)</code></p></li><li><p>文件名可以使用相对路径也可以使用绝对路径</p></li><li><p>Python提供七种文件打开模式，与C类似</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">打开模式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center"><strong>默认</strong>打开模式，只读，若文件不存在则抛出异常</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">覆盖写，若不存在则创建，若存在则完全覆盖</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">创建写，若不存在则创建，若存在则抛出异常</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">追加写，若不存在则创建，若存在则在文件后追加</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">二进制打开</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">文本打开，<strong>默认</strong>方式</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">与前四种模式一同使用，在原本的基础上增加读写功能</td></tr></tbody></table></div><ul><li><p>默认的文件编码格式为<code>UTF-8</code>，要打开其他编码格式的文件要在打开文件时为<code>read</code>添加参数<code>encoding</code>表示要使用的编码方式。</p></li><li><p>如果编码方式不规范，<code>open</code>会抛出异常，遇到这种情况可以添加<code>errors</code>参数表示如何处理，最简单的方式就是直接忽略<code>error = &#39;ignore&#39;</code>。</p></li></ul><ul><li><p>文件的关闭</p><ul><li><code>f.close()</code>用来关闭文件，使文件回到存储状态。</li></ul></li><li><p>处理异常</p><p>由于在每次打开文件的时候都可能会产生异常，所以应该对异常采取适当的处理方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>因为每次都要<code>try-finally</code>，过于繁琐，Python提供了<code>with</code>语句来简单处理（不局限但普遍应用于文件操作）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using with statement </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_path'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file: </span><br><span class="line">    file.write(<span class="string">'hello world !'</span>)</span><br></pre></td></tr></table></figure><p>这样的写法不需要自己手动关闭文件，也不需要手动捕获异常。</p></li></ul><h3 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h3><ul><li>python提供三种文件读取的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.read()</code></td><td style="text-align:center">直接读入整个文件，存到字符串当中，对于大文件慎用</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.read(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline()</code></td><td style="text-align:center">读一行</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readlines()</code></td><td style="text-align:center">读入所有行，组织成一个列表</td></tr><tr><td style="text-align:center"><code>&lt;dile_object&gt;.readlines(hint)</code></td><td style="text-align:center">读入前<code>hint</code> 行，组织成一个列表</td></tr></tbody></table></div><ul><li><p>逐行遍历文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h3><p>想要写入文件，在打开文件时应该用<code>w</code> / <code>wb</code>形式</p><ul><li>python提供两种写文件的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.write(str)</code></td><td style="text-align:center">写字符串或文件流到文件中</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.writelines(list)</code></td><td style="text-align:center">把一个全为字符串的列表写到文件里，实际上是把列表中的字符串续到一起</td></tr></tbody></table></div><ul><li><p>文件指针</p><ul><li><p>不是C语言里的那种文件指针。</p></li><li><p>就像文本编辑器里的光标一样，表示当前写入的位置。</p></li><li><p>使用<code>&lt;file_project&gt;.seek()</code>来调整文件指针</p><ul><li><p><code>seek()</code>接受两个参数，第一个参数表示偏移量，第二个参数表示起点（0-从开头开始，1-从当前位置开始，2-从末尾开始）</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'hihi '</span>, <span class="string">'haha '</span>, <span class="string">'hoho '</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br><span class="line">    <span class="comment"># f.seek(0, 0)  #hihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(1, 0)  #ihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(2, 0)  #hi haha hoho</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 1)  #None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 2)  #None</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li><li><p>如果写入之后接着读取是什么都读不到的，因为文件指针默认从当前位置开始读，而刚写入之后文件指针的后面什么都没有，需要移动之后再输出</p></li></ul></li></ul></li></ul><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant 存储状态 as ffparticipant 占用状态 as kkff-->kk: a = open(, )kk-->ff: a.close()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP学习笔记</title>
      <link href="/2019/09/26/KMP_learn/"/>
      <url>/2019/09/26/KMP_learn/</url>
      
        <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="KMP简介"><a href="#KMP简介" class="headerlink" title="KMP简介"></a>KMP简介</h2><p>KMP算法用于高效解决这样的问题：给定一个有 $n$ 个字符的字符串 <code>txt</code> 和一个有 $m$ 个字符的字符串 <code>pat</code> （$n &gt; m$），找出 <code>txt</code> 中 <code>pat</code> 每次出现的位置 。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input : txt[] = &quot;THIS IS A TEST TEXT&quot;</span><br><span class="line">        pat[] = &quot;TEST&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 10</span><br></pre></td></tr></table></figure><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:  txt[] = &quot;AABAACAADAABAABA&quot;</span><br><span class="line">        pat[] = &quot;AABA&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 0</span><br><span class="line">        Pattern found at index 9</span><br><span class="line">        Pattern found at index 12</span><br></pre></td></tr></table></figure><h2 id="暴力匹配法"><a href="#暴力匹配法" class="headerlink" title="暴力匹配法"></a>暴力匹配法</h2><p>对于这个问题，最容易想到的方法就是一个位置一个位置尝试匹配，每次将模式串 <code>pat</code> 向后移动一位，就像一个滑动的窗口一样，每次比较 $m$ 个位置。</p><p>但是这个方法在很多匹配的字符后面跟着一个不匹配的字符的情况下表现不够好，最坏的情况复杂度会达到 $O(m(n-m+1))$ 。</p><p>比如说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAAAAAAAAAAAAAAB&quot;</span><br><span class="line">pat[] = &quot;AAAAB&quot;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;ABABABCABABABCABABABC&quot;</span><br><span class="line">pat[] = &quot;ABABAC&quot;</span><br></pre></td></tr></table></figure></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法最基本的想法就是：不论我们在哪里失配了（在某些字符匹配成功之后），我们都知道了接下来要尝试匹配的 <code>txt</code> 的子串的一部分信息，因为每次 <code>pat</code> 都只向右移动一个字符，所以我们可以利用这一点来减少不必要的匹配。</p><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>第一次匹配是成功的，接下来 <code>pat</code> 串会向右移动一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>在暴力匹配算法中，我们会从 <code>txt</code> 的第二个位置，<code>pat</code>  的第一个位置开始尝试匹配，但是实际上我们只需要看<code>txt</code> 的第五个位置和 <code>pat</code> 的第四个位置是不是相同的就可以了，因为我们知道前三个字符一定会匹配。</p><p>为了做到这一点，我们需要进行一些预处理。</p><p>我们定义一个列表<code>lps[]</code>（<code>lps</code> 是 <strong>longest proper prefix which is also suffix</strong> 的缩写），<code>lps[i]</code>表示<code>pat</code> 中<code>[0, i]</code>这个子串中即是前缀又是后缀的最长的子串（不包括<code>[0, i]</code>这个子串本身）</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [0, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3]</span><br></pre></td></tr></table></figure><p>在有了<code>lps</code>数组之后，就可以进行我们的KMP算法了：</p><ul><li>我们用 <code>i</code> 来指示 <code>txt</code> 中当前考虑的元素的下标，<code>j</code>来指示 <code>pat</code> 中当前考虑元素的下标</li><li>匹配从<code>i = 0</code>，<code>j = 0</code> 开始，当 <code>txt[i] == pat[j]</code> 时，<code>i++; j++</code>，此时这个位置是匹配的</li><li>当<code>txt[i] != pat[j]</code>即这个位置不匹配的时候<ul><li>既然能进行到这一步，说明<code>pat</code>的<code>[0, j - 1]</code>中的每个位置和<code>txt</code>的<code>[i - j, i - 1]</code>中的每个位置都是匹配的</li><li>我们还知道<code>lps[j - 1]</code>表示<code>pat</code> 中<code>[0, j - 1]</code>这个子串中即是前缀又是后缀的最长的子串</li><li>基于以上两点，我们发现在<code>pat</code>向右移动一位准备开始下一次匹配的时候，<code>pat</code>的前<code>lps[j - 1]</code>个字符是不需要匹配的（一定可以匹配成功），<code>j</code>重置为<code>lps[j - 1]</code></li></ul></li></ul><p>简言之，以图中的例子来说，在 <code>i</code> 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串<code>i</code>之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p><img src="https://pic4.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg" alt="来自知乎">，</p><h3 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>直到<code>i = 4, j = 4</code>为止都是匹配的，此时一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code>，也就是说，在下一次匹配中，<code>pat</code> 的前三个字符都不必进行匹配（一定可以匹配成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 4, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>此时<code>i = 5, j = 4</code>，又一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =   &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[3 - 1] = lps[2] = 2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 2</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =    &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[2 - 1] = lps[1] = 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =     &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[1 - 1] = lps[0] = 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =      &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，但是此时<code>j = 0</code>，故<code>i++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 6, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =       &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>$\dots$</p><p>重复上述过程，直到<code>i = n</code>，算法结束。</p><h3 id="lps的计算"><a href="#lps的计算" class="headerlink" title="lps的计算"></a>lps的计算</h3><p>现在，问题只剩下如何求得<code>lps</code>这个列表了。</p><p>求解<code>lps</code>的过程可以看作模式串自己与自己匹配的过程，对于每个位置（除了0位置，0位置永远为0）都与自己从头开始匹配，能匹配的最大长度就是<code>lps</code>。</p><p>实现中用<code>len</code>记录当前匹配到的最大长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> txt[MAXN], pat[MAXN];</span><br><span class="line"><span class="keyword">int</span> lps[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> txt[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txt[i] == pat[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == lenB) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - j + <span class="number">1</span>);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcLps</span><span class="params">(<span class="keyword">int</span> lps[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenPat = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenPat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            lps[len] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[len] == pat[i]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                lps[i] = len;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    lps[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> len = lps[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, txt, pat);</span><br><span class="line">    calcLps(lps, pat);</span><br><span class="line">    KMP(txt, pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, lps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" target="_blank" rel="noopener">KMP Algorithm for Pattern Searching</a></p><p><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 3 - 3</title>
      <link href="/2019/08/08/acmsummer_33/"/>
      <url>/2019/08/08/acmsummer_33/</url>
      
        <content type="html"><![CDATA[<p>线段树与树状数组专题限时训练一</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316474#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组限时训练1</a></p><a id="more"></a><h2 id="HDU-4217-Data-Structure-树状数组区间第k小-二分"><a href="#HDU-4217-Data-Structure-树状数组区间第k小-二分" class="headerlink" title="HDU 4217 Data Structure? - 树状数组区间第k小 + 二分"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4217" target="_blank" rel="noopener">HDU 4217 Data Structure? - 树状数组区间第k小 + 二分</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>在一个含有$1 \cdots n$的序列中，每次找到第 $k_i$ 小的数，并把它删除，每组数据，输出一个整数，表示删除元素的总和。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>发现一个数的排名只受它的位置之前被删除的数的个数影响，删除比它大的数不影响它的排名，这样问题就转化为了前缀和，可以用树状数组维护，对于要求排名 $k_i$ 的数，只会位于 $[k_i, n]$ 这个区间中，在这个区间二分找到将要被删除的那个数，计入答案即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">262144</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index]++;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf("[%d %d]", l, r);</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tmp = mid - bit.query(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> del = find(x, n, x);</span><br><span class="line"></span><br><span class="line">            ans += del;</span><br><span class="line">            bit.modify(del);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZOJ-1610-Count-the-Colors-区间染色"><a href="#ZOJ-1610-Count-the-Colors-区间染色" class="headerlink" title="ZOJ 1610 Count the Colors - 区间染色"></a><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1610" target="_blank" rel="noopener">ZOJ 1610 Count the Colors - 区间染色</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>对线段染色，后染上去的会覆盖前染上的，问完成染色后每种颜色各有多少段</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>线段树维护区间当前的颜色，对于每次修改，下放标记然后修改子树。</p><p>每组数据只有一次查询，在所有修改都结束之后记录下每个叶节点的颜色，把连续的相同颜色  都算成一段，统计即可</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        color = <span class="number">-1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) color = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color != <span class="number">-1</span>) &#123;</span><br><span class="line">            lc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line">            rc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;color = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), color);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, mid), r, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) v.push_back(<span class="keyword">this</span>-&gt;color);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;query(l, <span class="built_in">std</span>::min(r, mid), v);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegtree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegtree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegtree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, MAXN);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line"></span><br><span class="line">            root-&gt;modify(l, r, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        root-&gt;query(<span class="number">0</span>, MAXN, v);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt; v.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i + j] != v[i]) &#123;</span><br><span class="line">                    cnt[v[i]]++;</span><br><span class="line">                    i += j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, cnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        deleteSegtree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 3 - 1+2</title>
      <link href="/2019/08/06/acmsummer_312/"/>
      <url>/2019/08/06/acmsummer_312/</url>
      
        <content type="html"><![CDATA[<p>线段树与树状数组专题</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316346" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/316349" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练2</a></p><a id="more"></a><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Ultra-QuickSort-树状数组求逆序对-离散化"><a href="#C-Ultra-QuickSort-树状数组求逆序对-离散化" class="headerlink" title="C - Ultra-QuickSort - 树状数组求逆序对 + 离散化"></a><a href="https://cn.vjudge.net/contest/316346#problem/C" target="_blank" rel="noopener">C - Ultra-QuickSort - 树状数组求逆序对 + 离散化</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列，求对于升序排序的逆序对个数</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>树状数组求逆序对的模板题。</p><p>树状数组可以处理的问题是前缀和，对于某个元素来说，升序排序的逆序对的个数就是位置在它后面数值比他小的数的个数，这个就是一个前缀和的问题了。</p><p>对于每个元素，记录他的值和他的位置，按照从数值小到大的顺序排序去重完成离散化之后，把原数组从后往前的每个元素在排序好的数组中找到位置，用树状数组维护这个位置数组，这个位置的前缀和就是这个数逆序数，在找到的位置处加一。</p><p>例如 </p><script type="math/tex; mode=display">a = [9, 1, 0, 5, 4] \\a' = [0, 1, 5, 4, 9]\\</script><p>从后往前遍历 <code>a</code> 数组，</p><p>首先找到 $4$ ，在 <code>a&#39;</code> 数组中查找发现 $4$ 在第 $4$ 个位置，在树状数组中查询 $4$ 这个位置，发现前缀为 $0$ ，也就是 $4$ 后面数值比他小的数的个数为 $0$ ，也就是 $4$ 对于逆序数的贡献为 $0$，接下来在树状数组中把 $4$ 这个位置加一，</p><p>接下来找到 $5$ , 在 <code>a&#39;</code> 数组中查找发现 $5$ 在第 $3$ 个位置，在树状数组中查询 $3$ 这个位置，发现前缀为 $1$ ，也就是之前插入的 $4$，这说明 $5$ 后面数值比他小的数的个数为 $1$，也就是 $5$ 对于逆序数的贡献为 $1$，接下来在树状数组中把 $3$ 这个位置加一，</p><p>以此类推，最后的结果就是逆序对的总数。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    Bit(<span class="keyword">int</span> size) : size(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        bit.size = n;</span><br><span class="line">        <span class="built_in">memset</span>(bit.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit.a));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            v.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator newEnd = <span class="built_in">std</span>::unique(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">std</span>::lower_bound(v.begin(), newEnd, a[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">            ans += bit.query(index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            bit.modify(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理"><a href="#E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理" class="headerlink" title="E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3333" target="_blank" rel="noopener">E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列和若干询问，对于每个询问给出区间中不重复的元素的和</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>单独的一棵线段树/树状数组不能维护所有区间的不重复元素和，需要主席树等数据结构，这里的做法是离线处理每个查询。</p><p>把所有询问存下来，按照右端点从小到大排序，从小到大依次处理每个询问，对于一个新的询问，考察比上一个询问扩展出来的部分是否有之前出现过的元素，如果有就把之前的元素删除，把最近的加入，这样就保证了每个元素在每个询问中只出现一次，且是所有出现中最右边的那个。</p><p>更新完之后就可以用树状数组查询了。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        bit.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        bit.size = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            v.push_back(Query(l, r, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= it-&gt;r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.count(a[i])) bit.modify(mp[a[i]], -a[i]);</span><br><span class="line"></span><br><span class="line">                bit.modify(i, a[i]);</span><br><span class="line">                mp[a[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(<span class="built_in">std</span>::make_pair(it-&gt;id, bit.query(it-&gt;r) - bit.query(it-&gt;l - <span class="number">1</span>)));</span><br><span class="line">            l = it-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理"><a href="#F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理" class="headerlink" title="F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener">F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理</a></h2><h3 id="【题目大意】-2"><a href="#【题目大意】-2" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>马里奥吃金币，马里奥有在每个区间里有一个跳跃高度，只能吃到小于等于这个高度的硬币，给出若干组询问，问某个区间中能吃到多少金币。</p><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>离线处理所有询问，把每个点和每个询问都按照高度从小到大排序，排序后从小到大考察每个询问。</p><p>利用树状数组前缀求和的特点，只需要设置一个变量表示现在到了哪个金币，如果这个金币的高度小于当前询问的高度，就加入到树状数组当中，因为询问高度是单调增的，所以在前面的询问中加入的点仍然满足后面询问的条件，这样就只需要用树状数组维护一下区间和了。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; qs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i].h);</span><br><span class="line">            num[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;qs[i].l, &amp;qs[i].r, &amp;qs[i].h);</span><br><span class="line">            qs[i].l++;</span><br><span class="line">            qs[i].r++;</span><br><span class="line"></span><br><span class="line">            qs[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(qs, qs + m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt;= n &amp;&amp; num[cnt].h &lt;= qs[i].h) &#123;</span><br><span class="line">                bit.modify(num[cnt++].id, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[qs[i].id] = bit.query(qs[i].r) - bit.query(qs[i].l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="C-An-easy-problem-线段树维护区间乘积"><a href="#C-An-easy-problem-线段树维护区间乘积" class="headerlink" title="C - An easy problem - 线段树维护区间乘积"></a><a href="https://cn.vjudge.net/contest/316349#problem/C" target="_blank" rel="noopener">C - An easy problem - 线段树维护区间乘积</a></h2><h3 id="【题目大意】-3"><a href="#【题目大意】-3" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>令$x = 1$，给出两种操作</p><ul><li>操作<code>(1, a)</code>表示令 $x = a \cdot x$ </li><li>操作<code>(2, i)</code>表示令 $x = \frac{x}{a[i]}$，其中 $a[i]$ 表示第 $i$ 个一号操作中的<code>a</code>。</li></ul><p>问经过若干次操作之后 $x$ 的值是多少。</p><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>看上去维护一个数的更改，和线段树没有什么关系，其实把所有的一操作看作一个序列，问题就变成了维护区间乘积，二操作相当于把序列中的某个位置改成 $1$ ，这样就可以用线段树维护单点修改和区间乘积了。</p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> data;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="number">1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = (lc-&gt;data % mod * rc-&gt;data % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line">            <span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r)) % mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r) % mod) % mod;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;q, &amp;mod);</span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, q);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) root-&gt;modify(i, x);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) root-&gt;modify(x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;query(<span class="number">0</span>, q));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-HDU-2795-Billboard-线段树变形"><a href="#G-HDU-2795-Billboard-线段树变形" class="headerlink" title="G - HDU 2795 -Billboard - 线段树变形"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2795" target="_blank" rel="noopener">G - HDU 2795 -Billboard - 线段树变形</a></h2><h3 id="【题目大意】-4"><a href="#【题目大意】-4" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一个广告牌，有很多人往上贴广告，每个广告占一个单位高度，若干单位长度，广告优先往上边贴，同样高度情况下优先往左边贴，如果没有空间贴，就不贴。</p><p>对于每一张广告，询问它被贴在哪一行。</p><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题的修改的基本单位是行，以行为单位划分区间，想象把广告牌逆时针旋转九十度，建立线段树。</p><p>线段树维护每个区间中剩余空间的最大值，如果我们想贴一张新的海报上去，先与线段树的根节点值比较，如果大于根节点的值，说明所有行都没有空间贴这张新的海报；如果小于，就再与左右节点比较，以此类推，直到找到能贴的位置，注意要先和左子树比较再和右子树比较，因为要求尽量贴得高，旋转之后就是尽量贴得左。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = w;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="built_in">std</span>::max(lc-&gt;data, rc-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", this-&gt;l, this-&gt;r);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data = SegmentTree::w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int query(int l, int r) &#123;</span></span><br><span class="line">    <span class="comment">//     if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return this-&gt;data;</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         int ans = INT_MIN;</span></span><br><span class="line">    <span class="comment">//         if (l &lt; mid) ans = std::max(ans, query(l, std::min(r, mid)));</span></span><br><span class="line">    <span class="comment">//         if (r &gt; mid) ans = std::max(ans, query(std::max(l, mid), r));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         return ans;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data -= delta;</span><br><span class="line">            <span class="comment">// if (ans &lt;  this-&gt;id) ans = this-&gt;id;</span></span><br><span class="line">            ans = <span class="keyword">this</span>-&gt;id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lc-&gt;data &gt;= delta) lc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rc-&gt;data &gt;= delta) rc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d %d], data = %d\n"</span>, <span class="keyword">this</span>-&gt;l, <span class="keyword">this</span>-&gt;r, <span class="keyword">this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (lc) lc-&gt;print();</span><br><span class="line">        <span class="keyword">if</span> (rc) rc-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SegmentTree::w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree::w = w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int m = h;</span></span><br><span class="line">        <span class="comment">// if (h &gt; n) m = n;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">200000</span>) h = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("m = %d\n", m);</span></span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, h);</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", root-&gt;l, root-&gt;r);</span></span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("root-&gt;data = %d\n", root-&gt;data);</span></span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;modify(x) != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 2 - 4</title>
      <link href="/2019/08/04/acmsummer_24/"/>
      <url>/2019/08/04/acmsummer_24/</url>
      
        <content type="html"><![CDATA[<p>第二周限时训练二，题目多为思维题，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/314478#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练2</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 2 - 3</title>
      <link href="/2019/08/01/acmsummer_23/"/>
      <url>/2019/08/01/acmsummer_23/</url>
      
        <content type="html"><![CDATA[<p>第二周限时训练一，题目简单且友好，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314466#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练1</a></p><a id="more"></a><h2 id="D-D1-Add-on-a-Tree"><a href="#D-D1-Add-on-a-Tree" class="headerlink" title="D - D1. Add on a Tree"></a><a href="https://cn.vjudge.net/contest/314466#problem/D" target="_blank" rel="noopener">D - D1. Add on a Tree</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一棵树，在这棵树上有这样的操作：选择两个叶节点，将连接他们的路径上的边全部加上某个<strong>实数</strong> 。</p><p>问是否任意的边权都能通过这种方法构造出来。</p><p><img src="https://vj.ti12z.cn/534562b9f71c214456d4ad6501057031?v=1564228755" alt="NO"></p><p>这棵树不满足条件</p><p><img src="https://vj.ti12z.cn/c3350c6775c16b2e8fc87ea1963db02a?v=1564228755" alt="YES"></p><p>这棵树满足条件</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始以为是 <code>LCA</code> 结果是普通的思维题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-B-Letters-Shop-二分查找"><a href="#G-B-Letters-Shop-二分查找" class="headerlink" title="G - B. Letters Shop - 二分查找"></a><a href="https://cn.vjudge.net/contest/314466#problem/G" target="_blank" rel="noopener">G - B. Letters Shop - 二分查找</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 $S$ ，从中取前缀组合成新的字符串，给出目标字符串，输出最小需要的前缀的长度，数据保证目标串一定可以由 $S$ 的前缀的字符重新组合而成。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不关心目标串中字符出现的顺序，只要前缀中相应字符的数目多于目标串中该字符数目即可，先预处理出每个前缀中的每个字母的个数，对于每个目标串，统计其中各个字母的个数，与每个前缀比较，满足条件即可。</p><p>朴素的线性比较会<code>TLE</code>，改成二分查找即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>][s[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">        a[i][s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line">        fill(b, b + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s1) &#123;</span><br><span class="line">            b[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[mid][k] &lt; b[k]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; l + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-B-Yet-Another-Crosses-Problem-模拟"><a href="#H-B-Yet-Another-Crosses-Problem-模拟" class="headerlink" title="H - B. Yet Another Crosses Problem - 模拟"></a><a href="https://cn.vjudge.net/contest/314466#problem/H" target="_blank" rel="noopener">H - B. Yet Another Crosses Problem - 模拟</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一些方格图，<br><img src="https://vj.ti12z.cn/b3bf19b1108c5f82bd973def2f3b1a20?v=1564477339" alt="pic1"></p><p><img src="https://vj.ti12z.cn/0f6acf44abaaaf4dade9e99d5c3067c9?v=1564477339" alt="pic2"></p><p>现在需要把一些白格子染成黑色，使得图里存在至少一个<code>cross</code>（如pic2）。</p><p>问最少染几个白格子。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>之前在cf上遇到了这题，当时没做出来。</p><p>其实很简单，要构成<code>cross</code>必须至少有一整行和一整列都是黑色的，那就把每行每列有多少黑色统计出来，枚举每种行列的组合，找出一个黑色数目最多的，把剩下的染上就行了。</p><p>但是有一个问题是，行数和列数的最大值都很大，开二维数组是开不下的。注意到虽然 $n, m$ 都很大，但是 $n \cdot m$ 是不大的，所以用 <code>std::string</code> 数组比较好</p><p>深夜果然容易神志不清。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row[MAXN], col[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'*'</span>) row[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'*'</span>) col[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, row[i] + col[j] - (s[i][j] == <span class="string">'*'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n + m - <span class="number">1</span> - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 2 - 1+2</title>
      <link href="/2019/07/31/acmsummer_212/"/>
      <url>/2019/07/31/acmsummer_212/</url>
      
        <content type="html"><![CDATA[<p>基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314459" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/314460" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练2</a></p><a id="more"></a><h1 id="新的邻接表写法"><a href="#新的邻接表写法" class="headerlink" title="新的邻接表写法"></a>新的邻接表写法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dfn, degree;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), degree(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v]));</span><br><span class="line">    nodes[v].edges.push_back(Edge(&amp;nodes[v], &amp;nodes[u]));</span><br><span class="line"></span><br><span class="line">    nodes[u].degree++;</span><br><span class="line">    nodes[v].degree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的好处是多组数据初始化的时候边的删除很方便，尤其相对于之前的版本来说。</p><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Skiing-最短路"><a href="#C-Skiing-最短路" class="headerlink" title="C - Skiing - 最短路"></a><a href="https://cn.vjudge.net/contest/314459#problem/C" target="_blank" rel="noopener">C - Skiing - 最短路</a></h2><h2 id="F-Sorting-It-All-Out-拓扑排序"><a href="#F-Sorting-It-All-Out-拓扑排序" class="headerlink" title="F - Sorting It All Out - 拓扑排序"></a><a href="https://cn.vjudge.net/contest/314459#problem/F" target="_blank" rel="noopener">F - Sorting It All Out - 拓扑排序</a></h2><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="D-Caterpillar-DFS"><a href="#D-Caterpillar-DFS" class="headerlink" title="D - Caterpillar - DFS"></a><a href="https://cn.vjudge.net/contest/314460#problem/D" target="_blank" rel="noopener">D - Caterpillar - DFS</a></h2><h2 id="E-昂贵的聘礼"><a href="#E-昂贵的聘礼" class="headerlink" title="E - 昂贵的聘礼 "></a><a href="https://cn.vjudge.net/contest/314460#problem/E" target="_blank" rel="noopener">E - 昂贵的聘礼 </a></h2><h2 id="F-最短路径问题-最短路"><a href="#F-最短路径问题-最短路" class="headerlink" title="F - 最短路径问题 - 最短路"></a><a href="https://cn.vjudge.net/contest/314460#problem/F" target="_blank" rel="noopener">F - 最短路径问题 - 最短路</a></h2><h2 id="K-Highways"><a href="#K-Highways" class="headerlink" title="K - Highways "></a><a href="https://cn.vjudge.net/contest/314460#problem/K" target="_blank" rel="noopener">K - Highways </a></h2><h2 id="L-Truck-History"><a href="#L-Truck-History" class="headerlink" title="L - Truck History "></a><a href="https://cn.vjudge.net/contest/314460#problem/L" target="_blank" rel="noopener">L - Truck History </a></h2>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分约束系统学习笔记</title>
      <link href="/2019/07/30/difference_constraints/"/>
      <url>/2019/07/30/difference_constraints/</url>
      
        <content type="html"><![CDATA[<p>数学问题转化到图论上解决，有点巧妙。</p><a id="more"></a><p>差分约束系统是一种特殊的 $N$ 元一次不等式组。包含 $N$ 个变量，$M$ 个约束条件，每个约束条件都是以差分的形式给出，形如 $X_i - X_j \leq c_k$。</p><p>现在要求 $X_i$ 的一组解，使得所有不等式成立。</p><p>对于这样的问题，有一个统一的转化方法：</p><ul><li>把不等式表示成 $X_i - X_j \leq c_k$ 的形式，</li><li>把每个变量 $X_i$ 看作 <strong>有向图</strong> 中的一个结点 $i$，把每个约束条件 $X_i - X_j \leq c_k$ 看作从 $i$ 到 $j$ 连一条长度为 $c_k$ 的有向边，</li><li>注意到此时建立的图不一定联通，需要添加一个超级源点，从 $0$ 号结点向每个点连一条边权为$0$ 的边。</li><li>用 <strong>spfa</strong> 求出 $0$ 号点到各个点的最短路，如果最短路存在，那么每个点的 <code>dis</code> 值就是原不等式组的一组解。</li><li>如果有负环，则解不存在，为了解决负环的问题，只能用 <strong>spfa</strong> 来求最短路。</li></ul><p>为什么这样是对的？看上去毫不相干的不等式怎么和最短路怎么联系起来的呢？<br><del>其实不知道也没关系</del></p><p><a href="https://blog.csdn.net/PleasantlY1/article/details/82775505" target="_blank" rel="noopener">有空就学</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Poj 3169] Layout - 差分约束 + spfa</title>
      <link href="/2019/07/30/poj_3169/"/>
      <url>/2019/07/30/poj_3169/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>遇到这题才去学的<a href="https://ilern.github.io/2019/07/30/difference_constraints/">差分约束系统</a>。</p><p>明显题目中给出了关于两元素差的不等式，是差分约束的模型，转化成标准的模式 $a - b \leq c$，建图之后<code>SPFA</code>求出最短路即可，答案为<code>nodes[n].dis</code>。 </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dis, times;</span><br><span class="line">    <span class="keyword">bool</span> inQue;</span><br><span class="line"></span><br><span class="line">    Node() : dis(INT_MAX), times(<span class="number">0</span>), inQue(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;times++;</span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = v-&gt;edges.begin(); it != v-&gt;edges.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;to-&gt;dis &gt; v-&gt;dis + it-&gt;w) &#123;</span><br><span class="line">                it-&gt;to-&gt;dis = v-&gt;dis + it-&gt;w;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!it-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    it-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                    it-&gt;to-&gt;times++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;to-&gt;times &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    q.push(it-&gt;to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ml, md;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;ml, &amp;md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &lt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, -w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; n; i++) addEdge(i, i + 1, 0);</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) addEdge(0, i, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spfa(nodes + <span class="number">1</span>, n)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[n].dis == INT_MAX) <span class="built_in">printf</span>(<span class="string">"-2"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[n].dis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 1-4</title>
      <link href="/2019/07/27/acmsummer_14/"/>
      <url>/2019/07/27/acmsummer_14/</url>
      
        <content type="html"><![CDATA[<p>第一周限时训练二</p><p><img src="https://s2.ax1x.com/2019/07/30/eJG8hT.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/312636" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练2</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 1-3</title>
      <link href="/2019/07/26/acmsummer_13/"/>
      <url>/2019/07/26/acmsummer_13/</url>
      
        <content type="html"><![CDATA[<p>第一周限时训练一</p><p><img src="https://s2.ax1x.com/2019/07/27/euRsht.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312627#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练1</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM集训队暑假训练 1-2</title>
      <link href="/2019/07/25/acmsummer_12/"/>
      <url>/2019/07/25/acmsummer_12/</url>
      
        <content type="html"><![CDATA[<p>数学与DP专题二，比较难，不怎么会</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312624" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em> 专题训练2</a></p><a id="more"></a><h2 id="A-Easy-Game-区间DP"><a href="#A-Easy-Game-区间DP" class="headerlink" title="A - Easy Game - 区间DP "></a><a href="https://cn.vjudge.net/contest/312624#problem/A" target="_blank" rel="noopener">A - Easy Game - 区间DP </a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组，$A，B$ 两人轮流从数组的开头或结尾取走一个或若干个连续的数，取走的数的和记为得分。现在 $A$ 先开始这个游戏，问在最优情况下 $A$ 比 $B$ 多得多少分</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看上去像博弈，其实是DP</p><p>设状态 $f(l, r)$ 表示在左闭右开区间（取决于具体实现） $[l, r)$ 中取数字，在最优情况下的得分。（不区分$A ,B$）<br>设函数 $sum(l, r)$ 表示开区间 $[l, r)$ 的所有数字的和，用前缀和数组实现。</p><p>则转移为:</p><script type="math/tex; mode=display">f(l, r) = sum(l ,r) - \min\{minR, minL\}</script><script type="math/tex; mode=display">minR = \min_{l \leq i \leq r} \{f(i ,r)\}</script><script type="math/tex; mode=display">minL = \min_{l \leq i \leq r} \{f(l, i)\}</script><p>由于 $A$ 先手，我们可以让 $B$ 的收益最小来使得 $A$ 的收益最大，$minL$ 和 $minR$ 分别表示从左边取和从右边取能留下来的最小 $f$ 值，区间和减去剩下的最小值，就是取走的最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], sum[MAXN], f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[r - <span class="number">1</span>] - sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            f[i][i + <span class="number">1</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[l, r)</span></span><br><span class="line">        <span class="comment">//[1, n + 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len &lt;= n + <span class="number">1</span>; l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minL = f[l + <span class="number">1</span>][r];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) minL = <span class="built_in">std</span>::min(minL, f[i][r]);</span><br><span class="line">                <span class="keyword">int</span> minR = f[l][r - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; i--) minR = <span class="built_in">std</span>::min(minR, f[l][i]);</span><br><span class="line"></span><br><span class="line">                f[l][r] = getSum(l, r) - <span class="built_in">std</span>::min(<span class="number">0</span>, <span class="built_in">std</span>::min(minL, minR));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cnt, f[<span class="number">1</span>][n + <span class="number">1</span>] - sum[n] + f[<span class="number">1</span>][n + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// printf("----------\n");</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 2; j &lt;= n + 1; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         printf("%5d ", f[i][j]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     printf("\n");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4 -10 -20 7</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure><h2 id="B-The-Fewest-Coins-混合背包"><a href="#B-The-Fewest-Coins-混合背包" class="headerlink" title="B - The Fewest Coins  - 混合背包"></a><a href="https://cn.vjudge.net/contest/312624#problem/B" target="_blank" rel="noopener">B - The Fewest Coins  - 混合背包</a></h2><h2 id="C-String-painter-区间DP"><a href="#C-String-painter-区间DP" class="headerlink" title="C - String painter - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/C" target="_blank" rel="noopener">C - String painter - 区间DP</a></h2><h2 id="D-Max-Sum-Plus-Plus-区间DP"><a href="#D-Max-Sum-Plus-Plus-区间DP" class="headerlink" title="D - Max Sum Plus Plus - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/D" target="_blank" rel="noopener">D - Max Sum Plus Plus - 区间DP</a></h2><h2 id="E-Constructing-Roads-In-JGShining’s-Kingdom-最长上升子序列"><a href="#E-Constructing-Roads-In-JGShining’s-Kingdom-最长上升子序列" class="headerlink" title="E - Constructing Roads In JGShining’s Kingdom - 最长上升子序列"></a><a href="https://cn.vjudge.net/contest/312624#problem/E" target="_blank" rel="noopener">E - Constructing Roads In JGShining’s Kingdom - 最长上升子序列</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一些穷国和一些富国分别排在两条直线上，每个穷国和一个富国之间可以建道路，但是路不能交叉，给出每个穷国和富国的联系，求最多能建多少条路</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>把富国编号从大到小排序，问题转化为求最长上升子序列。</p><p>朴素的$O(n^2)$的最长上升子序列求法会<code>TLE</code>，需要用优化后的$O(n\log n)$的算法。</p><p>简述如下：</p><p>舍弃之前的 <code>f</code> 数组，另设立一个数组 <code>d[len]</code> 记录长度为 <code>len</code> 的最长上升子序列的最小结尾。</p><p>每次读到一个新的数字，如果这个数字比 <code>d</code> 数组的最后一个元素还要大，说明这个数可以续在 <code>d</code> 数组最后一个元素的后面使最长上升子序变长，此时<code>d[++len] = a[i]</code>。</p><p>如果这个数字比<code>d</code>数组的最后一个元素要小，就在 <code>d</code> 数组中找到比这个数小的最大的数，用这个数去更新 <code>d</code> 数组，这一步可以用 <code>std::lower_bound()</code> 完成，这也是复杂度中<code>log</code>的来源。</p><p>为什么这这样是对的？</p><ul><li>由于<code>d</code>数组定义为长度为 <code>len</code> 的最长上升子序列的最小结尾，如果想让<code>d</code>数组长度增加，则新元素大小必定增加，所以<code>d</code>数组单调，可以二分。</li><li>关于<code>d</code>数组的更新，状态<code>i + 1</code>一定是从状态<code>i</code>转移过来的，此时我们选择一个更小的数作为状态<code>i</code>的值，一定不会比原先的选择更劣，所以这样的更新也是成立的。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a &lt; a.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].a, &amp;nodes[i].b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(nodes, nodes + n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = nodes[<span class="number">0</span>].b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i].b &gt; ans[len - <span class="number">1</span>]) ans[(++len) - <span class="number">1</span>] = nodes[i].b;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="built_in">std</span>::lower_bound(ans, ans + len, nodes[i].b) - ans;</span><br><span class="line">                ans[pos] = nodes[i].b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     printf("%d ", ans[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// printf("\n");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Case %d:\nMy king, at most %d road can be built.\n\n"</span>, ++cnt, len);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d:\nMy king, at most %d roads can be built.\n\n"</span>, ++cnt, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 7</span></span><br><span class="line"><span class="comment">// 3 1</span></span><br><span class="line"><span class="comment">// 4 5</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 7 3</span></span><br><span class="line"><span class="comment">// 8 8</span></span><br><span class="line"><span class="comment">// 10 9</span></span><br></pre></td></tr></table></figure><h2 id="F-Farey-Sequence-欧拉函数"><a href="#F-Farey-Sequence-欧拉函数" class="headerlink" title="F - Farey Sequence - 欧拉函数"></a><a href="https://cn.vjudge.net/contest/312624#problem/F" target="_blank" rel="noopener">F - Farey Sequence - 欧拉函数</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个数字 $n$ ，求有多少个有序对 $<a, b>$ 满足</a,></p><ul><li>$0  &lt; a &lt; b \leq n$</li><li>$ \gcd(a, b) = 1$ </li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><script type="math/tex; mode=display">ans = \sum_{i = 2}^n \varphi(i)</script><p>先处理出欧拉函数值的数组，直接求和即可</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phiTable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) phi[i] = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    phiTable(<span class="number">1000000</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += phi[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf("%d\n", 2 * sum + 1);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-The-Luckiest-number-欧拉定理-原根-数学技巧"><a href="#G-The-Luckiest-number-欧拉定理-原根-数学技巧" class="headerlink" title="G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧"></a><a href="https://cn.vjudge.net/contest/312624#problem/G" target="_blank" rel="noopener">G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧</a></h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数字 $L$ ，求一个最小的每一位都是 $8$ 的 $L$ 的倍数</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>对于一个 $n$ 位的全是 $8$ 的数字</p><script type="math/tex; mode=display">\begin{aligned}888 \dots 888 &= 8 \times 111 \dots 111 \\&= 8 \sum_{i = 0}^n 10^i \\&= 8 \times \frac{10^n - 1}{9}\end{aligned}</script><p>这个数是 $L$ 的倍数， 有</p><script type="math/tex; mode=display">8(10^n - 1) = k \cdot 9L</script><p>两边同除 $\gcd(8, L)$，记  $p = \frac{8}{\gcd(8, L)}, q = \frac{k \cdot 9L}{\gcd(8, L)}$，有</p><script type="math/tex; mode=display">p(10^n - 1) = q</script><p>$p, q$ 互质，两边同时对 $q$ 取模，得</p><script type="math/tex; mode=display">10^n \equiv 1 \pmod q</script><p>问题转化为求上面这个非线性同余方程的最小正整数解。</p><p>由欧拉定理知，当 $10$ 和 $q$ 互质的时候，有</p><script type="math/tex; mode=display">10^{\varphi(q)} \equiv 1 \pmod q</script><p>当 $10$ 和 $q$ 不互质的时候方程无解</p><p>$\varphi(q)$虽然是方程的一个解，但是不一定是最小正整数解，接下来枚举 $\varphi(q)$ 的因数，代入原方程检验是否成立</p><p>为什么$\varphi(q)$ 的因数是原方程的解？<br>涉及到<code>阶</code>的概念</p><ul><li>设 $m &gt; 1$ ，$\gcd(a, m) = 1$，则使得 $a^r \equiv 1 \pmod m$ 成立的最小正整数 $r_0$ 称为$a$ 对模 $m$ 的阶，记作 $\delta_m(a)$</li><li>若 $m &gt; 1$，$\gcd(a, m) = 1$，$a^n \equiv 1 \pmod m$，则 $\delta_m(a) | n$</li></ul><p>所以原方程就是求阶。</p><p>乘法会爆<code>long long</code> 所以使用所谓快速乘法</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long long fastPowMod(long long a, long long b, long long p) &#123;</span></span><br><span class="line"><span class="comment">//     long long ans = 1 % p;</span></span><br><span class="line"><span class="comment">//     for (; b; b &gt;&gt;= 1) &#123;</span></span><br><span class="line"><span class="comment">//         if (b &amp; 1) ans = (ans % p * a % p) % p;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         a = (a % p * a % p) % p;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return ans;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = (ans + a) % m;</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = (a + a) % m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">a %= m;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">ans = Mul(ans, a, m);</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = Mul(a, a, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x) != EOF &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">9</span> * x / gcd(<span class="number">8</span>, x);</span><br><span class="line">        <span class="keyword">if</span> (gcd(<span class="number">10</span>, p) != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> m = phi(p);</span><br><span class="line"></span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i * i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    v.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span> (i * i != m) v.push_back(m / i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fastPowMod(<span class="number">10</span>, v[i], p) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, v[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Best-Solver-矩阵快速幂-广义斐波那契循环节降幂"><a href="#H-Best-Solver-矩阵快速幂-广义斐波那契循环节降幂" class="headerlink" title="H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂"></a><a href="https://cn.vjudge.net/contest/312624#problem/H" target="_blank" rel="noopener">H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂</a></h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>设</p><script type="math/tex; mode=display">y = (5 + 2\sqrt6)^{1+2^x} , 0 \leq x \leq 2^{32}</script><p>给定 $x$ 和 $M$，求</p><script type="math/tex; mode=display">[y] \% m</script><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>看到这个式子，明显不能直接计算，先不管指数过大的问题，考虑如何求</p><script type="math/tex; mode=display">a_n = (5 + 2\sqrt6)^n</script><p>先写出前几项看一看</p><script type="math/tex; mode=display">a_1 = 5 + 2\sqrt6 \\a_2 = (5+2\sqrt6)^2 = 25 + 24 + 20\sqrt6 = 49 + 20\sqrt6 \\a_3 = (5+2\sqrt6)^2 = (49 + 20\sqrt6) \times (5 + 2\sqrt6) = 585 + 198\sqrt6</script><p>发现只是系数变了，不妨设 </p><script type="math/tex; mode=display">a_n =x_n + y_n \sqrt 6</script><p>则</p><script type="math/tex; mode=display">\begin{align}a_{n+1} &= (x_n + y_n \sqrt 6) \cdot (5 + 2\sqrt6) \\&= 5x_n + 12y_n + (2x_n + 5y_n)\sqrt6 \\&= x_{n+1} + y_{n+1}\sqrt6\end{align}</script><p>所以</p><script type="math/tex; mode=display">\begin{equation}\begin{cases}x_{n+1} = 5x_n + 12y_n \\[2ex]y_{n+1} = 2x_n + 5y_n\end{cases}\end{equation}</script><p>写成矩阵的形式</p><script type="math/tex; mode=display">\begin{bmatrix}     5 & 12 \\     2 & 5\end{bmatrix}\begin{bmatrix}    x_n\\    y_n\end{bmatrix}=\begin{bmatrix}    x_{n+1}\\    y_{n+1}\end{bmatrix}</script><p>现在我们就可以用矩阵快速幂快速计算系数了。</p><p>解决了底数计算，再来看指数上的$1 + 2^x$，这个东西非常大，所以需要用一些手段来降幂，对于整数的大幂计算，可以利用<a href="https://blog.csdn.net/ACdreamers/article/details/8236942" target="_blank" rel="noopener">指数循环节</a>用欧拉函数降幂，即</p><script type="math/tex; mode=display">A^B \mod C = A^{B \mod \varphi(C) + \varphi(C)} \mod C</script><p>但是对于矩阵是不能这样搞的，需要找到<a href="https://blog.csdn.net/ACdreamers/article/details/25616461" target="_blank" rel="noopener">矩阵的循环节(广义斐波那契数列循环节)</a>，对于寻找的方法，暂时超出了我的能力范围，暂记结论</p><p>广义斐波那契数列的循环节为 $p + 1$ 或 $(p+1) \cdot (p-1)$</p><p>这样就可以在用快速幂计算指数的时候把模数设为循环节达到降幂的目的。</p><p>这样底数和指数的问题就解决了，先降幂算出指数之后，矩阵快速幂算出底数两项的系数，带入公式计算然后取整即可。</p><p>注意降幂时的模数和矩阵快速幂的模数不是同一个。</p><p>这题比较难，但是也有套路的东西在里面。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> sizeX, sizeY;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> sizeX = <span class="number">0</span>, <span class="keyword">int</span> sizeY = <span class="number">0</span>) : sizeX(sizeX), sizeY(sizeY) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(sizeX, a.sizeY)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sizeY; k++) &#123;</span><br><span class="line">                    ans.a[i][j] += (<span class="keyword">this</span>-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD;</span><br><span class="line">                    ans.a[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;a[i][j] = a.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastPowMod</span><span class="params">(Matrix m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> fastPowMod(m, n - <span class="number">1</span>) * m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(m * m, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">for</span> ( ; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans % p * a % p) % p;</span><br><span class="line">        a = (a % p * a % p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MOD);</span><br><span class="line"></span><br><span class="line">        <span class="function">Matrix <span class="title">shift</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">        shift.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>; shift.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">12</span>;</span><br><span class="line">        shift.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>; shift.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">        ans.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int p = phi(MOD);</span></span><br><span class="line">        <span class="comment">// long long b = (fastPowMod(2, x, p) + 1 + p) % p;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b = fastPowMod(<span class="number">2</span>, x, MOD * MOD - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("p = %d, b = %lld\n", p, b);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Matrix tmp = fastPowMod(shift, b - 1);</span></span><br><span class="line">        <span class="comment">// ans = tmp * ans;</span></span><br><span class="line">        ans = fastPowMod(shift, b - <span class="number">1</span>) * ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("Case #%d: %d\n", ++cnt, (int)(ans.a[0][0] + ans.a[1][0] * sqrt(6)) % MOD);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++cnt, (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="number">2</span> * ans.a[<span class="number">0</span>][<span class="number">0</span>] % MOD - <span class="number">1</span>) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Queries-for-Number-of-Palindromes-区间DP"><a href="#K-Queries-for-Number-of-Palindromes-区间DP" class="headerlink" title="K - Queries for Number of Palindromes - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/K" target="_blank" rel="noopener">K - Queries for Number of Palindromes - 区间DP</a></h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串，求其回文子串的个数。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>比较典型的区间DP题目</p><p>设状态 $f(l, r)$ 表示左闭右开区间 $[l, r)$ 中的回文子串个数，<code>isP[l, r]</code>数组表示在区间$[l ,r)$中的字符串是否为回文串。</p><p>则转移为</p><script type="math/tex; mode=display">f(l, r) = f(l + 1, r) + f(l, r - 1) - f(l + 1, r - 1) + \text{isP}[l, r]</script><p>区间的计数问题常常这样解决。<br>好像有点容斥的感觉？<br>记得预处理<code>isP</code>数组。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> isP[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        isP[i][i + <span class="number">1</span>] = isP[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            isP[i][j] = (isP[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            f[i][j] = f[i][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j] - f[i + <span class="number">1</span>][j - <span class="number">1</span>] + isP[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[l][r + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Diophantus-of-Alexandria"><a href="#L-Diophantus-of-Alexandria" class="headerlink" title="L - Diophantus of Alexandria"></a><a href="https://cn.vjudge.net/contest/312624#problem/L" target="_blank" rel="noopener">L - Diophantus of Alexandria</a></h2><h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HDU 1576] A/B - 乘法逆元+费马小定理/扩展欧几里得</title>
      <link href="/2019/07/21/hdu_1576/"/>
      <url>/2019/07/21/hdu_1576/</url>
      
        <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576" target="_blank" rel="noopener">HDU 1576 A/B</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>要求$(A / B)\%9973$，但由于$A$很大，我们只给出$n(n = A \% 9973)$(我们给定的$A$必能被$B$整除，且$\gcd(B, 9973) = 1)$。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>$(A / B)\%9973 = (AB^{-1}) \% 9973 = (A \% 9973 \cdot B^{-1} \%9973) \%9973 = (n \cdot B^{-1} \%9973) \%9973$</p><p>问题转化为求$B^{-1}$</p><p>可用费马小定理或者扩展欧几里得算法求解。</p><p>​    </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % MOD;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;b);</span><br><span class="line"></span><br><span class="line">        b = fastPowMod(b, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (n % MOD * b % MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得算法学习笔记</title>
      <link href="/2019/07/21/exgcd_learn/"/>
      <url>/2019/07/21/exgcd_learn/</url>
      
        <content type="html"><![CDATA[<p>扩展欧几里得算法能在计算$\gcd(a,b)$ 的同时求解方程$ax + by = \gcd(a, b)$的一组特解。</p><p>是为欧几里得算法之扩展。</p><a id="more"></a><h3 id="Bezout’s-identity（裴蜀定理）"><a href="#Bezout’s-identity（裴蜀定理）" class="headerlink" title="Bézout’s identity（裴蜀定理）"></a>Bézout’s identity（裴蜀定理）</h3><blockquote><p>对于任意整数$a, b$，存在一对整数 $x, y$ 满足$ax + by = \gcd(a, b)$</p></blockquote><p>使用（类似）数学归纳法证明：</p><ul><li><p>当 $b = 0$ 时，有$x = 1, y  = 0$ 使得等式成立，即有 $a \times 1 + b \times 0 = \gcd(a, 0) = a$</p></li><li><p>当 $b&gt;0$ 时，假设存在 $x, y$  使得等式成立，即</p><script type="math/tex; mode=display">ax + by = \gcd(a, b) = \gcd(b, a \% b) = bx + (a \% b)y</script><p> 又由取模运算的定义</p><script type="math/tex; mode=display">a \% b = a - b \lfloor \frac{a}{b} \rfloor</script><p>可知</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\gcd(a, b) &= bx + ay - b \lfloor \frac{a}{b} \rfloor y \\&= ay + b(x - b \lfloor \frac{a}{b} \rfloor y)\end{aligned}\end{equation}</script><p>令 $x’ = y, y’ = x - b \lfloor \frac{a}{b} \rfloor y$ 可得 $ax’ + by’ = gcd(a, b)$</p><p>即 $bx + (a \% b)y = \gcd(a, b)$ 有解</p></li><li><p>这里的 $a, b$ 在交换一次之后变小了，这样一直递归下去就会到达 $b = 0$ 的边界，所以解一定存在</p></li></ul><h3 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x; x = y; y = z - y * (a / b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码求出了$ax + by = \gcd(a, b)$，返回了$\gcd(a, b)$。</p><p>对于一般的线性方程$ax + by = c$，当且仅当$\gcd(a, b) | c$ 时存在非负整数解，此时先用扩展欧几里得算法求出$ax + by = \gcd(a, b)$ 的一组特解 $x_0, y_0$ 再等式两边同时乘以$\frac{c}{\gcd(a,b)}$ 即可求得原方程的一组特解 $x_0 \frac{c}{\gcd(a, b)}, y_0 \frac{c}{\gcd(a, b)}$</p><p>而原方程的通解表示为</p><script type="math/tex; mode=display">\begin{aligned}x &= x_0 \frac{c}{\gcd(a, b)} + k \frac{b}{\gcd(a, b)} \\y &= y_0 \frac{c}{\gcd(a, b)} + k \frac{a}{\gcd(a, b)}\end{aligned}</script><p>其中 $k$ 可以取遍全体整数</p><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>线性同余方程是指形如 $ax \equiv b \pmod m$ 的方程，因为未知数为的次数为一，故称之为<strong>线性</strong>同余方程。</p><p>扩展欧几里得算法的应用之一就是求解线性同余方程。</p><p>同余可以理解为<strong>模等于</strong>，也就是 $ax$ 模 $m$ 等于 $b$ ，所以原方程表示 $ax-b$ 是 $m$ 的倍数，不妨设为 $-y$ 倍，则原方程转化为 $ax - b = -ym$ 即 $ax + my = b$ 。</p><p>这样的方程我们可以用扩展欧几里得算法进行求解，当且仅当 $\gcd(a, m) | b$ 时，方程有解，易得原线性同余方程方程的特解为 $x = x_0 \frac{b}{\gcd(a, m)}$</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>特殊地，当 $ax \equiv 1 \pmod m$ 时， $x$ 被称为 $a$ 在模 $m$ 意义下的逆元，可以套用上面的方法求出，要求$\gcd(x, m) = 1$</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Leading and Trailing - 对数 + 快速幂</title>
      <link href="/2019/07/21/Lat/"/>
      <url>/2019/07/21/Lat/</url>
      
        <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p> <a href="https://vjudge.net/contest/312605#problem/B" target="_blank" rel="noopener">Leading and Trailing</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>You are given two integers: $n$ and $k$, your task is to find the most significant three digits, and least significant three digits of $n^k$.</p><p>给定$n$和$k$，求$n^k$的前三位数字和后三位数字。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>后三位数字直接用快速幂对$1000$取模即可。</p><p>前三位数字的做法比较巧妙。</p><p>设 $10^p = n^k$ ，两边同取对数 $p = k\lg n$ ，$p$ 是一个浮点数，整数部分为$[p]$, 记为 $x$ ; 小数部分为 $p - [p]$， 记为$y$ 。有$10^p = 10^{x + y} = 10^x \cdot 10^y = n^k$ 这样就把 $n^k$ 转化为了科学记数法表示，$10^y &lt; 1$ ，所以要求的前三位就是 $10^y \cdot 10^3 = 10^{y+3}$。</p><p>最后三位前面不足的位置补$0$。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % MOD;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">1</span>; cnt &lt;= t; cnt++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> p = k * <span class="built_in">log10</span>(n);</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>)p;</span><br><span class="line">        <span class="keyword">double</span> y = p - x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %03d\n"</span>, cnt, (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10.0</span>, y + <span class="number">2</span>), fastPowMod(n, k));</span><br><span class="line">        <span class="comment">//if (cnt &lt; t) printf("\n");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[bzoj 1477] 青蛙的约会  - 扩展欧几里得</title>
      <link href="/2019/07/21/bzoj_1477/"/>
      <url>/2019/07/21/bzoj_1477/</url>
      
        <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1477" target="_blank" rel="noopener">bzoj 1477 青蛙的约会</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 $A$ 的出发点坐标是 $x$，青蛙 $B$ 的出发点坐标是 $y$。青蛙 $A$ 一次能跳 $m$ 米，青蛙 $B$ 一次能跳$n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>青蛙$A$: $(x + km) \% L$</p><p>青蛙$B$: $(y + kn)\%L$</p><p>问题转化为$(x + km) \% L = (y + kn)\%L$</p><p>展开得线性同余方程$k(m-n) \equiv y-x \pmod L$</p><p>其中 $m-n$ 和 $ y-x  $ 都是已知的常数，利用扩展欧几里得算法求出 $k$ 即可。</p><p>需要注意的是$(m-n)$一定要是正的，如果算出来是负的，等号两边同乘以负一。</p><p>最后 $k$ 也应该也是正的，如果算出来是负的，加上$\frac{b}{d}$就好。</p><p>记得用<code>long long</code></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x; x = y; y = z - y * (a / b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, m, n, l;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = m - n;</span><br><span class="line">    <span class="keyword">int</span> b = l;</span><br><span class="line">    <span class="keyword">int</span> c = y - x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        a = -a;</span><br><span class="line">        c = -c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("a = %d, b = %d, c = %d\n", a, b, c);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve ax + cy = b;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">    <span class="comment">//printf("d = %d\n", d);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x0 = <span class="number">0</span>, y0 = <span class="number">0</span>;</span><br><span class="line">        d = exgcd(a, b, x0, y0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = x0 * c / d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = b / d;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) x %= t;</span><br><span class="line">        <span class="keyword">else</span> x = x % t + t;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[QDUoj 582] 嘉馨学姐吃包子 - 三分</title>
      <link href="/2019/07/03/qduoj582/"/>
      <url>/2019/07/03/qduoj582/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://qduoj.com/problem/582" target="_blank" rel="noopener">嘉馨学姐吃包子</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>嘉馨学姐非常爱吃包子，但是嘉馨学姐这个人很懒，她总是希望包子可以自己飞到她的嘴里，现在有 $n(n \leq 100000)$ 个包子，告诉你每个包子的位置 $p_i(|p_i| \leq 10^6)$ 和重量$w_i(1 &lt; w_i \leq 10)$。</p><p>已知包子飞行时，包子的口感度会降低，如果一个包子飞行了$x$，那这个包子的口感度会降低$x^3 \times w$。嘉馨学姐的初始位置由你来决定，要求尽量使所有包子降低的口感度总和$F$最小。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设起点为$x$，则每个包子移动的距离为$|p_i - x|$，那么降低的口感总和为</p><script type="math/tex; mode=display">f(x) = \sum_{i = 0}^n (|p_i - x|)^3 \times w_i</script><p>三分这个函数求出最值即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret += (<span class="built_in">pow</span>(<span class="built_in">fabs</span>(p[i] - x), <span class="number">3</span>) * w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e6</span>; <span class="keyword">double</span> r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt;= EPS) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> midL = mid - EPS;</span><br><span class="line">        <span class="keyword">double</span> midR = mid + EPS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (func(n, midL) &gt; func(n, midR)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>, func(n, l) / <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 三分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三分法学习笔记</title>
      <link href="/2019/07/03/divide3/"/>
      <url>/2019/07/03/divide3/</url>
      
        <content type="html"><![CDATA[<p>三分法是一种求解单峰函数极值的算法</p><a id="more"></a><h3 id="【简介】"><a href="#【简介】" class="headerlink" title="【简介】"></a>【简介】</h3><p>所谓单峰函数，如图所示，三分法可以求出这样的函数的极值。</p><p><img src="https://s2.ax1x.com/2019/07/03/ZYK4FP.png" alt="pic1"></p><h3 id="【算法】"><a href="#【算法】" class="headerlink" title="【算法】"></a>【算法】</h3><ul><li>确定极值点所在的区间</li><li>取区间的中点 <code>mid</code></li><li>在中点左右各一个小距离中分别取<code>midL</code> <code>midR</code>，这两个点将整个区间三分</li><li><p>计算出<code>midL</code> <code>midR</code>的函数值</p><ul><li>若<code>f(midL)</code> 比较大，则舍弃右边的部分，将区间右端点设置为<code>mid</code></li><li>若<code>f(midR)</code>比较大，则舍弃左边的部分，将区间左端点设置为<code>mid</code></li></ul></li><li><p>重复上述过程直至区间大小小于某个设定好的<code>EPS</code></p></li></ul><h3 id="【模板】"><a href="#【模板】" class="headerlink" title="【模板】"></a>【模板】</h3><p><a href="https://www.luogu.org/problemnew/show/P3382" target="_blank" rel="noopener">洛谷P3382 【模板】三分法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// double func(double a[], int n, double x) &#123;</span></span><br><span class="line"><span class="comment">//     double ret = 0;</span></span><br><span class="line"><span class="comment">//     double b = 1;</span></span><br><span class="line"><span class="comment">//     for (int i = n; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//         ret += (b * a[i]);</span></span><br><span class="line"><span class="comment">//         b *= x;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return ret;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum = sum * x + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt;= EPS) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// double midL = (l + r) / 3;</span></span><br><span class="line">        <span class="comment">// double midR = midL * 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> midL = mid - EPS;</span><br><span class="line">        <span class="keyword">double</span> midR = mid + EPS;</span><br><span class="line">        <span class="keyword">if</span> (func(a, n, midL) &lt; func(a, n, midR)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[蓝桥杯 2013] 幸运数 - 构造</title>
      <link href="/2019/05/21/lq2013_1/"/>
      <url>/2019/05/21/lq2013_1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://lx.lanqiao.cn/problem.page?gpid=T33" target="_blank" rel="noopener">历届试题 幸运数</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成</p><p>首先从1开始写出自然数 $1,2,3,4,5,6, \dots$</p><p>$1$ 就是第一个幸运数。</p><p>我们从2这个数开始。把所有序号能被2整除的项删除，变为：</p><script type="math/tex; mode=display">1, 3, 5, 7, 9 \dots</script><p>这时，$3$ 为第 $2$ 个幸运数，然后把所有能被 $3$ 整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被$3$ 整除!! 删除的应该是 $5, 11, 17,\dots$</p><p>此时$7$为第$3$个幸运数，然后再删去序号位置能被$7$整除的$(19, 39, …)$</p><p>最后剩下的序列类似：</p><script type="math/tex; mode=display">1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, \dots</script><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>关键点在于如何构造出题目中要求的数列。</p><p>没有必要每次删除再移位再删除，发现前面没有被删除的数在后续的操作中也不会被删除</p><p>所以只需要找出当前这轮不会被删除的数填到数组中，下一轮参考的元素变成下一个，重复这样的过程。</p><p>只需要生成到$m$为止即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % a[x] != <span class="number">0</span>) a[cnt++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        a[i] = (i * <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; n) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【5.13】2019一起开心蓝桥国赛训练</title>
      <link href="/2019/05/14/5132109/"/>
      <url>/2019/05/14/5132109/</url>
      
        <content type="html"><![CDATA[<h2 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h2><p><a href="http://fastvj.rainng.com/contest/301445#overview" target="_blank" rel="noopener">【5.13】2019一起开心蓝桥国赛训练</a></p><ul><li>树状数组</li><li>线段树</li><li>SPFA</li><li>桥</li><li>欧拉回路/函数</li><li>数学</li><li>SG博弈</li></ul><a id="more"></a><p>密码：bullet</p><h2 id="A-hdu4738-Caocao’s-Bridges-Tajan求桥"><a href="#A-hdu4738-Caocao’s-Bridges-Tajan求桥" class="headerlink" title="A - hdu4738 - Caocao’s Bridges - Tajan求桥"></a>A - hdu4738 - Caocao’s Bridges - Tajan求桥</h2><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>双联通分量的模板题。</p><p>求出所有桥中边权最小的那个。</p><p>Tarjan算法求桥和求割点/强连通分量的算法类似，都用到了<code>low</code>和<code>dfn</code>两个标记。</p><p>由于一个环中的点<code>dfn</code>值都是相同的，如果有一个点的<code>dfn</code>大于它的父亲节点，那连接这两个点的边一定是一个桥。</p><p>参看<a href="https://ilern.github.io/2018/06/28/tarjan_note/">Tarjan强连通分量学习笔记</a></p><p>这题有几个坑:</p><ul><li>图可能不连通</li><li>图里可能有重边</li><li>如果边权最小的为$0$，答案应该是$1$，因为总要派一个人去爆破（题意）。</li></ul><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> haveEdge[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dfn, low;</span><br><span class="line">    <span class="keyword">bool</span> vis;</span><br><span class="line"></span><br><span class="line">    Node *fa;</span><br><span class="line"></span><br><span class="line">    Edge *edges;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), low(<span class="number">0</span>), vis(<span class="literal">false</span>), fa(<span class="literal">NULL</span>), edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">    v-&gt;edges = <span class="keyword">new</span> Edge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(haveEdge, <span class="number">0</span>, <span class="keyword">sizeof</span>(haveEdge));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nodes[i].dfn = <span class="number">0</span>;</span><br><span class="line">        nodes[i].low = <span class="number">0</span>;</span><br><span class="line">        nodes[i].vis = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> nodes[i].edges;</span><br><span class="line">        nodes[i].edges = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        nodes[i].fa = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;to == x-&gt;fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;to-&gt;fa) &#123;</span><br><span class="line">            e-&gt;to-&gt;fa = x;</span><br><span class="line">            tarjan(e-&gt;to);</span><br><span class="line">            x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;low);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x-&gt;vis) num++;</span><br><span class="line">    x-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;fa &amp;&amp; e-&gt;to == x-&gt;fa || e-&gt;to-&gt;vis) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (haveEdge[e-&gt;fr - nodes][e-&gt;to - nodes] == <span class="number">1</span> &amp;&amp; e-&gt;to-&gt;low &gt; x-&gt;low) min = <span class="built_in">std</span>::min(min, e-&gt;w);</span><br><span class="line">            dfs(e-&gt;to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF &amp;&amp; n != <span class="number">0</span> &amp;&amp; m != <span class="number">0</span>) &#123;</span><br><span class="line">        init(n);</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        min = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            addEdge(nodes + u, nodes + v, w);</span><br><span class="line">            haveEdge[u][v]++;</span><br><span class="line">            haveEdge[v][u]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tarjan(nodes + <span class="number">1</span>);</span><br><span class="line">        dfs(nodes + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num != n) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (min == INT_MAX) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-POJ-3245-Wormholes-SPFA判负环"><a href="#B-POJ-3245-Wormholes-SPFA判负环" class="headerlink" title="B - POJ 3245 - Wormholes - SPFA判负环"></a>B - POJ 3245 - Wormholes - SPFA判负环</h2><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>裸的SPFA判负环，条件是存在某一个节点入队次数大于$n$(节点总数)。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPFA判负环</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">bool</span> inQue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    Node() : edges(<span class="literal">NULL</span>), dis(INT_MAX), inQue(<span class="literal">false</span>), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;cnt++;</span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123;</span><br><span class="line">                e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w;</span><br><span class="line">                <span class="keyword">if</span> (!e-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    e-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                    e-&gt;to-&gt;cnt++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (e-&gt;to-&gt;cnt &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    q.push(e-&gt;to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes[i].dis = INT_MAX;</span><br><span class="line">        nodes[i].inQue = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">delete</span> nodes[i].edges;</span><br><span class="line">        nodes[i].edges = <span class="literal">NULL</span>;</span><br><span class="line">        nodes[i].cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;w);</span><br><span class="line"></span><br><span class="line">        init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + w; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s, e, t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;e, &amp;t);</span><br><span class="line">            s--; e--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m) &#123;</span><br><span class="line">                addEdge(nodes + s, nodes + e, t);</span><br><span class="line">                addEdge(nodes + e, nodes + s, t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addEdge(nodes + s, nodes + e, -t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (spfa(nodes, n)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-POJ-3468-A-Simple-Problem-with-Integers-线段树"><a href="#C-POJ-3468-A-Simple-Problem-with-Integers-线段树" class="headerlink" title="C - POJ 3468 - A Simple Problem with Integers - 线段树"></a>C - POJ 3468 - A Simple Problem with Integers - 线段树</h2><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>用线段树维护区间和，支持区间修改和区间查询。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树区间加 区间和</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lazy;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        sum = lazy = <span class="number">0</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;sum = lc-&gt;sum + rc-&gt;sum;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) sum = a[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">        lazy += tag;</span><br><span class="line">        sum += (r - l) * tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">            lc-&gt;addTag(lazy);</span><br><span class="line">            rc-&gt;addTag(lazy);</span><br><span class="line">            lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans += lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r));</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans += rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == l &amp;&amp; <span class="keyword">this</span>-&gt;r == r) addTag(delta);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r), delta);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, <span class="keyword">this</span>-&gt;mid), r, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, n);</span><br><span class="line">    root-&gt;build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        l--; r--;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;query(l, r + <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'C'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> del;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; del;</span><br><span class="line">            root-&gt;modify(l, r + <span class="number">1</span>, del);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-HDU-1166-敌兵布阵-树状数组-线段树"><a href="#D-HDU-1166-敌兵布阵-树状数组-线段树" class="headerlink" title="D - HDU 1166 - 敌兵布阵 - 树状数组/线段树"></a>D - HDU 1166 - 敌兵布阵 - 树状数组/线段树</h2><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>用线段树/树状数组维护区间和，支持单点修改区间查询，树状数组代码量相对较少。</p><p>注意用树状数组查询区间$[l, r]$的区间和要写成<code>query(r) - query(l - 1)</code></p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树（树状数组）单点修改前缀求和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= n) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            bit.modify(i, x);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++cnt &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">"End"</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> a, b;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">"Add"</span>) &#123;</span><br><span class="line">                    bit.modify(a, b);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">"Query"</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bit.query(b) - bit.query(a - <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">"Sub"</span>) &#123;</span><br><span class="line">                    bit.modify(a, -b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-POJ-2230-Watchcow-欧拉回路"><a href="#E-POJ-2230-Watchcow-欧拉回路" class="headerlink" title="E - POJ 2230 - Watchcow - 欧拉回路"></a>E - POJ 2230 - Watchcow - 欧拉回路</h2><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>欧拉回路模板题，用<code>dfs</code>求欧拉回路。其中不允许同向走两次的要求用对边打标记实现，由于加边时加的是两条方向相反的边，走的时候给其中一条标记上之后，相反方向的那条还是可以走的。</p><p>由于不确定的原因，<code>TLE</code>，大概是指针邻接表的锅。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line"></span><br><span class="line">    Node() : edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to), vis(<span class="literal">false</span>) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v); </span><br><span class="line">    v-&gt;edges = <span class="keyword">new</span> Edge(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span> * MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(e-&gt;vis)) &#123;</span><br><span class="line">            e-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">            dfs(e-&gt;to);</span><br><span class="line">            ans[cnt++] = (e-&gt;to) - nodes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addEdge(nodes + u, nodes + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nodes + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-POJ-3090-Visible-Lattice-Points-欧拉函数"><a href="#F-POJ-3090-Visible-Lattice-Points-欧拉函数" class="headerlink" title="F - POJ 3090 - Visible Lattice Points - 欧拉函数"></a>F - POJ 3090 - Visible Lattice Points - 欧拉函数</h2><h3 id="【题解】-5"><a href="#【题解】-5" class="headerlink" title="【题解】"></a>【题解】</h3><p>知道欧拉函数的提示就好做了，画图找规律可以得到</p><script type="math/tex; mode=display">ans = 2 \sum_{i = 2}^n \varphi(i) + 3</script><p>$\varphi(x)$是欧拉函数，表示小于等于$x$的与$x$互质的数的个数。</p><p>关于欧拉函数可以看<a href="https://ilern.github.io/2019/03/02/rcyl/">【数学】- 容斥原理学习笔记</a></p><p>可是为什么是欧拉函数？</p><p>首先发现上三角和下三角是对称的，所以只需要考虑一半。</p><p>易知$(1, 0), (0, 1), (1, 1)$是一定可见的，所以只需要考虑剩下的点。</p><p>如果某个点被挡住了，那在它之前一定有一个点和它共线，这里有点相似三角形的感觉，相当于两个直角边同时放大若干倍，也就是说，如果这个点的横纵坐标有公共因子，那么一定可以同时除以这个因子使得沿着这条线向$(0, 0)$方向移动，移动到不能动之后横纵坐标就互质了，所以对于每一个$x$只要求出小于等于它的（只考虑下三角）与它互质的数的个数即可。也就是$\varphi(x)$。</p><h3 id="【代码】-5"><a href="#【代码】-5" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">int</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = phi(i);</span><br><span class="line">            <span class="comment">// printf("phi(%d) = %d\n", i, a);</span></span><br><span class="line">            tmp += a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, cnt, n, tmp * <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-POJ-1845-Sumdiv-数学"><a href="#G-POJ-1845-Sumdiv-数学" class="headerlink" title="G - POJ 1845 - Sumdiv - 数学"></a>G - POJ 1845 - Sumdiv - 数学</h2><h2 id="H-POJ-2311-Cutting-Game-博弈-SG函数"><a href="#H-POJ-2311-Cutting-Game-博弈-SG函数" class="headerlink" title="H - POJ 2311 - Cutting Game - 博弈 + SG函数"></a>H - POJ 2311 - Cutting Game - 博弈 + SG函数</h2>]]></content>
      
      
      <categories>
          
          <category> 蓝桥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记（三）- 内联函数 / Lambda表达式</title>
      <link href="/2019/04/15/cpp3/"/>
      <url>/2019/04/15/cpp3/</url>
      
        <content type="html"><![CDATA[<p>上课时的随手笔记，供期末复习用。</p><a id="more"></a><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="普通的函数"><a href="#普通的函数" class="headerlink" title="普通的函数"></a>普通的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用这个函数的时候，不是简单的跳转，要先把<code>main()</code>函数里面的变量”保护起来”，再跳到<code>add()</code>函数的位置，重新分配变量，进行运算（此时<code>main()</code>里面的变量不能被修改），然后返回值。</p><p>这样的过程虽然不慢，但也要花时间，如果函数比较短小，同一个函数的多次调用在跳转上花费的时间可能会比执行花费的还要长。</p><p>所以我们有了<strong>内联函数</strong></p><h3 id="内联函数-1"><a href="#内联函数-1" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的函数会由编译器直接原地展开，例如上面的函数<code>int x = add(a, b)</code>就相当于<code>int x = a + b</code>，这样就有了更好的执行效率。</p><p>好处显而易见，不用手动复制代码，也提升了执行效率。</p><p>同样也存在缺点，代码被多次复制，增加了代码量，占用更多的内存空间。</p><p>有些函数即使声明为内联的也不一定会被编译器内联, 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数)</p><h2 id="Lambda-表达式-C-11"><a href="#Lambda-表达式-C-11" class="headerlink" title="Lambda 表达式(C++11)"></a>Lambda 表达式(C++11)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;<span class="keyword">return</span> x + y;&#125; (<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>Lambda表达式可以看作是一个匿名函数（但是实际上是个表达式）</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) mutable -&gt;return_type &#123;statement&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>[capture]</code>是捕捉列表，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，如果不需要可以只写中括号(捕捉列表为空)</p></li><li><p><code>(parameters)</code>是参数列表，就像普通函数一样，如果不需要传参数，则可以省略</p></li><li><p><code>mutable</code>是一个修饰符。默认情况下，Lambda函数总是一个<code>const</code>函数，<code>mutable</code>可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）</p></li><li><p><code>-&gt;return-type</code>表明了Lambda表达式的返回类型</p></li><li><p><code>{statement}</code>：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量</p></li></ul><p>捕捉列表中可以指定捕捉何种类型的变量</p><ul><li><p><code>[&amp;var_name]</code> 以传引用的方式捕获<code>var_name</code>这个变量（需要修改外部变量时）</p></li><li><p><code>[var_name]</code> 以传值的方式捕获<code>var_name</code>这个变量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [sum](<span class="keyword">int</span> x, <span class="keyword">int</span> y) <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before adding, sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sum = x + y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"After adding, sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(<span class="number">13</span>, <span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">2333</span>;</span><br><span class="line">    f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>[=]</code>以传值方式捕获所有变量</li><li><code>[&amp;]</code>以传引用方式捕获所有变量</li></ul><p>也可以同时混合多种使用，比如</p><ul><li><code>[=, &amp;sum]</code> 以传引用方式捕获<code>sum</code>这个变量，以传值方式捕获其他变量</li><li><code>[&amp;, sum]</code> 以传值方式捕获<code>sum</code>这个变量，以引用方式捕获其他变量</li></ul><p>但是<strong>不要</strong>重复使用，比如不能</p><ul><li><code>[=, sum]</code></li><li><code>[&amp;, &amp;sum]</code></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="自定义排序顺序"><a href="#自定义排序顺序" class="headerlink" title="自定义排序顺序"></a>自定义排序顺序</h4><p>在排序的时候，通常需要传入一个自定义的比较函数，这时就可以用一个匿名函数作为比较函数，而不是额外定义一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a是一个存了int的vector</span></span><br><span class="line">sort(a.begin(), a.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;))</span><br></pre></td></tr></table></figure><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>检索数组（vector）里有多少个偶数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    generate(a.begin(), a.end(), rand);</span><br><span class="line"></span><br><span class="line">    for_each(a.begin(), a.end(), [](<span class="keyword">int</span> x)&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    for_each(a.begin(), a.end(), [&amp;cnt](<span class="keyword">int</span> x)&#123;cnt += (x % <span class="number">2</span> == <span class="number">0</span>);&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h4><p><code>algorithm</code> 里提供的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    generate(a.begin(), a.end(), rand);</span><br><span class="line"></span><br><span class="line">    for_each(a.begin(), a.end(), [](<span class="keyword">int</span> x)&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count = count_if(a.begin(), a.end(), [](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数学】- 微分方程学习笔记（二）</title>
      <link href="/2019/04/11/diff_equation_2/"/>
      <url>/2019/04/11/diff_equation_2/</url>
      
        <content type="html"><![CDATA[<p>我们称表示<strong>未知函数</strong>、<strong>未知函数的导数</strong>、<strong>自变量</strong>之间的关系的方程叫做微分方程，微分方程的解是一个<strong>函数</strong>。下面我们讨论各种不同的微分方程的解法。</p><a id="more"></a><h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><h3 id="一阶线性齐次微分方程"><a href="#一阶线性齐次微分方程" class="headerlink" title="一阶线性齐次微分方程"></a>一阶线性齐次微分方程</h3><p>形如</p><script type="math/tex; mode=display">\frac{dy}{dx} + P(x)y = 0</script><p>的方程为一阶线性齐次微分方程。</p><p>通解公式为</p><script type="math/tex; mode=display">y = Ce^{-\int P(x) {\rm d}x}</script><h3 id="一阶线性非齐次微分方程"><a href="#一阶线性非齐次微分方程" class="headerlink" title="一阶线性非齐次微分方程"></a>一阶线性非齐次微分方程</h3><p>形如</p><script type="math/tex; mode=display">\frac{dy}{dx} + P(x)y = Q(x)</script><p>的方程为一阶线性非齐次微分方程。<br>通解公式为</p><script type="math/tex; mode=display">\begin{align}y &= Ce^{-\int P(x) {\rm d}x} \left( \int Q(x)e^{\int P(x) {\rm d}x} + C\right) \\&= Ce^{-\int P(x){\rm d}x} + e^{-\int P(x) {\rm d}x} \int Q(x)e^{\int P(x) {\rm d}x} {\rm d}x\end{align}</script><p>可以发现非齐次方程的通解是对应齐次方程的通解加上一个特解。</p><h2 id="可降阶的高阶微分方程"><a href="#可降阶的高阶微分方程" class="headerlink" title="可降阶的高阶微分方程"></a>可降阶的高阶微分方程</h2><h3 id="y-n-f-x-型"><a href="#y-n-f-x-型" class="headerlink" title="$y^{(n)} = f(x)$ 型"></a>$y^{(n)} = f(x)$ 型</h3><p>两边连续进行$n$次积分即可</p><h3 id="y’’-f-x-y’-型"><a href="#y’’-f-x-y’-型" class="headerlink" title="$y’’ = f(x, y’)$ 型"></a>$y’’ = f(x, y’)$ 型</h3><p>令$p = y’$，则原式转换为$p’ = f(x, p)$</p><h3 id="y’’-f-y-y’-型"><a href="#y’’-f-y-y’-型" class="headerlink" title="$y’’ = f(y, y’)$ 型"></a>$y’’ = f(y, y’)$ 型</h3><h2 id="线性微分方程解的结构"><a href="#线性微分方程解的结构" class="headerlink" title="线性微分方程解的结构"></a>线性微分方程解的结构</h2><p>对于二阶齐次线性方程</p><script type="math/tex; mode=display"></script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微分方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记（二） - C++11/STL</title>
      <link href="/2019/04/09/cpp2/"/>
      <url>/2019/04/09/cpp2/</url>
      
        <content type="html"><![CDATA[<p>上课时的随手笔记，供期末复习用。</p><a id="more"></a><h2 id="C-11的部分新特性"><a href="#C-11的部分新特性" class="headerlink" title="C++11的部分新特性"></a>C++11的部分新特性</h2><h3 id="使用auto进行自动的类型推断"><a href="#使用auto进行自动的类型推断" class="headerlink" title="使用auto进行自动的类型推断"></a>使用auto进行自动的类型推断</h3><h4 id="旧的用法"><a href="#旧的用法" class="headerlink" title="旧的用法"></a>旧的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//写和不写auto效果相同</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="新的用法"><a href="#新的用法" class="headerlink" title="新的用法"></a>新的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">6</span>; <span class="comment">//自动进行类型推断</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><code>auto</code>类型的变量声明时<strong>必须</strong>初始化。</li><li>并不会牺牲运行效率和编译效率。</li><li><code>auto</code>并不能用于函数的参数，如果不想进行函数重载请使用函数模板。</li></ul><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><h4 id="旧的用法-1"><a href="#旧的用法-1" class="headerlink" title="旧的用法"></a>旧的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新的用法-1"><a href="#新的用法-1" class="headerlink" title="新的用法"></a>新的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span> ,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : arr) &#123; <span class="comment">// 冒号后面应当是一个容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (auto k : arr) cout &lt;&lt; k &lt;&lt; " "; // 可以应用于各种类型的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>不止普通数组，其他的容器也可以进行类似的遍历操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s) <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量（动态数组）</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// only for c++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure></p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><p>为了形式的<strong>通用</strong>与<strong>统一</strong>，可以看作是一种<strong>广义的</strong>指针。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it; <span class="comment">//指向存储int的vector的迭代器</span></span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(), it != v.end(); it++) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v.begin()返回指向v的第一个元素的迭代器</span></span><br><span class="line"><span class="comment">//v.end()返回指向v的最后一个元素后面的位置的迭代器</span></span><br><span class="line"><span class="comment">//vector的随机存取迭代器的行为类似指针，允许++操作（前置后置均可）</span></span><br></pre></td></tr></table></figure><p>在C++11中，有更方便的写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only for c++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有更更方便的写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//only for c++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li>迭代器并不<strong>等同于</strong>指针，迭代器表示<strong>逻辑上的</strong>前后关系，而指针表示的是<strong>物理上的</strong>前后关系。</li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="vector（动态数组）"><a href="#vector（动态数组）" class="headerlink" title="vector（动态数组）"></a>vector（动态数组）</h4><p><a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector" target="_blank" rel="noopener">靠谱的参考</a></p><p>可以通过重载 <code>&lt;&lt;</code> 来实现直接用 <code>cout</code> 来输出<code>vector</code>，可以写成模板函数的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) out &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><h4 id="sort（排序）"><a href="#sort（排序）" class="headerlink" title="sort（排序）"></a>sort（排序）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要#include &lt;algorithm&gt;</span></span><br><span class="line">sort(v.begin(), v.end(), cmp); <span class="comment">//默认升序排序</span></span><br></pre></td></tr></table></figure><p><code>sort()</code>可以排序任何支持<strong>比较大小</strong>的对象，比如整数，字符串，甚至是自己定义的类（需要重载小于号，相当于给<code>sort()</code>一个比较的规则）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) out &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Stu() &#123;</span><br><span class="line">        score = <span class="number">-1</span>;</span><br><span class="line">        name = <span class="string">"Anonymous"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stu(<span class="keyword">int</span> sc, <span class="built_in">std</span>::<span class="built_in">string</span> nm) &#123;</span><br><span class="line">        score = sc;</span><br><span class="line">        name = nm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Stu &amp;a) &#123;</span><br><span class="line">    out &lt;&lt; a.score &lt;&lt; <span class="string">" "</span> &lt;&lt; a.name;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stu &amp;a, <span class="keyword">const</span> Stu &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score &lt; b.score) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; aa = &#123;<span class="string">"ZhangSans"</span>, <span class="string">"LiSi"</span>, <span class="string">"WangWu"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bb = &#123;<span class="number">11</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">4444</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Stu&gt; cc = &#123;&#123;<span class="number">99</span>, <span class="string">"ZhangSan"</span>&#125;, &#123;<span class="number">90</span>, <span class="string">"LiSi"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    cc.push_back(&#123;<span class="number">91</span>, <span class="string">"WangWu"</span>&#125;);</span><br><span class="line">    cc.push_back(Stu(<span class="number">95</span>, <span class="string">"ZhaoLiu"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cc;</span><br><span class="line">    <span class="built_in">std</span>::sort(cc.begin(), cc.end());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想倒序排序怎么办？</p><ul><li>不怎么靠谱的方法<ul><li>把小于号重载成大于号 【<strong>不推荐</strong>】</li></ul></li><li>靠谱的方法：<ul><li>写一个<strong>比较规则函数</strong>放在<code>cmp</code>的位置上，调用的时候用<code>sort(v.begin(), v.end(), cmp);</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Stu&amp; a, <span class="keyword">const</span> Stu&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score &gt; b.score) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="random-shuffle（打乱）"><a href="#random-shuffle（打乱）" class="headerlink" title="random_shuffle（打乱）"></a>random_shuffle（打乱）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要#include &lt;algorithm&gt;</span></span><br><span class="line">random_shuffle(v.begin(), v.end()); <span class="comment">//随机打乱</span></span><br></pre></td></tr></table></figure><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>用于遍历某容器的指定区间并执行某个操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for_each(v.begin(), v.end(), print);</span><br><span class="line"><span class="comment">//print 是一个函数指针</span></span><br><span class="line"><span class="comment">//这句话的意思是对从v.begin()到v.end()这个左闭右开区间中的每一个元素应用print这个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//print如果是一个函数模板，请指明其类型</span></span><br><span class="line">for_each(v.begin(), v.end(), print&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记（一）- 异常</title>
      <link href="/2019/04/08/cpp1/"/>
      <url>/2019/04/08/cpp1/</url>
      
        <content type="html"><![CDATA[<p>上课时的随手笔记，供期末复习用。</p><a id="more"></a><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="C语言的做法"><a href="#C语言的做法" class="headerlink" title="C语言的做法"></a>C语言的做法</h4><p>C语言中，通常使用函数的<strong>返回值</strong>来表示错误。</p><p>考虑下面的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    c = divide(a, b); <span class="comment">//b can't be 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了捕获 $b$ 为 $0$ 的错误，原始且暴力的方法是在<code>divide</code>函数中进行判断。但这样会导致程序终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">1</span>) <span class="built_in">abort</span>() <span class="comment">//example</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更进一步，函数通过某种方式告知调用者出现了某些问题。函数除了提供结果，还需要提供是否成功执行的标志。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b， <span class="keyword">double</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//failed</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *c = (<span class="keyword">double</span>)a / b;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//succeed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更丑陋的写法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b， <span class="keyword">int</span> *pFlag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        *pFlag = <span class="number">0</span>; <span class="comment">//failed</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pFlag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b; <span class="comment">//succeed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C语言中函数判断是否正常运行的机制并不独立，在面向对象的思想里面，把运行出错这件事情作为一个<strong>异常</strong>进行处理，程序永远只负责返回（正常情况下的）结果。</p><p>如果运行出错，则抛出(throw)一个<strong>异常</strong>。</p><h4 id="c-的做法"><a href="#c-的做法" class="headerlink" title="c++的做法"></a>c++的做法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常之后需要进行处理，否则被操作系统所捕获之后会终止程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = divide(a, b); <span class="comment">//b can't be 0</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">int</span> e) &#123; <span class="comment">// 'e' means exception</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"exception occured!"</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>try</code>和<code>catch</code>应当配对使用。必须<strong>紧挨着</strong>出现。</li><li>抛出异常之后函数的剩余部分不再执行，直接跳到<code>catch</code>块里。</li><li>如果<code>throw</code>多个东西，谁先被触发先扔谁。</li><li>一个<code>try</code>后面可以跟着多个<code>catch</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">"Negative!"</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = divide(a, b); <span class="comment">//b can't be 0</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">int</span> e) &#123; <span class="comment">// 'e' means exception</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"exception occured!"</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p>我们（通常）可以定义一个类来表示异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> msg;</span><br><span class="line">    E() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"E()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E(<span class="built_in">string</span> msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    E(<span class="keyword">const</span> E &amp;e) &#123;<span class="comment">//拷贝构造记得用const</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;msg = e.msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//better</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> E(<span class="string">"Divided by zero"</span>);<span class="comment">//带参构造一次</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//worse</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double divide(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    E e("hoho"); //带参构造一次</span></span><br><span class="line"><span class="comment">    if (b == 0) throw e; //拷贝构造一次</span></span><br><span class="line"><span class="comment">    return (double)a / b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = divide(a, b); <span class="comment">//b can't be 0</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (E &amp;e) &#123; <span class="comment">// 使用引用来避免多余的拷贝构造</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ <del>贴心地</del> 提供了标准的异常类。包含在<code>exception</code>头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> exception();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = divide(a, b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以从标准的<code>exception</code>类中派生出自己的异常类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> msg;</span><br><span class="line">    E() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"E()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E(<span class="built_in">string</span> msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    E(<span class="keyword">const</span> E &amp;e) &#123;<span class="comment">//拷贝构造记得用const</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;msg = e.msg;</span><br><span class="line">    &#125;</span><br><span class="line">    ~E() <span class="keyword">throw</span>() &#123;<span class="comment">//规范的写法要求重写基类的析构函数，记得加throw()表明这个函数不会抛出任何异常</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~E()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EE</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line">    EE() &#123;code = <span class="number">-1</span>;&#125;</span><br><span class="line">    EE(<span class="keyword">int</span> c) &#123;code = c;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于这样的两个类，都从<code>exception</code>派生而来，都有<code>what()</code>成员函数（来自<code>exception</code>），只需要重写<code>what()</code>这个函数，就可以只写一个<code>catch</code>块，来应对不同种类的异常（捕获的异常是抛出异常的基类），这也是多态性的一种体现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> msg;</span><br><span class="line"></span><br><span class="line">    E() &#123;</span><br><span class="line">        msg = <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E(<span class="built_in">string</span> msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~E() <span class="keyword">throw</span>() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Die"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;<span class="comment">//表示这个函数函数实现时不会抛出任何异常，c++11中通常写作 void func() noexcept&#123;&#125;</span></span><br><span class="line">        <span class="keyword">return</span> msg.c_str(); <span class="comment">//std::string转换成C风格字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> E(<span class="string">"Divided by zero"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">double</span>)a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = divide(a, b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (E &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更好的阅读体验？"><a href="#更好的阅读体验？" class="headerlink" title="更好的阅读体验？"></a>更好的阅读体验？</h3><p><a href="https://ilern.github.io/2019/04/08/cpp1">C++学习笔记（一） - 异常</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[GPLT2017]-古风排版</title>
      <link href="/2019/03/29/gplt2017-gf/"/>
      <url>/2019/03/29/gplt2017-gf/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://pintia.cn/problem-sets/1104698069054640128/problems/1104698209194725382" target="_blank" rel="noopener">GPLT 2017 古风排版</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。</p><a id="more"></a><h3 id="【输入样例】"><a href="#【输入样例】" class="headerlink" title="【输入样例】"></a>【输入样例】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">This is a test case</span><br></pre></td></tr></table></figure><h3 id="【输出样例】"><a href="#【输出样例】" class="headerlink" title="【输出样例】"></a>【输出样例】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asa T</span><br><span class="line">st ih</span><br><span class="line">e tsi</span><br><span class="line"> ce s</span><br></pre></td></tr></table></figure><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>模拟，先把句子用空格补成能被$n$整除的长度。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = n - s.size() % n;</span><br><span class="line">    <span class="keyword">if</span> (s.size() % n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) s += <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - n; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j -= n) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GPLT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学】- 容斥原理学习笔记</title>
      <link href="/2019/03/02/rcyl/"/>
      <url>/2019/03/02/rcyl/</url>
      
        <content type="html"><![CDATA[<p>容斥原理是组合数学基本的计数定理之一。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>设 $S$ 为有穷集 $P_1, P_2, \dots, P_n$ 是 $n$ 个性质。$S$ 中任意元素 $x$ 或者具有性质 $P_i$ 或者没有。令 $A_i$ 表示 $S$ 中具有性质 $P_i$ 的元素构成的子集，则$S$中不具有任何一种性质的元素个数表示为：</p><script type="math/tex; mode=display">|\overline A_1 \cap \overline A_2 \cap \dots \cap \overline A_n| = |S| - \sum_{i = 1}^n |A_i| + \sum_{1 \le i < j \le n} |A_i \cap A_j | - \sum_{1 \le i < j < k \le n} |A_i \cap A_j \cap A_k| + \dots +(-1)^n|A_1 \cap A_2 \cap \dots \cap A_n|</script><p>容斥原理被用来解决<strong>不具有任何性质</strong>的元素个数问题。</p><p>而由于<strong>不具有任何性质</strong>和<strong>至少具备一条性质</strong>是对立的，容斥原理也可以解决<strong>至少具备一条性质</strong>的元素个数问题。</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><h4 id="欧拉函数的求法"><a href="#欧拉函数的求法" class="headerlink" title="欧拉函数的求法"></a>欧拉函数的求法</h4><ol><li><p>欧拉函数$\varphi(n)$表示不大于$n$的与$n$互质的数的个数。</p></li><li><p>对于两个正整数 $a$ 和 $b$ ，如果有 $\gcd(a, b) = 1$ 那么我们称这两个数互质。</p></li><li><p>对于一个正整数$n$，根据唯一分解定理我们可以把它分解成若干质因数的幂次之积，即：</p><script type="math/tex; mode=display">n = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k}</script></li></ol><p>我们发现如果 $a$ 不能被 $n$ 的任何质因子以及其乘积整除(没有公共的质因子)，那么 $n$ 和 $a$ 一定互质。现在问题就转化为了求不大于$n$的数中不具有性质$A$的元素个数，其中性质$A$ 就是<strong>能被</strong> $n$ 的某个质因子或者其几个质因子的乘积整除。</p><p>而这种<strong>不具有任何性质</strong>的元素个数问题正是容斥原理所能解决的。</p><p>令</p><script type="math/tex; mode=display">A_i = \{ x \mid 0 \le x \le n - 1 \text{且} p_i | x \}</script><p>则</p><script type="math/tex; mode=display">\varphi(n) = |\overline A_1 \cap \overline A_2 \cap \dots \cap \overline A_k|</script><p>我们考虑等式右边的计算方法，在$[1, n - 1]$的范围中，一定是每 $p_i$ 个数出现一个数能被 $p_i$ 整除，所以</p><script type="math/tex; mode=display">|A_i| = \frac{n}{p_i}, i = 1, 2, 3, \dots ,k</script><p>又因为$p_i$都是质数所以任意两两互质，所以有</p><script type="math/tex; mode=display">|A_i \cap A_j| = \frac{n}{\operatorname{lcm}(p_i, p_j)} = \frac{n}{p_ip_j}， 1 \le i < j \le k</script><p>所以</p><script type="math/tex; mode=display">\begin{align}\varphi(n) &= |\overline A_1 \cap \overline A_2 \cap \dots \cap \overline A_k| \\\&= n - \sum_{i = 1}^k \frac{n}{p_i} + \sum_{1 \le i < j \le k} \frac{n}{p_ip_j} - \dots + (-1)^k \frac{n}{\prod_{i =1}^k p_i} \\\&= n(1- \frac{1}{p_1})(1- \frac{1}{p_2}) \dots (1- \frac{1}{p_k}) \\\&= n \prod_{i = 1}^k(1-p_k)\end{align}</script><h4 id="错位排列问题"><a href="#错位排列问题" class="headerlink" title="错位排列问题"></a>错位排列问题</h4><blockquote><p>一个人写了 $n$ 封不同的信及相应的 $n$ 个不同的信封，他把这 $n$ 封信都装错了信封，问都装错信封的装法有多少种？</p></blockquote><p>全错位排列求的是没有任何一个元素在自己的位置上的集合个数，不难发现我们所设的性质就是有某些元素在自己的位置上，设$A_i$表示第$i$个元素在自己位置上的集合。</p><p>不难看出全集为$[1, n]$的全排列构成的集合:</p><script type="math/tex; mode=display">|S| = n!</script><p>而</p><script type="math/tex; mode=display">|A_i| = (n - 1)! , i = 1, 2, \dots , n</script><script type="math/tex; mode=display">|A_i \cap A_j| = (n - 2)! , 1 \le i < j \le n</script><script type="math/tex; mode=display">\dots</script><script type="math/tex; mode=display">|A_1 \cap A_2 \cap \dots \cap A_n| = 0! = 1</script><p>所以错位排列$D_n$就是不具备以上任何一条性质的集合大小，</p><script type="math/tex; mode=display">\begin{align}D_n &= |A_1 \cap A_2 \cap \dots \cap A_n| \\&= n! - C_n^1(n - 1)! + C_n^2(n-2)!-\dots+(-1)^nC_n^n0! \\&= n![1 - \frac{1}{1!} + \frac{1}{2!} - \dots + (-1)^n\frac{1}{n!}]\end{align}</script><p>从表达式可以看出，当$n$充分大时，错位排列占全排列的比例大约等于$e^{-1}$.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学】- 微分方程学习笔记（一）</title>
      <link href="/2019/02/24/diff_equation_1/"/>
      <url>/2019/02/24/diff_equation_1/</url>
      
        <content type="html"><![CDATA[<p>我们称表示<strong>未知函数</strong>、<strong>未知函数的导数</strong>、<strong>自变量</strong>之间的关系的方程叫做微分方程，微分方程的解是一个<strong>函数</strong>。下面我们讨论各种不同的微分方程的解法。</p><a id="more"></a><h3 id="可分离变量的微分方程"><a href="#可分离变量的微分方程" class="headerlink" title="可分离变量的微分方程"></a>可分离变量的微分方程</h3><p>对于 $\frac{dy}{dx} = \frac{Q(x, y)}{P(x, y)}$ 这种形式的微分方程，我们将变量 $x$ 和 $y$ 分离到等号的两端，再对两边分别积分，得到答案。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><script type="math/tex; mode=display">xy' - y \ln y = 0</script><p>把导数写成$\frac{dy}{dx}$的形式</p><script type="math/tex; mode=display">x \frac{dy}{dx} - y \ln y  =0</script><p>分离变量</p><script type="math/tex; mode=display">\frac{dy}{y \ln y} = \frac{dx}{x}</script><p>两边分别积分</p><script type="math/tex; mode=display">\int \frac{dy}{y \ln y} = \int \frac{dx}{x}</script><script type="math/tex; mode=display">\ln |\ln y| = \ln |x|</script><script type="math/tex; mode=display">y = e^x</script><h3 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h3><p>如果一阶微分方程可化成</p><script type="math/tex; mode=display">\frac{dy}{dx} = \varphi(\frac{y}{x})</script><p>的形式，我们称其为<strong>齐次方程</strong>，对于这样的微分方程，我们先将其化为上面的标准形式，再令$u = \frac{y}{x}$，换元之后转化成可分离变量的微分方程求解。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><script type="math/tex; mode=display">(xy-y^2)dy-(x^2-2xy)dx=0</script><p>化简为标准的形式</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{xy-y^2}{x^2-2xy}</script><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{\frac{y}{x}-(\frac{y}{x})^2}{1-2 \times \frac{y}{x}}</script><p>变量代换$u = \frac{y}{x}$，则$\frac{dy}{dx} = u + x \frac{du}{dx}$原式转化为</p><script type="math/tex; mode=display">u + x\frac{du}{dx} = \varphi(u)</script><p>下面便可以分离变量进行求解。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微分方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起开心寒假训练 - 2</title>
      <link href="/2019/02/03/happyWinter2/"/>
      <url>/2019/02/03/happyWinter2/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/282348#overview" target="_blank" rel="noopener">一起开心寒假训练 - 2</a></p><p>这周好像都是带字符串的贪心/模拟/脑洞题</p><a id="more"></a><h3 id="A-Did-you-mean…-模拟-贪心"><a href="#A-Did-you-mean…-模拟-贪心" class="headerlink" title="A - Did you mean… - 模拟 + 贪心"></a>A - Did you mean… - 模拟 + 贪心</h3><h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定一个由小写字母组成的单词，规定如果单词中连续出现三个或以上的辅音字母，则这是一个错误的单词。存在特例：如果这些连续的辅音字母都相同的话，则不算一个错误的单词。</p><p>现在要在个单词中间插入若干个空格，使得产生的这些由空格分隔的新单词都是合法的。</p><h4 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h4><p>贪心，如果发现连续的三个不同辅音字母出现，就在第二个辅音字母后面加上一个空格。</p><p>具体实现上可以不用真的修改原先的字符串，而是先记录一下在哪个字母后面加空格，最后再输出。</p><h4 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">char</span> vowels[] = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isConsonants</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vowels[i] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>] &amp;&amp; s[i - <span class="number">1</span>] == s[i - <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isConsonants(s[i])) cnt++;</span><br><span class="line">        <span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">3</span> &amp;&amp; !isSame(i)) &#123;</span><br><span class="line">            q.push(i - <span class="number">1</span>);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == q.front()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, s[i]);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Alphabetic-Removals-模拟"><a href="#B-Alphabetic-Removals-模拟" class="headerlink" title="B - Alphabetic Removals - 模拟"></a>B - Alphabetic Removals - 模拟</h3><h4 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定一个由26个小写字母组成的字符串，进行如下操作$k$次：</p><ul><li>检查字母a的数目，如果大于一，则删除最左边的哪一个，结束操作。</li><li>否则继续按上述规则检查字母表中每一个字母。</li></ul><p>问最后的字符串是什么样子的，保证有解。</p><h4 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h4><p>直接按题意模拟，在寻找最左边的某个字母的操作中，使用了26个队列。</p><p>先从左至右扫一遍原串，预处理出每个字母的位置，这样最左边的那个字母的位置就在队头，每次删除只需要直接出队就可以了。</p><h4 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q[MAXL];</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        q[s[i] - <span class="string">'a'</span>].push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = q[i].front();</span><br><span class="line">                q[i].pop();</span><br><span class="line"></span><br><span class="line">                s[index] = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Crusaders-Quest-脑洞-贪心"><a href="#C-Crusaders-Quest-脑洞-贪心" class="headerlink" title="C - Crusaders Quest - 脑洞 + 贪心"></a>C - Crusaders Quest - 脑洞 + 贪心</h3><h4 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给了一个类似消消乐的游戏，一个或以上一样元素的碰在一起可以消除，三个一样的碰在一起就会是一个<code>powerful skill</code>，现在给定一个长度为 $9$ 的字符串，问最多能有几个三消。</p><h4 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h4><p>这个题目并不会做，但是长度为 $9$ 好像怎么做都可以。</p><p>我用的方法是用一个栈来维护，如果栈顶三个元素相同，那就弹出来，答案加一。</p><p>发现答案只可能是 $1$，$2$ 或 $3$，如果第一遍发现最后栈空了那就是$3$，如果不空，就删掉某种元素再重复压栈的操作，三种删法中取一个最好的结果，如果三种删法都不能使栈变空，那答案就是$1$。</p><h4 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">stack</span>[MAXN];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == c) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">stack</span>[top] == s[i] &amp;&amp; <span class="built_in">stack</span>[top - <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">            top -= <span class="number">2</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">stack</span>[++top] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (top &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">stack</span>[top] == s[i] &amp;&amp; <span class="built_in">stack</span>[top - <span class="number">1</span>] == s[i]) top -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">stack</span>[++top] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            top = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> a = solve(<span class="string">'a'</span>, len);</span><br><span class="line"></span><br><span class="line">            top = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> b = solve(<span class="string">'g'</span>, len);</span><br><span class="line"></span><br><span class="line">            top = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> c = solve(<span class="string">'o'</span>, len);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a == b &amp;&amp; b == c &amp;&amp; a == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Polycarp-and-Div-3-规律-贪心"><a href="#D-Polycarp-and-Div-3-规律-贪心" class="headerlink" title="D - Polycarp and Div 3 - 规律 + 贪心"></a>D - Polycarp and Div 3 - 规律 + 贪心</h3><h4 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定一个数字，可以切割这个数字，问最多切割出多少三的倍数。</p><p>比如 $3121$ 这个数字,可以切割成$3$，$1$ 和 $21$最多有两个数是三的倍数。</p><h4 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h4><p>我们知道如果一个数的各个位上的数的和是三的倍数，那么这个数就是三的倍数，也就是比如对于一个三位数 $abc$ 来说，如果$(a + b + c) \% 3 = 0$，那么<br>$abc \% 3 = 0$。</p><p>而一个数模三的结果只有 $0$，$1$，$2$ 三种，如果某位模 $3$ 为 $0$ ，就直接把这位分割出去，如果为 $1$ 或者 $2$ 就先留着看下一位，如果是 $[1, 2]$ 或 $[2, 1]$ 就把这两位分出去，也就是说每三位数都至少会分割出一个数。</p><h4 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>, tmpp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (s[i] - <span class="number">0</span>) % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            tmpp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt += tmp;</span><br><span class="line">            tmpp++;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                tmpp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmpp % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                tmpp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记(四)</title>
      <link href="/2019/01/30/git_learn_4/"/>
      <url>/2019/01/30/git_learn_4/</url>
      
        <content type="html"><![CDATA[<p>虽然这个博客是托管在<code>github</code>上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习<code>git</code>。</p><p>教程是<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《廖雪峰的Git教程》</a>和<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">《官方教程》</a></p><a id="more"></a><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支管理在多人协作开发的场景下有着重要的意义，试想你正在开发一个新功能，只开发了一半，如果直接提交的话，不完整的代码库会导致其他人都用不了了，如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。而有了分支，就可以自己单独开一个分支，等自己完全完成工作之后，再一次性合并到原来分支上，这样既安全又不影响别人工作。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><ul><li>使用<code>git check -b &lt;branch&gt;</code>来创建一个分支并切换到新的分支，其中<code>-b</code>参数表示创建并切换，等价于下面两条命令。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure></li></ul><p><code>git branch</code>是创建，<code>git checkout</code>是切换。</p><ul><li>使用<code>git branch</code>查看当前分支，这个命令会列出所有分支，并在当前分支前打一个星号。</li><li>使用<code>git merge &lt;branch&gt;</code>来将<code>&lt;branch&gt;</code>这个分支合并到当前分支。</li><li>使用<code>git branch -d &lt;baranch&gt;</code>来删除分支。</li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>有时候两个分支各自有不同的修改，就不能很顺利地完成合并。</p><p><img src="https://s2.ax1x.com/2019/02/01/k3IEfH.png" alt="t1"></p><p>这个时候直接<code>git merge &lt;branch&gt;</code>来合并的话会出现冲突，<code>master</code>后面会出现<code>MERGING</code>的标志。</p><p><img src="https://s2.ax1x.com/2019/01/30/klRyfx.png" alt="t2"></p><p>这个时候查看修改过文件的内容会给出不同分支中不同的部分，改成一样之后再<strong>提交</strong>就可以了。</p><p><img src="https://s2.ax1x.com/2019/01/30/klRotI.png" alt="t3"></p><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://s2.ax1x.com/2019/02/01/k3Ie1A.png" alt="t4"></p><p>最后删除<code>feature1</code>分支就行了。</p><p>这个图示可以用<code>git log --graph</code>来查看。</p><p><img src="https://s2.ax1x.com/2019/01/30/klfCad.png" alt="t5"></p><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如<code>1.0</code>版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布<code>1.0</code>版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://s2.ax1x.com/2019/02/01/k3IKnP.png" alt="t6"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记(三)</title>
      <link href="/2019/01/29/git_learn_3/"/>
      <url>/2019/01/29/git_learn_3/</url>
      
        <content type="html"><![CDATA[<p>虽然这个博客是托管在<code>github</code>上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习<code>git</code>。</p><p>教程是<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《廖雪峰的Git教程》</a>和<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">《官方教程》</a></p><a id="more"></a><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>我们使用Github作为我们学习Git使用的远程仓库。</p><p>本地仓库和远程仓库之间的数据传输是通过<code>SSH</code>进行加密的，所以需要先生成<code>SSH key</code>。</p><p>使用<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>命令创建<code>SSH key</code>，一路回车之后发现主目录下多了一个<code>.ssh</code>目录，里面有里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是<code>SSH Key</code>的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>关于非对称加密中公钥和私钥的理解可以<a href="http://www.cnblogs.com/mujian/p/7665952.html" target="_blank" rel="noopener">看这里</a>。</p><p>获得自己的<code>SSH key</code>之后，可以在Github的Setting里找到添加SSH key。</p><p>这样一来Github就知道是你在向库里提交东西了。</p><h3 id="添加远程库（先有本地库，再有远程库）"><a href="#添加远程库（先有本地库，再有远程库）" class="headerlink" title="添加远程库（先有本地库，再有远程库）"></a>添加远程库（先有本地库，再有远程库）</h3><p>在Github上新建一个仓库，使用<code>git remote add origin &lt;SSH key&gt;</code>添加一个远程库，其中SSH key可以在如图所示的地方找到。<br><img src="https://s2.ax1x.com/2019/01/29/kQb45F.png" alt="t1"></p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>接下来用<code>git push -u origin master</code>命令就可以把本地内容推送到远程库上了，第一次提交需要写<code>-u</code>，以后就不需要了，可以直接<code>git push origin master</code>。</p><p>这样就可以在没有网络的时候在本地工作，有网络之后直接<code>git push</code>就好了。</p><h3 id="从远程库克隆（先有远程库，再有本地库）"><a href="#从远程库克隆（先有远程库，再有本地库）" class="headerlink" title="从远程库克隆（先有远程库，再有本地库）"></a>从远程库克隆（先有远程库，再有本地库）</h3><p>先找到想要克隆的仓库，还是在如图位置找到地址，使用<code>git clone &lt;SSH key&gt;</code>来将这个库克隆到本地。</p><p><img src="https://s2.ax1x.com/2019/01/29/kQLuFO.png" alt="t2"></p><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记(二)</title>
      <link href="/2019/01/28/git_learn_2/"/>
      <url>/2019/01/28/git_learn_2/</url>
      
        <content type="html"><![CDATA[<p>虽然这个博客是托管在<code>github</code>上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习<code>git</code>。</p><p>教程是<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《廖雪峰的Git教程》</a>和<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">《官方教程》</a></p><a id="more"></a><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li>使用 <code>git log</code> 查看自己的历史纪录，嫌输出信息太多可以用 <code>git log --pretty=oneline</code> 命令，其中最前面显示的叫<code>commit id</code>。</li><li>想要回退到上个版本可以使用<code>git reset --hard HEAD^</code>。Git里面<code>HEAD</code>是一个指针，表示的就是当前版本。</li><li>如果想回退很多版本的话可以打很多<code>^</code>，也可以指定数字<code>~&lt;num&gt;</code>。</li><li>想回退到指定版本可以使用<code>git reset --hard &lt;commit id&gt;</code>，其中版本号可以只写前几位。这样可以在回退之后再返回最新的版本。</li><li>Git提供<code>git reflog</code>命令来查看过去的每一条命令，可以找到每一次的<code>commit id</code></li><li>注意<code>git log</code>是提交的历史，是和当前版本相关的，是到当前版本为止的历史提交，<code>git reflog</code>是命令的历史，会一直保存。</li></ul><h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h3><p><img src="https://s2.ax1x.com/2019/02/01/k3IAte.jpg" alt="t1"></p><ul><li><p>如图所示，工作区即为本地的那个目录（仓库），版本库就是那个隐藏的<code>.git</code>文件夹。</p></li><li><p>在这个版本库里有一个暂存区（stage）和 Git 自动创建的第一个分支<code>master</code>（后面会学到关于分支的内容）。</p></li><li><p>前面说的我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ul><li>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li></ul></li><li><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p></li><li><p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p></li><li><p><code>git diff</code> 比较的是工作区文件与暂存区文件的区别（上次<code>git add</code> 的内容）<code>git diff --cached</code> 比较的是暂存区的文件与仓库分支里（上次<code>git commit</code> 后的内容）的区别。</p></li><li><p>Git管理的是“修改”，也就是说只要不<code>git add</code>，<code>git commit</code>就不会把修改提交上去。</p></li></ul><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li><p>情况一：只在工作区修改，既没有<code>add</code>也没有<code>commit</code></p><ul><li><code>git checkout -- &lt;file name&gt;</code> 可以撤销当前工作区的全部修改，注意<code>--</code>之后要加空格</li></ul></li><li><p>情况二：已经<code>add</code>到暂存区了</p><ul><li><code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉，重新放回工作区。</li><li>之前见过<code>reset</code>命令，它既可以用作回退版本，也可以用作把暂存区的修改回退到工作区</li><li>这样一来就转换成了情况一</li></ul></li><li><p>情况三：已经<code>commit</code>过了</p><ul><li>直接回退到上个版本</li></ul></li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li>直接在工作区删除</li><li>如果真的要删除，就用<code>git rm &lt;file name&gt;</code>告诉Git要在版本库里删除，然后<code>git commit</code></li><li>如果是自己手滑删错了，就用<code>git checkout -- &lt;file name&gt;</code>恢复过来</li></ul><h3 id="还有一点"><a href="#还有一点" class="headerlink" title="还有一点"></a>还有一点</h3><p><code>git checkout -- &lt;file name&gt;</code>这个命令，做的事情实际上是用版本库里的版本去替换工作区的版本，具体来说是分支里的版本，不是暂存区里的版本。</p><p>所以在撤销修改一节中，由于既没有<code>add</code>也没有<code>commit</code>，版本库里的是老版本，用过命令后工作区的版本就被替换成了版本库里的老版本。</p><p>在误删这个情境下，如果没有既没有<code>add</code>也没有<code>commit</code>，版本库里仍然存着被删掉的文件，自然就可以恢复过来了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记(一)</title>
      <link href="/2019/01/27/git_learn_1/"/>
      <url>/2019/01/27/git_learn_1/</url>
      
        <content type="html"><![CDATA[<p>虽然这个博客是托管在<code>github</code>上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习<code>git</code>。</p><p>教程是<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">《廖雪峰的Git教程》</a>和<a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">《官方教程》</a></p><a id="more"></a><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>对于 Windows 系统，直接到<a href="https://git-scm.com/" target="_blank" rel="noopener">官网</a>下载并安装。</p><p>安装完之后打开 <code>GitBash</code> 用这两个命令进行设置，因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h3><ul><li>随便新建一个文件夹</li><li>在这个文件夹下使用<code>git init</code>命令将这个文件夹变成一个仓库(repository)</li><li>Git 实际上做的事情是在这个文件夹下建立了一个隐藏的文件夹<code>.git</code>用于管理这个库</li></ul><h3 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h3><ul><li>在仓库里新建一个<strong>文本文件</strong></li><li>使用命令<code>git add &lt;filename&gt;</code>来添加文件到版本库</li><li>使用命令<code>git commit -m &lt;message&gt;</code>来将刚才添加的文件提交到版本库，这个命令可以一次提交多个文件，感觉就像把很多东西塞到一辆货车上，再一块拉去仓库</li></ul><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><ul><li>用<code>git status</code>查看当前仓库的状态</li><li>用<code>git diff</code>查看进行了哪些修改</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起开心寒假训练 - 1</title>
      <link href="/2019/01/27/happyWinter1/"/>
      <url>/2019/01/27/happyWinter1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/281288#overview" target="_blank" rel="noopener">一起开心寒假训练 - 1</a></p><a id="more"></a><h3 id="A-矩形判断-几何"><a href="#A-矩形判断-几何" class="headerlink" title="A - 矩形判断 - 几何"></a>A - 矩形判断 - 几何</h3><h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给出平面上$4$条线段，判断这$4$条线段是否恰好围成一个面积大于$0$的矩形。</p><h4 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h4><p>先判断这四条线能否首尾相连形成一个封闭的四边形，再通过斜率或者向量相乘的方法判断是否垂直。</p><h4 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            v.push_back(<span class="built_in">std</span>::make_pair(x1, y1));</span><br><span class="line">            v.push_back(<span class="built_in">std</span>::make_pair(x2, y2));</span><br><span class="line"></span><br><span class="line">            v1.push_back((<span class="keyword">double</span>)(y1 - y2) / (<span class="keyword">double</span>)(x1 - x2));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::unique(v.begin(), v.end()) - v.begin() != <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::sort(v1.begin(), v1.end());</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">std</span>::unique(v1.begin(), v1.end()) - v1.begin() != <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v1[<span class="number">0</span>] * v1[<span class="number">1</span>] == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-水陆距离-BFS"><a href="#B-水陆距离-BFS" class="headerlink" title="B - 水陆距离 - BFS"></a>B - 水陆距离 - BFS</h3><h4 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定一个$N \times M$ 的 $01$ 矩阵，其中 $1$ 表示陆地，$0$ 表示水域。对于每一个位置，求出它距离最近的水域的距离是多少。  </p><p>矩阵中每个位置与它上下左右相邻的格子距离为$1$。</p><h4 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h4><p>一开始以所有水域为起点开始BFS，每块陆地一旦被扩展到就说明找到了离它最近的水域。可以一开始将所有陆地设置初值为$-1$来实现判重。</p><h4 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;info&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            ans[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                q.push(<span class="built_in">std</span>::make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        info v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = v.first, y = v.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy = y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xx &gt;= <span class="number">0</span> &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; yy &lt; m &amp;&amp; ans[xx][yy] == <span class="number">-1</span>) &#123;</span><br><span class="line">ans[xx][yy] = ans[x][y] + <span class="number">1</span>;</span><br><span class="line">q.push(<span class="built_in">std</span>::make_pair(xx, yy));</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; m - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i][j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-满减优惠-背包DP"><a href="#C-满减优惠-背包DP" class="headerlink" title="C - 满减优惠 - 背包DP"></a>C - 满减优惠 - 背包DP</h3><h4 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><h4 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h4><h4 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h4><h3 id="D-出勤记录I-模拟"><a href="#D-出勤记录I-模拟" class="headerlink" title="D - 出勤记录I - 模拟"></a>D - 出勤记录I - 模拟</h3><h4 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>小Hi的算法课老师每次上课都会统计小Hi的出勤记录。迟到会被记录一个<code>L</code>，缺席会被记录一个<code>A</code>，按时上课会被记录一个<code>O</code>。</p><p>一学期结束，小Hi的出勤记录可以看成是一个只包含<code>L</code> <code>A</code> <code>O</code>的字符串，例如<code>OOOOLOOOLALLO……</code>。</p><p>如果小Hi整学期缺席不超过1次，并且没有连续3次迟到，小Hi的出勤记录就算合格。 </p><p>现在给出小Hi的出勤记录，你能判断他是否合格么？</p><h4 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h4><p>按照题目说的模拟即可。</p><h4 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, a = <span class="number">0</span>, o = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'A'</span>) a++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i + <span class="number">3</span> &lt; s.size() &amp;&amp; s[i] == <span class="string">'L'</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">'L'</span> &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">'L'</span> ) &#123;</span><br><span class="line">l += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">1</span> || l &gt;= <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-跳石头-线性DP"><a href="#E-跳石头-线性DP" class="headerlink" title="E - 跳石头 - 线性DP"></a>E - 跳石头 - 线性DP</h3><h4 id="【题目描述】-4"><a href="#【题目描述】-4" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>有 $n$ 个石头从左到右拍成一排，第 $i$ 个石头的颜色为 $c_i$ 。现在小 Ho 在第一个石头，他想跳到第 $n$ 个石头，每一步有两种跳跃方式：</p><ul><li><p>从第 $i$ 个石头跳到第 $i + 1$ 个石头</p></li><li><p>跳到右边第一个和当前石头颜色相同的石头（如果存在的话）</p></li></ul><p>现在他想知道，从第一个石头跳到第 $n$ 个石头至少需要几步跳跃</p><h4 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h4><p>设 $f(i)$ 表示跳到第 $i$ 个石头需要的最少步数，容易写出状态转移方程为：</p><script type="math/tex; mode=display">f(i) = \min \{ f(i - 1), f(\text{same color})\} + 1</script><p>使用记忆化搜索来实现这个DP，代码中使用了<code>std::map</code>来预处理出每个石头之前最近的颜色相同的石头的编号。</p><h4 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; info;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;info&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dp[x] != <span class="number">-1</span>) <span class="keyword">return</span> dp[x];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[x].second != <span class="number">-1</span>) <span class="keyword">return</span> dp[x] = <span class="built_in">std</span>::min(solve(x - <span class="number">1</span>), solve(v[x].second)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dp[x] = solve(x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (mp.count(x)) v.push_back(<span class="built_in">std</span>::make_pair(x, mp[x]));</span><br><span class="line">        <span class="keyword">else</span> v.push_back(<span class="built_in">std</span>::make_pair(x, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        mp[x] = i;</span><br><span class="line">        dp[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-机会渺茫-数学"><a href="#F-机会渺茫-数学" class="headerlink" title="F - 机会渺茫 - 数学"></a>F - 机会渺茫 - 数学</h3><h4 id="【题目描述】-5"><a href="#【题目描述】-5" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定两个正整数 $n$ 和 $m$，随机选出 $n$ 的一个因数 $n_1$ 和 $m$ 的一个因数 $m_1$，问 $n_1 = m_1$ 的概率为多少。</p><h4 id="【题解】-5"><a href="#【题解】-5" class="headerlink" title="【题解】"></a>【题解】</h4><p>记 $x’$ 为 $x$ 的因数个数，对于两个数 $a$ 和 $b$ ，他们共有的因数个数为$\gcd(a, b)’$，故：</p><script type="math/tex; mode=display">P(n_1 = m_1) = \frac{\gcd(n, m)'}{n' \times m'}</script><p>题目要求分子分母互质，因此最后要同除分子分母的 $\gcd$</p><h4 id="【代码】-5"><a href="#【代码】-5" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getCntX</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cntX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            cntX++;</span><br><span class="line">            <span class="keyword">if</span> (x / i != i) cntX++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cntX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cntN = getCntX(n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cntM = getCntX(m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p = gcd(n, m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cntP = getCntX(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cntN * cntM;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x = gcd(tmp, cntP);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, tmp / x, cntP / x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于异或</title>
      <link href="/2018/09/06/Xor/"/>
      <url>/2018/09/06/Xor/</url>
      
        <content type="html"><![CDATA[<p>异或的一些应用</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>异或是一种二元逻辑运算符，作用是 「取异」，即两值相异返回$1$，相同返回 $0$ 。</p><p>另外一种理解是异或是二进制下忽略进位的加法：</p><script type="math/tex; mode=display">0 \oplus 0 = 0 \rightarrow 0 + 0 = 0</script><script type="math/tex; mode=display">1 \oplus 1 = 0 \rightarrow 1 + 1 = (1)0</script><script type="math/tex; mode=display">1 \oplus 0 = 1 \rightarrow 1 + 0 = 1</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>异或运算满足交换律与结合律。</p><p>异或具有自反性即 $a \oplus b \oplus b = a$。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="两数交换"><a href="#两数交换" class="headerlink" title="两数交换"></a>两数交换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b ^= a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不易懂，不推荐使用，三变量交换法足够了。</p><h4 id="寻找只出现一次的数"><a href="#寻找只出现一次的数" class="headerlink" title="寻找只出现一次的数"></a>寻找只出现一次的数</h4><p>给定一个非空数组，其中一个元素出现过奇数次，其余均出现偶数次，找出这个只出现奇数次的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用异或的定义，相同两数异或结果为$0$，又有异或满足结合律。</p><h4 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h4><p>$1$ 到 $n$放在含有$n + 1$个元素的数组中，只有唯一的一个元素值重复，其它均只出现<br>一次。找出这个重复的元素。</p><p>与上面的做法相同，把所有数异或起来再与$1$到$n$异或一遍就是最终的答案。</p><p>相当于强行构造出奇数次与偶数次的异或。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        ans ^= a[i];</span><br><span class="line">        ans ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Educational Codeforces 49 C] Minimum Value Rectangle - 贪心</title>
      <link href="/2018/08/22/Codeforces_E49_C/"/>
      <url>/2018/08/22/Codeforces_E49_C/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://codeforces.com/contest/1025/problem/B" target="_blank" rel="noopener">Educational Codeforces 49 C Minimum Value Rectangle</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出一些木棍拼成矩形，求一种方案使得 $\frac{P^2}{S}$ 最小，其中$P$<br>代表矩形的周长，$S$代表矩形的面积。 </p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设拼成的矩形的长和宽分别为$x$和$y$ $(x &gt; y)$，则</p><script type="math/tex; mode=display">\frac{P^2}{S} = \frac{(x+y)^2}{xy} = \frac{x^2+y^2+2xy}{xy} = \frac{x}{y} + \frac{y}{x} + 2</script><p>记$a = \frac{x}{y}$，则$a&gt;1$</p><p>原式化为$a + \frac{1}{a} + 2$，由对号函数的性质可知，上式在$(1, +\infty)$单调增，故我们的贪心策略为使$a$尽量小。</p><p>我的做法是利用<code>std::map</code>有序的特点把出现超过两次的木棍存在<code>map</code>里，顺序遍历，每次只考虑相邻的两个元素，最终比较得到最小值，并将方案输出。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        mp.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            mp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, it-&gt;first, it-&gt;first, it-&gt;first, it-&gt;first);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;second == <span class="number">1</span> ? mp.erase(it++) : it++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n--------\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> minDiff = DBL_MAX;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> it1 = mp.end();</span><br><span class="line">            it1--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != it1; it++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it2 = it;</span><br><span class="line">                it2++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> tmp = <span class="keyword">double</span>(<span class="built_in">std</span>::max(it2-&gt;first, it-&gt;first)) / <span class="keyword">double</span>(<span class="built_in">std</span>::min(it2-&gt;first, it-&gt;first));</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt;= minDiff) &#123;</span><br><span class="line">                    minDiff = tmp;</span><br><span class="line">                    a = it-&gt;first;</span><br><span class="line">                    b = it2-&gt;first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, a, a, b, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【我还有要说的话】"><a href="#【我还有要说的话】" class="headerlink" title="【我还有要说的话】"></a>【我还有要说的话】</h3><ul><li><code>map</code>中调用<code>erase</code>方法之后<code>iterator</code>失效，故不能在循环中直接用<code>erase</code>删除循环变量指向的元素，一种参考做法是这样<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); ) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">          it-&gt;second == <span class="number">1</span> ? mp.erase(it++) : it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>浮点数的最大最小值不在<code>&lt;climits&gt;</code>里面而在<code>&lt;cfloat&gt;</code>里面</p></li><li><p><code>map</code>的迭代器不能<code>+1</code>，但可以<code>++</code>，上面代码中迫不得已YY出来的用法并不优美</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codeforces #505(div2) B] Weakened Common Divisor - 枚举 + 质因数分解</title>
      <link href="/2018/08/21/Codeforces_505_B/"/>
      <url>/2018/08/21/Codeforces_505_B/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://codeforces.com/contest/1025/problem/B" target="_blank" rel="noopener">Codeforces #505(div2) Weakened Common Divisor</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>定义 $\text{WCD(Weakened Common Divisor)}$ 如下：</p><p>对于 $n$ 个二元组 $(a_i, b_i)$ 若存在某个数 $p$ 能被每个二元组的其中至少一个数整除，则称 $p$ 为这些二元组的 $\text{WCD}$。</p><p>现给定若干二元组，求他们的 $\text{WCD}$。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>对第一个二元组质因数分解，之后枚举每个质因数看看能不能满足定义。</p><p>复杂度$O(n \times \sqrt{a_{max}})$</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; info;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;info&gt; inv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) v.push_back(i);</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) v.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            calc(a); calc(b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        inv.push_back(<span class="built_in">std</span>::make_pair(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : v) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n-------\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : v) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = inv.begin(); it != inv.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;first % p != <span class="number">0</span> &amp;&amp; it-&gt;second % p != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【TLE代码】"><a href="#【TLE代码】" class="headerlink" title="【TLE代码】"></a>【TLE代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">150000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i][<span class="number">0</span>], &amp;a[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        max = <span class="built_in">std</span>::max(max, <span class="built_in">std</span>::max(a[i][<span class="number">0</span>], a[i][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j][<span class="number">0</span>] % i == <span class="number">0</span> || a[j][<span class="number">1</span>] % i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 质因数分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[QDU 门槛题 1010] easy problem - 枚举</title>
      <link href="/2018/08/08/QDU_Entrance_1010/"/>
      <url>/2018/08/08/QDU_Entrance_1010/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://qduoj.com/problem/59" target="_blank" rel="noopener">[QDU 59] Easy Problem</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一个数字$n$，$n$的范围是$1 \dots 1000000$，求一个最小的正整数$m$，这个数字的各个位的数字加上它本身之和恰好为$n$。当然，如果没有解，输出$0$。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>经过观察不难发现 $m$ 各位数之和最大不会超过 $54$，因为这个数字最大不过$999999$</p><p>那么只需要枚举和，以 $n$ 减之，并判断差的各位数之和是否等于枚举得到的和</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">54</span>; sum &gt;= <span class="number">1</span>; sum--) &#123;</span><br><span class="line">            <span class="keyword">int</span> rest = n - sum;</span><br><span class="line">            <span class="keyword">if</span> (rest &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>, tmp2 = rest;</span><br><span class="line">                <span class="keyword">while</span> (tmp2 != <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp += (tmp2 % <span class="number">10</span>);</span><br><span class="line">                    tmp2 /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tmp == sum) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rest);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codeforces #500(div2) D] Chemical table - 并查集</title>
      <link href="/2018/07/31/Codeforces_500_D/"/>
      <url>/2018/07/31/Codeforces_500_D/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://codeforces.com/contest/1013/problem/D" target="_blank" rel="noopener">Codeforces #500(div2) Chemical table</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个网格图，其中一些格子里放有一些「元素」，对于这样的三个元素$e_1(r_1, c_1), e_2(r_1, c_2), e_3(r_2, c_1)$，可以生成第四个元素$e_4(r_2, c_2)$<br><img src="https://codeforces.com/predownloaded/95/22/95223620a323ec59470718b34958c7f295698ff1.png" alt></p><p>问给定初始的一些元素，最少需要额外添加多少元素能使得整个表格被填满。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这里用到一个没见过的很巧妙的转化。</p><p>把一个格子看做一行和一列的「连接」，当 $r_1$ 和 $c_1$，$r_1$ 和 $c_2$，$r_2$ 和 $c_1$ 都相应地联系起来时，$r_2$ 和 $c_2$ 也自然联系起来了。</p><p>维护这种集合间的连接关系，就要用到并查集。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> * <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[MAXN]; </span><br><span class="line"></span><br><span class="line">    UnionFindSet() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return fa[x] == x ? x : find(fa[x]);</span></span><br><span class="line">        <span class="keyword">if</span> (fa[x] != x) fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> r2 = find(y);</span><br><span class="line"></span><br><span class="line">        fa[r1] = r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        y += n;</span><br><span class="line"></span><br><span class="line">        ufs.merge(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ufs.fa[i] == i) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷 P2341 / HAOI2006] 受欢迎的牛 - 强连通分量</title>
      <link href="/2018/07/02/luogup3241/"/>
      <url>/2018/07/02/luogup3241/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://www.luogu.org/problemnew/show/P2341#sub" target="_blank" rel="noopener">P2341 [HAOI2006]受欢迎的牛</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果$A$喜欢$B$，$B$喜欢$C$，那么$A$也喜欢$C$。牛栏里共有$n$头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>Tarjan求出所有强连通分量，把每个强连通分量看做一个 <strong>超级点</strong> ，缩点后输出出度为 $0$ 的点所对应的强连通分量的大小，若有不止一个点出度为 $0$ ，则无解，输出 $0$ 。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SCC</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line">    <span class="keyword">bool</span> vis, inStack;</span><br><span class="line">    <span class="keyword">int</span> dfn, low, sccNum, outEdge;</span><br><span class="line">&#125; nodes[MAXN], newMap[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">    u-&gt;outEdge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SCC</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; nodes; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SCC *&gt; scc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node *&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    x-&gt;low = x-&gt;dfn = ++index;</span><br><span class="line">    x-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;inStack = <span class="literal">true</span>;</span><br><span class="line">    s.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!e-&gt;to-&gt;vis) &#123;</span><br><span class="line">             tarjan(e-&gt;to);</span><br><span class="line">             x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;low);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;to-&gt;inStack) &#123;</span><br><span class="line">             x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;dfn);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;low == x-&gt;dfn) &#123;</span><br><span class="line">        SCC *newOne = <span class="keyword">new</span> SCC();</span><br><span class="line">        Node *v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            v-&gt;sccNum = scc.size();</span><br><span class="line">            v-&gt;inStack = <span class="literal">false</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            newOne-&gt;nodes.push_back(v);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != v);</span><br><span class="line">        scc.push_back(newOne);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        u--, v--;</span><br><span class="line">        addEdge(nodes + u, nodes + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodes[i].vis) tarjan(nodes + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = scc.begin(); it != scc.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = (*it)-&gt;nodes.begin(); it1 != (*it)-&gt;nodes.end(); it1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Edge *e = (*it1)-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e-&gt;to-&gt;sccNum != (*it1)-&gt;sccNum) </span><br><span class="line">                    addEdge(newMap + (*it1)-&gt;sccNum, newMap + e-&gt;to-&gt;sccNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popular;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scc.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newMap[i].outEdge == <span class="number">0</span>) popular.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (popular.size() != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, scc[popular[<span class="number">0</span>]]-&gt;nodes.size());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 强连通分量 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan强连通分量学习笔记</title>
      <link href="/2018/06/28/tarjan_note/"/>
      <url>/2018/06/28/tarjan_note/</url>
      
        <content type="html"><![CDATA[<p>看了<a href="https://blog.csdn.net/qq_34374664/article/details/77488976" target="_blank" rel="noopener">这篇文章(《全网最!详!细!tarjan算法讲解》)</a>终于学会了 Tarjan 求强连通分量的算法</p><a id="more"></a><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="弱连通图"><a href="#弱连通图" class="headerlink" title="弱连通图"></a>弱连通图</h4><p>将 <strong>有向图</strong> 的所有的有向边替换为无向边，所得到的图称为原图的<strong>基图</strong>。如果一个有向图的基图是连通图，则有向图是 <strong>弱连通图</strong>。</p><h4 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h4><p>在一个 <strong>有向图</strong> $G$ 中，如果两个点之间能够从一个点到达另一个点，则这两个点 <strong>连通</strong>，相对的，如果两个点之间能够 <strong>相互</strong> 到达，则这两个点 <strong>强连通</strong>。</p><h4 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h4><p>在一个 <strong>有向图</strong> $G$ 中，如果 <strong>任意</strong> 两点都是强连通的，那么这个图为 <strong>强连通图</strong>。</p><h4 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h4><p>对于一个有向 <strong>非</strong> 强连通图，其 <strong>极大强连通子图</strong> 为其 <strong>强连通分量</strong>。注意是指 <strong>极大</strong> 而非 <strong>最大</strong>。</p><h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>可以在 $O(N + M)$ 的时间内求出图中所有的强连通分量。</p><h4 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h4><ul><li>$\text{dfn[ ]}$ : 时间戳，表示这个点是第几个被搜索到的，每个点的 $\text{dfn}$ 都不同。</li><li>$\text{low[ ]}$ : 这个点所能到达的点中在搜索树中为这个点的祖先且 $\text{dfn}$ 最小的点的 $\text{dfn}$ (有点拗口)。</li></ul><h4 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h4><ul><li><p>这个算法的核心是一次DFS，它基于这样一个事实：强连通分量中的点一定存在于搜索树上的同一棵子树当中。</p></li><li><p>我们使用栈来存储强连通分量中的点。</p></li><li><p>算法流程如下</p><ul><li>从点 $x$ 开始DFS。令<code>x-&gt;low = x-&gt;dfn = ++index</code>，其中 <code>index</code> 为计数器。将 $x$ 标记为已访问。将 $x$ 扔入栈中，记录其 <em>已入栈</em> 的状态。 </li><li>枚举起点连出去的每一条边。</li><li>若该边的终点未被访问过，则DFS进入该点，并更新<code>x-&gt;low = min(x-&gt;low, e-&gt;to-&gt;low)</code></li><li>若该边的终点已在栈中，即找到了一条指向自己在搜索树中的祖先的边，则更新<code>x-&gt;low = min(x-&gt;low, e-&gt;to-&gt;dfn)</code></li><li>所有邻接点回溯完成后，若当前点仍满足<code>low == dfn</code>，即在搜索的过程中该点为该子树的根，则让该点之后进栈的点全部出栈，并将其标记为一个强连通分量。</li></ul></li></ul><ul><li>对于一个强连通分量中的所有点，其 $\text{low}$ 都是相同的，该命题的逆命题同样成立。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>在实际应用的过程中，整个图不一定是弱联通的，所以要对每一个未访问过的点都进行一遍该算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Connection</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dfn, low;</span><br><span class="line">    Edge *edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> inStack, visited;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Connection</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Connection *&gt; connections;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum, index;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node *&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++index;</span><br><span class="line">    x-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;inStack = <span class="literal">true</span>;</span><br><span class="line">    s.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;to-&gt;visited) &#123;</span><br><span class="line">            tarjan(e-&gt;to);</span><br><span class="line">            x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;to-&gt;inStack) &#123;</span><br><span class="line">            x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;low == x-&gt;dfn) &#123;</span><br><span class="line">        Connection *connection = <span class="keyword">new</span> Connection();</span><br><span class="line">        Node *v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            v-&gt;inStack = <span class="literal">false</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            connection-&gt;size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != v);</span><br><span class="line">        connections.push_back(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addEdge(nodes + u, nodes + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodes[i].visited) tarjan(nodes + i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Connection *&gt;::iterator it = connections.begin(); it != connections.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*it)-&gt;size &gt; <span class="number">1</span>) sum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 强连通分量 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学】- 交替和</title>
      <link href="/2018/03/02/Math_Set/"/>
      <url>/2018/03/02/Math_Set/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p> 对于集合$ N = {1, 2, 3, \dots, n } $的每一个非空子集，定义一个「交替和」如下：</p><blockquote><p>按照递减的顺序重新排列该子集，然后从最大数开始交替地减、加其后继数。</p></blockquote><p>例如：当集合$N = {1, 2}$ 时，其所有非空子集为 ${1}, {2}, {1, 2}$，则它的所有交替和的总和为</p><script type="math/tex; mode=display">S_2 = 1 + 2 + (2 - 1) = 4</script><p>现有一 $n$ 元集合$N = {1, 2, 3, \dots, n}$，求其交替和的总和。</p><a id="more"></a><h3 id="【解】"><a href="#【解】" class="headerlink" title="【解】"></a>【解】</h3><p>考虑集合$M = {1, 2, \dots, {n-1}}$，记其交替和的总和为$S_{n - 1}$，则在其中添加一个元素$n$之后，构成集合$N$，此时所有的非空子集包括三种：</p><ul><li>$M$ 所有的非空子集。交替和的总和为$S_{n-1}$</li><li>$M$ 所有的非空子集中都添加一个$n$。这时由交替和的定义可得对于某个集合，增加一个$n$会使其交替和 $S<em>i$ 变为 $n - S_i$，因此在这种情况下交替和的总和为 $2^{n-2} \times n - S</em>{n-1}$</li><li>${n}$。交替和的总和为$n$</li></ul><p>故最终答案为$S<em>{n - 1} + 2^{n - 2} \times n - S</em>{n - 1} + n$，即$n \times 2^{n - 1}$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST 表模板</title>
      <link href="/2017/11/08/S_Table/"/>
      <url>/2017/11/08/S_Table/</url>
      
        <content type="html"><![CDATA[<p>ST 表的模板题，有一些加一减一的地方要注意<br><a id="more"></a></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://poj.org/problem?id=3264" target="_blank" rel="noopener">Poj 3264 Balanced Lineup</a></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">18</span>; <span class="comment">// ln(MAXN) = 17.609</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXLOG + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXLOG + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">std</span>::max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            g[i][j] = <span class="built_in">std</span>::min(g[i][j - <span class="number">1</span>], g[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= r - l + <span class="number">1</span>) k++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int k = log2(r - l + 1);</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="built_in">std</span>::max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">int</span> min = <span class="built_in">std</span>::min(g[l][k], g[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max - min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepare(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ST表 </tag>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组拓展</title>
      <link href="/2017/11/07/exbit/"/>
      <url>/2017/11/07/exbit/</url>
      
        <content type="html"><![CDATA[<p>被 WangLL 拐去学习了树状数组的一些拓展用法，当然可以用线段树做，但是树状数组似乎更好写一点</p><a id="more"></a><h3 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改 单点查询"></a>区间修改 单点查询</h3><p>考虑正常的树状数组可以做些什么。</p><ul><li>「单点修改」</li><li>「前缀查询」</li></ul><p>回忆我们学习的<a href="https://ilern.coding.me/428/2016/08/20/premixSum/" target="_blank" rel="noopener">差分</a>，可以把 <strong>区间修改</strong> 转移到差分数组的 <strong>单点修改</strong>，可以把 <strong>单点查询</strong> 转移到差分数组的 <strong>前缀查询</strong>，发现这正好是树状数组可以做的事情，所以我们维护一个差分数组 $C$ ，对这个数组建立树状数组.</p><p>对于原数组的区间$[l, r]$进行的修改，不去对原数组进行操作，而是对差分数组进行单点修改<code>modify(l, delta)</code>，<code>modify(r + 1, delta)</code>。</p><p>对于原数组的 $index$ 位置的单点查询，对差分数组进行前缀查询<code>query(index)</code>，求出原数组的变化量，再加上原数组的值即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[MAXN],c[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k&amp;-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        c[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x,y,z,i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            add(x,z); add(y+<span class="number">1</span>,-z);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[x]+sum(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改 区间查询"></a>区间修改 区间查询</h3><p>延续刚才的思路，区间修改仍然是刚才的方法，对于区间查询，依然可以表示为<code>原值 + 变化量</code>的形式。</p><script type="math/tex; mode=display">\begin{equation}\begin{split}sum[x] &= \sum_{i = 1}^x a[i] + \sum_{i = 1}^x delta[i] \times (x - i + 1) \\&= \sum_{i = 1}^x a[i] + \sum_{i = 1}^x delta[i] \times [(x + 1) - i] \\&= \sum_{i = 1}^x a[i] + \sum_{i = 1}^x delta[i] \times (x - 1) - \sum_{i = 1}^x i \times delta[i] \\&= \sum_{i = 1}^x a[i] + (x - 1)\sum_{i = 1}^xdelta[i] - \sum_{i = 1}^x i \times delta[i]\end{split}\end{equation}</script><p>上式中的$sum[x]$表示变化的前缀和，$delta[x]$表示差分数组。</p><p>上式中的</p><script type="math/tex; mode=display">\sum_{i = 1}^x a[i]</script><p>可以预处理得到，</p><script type="math/tex; mode=display">(x - 1)\sum_{i = 1}^x delta[i]</script><p>和</p><script type="math/tex; mode=display">\sum_{i = 1}^x i \times delta[i]</script><p>两个值我们使用两个树状数组进行维护</p><p>这样我们在查询区间和的时候，直接<code>sum[r] - sum[l - 1]</code>即可</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">500000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> suml,sumr,a[MAXN],c[MAXN],deltac[MAXN],sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k&amp;-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deltaAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        deltac[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        c[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">deltaSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=deltac[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        sum[i]+=a[i]+sum[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x,y,z,i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            Add(x,z); Add(y+<span class="number">1</span>,-z);</span><br><span class="line">            deltaAdd(x,x*z); deltaAdd(y+<span class="number">1</span>,(y+<span class="number">1</span>)*-z);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            suml=sum[x<span class="number">-1</span>]+x*Sum(x<span class="number">-1</span>)-deltaSum(x<span class="number">-1</span>);</span><br><span class="line">            sumr=sum[y]+(y+<span class="number">1</span>)*Sum(y)-deltaSum(y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sumr-suml);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>感谢 WangLL 同学提供的代码</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组模板</title>
      <link href="/2017/11/06/bit/"/>
      <url>/2017/11/06/bit/</url>
      
        <content type="html"><![CDATA[<p>树状数组是一种支持单点修改前缀查询的数据结构。<br><a id="more"></a></p><p>可以在 <strong>部分场合，一定程度</strong> 代替线段树。</p><h4 id="灵魂操作"><a href="#灵魂操作" class="headerlink" title="灵魂操作"></a>灵魂操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br></pre></td></tr></table></figure><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= n) &#123;</span><br><span class="line">        a[index] += delta;</span><br><span class="line">        index += lowbit(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += a[index];</span><br><span class="line">        index -= lowbit(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= n) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>初始化<code>a</code>数组的时候要用<code>bit.modify()</code>函数</li><li>区间和查询相当于两个前缀和相减，是<code>bit.query(r) - bit.query(l - 1)</code></li><li><del>不用理解背过就行</del></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「lyx_tst 系列」lyx 的小迷妹 - 最短路</title>
      <link href="/2017/11/05/lyx_tst_4/"/>
      <url>/2017/11/05/lyx_tst_4/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/86" target="_blank" rel="noopener">「lyx_tst 系列」lyx 的小迷妹</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>lyx 一脚踢倒了关押 tst 小黑屋的门，说时迟那时快，杨教授扛起 tst 就是一个百米冲刺。杨教授跑到四院门口，迎面来了一辆公交车，他不假思索的冲了上去。</p><p>市内有 $n$ 个路口和 $m$ 条双向道路，每条道路都有过路费，第 $i$ 条道路的过路费为 $w_i$ 元。市内还有 $k$ 条公交线路，公交车只在路口停靠，而且一路公交车只会沿着固定的线路往返行驶。上第 $i$ 路公交车需要 $b_i$ 元的费用，但费用是一次性的，即你可以在公交线路上的任意停靠路口下车。但是一旦下车了，如果要再次上车，则还需要再次付费。</p><p>路痴 lyx 有点迷茫，杨教授在全市乱跑，她要从路口 $s$ 怎么行动，才能到每个路口的费用最小？</p><p>（我跟你们嗦，lyx 呀，怎么这么可爱啊！<br><a id="more"></a></p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行四个整数 $n$、$m$、$k$ 和 $s$，分别代表路口数、道路数、公交线路数和 lyx 所处的路口编号。</p><p>接下来的 $m$ 行，每行三个整数 $u_i$、$v_i$ 和  $w_i$ ，代表第 i $i$ i 条道路连接 $u_i$ 路口和 $v_i$路口，并且通过这条道路需要缴纳 $w_i$ 元的过路费。</p><p>接下来的 $k$ 行，每行首先是两个整数 $b_i$ 和 $t_i$ ，代表第 $i$ 路公交车的上车费用为 $b_i$ 元，而且公交线路共有 $t_i$ 个停靠路口。接下来同一行内有 $t_i$ 个整数，按顺序给出了这路公交车的各个停靠路口。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>一行 $n$ 个整数，表示从路口 $s$ 到每个路口的最小费用。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>明显是最短路，重点是车站怎么处理，只要给车站建一个虚拟点，从可以坐车的地方到车站连一条边权为上车费用的边，车站虚拟点到每个可以停车的点连一条边权为$0$的边，跑最短路即可</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis;</span><br><span class="line"></span><br><span class="line">    Node() : edges(<span class="literal">NULL</span>), dis(LLONG_MAX) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN + MAXK];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">long</span> <span class="keyword">long</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">long</span> <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, Node*&gt; info;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;info, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;info&gt;, <span class="built_in">std</span>::greater&lt;info&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    pq.push(<span class="built_in">std</span>::make_pair(<span class="number">0</span>, x));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        info x = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x.second-&gt;dis != x.first) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge *e = x.second-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;to-&gt;dis &gt; e-&gt;w + x.second-&gt;dis) &#123;</span><br><span class="line">                e-&gt;to-&gt;dis = e-&gt;w + x.second-&gt;dis;</span><br><span class="line">                pq.push(<span class="built_in">std</span>::make_pair(e-&gt;to-&gt;dis, e-&gt;to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"lyx_tst.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"lyx_tst.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, k, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        addEdge(nodes + u, nodes + v, w);</span><br><span class="line">        addEdge(nodes + v, nodes + u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + k; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;b, &amp;t);</span><br><span class="line">        <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line"></span><br><span class="line">            addEdge(nodes + tmp, nodes + i, b);</span><br><span class="line">            addEdge(nodes + i, nodes + tmp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra(nodes + s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, nodes[i].dis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 这是一个系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[POJ 2777] Count Color - 线段树 + 状态压缩</title>
      <link href="/2017/11/05/POJ_2777/"/>
      <url>/2017/11/05/POJ_2777/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://poj.org/problem?id=2777" target="_blank" rel="noopener">POJ 2777 Count Color</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出一个区间，每次选择一个子区间染色，每次询问某个区间内颜色种类数</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>线段树，发现颜色 <strong>种类</strong> 数在合并的时候不能简单相加，而是 <strong>并集</strong> 操作，想到<a href="https://ilern.coding.me/428/2017/10/31/lyoj_104/" target="_blank" rel="noopener">愤怒的小鸟</a>一题中取并集的方法，考虑状态压缩，因为颜色种类数并不多，所以可以把状态压入一个<code>int</code>里面，建立线段树即可</p><p><del>调了很久发现是自己手算算错</del></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt; <span class="number">1</span>) + (n &amp; <span class="number">0x55555555</span>);  </span><br><span class="line">    <span class="comment">//0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt; <span class="number">2</span>) + (n &amp; <span class="number">0x33333333</span>);  </span><br><span class="line">    <span class="comment">//0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xF0F0F0F0</span>) &gt;&gt; <span class="number">4</span>) + (n &amp; <span class="number">0x0F0F0F0F</span>);  </span><br><span class="line">    <span class="comment">//0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xFF00FF00</span>) &gt;&gt; <span class="number">8</span>) + (n &amp; <span class="number">0x00FF00FF</span>);  </span><br><span class="line">    <span class="comment">//0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>) + (n &amp; <span class="number">0x0000FFFF</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> n;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinary</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, x % <span class="number">2</span>);</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">        color = <span class="number">0</span>;</span><br><span class="line">        tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        color = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lc) color |= lc-&gt;color;</span><br><span class="line">        <span class="keyword">if</span> (rc) color |= rc-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) color = a[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tag = tag;</span><br><span class="line">        color = <span class="number">0</span>;</span><br><span class="line">        color |= (<span class="number">1</span> &lt;&lt; (tag - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lc) lc-&gt;addTag(tag);</span><br><span class="line">            <span class="keyword">if</span> (rc) rc-&gt;addTag(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int ans = 0;</span></span><br><span class="line">        <span class="comment">// if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return count(color);</span></span><br><span class="line">        <span class="comment">// else &#123;</span></span><br><span class="line">        <span class="comment">//     pushDown();</span></span><br><span class="line">        <span class="comment">//     if (l &lt; mid) ans += lc-&gt;query(l, std::min(mid, r));</span></span><br><span class="line">        <span class="comment">//     if (r &gt; mid) ans += rc-&gt;query(std::max(l, mid), r);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//     return ans;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == l &amp;&amp; <span class="keyword">this</span>-&gt;r == r) <span class="keyword">return</span> color;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) ans |= lc-&gt;query(l, <span class="built_in">std</span>::min(mid, r));</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) ans |= rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == l &amp;&amp; <span class="keyword">this</span>-&gt;r == r) &#123;</span><br><span class="line">            addTag(delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), delta);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, mid), r, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printColor</span><span class="params">(SegmentTree *x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d, %d]:\n"</span>, x-&gt;l, x-&gt;r - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    tag = %d\n"</span>, x-&gt;tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    color = %d =&gt;"</span>, x-&gt;color); printBinary(x-&gt;color);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;lc) printColor(x-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;rc) printColor(x-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, t, o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;t, &amp;o) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(a + <span class="number">1</span>, a + l + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">SegmentTree <span class="title">root</span><span class="params">(<span class="number">1</span>, l + <span class="number">1</span>)</span></span>;</span><br><span class="line">        root.build();</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= o; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> op;</span><br><span class="line">            op = getchar();</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">'C'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> l, r, delta;</span><br><span class="line">                <span class="keyword">if</span> (r &lt; l) <span class="built_in">std</span>::swap(l ,r);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;delta);</span><br><span class="line">                root.modify(l, r + <span class="number">1</span>, delta);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line">    printColor(&amp;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> l, r;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">                <span class="keyword">if</span> (r &lt; l) <span class="built_in">std</span>::swap(l, r);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count(root.query(l, r + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「lyx_tst 系列」沉迷于 tst 女装的 lyx - 递推 + 矩乘</title>
      <link href="/2017/11/04/lyx_tst_1/"/>
      <url>/2017/11/04/lyx_tst_1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/83" target="_blank" rel="noopener">「lyx_tst 系列」沉迷于 tst 女装的 lyx</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>很久很久以前，有个 OI 界的 dalao，是个风流倜傥、玉树临风、目若朗星、仪表堂堂的，妹子。她叫做 lyx，这么一个迷倒万千少女的人自从在某晚目睹了 tst 穿女装后，沉迷于此无法自拔，日渐消瘦。</p><p>不久后，tst 被邪恶的团长困在了一座台阶为 $N$ 的高塔里【tst：QVQ】，团长向世界上的各单位提供了丰富的悬赏，如果有人能数出自己走上高塔的走法，那么就让 tst 穿小旗袍给那个人看。</p><p>听说了这个消息，lyx 跑的比香港记者还快╭(`З’)╯，马上来到了高塔下。她比量了一下自己脖子以下全是腿的长度，大致计算了一下。</p><p>已知 lyx 每次只能走一级、两级、三级或四级 【lyx 腿长有两米八！(๑´ㅂ`๑)】。</p><p>（我跟你们嗦，tst 的女装，棒！(๑•̀ㅂ•́)و✧）（说完 tst 提着 $\mathrm{40m}$ 长的大刀赶来了我也不知道为什么）</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>一行一个整数 $N$，表示团长囚禁 tst 的塔所拥有的台阶数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>一行一个整数，表示 lyx 登上塔顶可能的方案数。由于某些特殊的原因，答案对第 $201314$ 个质数取模。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>易得递推式为：</p><script type="math/tex; mode=display">f(i) = f(i - 1) + f(i - 2) + f(i - 3) + f(i - 4)</script><script type="math/tex; mode=display">f(1) = f(0) = 1, f(2) = 2, f(3) = 4, f(4) = 8</script><p>构造初始矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 & 4 & 8\end{bmatrix}</script><p>转移矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}0 & 0 & 0 & 1 \\1 & 0 & 0 & 1 \\0 & 1 & 0 & 1 \\0 & 0 & 1 & 1\end{bmatrix}</script><p>直接计算快速幂即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">2769433</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sizeX, sizeY;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> sizeX = <span class="number">0</span>, <span class="keyword">int</span> sizeY = <span class="number">0</span>) : sizeX(sizeX), sizeY(sizeY) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(sizeX, a.sizeY)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sizeY; k++) &#123;</span><br><span class="line">                    ans.a[i][j] += (<span class="keyword">this</span>-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD;</span><br><span class="line">                    ans.a[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;a[i][j] = a.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastPowMod</span><span class="params">(Matrix m, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">        ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; ans.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; ans.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>; ans.a[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> fastPowMod(m, n - <span class="number">1</span>) * m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(m * m, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"lyx_tst.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"lyx_tst.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%llu"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">begin</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Matrix <span class="title">change</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    begin.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; begin.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>; begin.a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">4</span>; begin.a[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    change.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; change.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; change.a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; change.a[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    change.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; change.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>; change.a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>; change.a[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    change.a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>; change.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>; change.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>; change.a[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    change.a[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0</span>; change.a[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>; change.a[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>; change.a[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin.print();</span></span><br><span class="line">    <span class="comment">// change.print();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin = begin * change;</span></span><br><span class="line">    <span class="comment">// begin.print();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"4\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"8\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        change = fastPowMod(change, n - <span class="number">4</span>);</span><br><span class="line">        begin = begin * change;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, begin.a[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【写的时候犯的错误】"><a href="#【写的时候犯的错误】" class="headerlink" title="【写的时候犯的错误】"></a>【写的时候犯的错误】</h3><ul><li>没用<code>long long</code></li><li>初始矩阵计算错误</li><li>构造函数里没有对数组清零</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 这是一个系列 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「lyx_tst 系列」lyx 超强超满足 - BFS</title>
      <link href="/2017/11/04/lyx_tst_3/"/>
      <url>/2017/11/04/lyx_tst_3/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p> <a href="https://ly.men.ci/problem/85" target="_blank" rel="noopener">「lyx_tst 系列」lyx 超强超满足 </a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p> 神犇 lyx 得到了足够的线索，来到了临沂第四人民医院，去拯救即将被教育的 tst 。她发现整个医院可以看做一个矩阵，tst 肯定在某个房间里。房间类型如下：</p><ul><li><code>-</code>，普通房间，无任何特殊性质；</li><li><code>*</code>，墙，不可进入或经过；</li><li><code>L</code>、<code>Y</code>、<code>X</code>，普通传送门，可以传送到相同字符的任意房间；</li><li><code>(</code>、<code>)</code>，配对传送门，只能传送到相反的括号，即 <code>(</code> 可以传送到任意一个 <code>)</code>，<code>)</code> 可以传送到任意一个 <code>(</code>。<br>lyx 不愧是 lyx，她早就根据线索推导出 tst 的位置 $T$ ，已知 lyx 所在的位置为 $S$ ，现在她想在最短的时间内救出 tst。</li></ul><p>走到传送门时可以选择使用传送门，使用传送门不会消耗时间，如果不使用传送门，则相当于经过一个普通房间。在四连通的房间之间可以花费 $k$ 时间移动。</p><p>（我跟你们嗦，lyx 啊，超强！</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行两个正整数 $n$ 和 $m$ ，表示矩阵大小为 $n$ 行 $m$ 列。</p><p>第二行四个正整数  $a_S, b_S, a_T, b_T$，表示起点为第 $a_S$ 行 $b_S$ 列，终点为第 $a_T$ 行第 $b_T$ 列。</p><p>第三行一个正整数 $k$，表示每走一步需要消耗的时间。</p><p>之后的 $n$ 行，每行 $m$ 个字符，表示矩阵中格子的类型。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>一行一个整数，表示所用的最短时间。由于某些特♂殊的原因，你需要输出答案对第 $520$ 个质数取模后的结果。</p><p>如果 tst 一生都等不到 lyx 去救他，请输出 <code>please go home to sleep</code>。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>普通的BFS.</p><p>遇到传送门的时候就把它对面那个传送门一并扔到队列里，但是步数不加，注意可以不走传送门，所以先处理正常走路的情况，然后再处理传送门的情况</p><p>代码里很多重复的地方，感觉写个函数能一下短不少，<del>不过复制粘贴几次也不是什么很难的事情</del></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">800</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">3727</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> isL, isY, isX, isLeft, isRight;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;</span><br><span class="line">        isL = isY = isX = isLeft = isRight = <span class="literal">false</span>;</span><br><span class="line">        dis = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; l;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; y;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; left;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; right;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"lyx_tst.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"lyx_tst.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">'L'</span>) l.push_back(Node(i, j));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">'Y'</span>) y.push_back(Node(i, j));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">'X'</span>) x.push_back(Node(i, j));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">'('</span>) left.push_back(Node(i, j));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">')'</span>) right.push_back(Node(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">s</span><span class="params">(x1, y1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g[x1][y1] == <span class="string">'L'</span>) s.isL = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g[x1][y1] == <span class="string">'Y'</span>) s.isY = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g[x1][y1] == <span class="string">'X'</span>) s.isX = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g[x1][y1] == <span class="string">'('</span>) s.isLeft = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g[x1][y1] == <span class="string">')'</span>) s.isRight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    s.dis = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[x1][y1] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v.x == x2 &amp;&amp; v.y == y2) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v.dis);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> xx = v.x, yy = v.y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xx + dx[i] &lt;= <span class="number">0</span> || yy + dy[i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!vis[xx + dx[i]][yy + dy[i]] &amp;&amp; g[xx + dx[i]][yy + dy[i]] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="function">Node <span class="title">tmp</span><span class="params">(xx + dx[i], yy + dy[i])</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (g[xx + dx[i]][yy + dy[i]] == <span class="string">'L'</span>) tmp.isL = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (g[xx + dx[i]][yy + dy[i]] == <span class="string">'Y'</span>) tmp.isY = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (g[xx + dx[i]][yy + dy[i]] == <span class="string">'X'</span>) tmp.isX = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (g[xx + dx[i]][yy + dy[i]] == <span class="string">'('</span>) tmp.isLeft = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (g[xx + dx[i]][yy + dy[i]] == <span class="string">')'</span>) tmp.isRight = <span class="literal">true</span>;</span><br><span class="line">                vis[xx + dx[i]][yy + dy[i]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                tmp.dis = v.dis + k;</span><br><span class="line">                tmp.dis %= MOD;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v.isL) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator it = l.begin(); it != l.end(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[it-&gt;x][it-&gt;y]) &#123;</span><br><span class="line">                    <span class="function">Node <span class="title">tmp</span><span class="params">(it-&gt;x, it-&gt;y)</span></span>;</span><br><span class="line">                    tmp.dis = v.dis;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    vis[it-&gt;x][it-&gt;y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.isY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator it = y.begin(); it != y.end(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[it-&gt;x][it-&gt;y]) &#123;</span><br><span class="line">                    Node tmp(it-&gt;x, it-&gt;y);</span><br><span class="line">                    tmp.dis = v.dis;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    vis[it-&gt;x][it-&gt;y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.isX) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator it = x.begin(); it != x.end(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[it-&gt;x][it-&gt;y]) &#123;</span><br><span class="line">                    Node tmp(it-&gt;x, it-&gt;y);</span><br><span class="line">                    tmp.dis = v.dis;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    vis[it-&gt;x][it-&gt;y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.isLeft) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator it = right.begin(); it != right.end(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[it-&gt;x][it-&gt;y]) &#123;</span><br><span class="line">                    Node tmp(it-&gt;x, it-&gt;y);</span><br><span class="line">                    tmp.dis = v.dis;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    vis[it-&gt;x][it-&gt;y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.isRight) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator it = left.begin(); it != left.end(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[it-&gt;x][it-&gt;y]) &#123;</span><br><span class="line">                    Node tmp(it-&gt;x, it-&gt;y);</span><br><span class="line">                    tmp.dis = v.dis;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    vis[it-&gt;x][it-&gt;y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please go home to sleep\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
            <tag> 这是一个系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「lyx_tst 系列」lyx 最神啦 - 序列DP</title>
      <link href="/2017/11/04/lyx_tst_2/"/>
      <url>/2017/11/04/lyx_tst_2/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/84" target="_blank" rel="noopener">「lyx_tst 系列」lyx 最神啦</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>由于磁暴步兵杨教授的罪恶统治，LYOI 的很多同学都被抓去临沂第四院（简称 lydsy）进行爱♂的♂教♂育。某天，神犇 lyx 发现 tst 不见了，为了找到 tst，她决定走出机房，到校园去找线索。路线可看做数轴，数轴上有连续的 $n$ 个点，第 $i$ 个点有 $a_i$ 名同学，lyx 可以在每个同学那里得知一条线索。</p><p>lyx 一开始停留在第 $i$ 个点上， 她每次可以选择左边第一个未停留过的点或右边第一个未停留过的点，在那个点上停留并询问一条线索；也可以在当前点停下来不继续询问。最终 lyx 获得的总线索为她访问过的点的数量加上最终停下来时所在点的线索量。</p><p>为了让 lyx 有把握地解救 tst，你需要求出对于每一个 $i$ ，lyx 可以获得的最大线索量。由于某些特♂殊的原因，你需要输出答案对第$5201314$个质数取模后的结果。</p><p>（我跟你们嗦，lyx 呀，太神辣！</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行一个正整数 $n$。</p><p>之后的 $n$ 行，每行一个正整数 $a_i$</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>共 $n$ 行，每行一个正整数，第 $i$ 行表示 lyx 的起点为 $i$ 时的答案对第 $5201314$ 个质数取模后的结果。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>序列DP</p><p>在起点的一侧停下来的最优方案肯定是走完另一侧的所有点，最后在这个点停下来</p><p>设状态$f(i)$表示到第$i$个位置停下来，且这个位置在起点右边时能获得的最大价值，转移为</p><script type="math/tex; mode=display">f(i) = \max\{ f(i + 1), a(i) + i\}</script><p>设状态$g(i)$表示到第$j$个位置停下来，且这个位置在起点左边时能获得的最大价值，转移为</p><script type="math/tex; mode=display">g(i) = \max \{ f(i - 1), a(i) + n - i + 1\}</script><p>注意递推方向</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">89712239</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"lyx_tst.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"lyx_tst.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">        a[i] = x % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) f[i] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>], (a[i] + i) % MOD);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] = <span class="built_in">std</span>::max(g[i - <span class="number">1</span>], (a[i] + n - i + <span class="number">1</span>) % MOD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = a[i];</span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, f[i + <span class="number">1</span>]);</span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, g[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 序列DP </tag>
            
            <tag> 这是一个系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷 P3939] 数颜色 - 二分查找</title>
      <link href="/2017/11/03/luogu_P3939/"/>
      <url>/2017/11/03/luogu_P3939/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://www.luogu.org/problemnew/show/3939" target="_blank" rel="noopener">洛谷 P3939 数颜色</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>小 $C$ 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有相同的颜色。小 $C$ 把她标号从 1 到 $n$ 的 $n$ 只兔子排成长长的一排，来给他们喂胡萝卜吃。 排列完成后，第 $i$ 只兔子的颜色是 $a_i$ 。</p><p>俗话说得好，“萝卜青菜，各有所爱”。小 $C$ 发现，不同颜色的兔子可能有对胡萝卜的不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而 绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 $C$ 十分苦恼。所以，为 了使得胡萝卜喂得更加准确，小 C 想知道在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$的兔子。</p><p>不过，因为小 $C$ 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同 时，小 $C$ 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 $x<em>j$ 和 $x</em>{j+1}$的两只兔子会交换位置。 小 $C$ 被这一系列麻烦事给难住了。你能帮帮她吗？</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>从标准输入中读入数据。 输入第 $1$ 行两个正整数 $n$,$m$。</p><p>输入第 $2$ 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$</p><p>输入接下来 mm 行，每行为以下两种中的一种：</p><ul><li><p>$1 \ l_j \ r_j \ c_j$ 询问在区间$[l_j, r_j]$中有多少颜色为$c_j$的兔子</p></li><li><p>$2 \ x<em>j$ 表示$x_j$和$x</em>{j + 1}$交换了位置</p></li></ul><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出到标准输出中。</p><p>对于每个 <code>1</code> 操作，输出一行一个正整数，表示你对于这个询问的答案。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>乍一看区间操作然后乱搞一发线段树强行维护，然后就<code>MLE</code>了，只有$25$分</p><p>通过观察可以发现查询操作可以直接二分查找，具体来说就是记录下每个颜色的兔子的位置，二分找到左边界的那一只和右边界的那一只，两个位置中间的兔子就是在区间中的。</p><p>至于修改操作，因为每次都只会修改相邻两只兔子，所以如果两只兔子颜色相同，那是不会影响查询的，那我们就<code>continue</code>掉，如果两个兔子颜色不同，还是二分找到与他相邻的兔子，两者交换一下即可</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v(MAXN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        v[a[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;q);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator lPos, rPos;</span><br><span class="line">            lPos = <span class="built_in">std</span>::lower_bound(v[q].begin(), v[q].end(), l);</span><br><span class="line">            rPos = <span class="built_in">std</span>::upper_bound(v[q].begin(), v[q].end(), r);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, rPos - lPos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a[index] == a[index + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> col1 = a[index], col2 = a[index + <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator lPos, rPos;</span><br><span class="line">                lPos = <span class="built_in">std</span>::lower_bound(v[col1].begin(), v[col1].end(), index);</span><br><span class="line">                rPos = <span class="built_in">std</span>::lower_bound(v[col2].begin(), v[col2].end(), index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">std</span>::swap(v[col1][lPos - v[col1].begin()], v[col2][rPos - v[col2].begin()]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//std::swap(col1, col2);</span></span><br><span class="line">                a[index] = col2;</span><br><span class="line">                a[index + <span class="number">1</span>] = col1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MLE</code>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3</span> * <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> color, id;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> color = <span class="number">0</span>, <span class="keyword">int</span> id = <span class="number">0</span>) : color(color), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (color &lt; a.color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> id &lt; a.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (color == a.color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id == a.id) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; v;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        v.push_back(Node(x, i));</span><br><span class="line">        a[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::stable_sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf("Done\n");</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, q;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator it = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), Node(q, <span class="number">-1</span>));</span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">//             printf("--------\n");</span></span><br><span class="line"><span class="comment">//             printf("*it : color = %d, id = %d\n", it-&gt;color, it-&gt;id);</span></span><br><span class="line"><span class="comment">//             printf("--------\n");</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line">            <span class="keyword">while</span> (it-&gt;color == q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;id &gt;= l &amp;&amp; it-&gt;id &lt;= r) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;index);</span><br><span class="line">            <span class="keyword">int</span> color1 = a[index];</span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">//             printf("color1 : %d\n", color1);</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator s = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), Node(color1, <span class="number">-1</span>));</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator t = s;</span><br><span class="line">            <span class="keyword">while</span> (t-&gt;color == color1) t++;</span><br><span class="line">            t--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">//             printf("--------\n");</span></span><br><span class="line"><span class="comment">//             printf("*s : color = %d, id = %d\n", s-&gt;color, s-&gt;id);</span></span><br><span class="line"><span class="comment">//             printf("*t : color = %d, id = %d\n", t-&gt;color, t-&gt;id);</span></span><br><span class="line"><span class="comment">//             printf("--------\n");</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt;::iterator aim = <span class="built_in">std</span>::lower_bound(s, t, Node(<span class="number">-1</span>, index));</span><br><span class="line">            aim-&gt;id = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">//             printf("----------\n");</span></span><br><span class="line"><span class="comment">//             printf("aim : %d, %d\n", aim-&gt;color, aim-&gt;id);</span></span><br><span class="line"><span class="comment">//             printf("----------\n");</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> color2 = a[index + <span class="number">1</span>];</span><br><span class="line">            s = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), Node(color2, <span class="number">-1</span>));</span><br><span class="line">            t = s;</span><br><span class="line">            <span class="keyword">while</span> (t-&gt;color == color2) t++;</span><br><span class="line">            t--;</span><br><span class="line"></span><br><span class="line">            aim = <span class="built_in">std</span>::lower_bound(s, t, Node(<span class="number">-1</span>, index + <span class="number">1</span>));</span><br><span class="line">            aim-&gt;id = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 11582] Colossal Fibonacci Numbers! - 数学相关</title>
      <link href="/2017/11/01/UVa_11582/"/>
      <url>/2017/11/01/UVa_11582/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/problem/UVA-11582" target="_blank" rel="noopener">UVa 11582 Colossal Fibonacci Numbers</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定两个非负整数$a$, $b$和正整数$n (0 \le a, b &lt; 2 ^ {64}, 1 \le n \le 1000)$，计算$f(a ^ b) \% n$，其中$f(i)$表示斐波那契数列的第$i$项</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>Input begins with an integer $t \le 10, 000$, the number of test cases.</p><p>Each test case consists of three integers $a, b, n$ where $0 \le a, b &lt; 2^{64} $，$1 \le n \le 1000$.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>For each test case, output a single line containing the remainder of $f(a^b)$ upon division by $n$.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>斐波那契数列取模后是有周期性的，所以求出循环节后算一个快速幂取模就可以了。</p><p>数据很大要用<code>unsigned long long</code>，因为这个原因调了很久还出了很多奇奇怪怪的错误</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1000</span> + <span class="number">10</span>) * (<span class="number">1000</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mulMod</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a % mod) * (b % mod)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> m, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> mulMod(fastPowMod(m, n - <span class="number">1</span>, mod), m, mod); </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(mulMod(m, m, mod), n &gt;&gt; <span class="number">1</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%llu%llu%d"</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>; f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n * n + <span class="number">10</span>; i++) &#123;</span><br><span class="line">            f[i] = (f[i - <span class="number">1</span>] % n + f[i - <span class="number">2</span>] % n) % n;</span><br><span class="line">            <span class="keyword">if</span> (f[i] == f[<span class="number">2</span>] &amp;&amp; f[i - <span class="number">1</span>] == f[<span class="number">1</span>]) &#123;</span><br><span class="line">                loop = i - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[fastPowMod(a % loop, b, loop)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LYOJ 104] 愤怒的小鸟 - 状压DP</title>
      <link href="/2017/10/31/lyoj_104/"/>
      <url>/2017/10/31/lyoj_104/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/104" target="_blank" rel="noopener">LYOJ 104 愤怒的南小鸟 #NOIp2016</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>钟皓曦最近沉迷于一款神奇的游戏无法自拔。</p><p>简单来说，这款游戏是在一个平面上进行的。</p><p>有一架弹弓位于$(0, 0)$处，每次钟皓曦可以用它向第一象限发射一只南小鸟，南小鸟们的飞行轨迹均为形如 $y = ax ^ 2 + bx$ 的曲线，其中 $a，b$ 是钟皓曦指定的参数，且必须满足 $a &lt; 0$。</p><p>当南小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。</p><p>在游戏的某个关卡里，平面的第一象限中有  $n$  只绿色的小葱，其中第  $i$  只小葱所在的坐标为 $(x_i, y_i)$</p><p>如果某只南小鸟的飞行轨迹经过了 $(x_i, y_i) $，那么第 $i$ 只小葱就会被消灭掉，同时南小鸟将会沿着原先的轨迹继续飞行；</p><p>如果一只南小鸟的飞行轨迹没有经过$(x_i, y_i)$，那么这只南小鸟飞行的全过程就不会对第 $i$ 只小葱产生任何影响。</p><p>例如，若两只小葱分别位于 $(1, 3)$ 和  $(3, 3)$ ，钟皓曦可以选择发射一只飞行轨迹为 $y = -x ^ 2 + 4x$ 的南小鸟，这样两只小葱就会被这只南小鸟一起消灭。</p><p>而这个游戏的目的，就是通过发射南小鸟消灭所有的小葱。</p><p>这款神奇游戏的每个关卡对来说都很难，所以钟皓曦还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。</p><p>假设这款游戏一共有 $T$ 个关卡，现在钟皓曦想知道，对于每一个关卡，至少需要发射多少只南小鸟才能消灭所有的小葱。由于她不会算，所以希望由你告诉她。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含一个正整数 $T$，表示游戏的关卡总数。</p><p>下面依次输入这 $T$ 个关卡的信息。每个关卡第一行包含两个非负整数 $n$，$m$ ，分别表示该关卡中的小葱数量和钟皓曦输入的神秘指令类型。接下来的 $n$ 行中，第 $i$ 行包含两个正实数 $(x_i, y_i)$ ，表示第 $i$ 只小葱坐标为 $(x_i, y_i)$。数据保证同一个关卡中不存在两只坐标完全相同的小葱。</p><p>如果 $m = 0$，表示钟皓曦输入了一个没有任何作用的指令。</p><p>如果 $m = 1$，则这个关卡将会满足：至多用$\lceil \frac{n}{3} + 1 \rceil$只南小鸟即可消灭所有小葱。</p><p>如果$m = 2$，则这个关卡将会满足：一定存在一种最优解，其中有一只南小鸟消灭了至少$\lfloor \frac{n}{3} \rfloor$ 只小葱。</p><p>保证 $1 \leq n \leq 18$，$0 \leq m \leq 2$，$0 &lt; x_i, y_i &lt; 10$，输入中的实数均保留到小数点后两位。</p><p>上文中，符号 $\lceil x \rceil$ 和$\lfloor x \rfloor$ 分别表示对 $x$ 向上取整和向下取整。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>对每个关卡依次输出一行答案。</p><p>输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小葱最少需要的南小鸟数量。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>状压DP</p><p>设状态为当前没有被击中的猪的集合，压缩到一个二进制数中，转成十进制后作为数组下标，$f(i)$ 表示到达$i$这个状态最少需要发射的鸟的数目。</p><p>由于每条抛物线都是过原点的，枚举每两只猪便可以解出抛物线解析式里的 $a$ 和 $b$ ，可以由此确定出 $C_n^2$ 条抛物线，再枚举每一只猪，看能否被这条抛物线击中。</p><p>我们发现状态的转移是以抛物线为媒介的，所以说我们记录每一条抛物线能对状态造成的更改，同样用一个二进制数表示，这样就可以以没有被击中的猪的集合为点，抛物线为边建立状态图了，这个图是一个<code>DAG</code>，所以只需要刷表法跑一遍就可以了，使用类似<code>BFS</code>的做法，<code>BFS</code>保证最先找到的解一定是最小的。</p><p>题目中给出的 $m$ 没有什么用，是给的部分分 <del>但是并不觉得有多简单</del></p><p>状态在修改的时候实际上就是当前的状态与抛物线的转移取并集，用位运算中的<code>|</code>就可以实现</p><p>关于位运算可以<a href="https://ilern.coding.me/428/2017/10/28/bitCalc/#more" target="_blank" rel="noopener">看这里</a></p><p>希望NOIp早日支持<code>c++11</code></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">18</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSTATUS = <span class="number">1048576</span> + <span class="number">100</span>; <span class="comment">//2 ** MAXN</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pig</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> hit;</span><br><span class="line">    Pig(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y), hit(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parabola</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> cnt, status;</span><br><span class="line">    Parabola(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>, <span class="keyword">int</span> cnt = <span class="number">0</span>) : a(a), b(b), cnt(cnt), status(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Pig&gt; pigs;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Parabola&gt; parabola;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(a - b) &lt;= EPS;</span><br><span class="line">&#125;</span><br><span class="line">de</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(Pig pig1, Pig pig2, <span class="keyword">double</span> &amp;a, <span class="keyword">double</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a = (pig2.x * pig1.y - pig1.x * pig2.y) / (pig1.x * pig1.x * pig2.x - pig2.x * pig2.x * pig1.x);</span><br><span class="line">    b = (pig2.x * pig2.x * pig1. y - pig1.x * pig1.x * pig2.y) / (pig2.x * pig2.x * pig1.x - pig1.x * pig1.x * pig2.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(Parabola a, Pig b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmp(b.x * b.x * a.a + b.x * a.b, b.y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinary</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, a % <span class="number">2</span>);</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXSTATUS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"angrykotori.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"angrykotori.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        pigs.clear();</span><br><span class="line">        parabola.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">            pigs.push_back(Pig(x, y));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Pig&gt;::iterator it1 = pigs.begin(); it1 != pigs.end(); it1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Pig&gt;::iterator it2 = it1 + <span class="number">1</span>; it2 != pigs.end(); it2++) &#123;</span><br><span class="line">                <span class="keyword">double</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// if (!it1-&gt;hit &amp;&amp; !it2-&gt;hit) calc(*it1, *it2, a, b);</span></span><br><span class="line">                calc(*it1, *it2, a, b);</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    it1-&gt;hit = <span class="literal">true</span>; it2-&gt;hit = <span class="literal">true</span>;</span><br><span class="line">                    parabola.push_back(Parabola(a, b, <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----------\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : parabola) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf \n"</span>, (-x.b) / <span class="number">2</span> * x.a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----------\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function">Parabola <span class="title">unHit</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Pig&gt;::iterator it1 = pigs.begin(); it1 != pigs.end(); it1++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!it1-&gt;hit) &#123;</span><br><span class="line">                unHit.status |= (<span class="number">1</span> &lt;&lt; (it1 - pigs.begin()));</span><br><span class="line">                unHit.cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        parabola.push_back(unHit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Parabola&gt;::iterator it1 = parabola.begin(); it1 != parabola.end(); it1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Pig&gt;::iterator it2 = pigs.begin(); it2 != pigs.end(); it2++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (check(*it1, *it2)) &#123;</span><br><span class="line">                    <span class="comment">// it1-&gt;cnt++;</span></span><br><span class="line">                    it1-&gt;status |= (<span class="number">1</span> &lt;&lt; (it2 - pigs.begin()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----------------\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : parabola) &#123;</span><br><span class="line">            printBinary(x.status);</span><br><span class="line">            <span class="comment">// printf("%d\n", x.cnt);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----------------\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::fill(f, f + MAXSTATUS, <span class="number">0x7f7f7f7f</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Parabola&gt;::iterator it = parabola.begin(); it != parabola.end(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[now | it-&gt;status] &gt; f[now] + it-&gt;cnt) &#123;</span><br><span class="line">                    f[now | it-&gt;status] = f[now] + it-&gt;cnt;</span><br><span class="line">                    q.push(now | it-&gt;status);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 5 2</span></span><br><span class="line"><span class="comment">// 1.00 5.00</span></span><br><span class="line"><span class="comment">// 2.00 8.00</span></span><br><span class="line"><span class="comment">// 3.00 9.00</span></span><br><span class="line"><span class="comment">// 4.00 8.00</span></span><br><span class="line"><span class="comment">// 5.00 5.00</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LYOJ 103] 蚯蚓 - 单调队列</title>
      <link href="/2017/10/31/lyoj_103/"/>
      <url>/2017/10/31/lyoj_103/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/103" target="_blank" rel="noopener">LYOJ 103 蚯蚓 #NOIp2016</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>本题中，我们将用符号 $\lfloor c \rfloor$ 表示对 $c$ 向下取整，例如：$\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。</p><p>蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。</p><p>蛐蛐国里现在共有  $n$  只蚯蚓（ $n$ 为正整数）。每只蚯蚓拥有长度，我们设第  $i$ 只蚯蚓的长度为 $a_i$（$i = 1, 2, \ldots , n$ ），并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。</p><p>每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 &lt; p &lt; 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$  和 $x - \lfloor px \rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$ ，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。</p><p>蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来 ……（ $m$ 为非负整数）</p><p>蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：</p><ul><li>$m$  秒内，每一秒被切断的蚯蚓被切断前的长度（有  $m$ 个数）；</li><li>$m$  秒后，所有蚯蚓的长度（有 $n + m$ 个数）。</li></ul><p>蛐蛐国王当然知道怎么做啦！但是他想考考你 ……</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含六个整数 $n, m, q, u, v, t$ 其中：$n, m, q$ 的意义见「问题描述」，$u, v, t$ 均为正整数，你需要自己计算 $p = \frac{u}{v}$ (保证 $0 &lt; u &lt; v$) $t$是输出参数，其含义将会在「输出格式」中解释。</p><p>第二行包含 n n n 个非负整数，为 $a_1, a_2, \ldots, a_n$ 即初始时 $n$ 只蚯蚓的长度。</p><p>同一行中相邻的两个数之间，恰好用一个空格隔开。</p><p>保证 $1 \leq n \leq 10 ^ 5, 0 &lt; m &lt; 7 \times 10 ^ 6 ,<br> 0 &lt; u &lt; v &lt; 10 ^ 9, 0 \leq q \leq 200, 1 &lt; t &lt; 71, 0 &lt; a_i &lt; 10 ^ 8$ 。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>第一行输出 $\lfloor \frac{m}{t} \rfloor$ 个整数，按时间顺序，依次输出第 $t$秒，第$2t$秒，第 $3t$秒 …… 被切断蚯蚓（在被切断前）的长度。</p><p>第二行输出 $\lfloor \frac{(n+m)}{t} \rfloor$ 个整数，输出$m$秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 $t$，第 $2t$，第 $3t$…… 的长度。</p><p>同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。</p><p>请阅读样例来更好地理解这个格式。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>题面中提到 <strong>最长的</strong> 那只蚯蚓，自然考虑优先队列，要求每次对 <strong>所有的</strong> 蚯蚓增加长度，可以打一个全局标记而不是真正修改，等到输出的时候在假装修改，但是这样会<code>TLE</code>只有$80$分的样子（在考场上打暴力还是很划算的）</p><p>经过观察我们发现每次切的蚯蚓长度是单调递减的，所以构造三个队列，一个用来存放从小到大排序好的初始序列，另外两个一个存每次切完后较大的那一段另一个存较小的那一段，可以证明这三个队列都是单调递减的，只需要每次取这三个队列队头元素中最大的那一个切一切，全局标记增加，这两段的长度减小就可以了。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, q, u, v, t;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; qa;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; qb;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; qc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; *curq = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cur = LLONG_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qa.empty() &amp;&amp; qa.front() &gt; cur) &#123;</span><br><span class="line">        cur = qa.front();curq = &amp;qa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!qb.empty() &amp;&amp; qb.front() &gt; cur) &#123;</span><br><span class="line">        cur = qb.front();curq = &amp;qb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!qc.empty() &amp;&amp; qc.front() &gt; cur) &#123;</span><br><span class="line">        cur = qc.front();curq = &amp;qc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curq!=<span class="literal">NULL</span>)curq-&gt;pop();</span><br><span class="line">    <span class="keyword">return</span> cur + (time - <span class="number">1</span>)*q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"earthworm.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"earthworm.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        qa.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> realcur = getMax(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i%t == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, realcur);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cut1 = realcur * u / v;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cut2 = realcur - cut1;</span><br><span class="line"></span><br><span class="line">        cut1 -= i * q;</span><br><span class="line">        cut2 -= i * q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cut1 &gt; cut2) <span class="built_in">std</span>::swap(cut1, cut2);</span><br><span class="line"></span><br><span class="line">        qb.push(cut1);</span><br><span class="line">        qc.push(cut2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = getMax(m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i % t == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LYOJ 101] 换教室 - 期望DP</title>
      <link href="/2017/10/30/lyoj_101/"/>
      <url>/2017/10/30/lyoj_101/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/101" target="_blank" rel="noopener">LYOJ 101 换教室 #NOIp 2016</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。</p><p>在可以选择的课程中，有 $2n$ 节课程安排在 $n$ 个时间段上。在第  $i$  $(1 \leq i \leq n)$个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $c_i$ 上课，而另一节课程在教室 $d_i$ 进行。</p><p>在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的$n$节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $i$个时间段去教室 $d_i$上课，否则仍然在教室 $c_i$ 上课。</p><p>由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $i$ 节课程的教室时，申请被通过的概率是一个已知的实数 $k_i$，并且对于不同课程的申请，被通过的概率是互相独立的。</p><p>学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $m$ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 $m$ 门课程，也可以不用完这 $m$ 个申请的机会，甚至可以一门课程都不申请。</p><p>因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课问时间从一间教室赶到另一间教室。</p><p>牛牛所在的大学有 $v$ 个教室，有 $e$ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $i$ $(1 \leq i \leq n - 1)$节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。</p><p>现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行四个整数 $n$ ，$m$，$v$，$e$。$n$ 表示这个学期内的时间段的数量；$m$ 表示牛牛最多可以申请更换多少节课程的教室；$v$ 表示牛牛学校里教室的数量；$e$表示牛牛的学校里道路的数量。</p><p>第二行 $n$ 个正整数，第 $i$ $(1 \leq i \leq n)$个正整数表示 $c_i$ ，即第 $i$ 个时间段牛牛被安排上课的教室；保证 $1 \leq c_i \leq v$。</p><p>第三行$n$个正整数，第 $i (1 \leq i \leq n)$个正整数表示 $d_i$，即第 $i$ 个时间段另一间上同样课程的教室；保证 $1 \leq d_i \leq v$</p><p>第四行 $n$个实数，第$i(1 \leq i \leq n)$个实数表示 $k_i$，即牛牛申请在第 $i$ 个时间段更换教室获得通过的概率。保证  $0 \leq k_i \leq 1$</p><p>接下来 $e$ 行，每行三个正整数 $a_j, b_j, w_j$ ，表示有一条双向道路连接教室  $a_j, b_j$ ，通过这条道路需要耗费的体力值是  $w_j$ ；保证 $1 \leq a_j, b_j \leq v, 1 \leq w_j \leq 100 $。</p><p>保证  $1 \leq n \leq 2000 ，0 \leq m \leq 2000， 1 \leq v \leq 300 ， 0 \leq e \leq 90000$ 。</p><p>保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。</p><p>保证输入的实数最多包含 $3$ 位小数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出一行，包含一个实数，四舎五入精确到小数点后恰好 $2$ 位，表示答案。你的输出必须和标准输出完全一样才算正确。</p><p>测试数据保证四舎五入后的答案和准确答案的差的绝对值不大于 $4 \times 10 ^ {-3}$<br>​​ 。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理）</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>期望DP</p><p>设状态$f(i, j, 0 / 1)$表示在第$i$个时间段以前，换了$j$个教室，第$i$个换$(1)$, 不换$(0)$，所能达到的最小距离，则转移为</p><script type="math/tex; mode=display">f(i, j, 0) = \min \begin{cases}f(i - 1, j, 0) + dis(c_{i - 1}, c_i)\\\[2ex]f(i - 1, j, 1) + dis(d_{i - 1}, c_i) \times k_{i - 1} + dis(c_{i - 1}, c_i) \times (1 - k_i)\end{cases}</script><script type="math/tex; mode=display">f(i, j, 1) = \min\begin{cases}f(i - 1, j - 1, 0) + dis(c_{i - 1}, d_i) \times k_i + dis(c_{i - 1}, c_i) \times (1 - k_i) \\\[2ex]f(i - 1, j - 1, 1)+dis(d_{i - 1}, d_i) \times k_{i - 1} \times k_i+dis(c_{i - 1}, d_i) \times (1 - k_{i - 1}) \times k_i+dis(d_{i - 1}, c_i) \times k_{i - 1} \times (1 - k_i)+dis(c_{i - 1}, c_i) \times (1 - k_{i - 1}) \times (1 - k_i)\end{cases}</script><p>其中$dis(u, v)$表示的是从教室$u$到教室$v$的最短路，用<code>Floyd</code>算法预处理出即可</p><p>感觉说是<strong>期望DP</strong>实际上只要知道<strong>期望</strong>是个什么东西就和普通的DP没什么区别了，不过这个状态转移虽然不难想但是是真的长</p><p>原题给了很多部分分，比如说一个<code>Floyd</code>交上去就能有$20$分了，但是考场上没能仔细分析没拿到暴力分 <del>拿到了说不定我现在就不会在这里了</del></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[MAXN], d[MAXN];</span><br><span class="line"><span class="keyword">double</span> k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"classroom.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"classroom.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, v, e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;v, &amp;e); <span class="comment">// n-&gt;sizeOfTime, m-&gt;sizeOfChance, v-&gt;sizeOfNode, e-&gt;sizeOfEdge</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;k[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">            g[i][j] = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">        g[x][y] = g[y][x] = <span class="built_in">std</span>::min(g[x][y], w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][k] != INT_MAX &amp;&amp; g[k][j] != INT_MAX) &#123;</span><br><span class="line">                    g[i][j] = <span class="built_in">std</span>::min(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        g[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = DBL_MAX;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">1</span>] = DBL_MAX;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + g[c[i - <span class="number">1</span>]][c[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">std</span>::min(f[i - <span class="number">1</span>][j][<span class="number">0</span>] + g[c[i - <span class="number">1</span>]][c[i]], f[i - <span class="number">1</span>][j][<span class="number">1</span>] + g[d[i - <span class="number">1</span>]][c[i]] * k[i - <span class="number">1</span>] + g[c[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - k[i - <span class="number">1</span>]));</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">std</span>::min(f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + g[d[i - <span class="number">1</span>]][d[i]] * k[i - <span class="number">1</span>] * k[i] + g[c[i - <span class="number">1</span>]][d[i]] * (<span class="number">1</span> - k[i - <span class="number">1</span>]) * k[i] + g[d[i - <span class="number">1</span>]][c[i]] * k[i - <span class="number">1</span>] * (<span class="number">1</span> - k[i]) + g[c[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - k[i - <span class="number">1</span>]) * (<span class="number">1</span> - k[i]), f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] + g[c[i - <span class="number">1</span>]][d[i]] * k[i] + g[c[i - <span class="number">1</span>]][c[i]] * (<span class="number">1</span> - k[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ans = DBL_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, f[n][i][<span class="number">1</span>]);</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, f[n][i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【写的时候犯的错误】"><a href="#【写的时候犯的错误】" class="headerlink" title="【写的时候犯的错误】"></a>【写的时候犯的错误】</h3><ul><li>变量名起重复了……</li><li>这大概是我写的最 <strong>宽</strong> 的代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 期望DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩中常见的位运算技巧</title>
      <link href="/2017/10/28/bitCalc/"/>
      <url>/2017/10/28/bitCalc/</url>
      
        <content type="html"><![CDATA[<p> 在学习状态压缩DP之前先来看看这些位运算的处理方法</p><a id="more"></a><h3 id="【基本运算】"><a href="#【基本运算】" class="headerlink" title="【基本运算】"></a>【基本运算】</h3><ul><li><p><code>&amp;</code> 「按位与」运算，返回<strong>两个数在二进制下进行按位与运算后的结果的十进制表示形式</strong>，对应到集合运算中为<strong>交</strong>运算</p></li><li><p><code>|</code> 「按位或」运算，返回<strong>两个数在二进制下进行按位或运算后的结果的十进制表示形式</strong>，对应到集合运算中为<strong>并</strong>运算</p></li><li><p><code>^</code> 「按位异或」运算，返回<strong>两个数在二进制下进行按位异或运算后的结果的十进制表示形式</strong>，对应到集合运算中为<strong>对称差</strong>运算</p></li><li><p><code>~</code> 「按位取反」运算，返回<strong>一个数在二进制下进行按位取反运算后的结果的十进制表示形式</strong></p></li><li><p><code>&lt;&lt;</code> 「左移」运算，返回<strong>一个数在二进制下丢掉最高位并在最低位补零之后的结果的十进制表示</strong>(看上去就是向左错开了一位)，在十进制下表现为<strong>扩大</strong>为原数的两倍</p></li><li><p><code>&gt;&gt;</code> 「右移」运算，返回<strong>一个数在二进制下丢掉最低位并在最高位补零之后的结果的十进制表示</strong>(看上去就是向右错开了一位)，在十进制下表现为<strong>缩小</strong>到原数的二分之一</p></li></ul><h3 id="【应用】"><a href="#【应用】" class="headerlink" title="【应用】"></a>【应用】</h3><ul><li>判断一个数字x二进制下第i位是否等于1<ul><li><code>if (((1 &lt;&lt; (i - 1)) &amp; x ) &gt; 0)</code></li></ul></li></ul><ul><li>将一个数字x二进制下第i位更改成1<ul><li><code>x = x | (1 &lt;&lt; (i - 1))</code></li></ul></li></ul><ul><li>将一个数字x二进制下第i位更改成0<ul><li><code>n &amp; ~(1 &lt;&lt; (m - 1))</code></li></ul></li></ul><ul><li>把一个数字二进制下最靠右的第一个1去掉<ul><li><code>x = x &amp; (x - 1)</code></li></ul></li></ul><ul><li>判断一个数的是否为偶数<ul><li><code>if(x &amp; 1)</code></li></ul></li></ul><ul><li>判断一个数是否为$2$的整数次幂<ul><li><code>if(!(n &amp; (n - 1) &amp;&amp; n) = 1 || n == 1)</code></li></ul></li></ul><ul><li>获得一个$n$位的全$1$二进制数<ul><li><code>(1 &lt;&lt; n) - 1</code></li></ul></li></ul><ul><li>统计一个数在二进制下$1$的个数</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountOne</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt; <span class="number">1</span>) + (n &amp; <span class="number">0x55555555</span>);  </span><br><span class="line">    <span class="comment">//0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt; <span class="number">2</span>) + (n &amp; <span class="number">0x33333333</span>);  </span><br><span class="line">    <span class="comment">//0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xF0F0F0F0</span>) &gt;&gt; <span class="number">4</span>) + (n &amp; <span class="number">0x0F0F0F0F</span>);  </span><br><span class="line">    <span class="comment">//0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xFF00FF00</span>) &gt;&gt; <span class="number">8</span>) + (n &amp; <span class="number">0x00FF00FF</span>);  </span><br><span class="line">    <span class="comment">//0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位  </span></span><br><span class="line">    n = ((n &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>) + (n &amp; <span class="number">0x0000FFFF</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> n;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【注意事项】"><a href="#【注意事项】" class="headerlink" title="【注意事项】"></a>【注意事项】</h3><p>  多用括号</p><h3 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a>【参考资料】</h3><p>  <a href="http://blog.csdn.net/u011077606/article/details/43487421" target="_blank" rel="noopener">动态规划之状态压缩dp入门</a></p><p>  <a href="http://blog.csdn.net/yunyu5120/article/details/6692072" target="_blank" rel="noopener">编程技巧—位运算的巧妙运用</a></p><p>  <a href="http://blog.csdn.net/zmazon/article/details/8262185" target="_blank" rel="noopener">优秀程序员不得不知道的20个位运算技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1378]选课 - 树形DP</title>
      <link href="/2017/10/28/Codevs_1378/"/>
      <url>/2017/10/28/Codevs_1378/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1378/" target="_blank" rel="noopener">Codevs 1378 选课</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给出$n$个课程之间的关系(是否有先修课，有的话是谁)以及每一个课程的学分，和$m$个选课名额，问如何选课使得最后能获得的学分最多</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件的第一行包括两个整数$n$、$m$（中间用一个空格隔开）其中$1 \le n \le 300,1 \le m \le n$。 </p><p>以下N行每行代表一门课。课号依次为$1，2, \cdots n$。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为$0$），第二个数为这门课的学分。学分是不超过$10$的正整数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件只有一个数,实际所选课程的学分总数。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>树形DP</p><p>设状态$f(i, m)$表示在$i$及$i$的兄弟 <strong>或</strong> 儿子节点分配$m$个名额能得到的最大学分，则转移为：</p><script type="math/tex; mode=display">f(i, m) = \max \{f(ch(i), k) + f(bra(i), m - k - 1), f(bra(i), m) \mid k \in [0, m - 1]\}</script><p>其中$ch(i)$表示$i$号点的 <strong>最后一个加入的</strong> 孩子，$bra(i)$表示$i$号点<strong>最后一个加入的</strong>兄弟 <del>（感觉怪怪的）</del></p><p>上述方程直观表示出转移的两种情况：</p><ul><li>如果选这门课， 那么有一个名额留给自己，剩下的分$i$个名额给孩子，分$m - i - 1$个名额给兄弟</li><li>如果不选这门课，那么就把所有的$m$个名额让给兄弟</li></ul><p>在建树的时候用的是一种类似邻接表的表示方法，每个点里存的是 <strong>最后一个加入的</strong> 孩子，和 <strong>最后一个加入的兄弟</strong> ，通过<code>next</code>指针链接成链表。</p><p>值得注意的是对于每一个点的状态是有很多种的（取决与兄弟和孩子的不同分配方案），所以在记录的时候不能只简单记录一个<code>ans</code>，而是应该用一个数组保存所有的状态值</p><p>另外数据中可能会有一些课程是<strong>没有先修课</strong>的，也就是说题目中给出的是一个<strong>森林</strong>，这个时候我们增加一个虚拟节点$0$号点，把所有的点都连到以这个虚拟节点为根的树上，但是这样的话总的可选课程数就要加一，因为$0$号点显然是必须要选的。</p><p>代码使用了记忆化搜索，因为树形结构本身具有的层次关系，记忆化搜索往往要比递推要容易实现</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *fa, *ch, *next;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> solved[MAXN];</span><br><span class="line">    <span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line">    Node() : fa(<span class="literal">NULL</span>), ch(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>), value(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::fill(ans, ans + MAXN, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::fill(solved, solved + MAXN, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *a, Node *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;ch) a-&gt;ch = b;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        b-&gt;next = a-&gt;ch;</span><br><span class="line">        a-&gt;ch = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(Node *x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;solved[m]) <span class="keyword">return</span> x-&gt;ans[m];</span><br><span class="line">    <span class="keyword">else</span> x-&gt;solved[m] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    x-&gt;ans[m] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        x-&gt;ans[m] = <span class="built_in">std</span>::max(dp(x-&gt;ch, i) + dp(x-&gt;next, m - i - <span class="number">1</span>) + x-&gt;value, x-&gt;ans[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x != nodes) &#123;</span><br><span class="line">        x-&gt;ans[m] = <span class="built_in">std</span>::max(dp(x-&gt;next, m), x-&gt;ans[m]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x-&gt;ans[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        addEdge(nodes + x, nodes + i);</span><br><span class="line">        nodes[i].value = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Node %d :\n"</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    value = %d\n"</span>, nodes[i].ans);</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].ch) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"    ch = %d\n"</span>, nodes[i].ch - nodes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"    ch = NULL\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"brothers : "</span>);</span><br><span class="line">        Node *v = nodes[i].ch;</span><br><span class="line">        <span class="keyword">while</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, v - nodes);</span><br><span class="line">            v = v-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp(nodes, m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 12186] Another Crisis - 树形DP</title>
      <link href="/2017/10/28/UVa_12186/"/>
      <url>/2017/10/28/UVa_12186/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/problem/UVA-12186" target="_blank" rel="noopener">UVa 12186 Another Crisis</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>一个老板和$n$个员工组成树状结构，每个员工都有自己的唯一上司，老板的编号为$0$，员工$1 \dots n$，工人们打算签署一个志愿书给老板，但无法跨级，当一个中级员工（非是工人的员工）的直属下属中不小于$T\%$的人签字时，他也会签字并且递给他的直属上司，问：要让老板收到请愿书至少需要多少个工人签字</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>There are several test cases. The input for each test case is given in exactly two lines. The first line contains two integers $N$ and $T (1 \le N \le 10^5 , 1 \le T \le 100)$, separated by a single space. $N$ indicates the number of employees of the company (not counting the owner) and $T$ is the parameter described above. Each of the employees is identified by an integer between $1$ and $N$. The owner is identified by the number $0$. The second line contains a list of integers separated by single spaces. The integer $B_i$, at position $i$ on this list (starting from $1$), indicates the identification of the direct boss of employee $i (0 \le B_i \le i − 1)$.</p><p>The last test case is followed by a line containing two zeros separated by a single space.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>For each test case output a single line containing a single integer with the minimum number of workers that need to file a petition in order to get the owner of the company to receive a petition.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设状态$f(i)$表示员工$i$向上传递信息最少要有多少（底层的）工人同意。</p><p>则转移为</p><script type="math/tex; mode=display">f(i) = \min \{ \sum_{cnt=1}^{num} f(j) \mid j \in s(i) \}</script><p>其中 $num = \frac{k \times T - 1}{100} + 1$, $s(i)$表示节点$i$的儿子节点集合</p><p>边界为工人的答案为$1$，最后把每个节点的子节点汇总上来的答案排序后取前$num$个作为这个节点的答案即可</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node *fa;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node*&gt; ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    Node() : fa(<span class="literal">NULL</span>), d(<span class="number">0</span>) &#123;</span><br><span class="line">        ch.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *fa, Node *son)</span> </span>&#123;</span><br><span class="line">    fa-&gt;ch.push_back(son);</span><br><span class="line">    son-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;ch.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numOfSon = x-&gt;ch.size();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfSon; i++) &#123;</span><br><span class="line">        d.push_back(dp(x-&gt;ch[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::sort(d.begin(), d.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = (numOfSon * t - <span class="number">1</span>) / <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">         ans += d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;d = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;t) == <span class="number">2</span> &amp;&amp; n &amp;&amp; t) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">             nodes[i].ch.clear();</span><br><span class="line">             nodes[i].d = <span class="number">0</span>;</span><br><span class="line">             nodes[i].fa = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            addEdge(nodes + x, nodes + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm node[%d]\n"</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"My father is %ld\n"</span>, nodes[i].fa - nodes);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I have %d sons\n"</span>, nodes[i].ch.size());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"They are:\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes[i].ch.size(); j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, nodes[i].ch[j] - nodes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        dp(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[<span class="number">0</span>].d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[LyOJ #77]小澳的坐标系 - 矩阵乘法</title>
      <link href="/2017/10/27/LYOJ_77/"/>
      <url>/2017/10/27/LYOJ_77/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://ly.men.ci/problem/77" target="_blank" rel="noopener">LyOJ #77 小澳的坐标系</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>小澳的梦境中出现了一个平面直角坐标系，自原点，向四方无限延伸。</p><p>小澳在坐标系的原点，他可以向上、向左或者向右走。他可以走 $n$ 步，但不能经过相同的点。</p><p>小澳想知道他有多少种走法。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件仅第一行一个正整数 $n$，表示小澳可以走的步数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件共一行，输出一个正整数，表示答案（对 $10^9 + 7$ 取模）。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>容易想到用$f(i, 0)$，$f(i, 1)$，$f(i, 2)$分别表示第 $i$ 步向上，向左，向右走的方案数，则可由下面的式子递推求解：</p><script type="math/tex; mode=display">\begin{cases}f(i, 0) = f(i - 1, 0) + f(i - 1, 1) + f(i - 1, 2) \\\[2ex]f(i, 1) = f(i - 1, 0) + f(i - 1, 1)\\\[2ex]f(i, 2) = f(i - 1, 0) + f(i - 1, 2)\end{cases}</script><p>最终答案为$f(n, 0) + f(n, 1) + f(n, 2)$</p><p>使用滚动数组优化空间</p><p>但是问题是这样递推是会超时的，所以把上面的式子化简一下可以得到</p><script type="math/tex; mode=display">f(n) = f(n - 2) + 2f(n - 1)</script><p>对于这样的<strong>线性齐次递推式</strong>，考虑使用<a href="http://ilern.coding.me/428/2016/10/23/Matrix/" target="_blank" rel="noopener">矩阵快速幂</a>优化时间</p><p>我们可以<a href="http://ilern.coding.me/428/2017/10/27/cons/" target="_blank" rel="noopener">构造出</a>转移矩阵</p><script type="math/tex; mode=display">\left[  \begin{matrix}    0 & 1 \\    1 & 2   \end{matrix}\right]</script><p>然后答案直接计算即可</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> sizeX, sizeY;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> sizeX = <span class="number">0</span>, <span class="keyword">int</span> sizeY = <span class="number">0</span>) : sizeX(sizeX), sizeY(sizeY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(sizeX, a.sizeY)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sizeY; k++) &#123;</span><br><span class="line">                    ans.a[i][j] += (<span class="keyword">this</span>-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD;</span><br><span class="line">                    ans.a[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;a[i][j] = a.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%lld %lld]\n"</span>, a[<span class="number">0</span>][<span class="number">0</span>], a[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%lld %lld]\n"</span>, a[<span class="number">1</span>][<span class="number">0</span>], a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastPowMod</span><span class="params">(Matrix m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> fastPowMod(m, n - <span class="number">1</span>) * m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(m * m, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">    freopen(<span class="string">"coordinate.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"coordinate.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Matrix <span class="title">begin</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    begin.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    begin.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// printf("this is Matrix Begin\n");</span></span><br><span class="line">   <span class="comment">// begin.print();</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">move</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    move.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    move.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    move.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    move.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// printf("this is Matrix Move\n");</span></span><br><span class="line">   <span class="comment">// move.print();</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Matrix <span class="title">ans</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    ans = begin * fastPowMod(move, n - <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// printf("this is Matrix Ans\n");</span></span><br><span class="line">   <span class="comment">// ans.print();</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans.a[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【递推式化简的过程】"><a href="#【递推式化简的过程】" class="headerlink" title="【递推式化简的过程】"></a>【递推式化简的过程】</h3><script type="math/tex; mode=display">\begin{equation}\begin{split}  F(n) &= f(n, 0) + f(n, 1) + f(n, 2) \\       &= f(n - 1, 1) + f(n - 1, 2) + f(n - 1, 0) + f(n - 1, 0) + f(n - 1, 1) + f(n - 1, 0) + f(n - 1, 2) \\       &= 2f(n - 1, 1) + 2f(n - 1 ,2) + 3f(n - 1, 0) \\       &= 2F(n - 1) + f(n - 1, 0) \\       &= 2F(n - 1) + F(n - 2)\end{split}\end{equation}</script>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 10003] Cutting Sticks - 区间DP</title>
      <link href="/2017/10/27/UVa_10003/"/>
      <url>/2017/10/27/UVa_10003/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/problem/UVA-10003" target="_blank" rel="noopener">UVa 10003 Cutting Sticks</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一根木棍，木棍上有若干切割点，切割木棍的花费数值上等于被切割木棍的长度，问最小花费</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>The input will consist of several input cases. The first line of each test case will contain a positive number $l$ that represents the length of the stick to be cut. You can assume $l &lt; 1000$. The next line will<br>contain the number $n (n &lt; 50)$ of cuts to be made.</p><p>The next line consists of $n$ positive numbers $c_i (0 &lt; c_i &lt; l)$ representing the places where the cuts have to be done, given in strictly increasing order.</p><p>An input case with $l = 0$ will represent the end of the input.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>You have to print the cost of the optimal solution of the cutting problem, that is the minimum cost of cutting the given stick. Format the output as shown below.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>区间DP</p><p>设状态$f(l, r)$表示切割$[l, r]$这个<strong>闭区间</strong>所能实现的最小花费。</p><p>则转移为：</p><script type="math/tex; mode=display">f(l, r) = \min\{f(l, k) + f(k, j) | i < k < j\} + a[j] - a[i]</script><p>最终答案为$f(0, n + 1)$</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis [l][r]) <span class="keyword">return</span> f[l][r];</span><br><span class="line">    <span class="keyword">else</span> vis[l][r] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;ans = f[l][r];</span><br><span class="line">    ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = dp(l, i) + dp(i, r) + a[r] - a[l];</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span> || tmp &lt; ans) &#123;</span><br><span class="line">            ans = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l) == <span class="number">1</span> &amp;&amp; l) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        a[n + <span class="number">1</span>] = l;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The minimum cutting is %d.\n"</span>, dp(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用矩阵快速幂优化递推时转移矩阵的构造</title>
      <link href="/2017/10/27/cons/"/>
      <url>/2017/10/27/cons/</url>
      
        <content type="html"><![CDATA[<p>在使用矩阵快速幂优化递推时最重要最核心的一步就是构造出关键的转移矩阵，这篇文章介绍了一种构造方法</p><a id="more"></a><p>我们以<a href="http://ilern.coding.me/428/2017/10/27/LYOJ_77/#more" target="_blank" rel="noopener">LyOJ #77小澳的坐标系</a>一题为例，说明如何构造转移矩阵</p><p>已知递推式为</p><script type="math/tex; mode=display">f(n) = f(n - 2) + 2f(n - 1)</script><p>也就是说我们要构造一个矩阵使得</p><script type="math/tex; mode=display">\begin{bmatrix}    f(n - 2) & f(n - 1)\end{bmatrix}\times \begin{bmatrix}        a & b  \\        c & d\end{bmatrix}=\begin{bmatrix}    f(n - 1) & f(n) \end{bmatrix}</script><p>根据矩阵乘法的定义可以得到</p><script type="math/tex; mode=display">\begin{bmatrix}    f(n - 2) & f(n - 1)\end{bmatrix}\times \begin{bmatrix}    a & b  \\    c & d\end{bmatrix}=\begin{bmatrix}        af(n - 2) + cf(n - 1) & bf(n - 2) + df(n - 1)\end{bmatrix}</script><p>然后与我们的目标结果做一下对应，便可以得到转移矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}    0 & 1 \\    1 & 2\end{bmatrix}</script>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 12563]Jin Ge Jin Qu hao - 背包DP</title>
      <link href="/2017/10/25/uva_12563/"/>
      <url>/2017/10/25/uva_12563/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/problem/UVA-12563" target="_blank" rel="noopener">UVa 12563 Jin Ge Jin Qu hao</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>(If you smiled when you see the title, this problem is for you ^_^)<br>For those who don’t know KTV, see:<a href="http://en.wikipedia.org/wiki/Karaoke_box" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Karaoke_box</a><br>There is one very popular song called Jin Ge Jin Qu(). It is a mix of 37 songs, and is extremely long (11 minutes and 18 seconds) — I know that there are Jin Ge Jin Qu II and III, and some other unofficial versions. But in this problem please forget about them.</p><p>Why is it popular? Suppose you have only 15 seconds left (until your time is up), then you should select another song as soon as possible, because the KTV will not crudely stop a song before it ends (people will get frustrated if it does so!). If you select a 2-minute song, you actually get 105 extra seconds! ….and if you select Jin Ge Jin Qu, you’ll get 663 extra seconds!!!</p><p>Now that you still have some time, but you’d like to make a plan now. You should stick to the<br>following rules:</p><p>• Don’t sing a song more than once (including Jin Ge Jin Qu).</p><p>• For each song of length t, either sing it for exactly t seconds, or don’t sing it at all.</p><p>• When a song is finished, always immediately start a new song.<br>Your goal is simple: sing as many songs as possible, and leave KTV as late as possible (since we have rule 3, this also maximizes the total lengths of all songs we sing) when there are ties.</p><p>给定一个容量为 $t$ 的背包和体积分别为 $v_i$ 的 $n$ 个物品，使得在选择最多物品的情况下使得最后背包中剩余体积最小</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>The first line contains the number of test cases $T (T \le 100)$. Each test case begins with two positive integers $n, t (1 \le n \le 50, 1 \le t \le 10^9)$, the number of candidate songs (BESIDES Jin Ge Jin Qu) and the time left (in seconds). The next line contains n positive integers, the lengths of each song, in seconds. Each length will be less than $3$ minutes — I know that most songs are longer than $3$ minutes.</p><p>But don’t forget that we could manually “cut” the song after we feel satisfied, before the song ends.</p><p>So here “length” actually means “length of the part that we want to sing”.</p><p>It is guaranteed that the sum of lengths of all songs (including Jin Ge Jin Qu) will be strictly larger than $t$.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>For each test case, print the maximum number of songs (including Jin Ge Jin Qu), and the total lengths of songs that you’ll sing.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">9678</span> + <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXV], a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;t);</span><br><span class="line">        t--;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = t; j &gt;= a[i]; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j - a[i]] &gt;= <span class="number">1</span> || j == a[i]) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">std</span>::max(f[j], f[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">                    ans = <span class="built_in">std</span>::max(ans, f[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (cnt = t; f[cnt] != ans; cnt--) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Case %d: 1 678\n"</span>, cas);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: %d %d\n"</span>, cas, <span class="number">1</span> + ans, cnt + <span class="number">678</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 11584] Partitioning by Palindromes - 划分DP</title>
      <link href="/2017/10/25/UVa_11584/"/>
      <url>/2017/10/25/UVa_11584/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p> <a href="https://vjudge.net/problem/UVA-11584" target="_blank" rel="noopener">UVa 11584 Partitioning by Palindromes</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p> 给定一个字符串，求最多能少能被划分成多少个回文串。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>Input begins with the number $n$ of test cases. Each test case consists of a single line of between $1$ and $1000$ lowercase letters, with no whitespace within.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>For each test case, output a line containing the minimum number of groups required to partition the input into groups of palindromes.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>划分DP</p><p>设 $f(i)$ 表示前 $i$ 个字符中能划分出的最少回文串的个数，则转移为</p><script type="math/tex; mode=display">f(i) = \min \{f(j) + 1\ | j \leq i , \text{$s[j \dots i]$ is Memo string} \}</script><p>含义为从$j$这个位置分割，$s[j, i]$作为一个回文串，前边的部分用前边的最优做法。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">            l++; r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">           f[i] = i;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (check(j, i)) f[i] = <span class="built_in">std</span>::min(f[i], f[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"f[%d] = %d \n"</span>, i, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 划分DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1004] 四子连棋 - BFS + Hash</title>
      <link href="/2017/10/24/Codevs_1004/"/>
      <url>/2017/10/24/Codevs_1004/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在一个$4 \times 4$的棋盘上摆放了$14$颗棋子，其中有$7$颗白色棋子，$7$颗黑色棋子，有两个空白地带，任何一颗黑白棋子都可以向上下左右四个方向移动到相邻的空格，这叫行棋一步，<strong>黑白双方交替走棋，任意一方可以先走</strong>，如果某个时刻使得任意一种颜色的棋子形成四个一线（包括斜线），这样的状态为目标棋局。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>从文件中读入一个$4 \times 4$的初始棋局，黑棋子用$B$表示，白棋子用$W$表示，空格地带用$O$表示。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>用最少的步数移动到目标棋局的步数。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>BFS，队列里存储的是整个棋盘，每个棋盘记录第一个空格的坐标和第二个空格的坐标，以及变换到当前棋盘所用的步数，判重可以把一个棋盘看做一个十六位三进制数，转换成十进制后判重即可。</p><p>听说用迭代加深搜索可以秒杀，但是我不是很会</p><p>代码出现了在<code>GDB</code>里跑得过，直接运行跑不过的尴尬情况，仍有待解决。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="keyword">int</span> color; <span class="comment">//0-&gt;w, 1-&gt;b;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> x1 = <span class="number">-1</span>, <span class="keyword">int</span> y1 = <span class="number">-1</span>, <span class="keyword">int</span> x2 = <span class="number">-1</span>, <span class="keyword">int</span> y2 = <span class="number">-1</span>, <span class="keyword">int</span> step = <span class="number">0</span>) : x1(x1), y1(y1), x2(x2), y2(y2), step(step) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                 a[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        color = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Node &amp;x) &#123;</span><br><span class="line">        x1 = x.x1; y1 = x.y1; x2 = x.x2; y2 = x.y2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                a[i][j] = x.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Check\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[x1, x1] = [%d, %d]\n"</span>, x1, y1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[x2, y2] = [%d, %d]\n"</span>, x2, y2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d][%d] = %d "</span>, i, j, a[i][j]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"color : %d\n"</span>, color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(Node *x, <span class="keyword">int</span> i, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(x-&gt;a[x-&gt;x1 + dx[i]][x-&gt;y1 + dy[i]], x-&gt;a[x-&gt;x1][x-&gt;y1]);</span><br><span class="line">        x-&gt;x1 += dx[i];</span><br><span class="line">        x-&gt;y1 += dy[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(x-&gt;a[x-&gt;x2 + dx[i]][x-&gt;y2 + dy[i]], x-&gt;a[x-&gt;x2][x-&gt;y2]);</span><br><span class="line">        x-&gt;x2 += dx[i];</span><br><span class="line">        x-&gt;y2 += dy[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;step++;</span><br><span class="line">    x-&gt;color ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHash</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, bit = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            ans += x.a[i][j] * <span class="built_in">pow</span>(<span class="number">3</span>, bit--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b &amp;&amp; b == c &amp;&amp; c == d) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (check(x.a[i][<span class="number">0</span>], x.a[i][<span class="number">1</span>], x.a[i][<span class="number">2</span>], x.a[i][<span class="number">3</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (check(x.a[<span class="number">0</span>][i], x.a[<span class="number">1</span>][i], x.a[<span class="number">2</span>][i], x.a[<span class="number">3</span>][i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (check(x.a[<span class="number">0</span>][<span class="number">0</span>], x.a[<span class="number">1</span>][<span class="number">1</span>], x.a[<span class="number">2</span>][<span class="number">2</span>], x.a[<span class="number">3</span>][<span class="number">3</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (check(x.a[<span class="number">0</span>][<span class="number">3</span>], x.a[<span class="number">1</span>][<span class="number">2</span>], x.a[<span class="number">2</span>][<span class="number">1</span>], x.a[<span class="number">3</span>][<span class="number">0</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">vis</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>.count(getHash(x))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(Node &amp;x, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    </span><br><span class="line">    x.step = <span class="number">0</span>;</span><br><span class="line">    x.color = color;</span><br><span class="line"></span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis(tmp)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span>.insert(getHash(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (judge(tmp)) <span class="keyword">return</span> tmp.step;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx1 = tmp.x1 + dx[i]; <span class="comment">//printf("xx1 = %d ", xx1);</span></span><br><span class="line">            <span class="keyword">int</span> yy1 = tmp.y1 + dy[i]; <span class="comment">//printf("yy1 = %d\n", yy1);</span></span><br><span class="line">            <span class="keyword">if</span> (xx1 &gt;= <span class="number">0</span> &amp;&amp; xx1 &lt;= <span class="number">3</span> &amp;&amp; yy1 &gt;= <span class="number">0</span> &amp;&amp; yy1 &lt;= <span class="number">3</span> &amp;&amp; tmp.a[xx1][yy1] == tmp.color) &#123;</span><br><span class="line">                Node tmpp = tmp;</span><br><span class="line">                move(&amp;tmpp, i, <span class="number">1</span>);</span><br><span class="line">                q.push(tmpp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> xx2 = tmp.x2 + dx[i]; <span class="comment">//printf("xx2 = %d ", xx2);</span></span><br><span class="line">            <span class="keyword">int</span> yy2 = tmp.y2 + dy[i]; <span class="comment">//printf("yy2 = %d\n", yy2);</span></span><br><span class="line">            <span class="keyword">if</span> (xx2 &gt;= <span class="number">0</span> &amp;&amp; xx2 &lt;= <span class="number">3</span> &amp;&amp; yy2 &gt;= <span class="number">0</span> &amp;&amp; yy2 &lt;= <span class="number">3</span> &amp;&amp; tmp.a[xx2][yy2] == tmp.color) &#123;</span><br><span class="line">                Node tmpp = tmp;</span><br><span class="line">                move(&amp;tmpp, i, <span class="number">2</span>);</span><br><span class="line">                q.push(tmpp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = getchar();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'B'</span>) a[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'W'</span>) a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i][j] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span> &amp;&amp; start.x1 == <span class="number">-1</span> &amp;&amp; start.y1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                 start.x1 = i;</span><br><span class="line">                 start.y1 = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i][j] == <span class="number">2</span> &amp;&amp; start.x2 == <span class="number">-1</span> &amp;&amp; start.y2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                 start.x2 = i;</span><br><span class="line">                 start.y2 = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start.a[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">std</span>::min(bfs(start, <span class="number">1</span>), bfs(start, <span class="number">0</span>))); <span class="comment">//1-&gt;b, 0-&gt;w</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1099] 字串变换 - BFS</title>
      <link href="/2017/10/23/Codevs_1099/"/>
      <url>/2017/10/23/Codevs_1099/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>已知有两个字串 $A$, $B$ 及一组字串变换的规则（至多6个规则）</p><p>规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$、$A_2$ 可以变换为 $B_2$</p><p>问将起始串按照上述规则变为目标串所需的最少步数。   </p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入格式如下：</p><p>　　　$A$ $B$</p><p>　　　$A_1$ $B_1$</p><p>　　　$A_2$ $B_2$ </p><p>　　　$\dots$ $\dots$</p><p>所有字符串长度的上限为 20。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>若在 $10$ 步（包含 $10$ 步）以内能将 $A$ 变换为 $B$ ，则输出最少的变换步数；否则输出<code>NO ANSWER!</code></p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>普通的<code>BFS</code>，对原串的每一位考虑每一个变换规则能否成立，成立就扔到队列里，记得用<code>std::set</code>判一下重。</p><p>注意字母可能重复，所以不能直接<code>str.find()</code>，而是应该对每一位往后的子串看是不是和某个变换规则吻合。</p><p>记得要写<code>NO ANSWER!</code>，别忘了感叹号和大写</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">String</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line">    String(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">int</span> n) : str(s), step(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a, b;    </span><br><span class="line">&#125; pairs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> before, after;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; before &gt;&gt; after;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; pairs[cnt].a &gt;&gt; pairs[cnt].b) cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;String&gt; q;</span><br><span class="line">    q.push(String(before, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        String tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (st.count(tmp.str)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp.step &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO ANSWER!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp.str == after) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tmp.step &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)tmp.str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp.str.substr(i, pairs[j].a.size()) == pairs[j].a) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> tmpp = tmp.str;</span><br><span class="line">                    tmpp.replace(i, pairs[j].a.size(), pairs[j].b);</span><br><span class="line">                    q.push(String(tmpp, tmp.step + <span class="number">1</span>));</span><br><span class="line">                    st.insert(tmp.str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO ANSWER!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通的读入/输出优化</title>
      <link href="/2017/10/22/IO/"/>
      <url>/2017/10/22/IO/</url>
      
        <content type="html"><![CDATA[<p>普通的读入/输出优化<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="keyword">char</span> c[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">while</span>(x) c[++num] = (x % <span class="number">10</span>) + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) <span class="built_in">putchar</span>(c[num--]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> 输出/输出优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 11400] Lighting System Design - 序列DP</title>
      <link href="/2017/10/19/UVa_11400/"/>
      <url>/2017/10/19/UVa_11400/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p> <a href="https://vjudge.net/problem/UVA-11400" target="_blank" rel="noopener">UVa 11400 Lighting System Design</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p> You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of $n$ different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating. Now, you know the<br>number of lamps and cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) and complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources and replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.</p><p>给出$n$种灯的相关信息：额定电压($V$)，电源价格($K$)，灯的价格($C$)，灯的个数($L$)，其中一个电源可以给任意多的灯供电，所以为了省钱，我们可以把一些额定电压比较高的灯换成额定电压比较低的灯，从而让他们共用一个电源。任务是计算最优方案的花费。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>Each case in the input begins with $n (1 \le n \le 1000)$, denoting the number of categories. Each of the following $n$ lines describes a category. A category is described by $4$ integers - $V (1 \le V \le 132000)$, the voltage rating, $K (1 \le K \le 1000)$, the cost of a voltage source of this rating, $C (1 \le C \le 10)$, the cost of a lamp of this rating and $L (1 \le L \le 100)$, the number of lamps required in this category. The input terminates with a test case where $n = 0$. This case should not be processed.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>For each test case, print the minimum possible cost to design the system.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>序列DP</p><p>设状态 $f(i)$ 为只考虑前 $i$ 盏灯时的最少花费，则转移为</p><script type="math/tex; mode=display">f(i) = \min \{f(j) + (s[i] - s[j]) \times c[i] + k[i]\}</script><p>其中 $s$ 表示灯的数目的前缀和，$c[i]$表示第$i$种灯的价格，$k[i]$表示第$i$种电源的价格。表示前$j$种灯使用最佳的策略，其他的灯全部换成第$i$种灯之后所能实现的最小花费。</p><p>所以把灯按照价格从小到大排序后，按照上式进行转移，最后答案为$f(n - 1)$（从$0$开始编号）</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Light</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v, k, c, l;</span><br><span class="line">Light(<span class="keyword">int</span> v, <span class="keyword">int</span> k, <span class="keyword">int</span> c, <span class="keyword">int</span> l) : v(v), k(k), c(c), l(l) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Light &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v &lt; a.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Light&gt; <span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) &#123;</span><br><span class="line"><span class="built_in">vector</span>.clear();</span><br><span class="line">f.clear(); f.resize(n + <span class="number">10</span>); <span class="built_in">std</span>::fill(f.begin(), f.end(), INT_MAX);</span><br><span class="line">s.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v, k, c, l;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;v, &amp;k, &amp;c, &amp;l);</span><br><span class="line"><span class="built_in">vector</span>.push_back(Light(v, k, c, l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end());</span><br><span class="line"></span><br><span class="line">s.push_back(<span class="built_in">vector</span>[<span class="number">0</span>].l);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">s.push_back(s[i - <span class="number">1</span>] + <span class="built_in">vector</span>[i].l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">f[i] = <span class="built_in">vector</span>[i].c * <span class="built_in">vector</span>[i].l + <span class="built_in">vector</span>[i].k;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>) tmp = s[i] * <span class="built_in">vector</span>[i].c + <span class="built_in">vector</span>[i].k;</span><br><span class="line"><span class="keyword">else</span> tmp = f[j] + (s[i] - s[j]) * <span class="built_in">vector</span>[i].c + <span class="built_in">vector</span>[i].k;</span><br><span class="line">f[i] = <span class="built_in">std</span>::min(f[i], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【写的时候犯的错误】"><a href="#【写的时候犯的错误】" class="headerlink" title="【写的时候犯的错误】"></a>【写的时候犯的错误】</h3><ul><li>没有考虑所有的都换成第$i$种灯的情况，如果从$1$开始编号$j$应该从$0$开始枚举，如果从$0$开始编号，就应该从$-1$开始枚举，并特判$ j = -1$的情况</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 序列DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1166] 矩阵取数游戏 - 区间DP</title>
      <link href="/2017/10/19/Codevs_1166/"/>
      <url>/2017/10/19/Codevs_1166/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p> <a href="http://codevs.cn/problem/1166/" target="_blank" rel="noopener">Codevs 1166 矩阵取数游戏</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p> 帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素$a_{ij}$均为非负整数。游戏规则如下：</p><ul><li>每次取数时须从每行各取走一个元素，共$n$个。$m$次后取完矩阵所有元素；</li><li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li><li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 $=$ 被取走的元素值$\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；</li><li>游戏结束总得分为$m$次取数得分之和。</li></ul><p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第$1$行为两个用空格隔开的整数n和m。</p><p>第$2 \to n+1$ 行为$n \times m$矩阵，其中每行有$m$个用单个空格隔开的非负整数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p> 输出 仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>$60\%$的数据满足：$1 \le n, m \le 30$, 答案不超过$10^{16}$</p><p>$100\%$的数据满足：$1 \le n, m \le 80, 0 \le a_{ij} \le 1000$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p> 区间DP</p><p> 考虑到行与行之间互不影响，所以把每一行单独考虑，问题转化到序列上。</p><p> 设状态 $f(i, j)$ 表示在<strong>闭区间</strong> $[i, j]$ 中进行取数能得到的最大收益，则转移为</p><script type="math/tex; mode=display">f(i, j) = \max ( f[i + 1][j] + a[i] \times 2^{m - i + j}, f[i][j - 1] + a[j] \times 2^{m - i + j})</script><p>$m$很小，所以随便按区间长度从小到大枚举一下区间端点就可以了</p><p>需要高精度</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BASE = <span class="number">10</span>;</span><br><span class="line">    BigInt(<span class="keyword">long</span> <span class="keyword">long</span> x) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v.push_back(x % <span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str) &#123;</span><br><span class="line">        v.reserve(str.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            v.push_back(str[i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt() &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removePreZero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(v.size() &gt; <span class="number">1</span> &amp;&amp; v.back() == <span class="number">0</span>) v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.size() != a.v.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> v.size() &lt; a.v.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] != a.v[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> v[i] &lt; a.v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(a &lt; *<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; a);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span> || a &gt; *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(a &lt; *<span class="keyword">this</span>) &amp;&amp; !(a &gt; *<span class="keyword">this</span>);&#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span>::max(a.v.size(), v.size()); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.v.size()) sum += a.v[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v.size()) sum += v[i];</span><br><span class="line">            ans.v.push_back(sum % BASE);</span><br><span class="line">            sum /= BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum) ans.v.push_back(sum);</span><br><span class="line">        ans.removePreZero();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*    BigInt operator+=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">        return *this = *this + a;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    BigInt <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt ans;</span><br><span class="line">        <span class="keyword">int</span> dif = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span>::max(a.v.size(), v.size()); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; v.size()) dif += v[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.v.size()) dif -= a.v[i];</span><br><span class="line">            <span class="keyword">if</span> (dif &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans.v.push_back(dif);</span><br><span class="line">                dif = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.v.push_back((dif + BASE) % BASE);</span><br><span class="line">                dif = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.removePreZero();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*    BigInt operator-=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">        return *this = *this - a;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt ans;</span><br><span class="line">        ans.v.resize(v.size() + a.v.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.v.size(); j++) &#123;</span><br><span class="line">                ans.v[i + j] += v[i] * a.v[j];</span><br><span class="line">                ans.v[i + j + <span class="number">1</span>] += ans.v[i + j] / BASE;</span><br><span class="line">                ans.v[i + j] %= BASE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">ans.removePreZero();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*    BigInt operator*=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">        return *this = *this * a;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    BigInt <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt ans, ret(<span class="number">0</span>);</span><br><span class="line">        ans.v.resize(v.size(), <span class="number">0</span>);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + v[i];</span><br><span class="line">            <span class="keyword">while</span> (ret &gt;= a) &#123;</span><br><span class="line">                ret = ret - a;</span><br><span class="line">                ans.v[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.removePreZero();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*    BigInt operator/=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">        return *this = *this / a;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> BigInt &amp;x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x.v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        out &lt;&lt; x.v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt; (<span class="built_in">std</span>::istream &amp;in, BigInt &amp;x) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    in &gt;&gt; str;</span><br><span class="line">    x = BigInt(str);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">80</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">BigInt a[MAXN];</span><br><span class="line">BigInt x[MAXN];</span><br><span class="line">BigInt f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInt <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">x[i] = x[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="comment">//BigInt tmp(1 &lt;&lt; m);</span></span><br><span class="line">f[i][i] = a[i] * x[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> len = j - i;</span><br><span class="line"><span class="keyword">int</span> cnt = m - len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BigInt tmp(1 &lt;&lt; cnt);</span></span><br><span class="line"></span><br><span class="line">f[i][j] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][j] + a[i] * x[cnt], f[i][j - <span class="number">1</span>] + a[j] * x[cnt]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = sum + f[<span class="number">1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【出现的问题】"><a href="#【出现的问题】" class="headerlink" title="【出现的问题】"></a>【出现的问题】</h3><p> 刚开始自己随便yy了一个记忆化搜索，调了很久发现好像就是暴力，看了题解之后写了递推……</p><p> 记忆化搜索代码（80分）:<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">80</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][<span class="number">2</span>][MAXN][MAXN];</span><br><span class="line">BigInt a[MAXN];</span><br><span class="line">BigInt f[MAXN][<span class="number">2</span>][MAXN][MAXN];</span><br><span class="line">BigInt x[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInt <span class="title">dp</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">BigInt &amp;ans = f[cnt][d][l][r];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vis[cnt][d][l][r]) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">else</span> vis[cnt][d][l][r] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BigInt tmp(1 &lt;&lt; cnt);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">BigInt tmp = x[cnt];</span><br><span class="line"><span class="keyword">if</span> (r == l) ans = tmp * a[l];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">BigInt x, y;</span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">x = dp(cnt + <span class="number">1</span>, <span class="number">0</span>, l + <span class="number">1</span>, r);</span><br><span class="line">y = dp(cnt + <span class="number">1</span>, <span class="number">1</span>, l + <span class="number">1</span>, r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = dp(cnt + <span class="number">1</span>, <span class="number">0</span>, l, r - <span class="number">1</span>);</span><br><span class="line">y = dp(cnt + <span class="number">1</span>, <span class="number">1</span>, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BigInt tmp = (x &gt; y ? a[l] : a[r]);</span></span><br><span class="line"></span><br><span class="line">BigInt take = (d == <span class="number">0</span> ? a[l] : a[r]);</span><br><span class="line">ans = take * tmp;</span><br><span class="line">ans = ans + <span class="built_in">std</span>::max(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f["</span> &lt;&lt; cnt &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; d &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; l &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; r &lt;&lt; <span class="string">"]"</span> <span class="string">"="</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInt <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">x[i] = x[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum = sum + std::max(dp(m, 0, 0, m - 1), dp(m, 1, 0, m - 1)); //0-&gt;front-&gt;l, 1-&gt;back-&gt;r []</span></span><br><span class="line">sum = sum + <span class="built_in">std</span>::max(dp(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>), dp(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 还有要注意的就是要乘上去的$2$的次幂会爆<code>long long</code>，所以不能简单的用<code>2 &lt;&lt; cnt</code>来构造一个大整数，应该先预处理出这些幂，存在一个数组里</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 437] The Tower of Babylon - DP</title>
      <link href="/2017/10/18/UVa_437/"/>
      <url>/2017/10/18/UVa_437/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/problem/UVA-437" target="_blank" rel="noopener">UVa 437 The Tower of Babylon</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>Perhaps you have heard of the legend of the Tower of Babylon. Nowadays many details of this tale have been forgotten. So now, in line with the educational nature of this contest, we will tell you the whole story:</p><p>The babylonians had n types of blocks, and an unlimited supply of blocks of each type.<br>Each type-$i$ block was a rectangular solid with linear dimensions $(x_i, y_i, z_i)$. A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.</p><p>They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to have<br>equal-sized bases couldn’t be stacked.</p><p>Your job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks.</p><p>给出 $n$ 种长方体的长宽高，每种长方体都可以使用无限次，要求选一些长方体把他们摞成一根尽可能高的柱子，但是每个立方体的底面长宽都必须<strong>严格小于</strong>他下面的那个立方体的长宽。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>The input file will contain one or more test cases. The first line of each test case contains an integer n,representing the number of different blocks in the following data set. The maximum value for $n$ is $30$.</p><p>Each of the next n lines contains three integers representing the values $x_i, y_i$ and $z_i$<br>.<br>Input is terminated by a value of zero $(0)$ for $n$.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>For each test case, print one line containing the case number (they are numbered sequentially starting from $1$) and the height of the tallest possible tower in the format</p><p><code>Case case: maximum height = height</code></p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于$\%100$的数据 $n \le 30$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p><code>DAG</code>上的DP</p><p>因为每向上摞一块，长宽都是<strong>严格减小</strong>的，所以状态图可以表示为一个<code>DAG</code></p><p>设状态$f(a, b)$表示从底边长宽分别为$a, b$的立方体开始向上摞能得到的最大高度，则按照一般的<code>DAG</code>上DP的套路，转移为</p><script type="math/tex; mode=display">f(a, b) = \max \{f(x, y)\} + h</script><p>其中 $h$ 表示这块立方体的高，$x, y$应当满足题目中给出的长宽都是<strong>严格减小</strong>的条件。</p><p>但是现在的问题是$a, b$可能很大，不能直接这样存状态，考虑到如果知道了高，那么长宽就都知道了，所以把状态修改为$f(id, h)$，表示编号为$id$的立方体把$h$作为高，把，从这个立方体向上摞能达到的最大高度，转移是一样的。</p><p>看了别人的代码才发现可以显式的把图建出来，这样判断会方便很多。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">Block() : a(<span class="number">0</span>), b(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line"><span class="keyword">if</span> (a &gt; c) <span class="built_in">std</span>::swap(a, c);</span><br><span class="line"><span class="keyword">if</span> (b &gt; c) <span class="built_in">std</span>::swap(b, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125; blocks[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> h, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (h == <span class="number">0</span>) &#123;</span><br><span class="line">x = blocks[id].b; y = blocks[id].c;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">x = blocks[id].a; y = blocks[id].c;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (h == <span class="number">2</span>) &#123;</span><br><span class="line">x = blocks[id].a; y = blocks[id].b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> h1, <span class="keyword">int</span> id2, <span class="keyword">int</span> h2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x1, y1; <span class="comment">//x1 &lt; y1</span></span><br><span class="line">calc(id1, h1, x1, y1);</span><br><span class="line"><span class="keyword">int</span> x2, y2; <span class="comment">//x2 &lt; y2</span></span><br><span class="line">calc(id2, h2, x2, y2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((x1 &gt; x2 &amp;&amp; y1 &gt; y2) || (x1 &gt; y1 &amp;&amp; x2 &gt; y2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;ans = f[x][y];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vis[x][y]) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">else</span> vis[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>) delta = blocks[x].a;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1</span>) delta = blocks[x].b;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">2</span>) delta = blocks[x].c;</span><br><span class="line"></span><br><span class="line">ans = delta;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (check(x, y, i, j)) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, dp(i, j) + delta);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;blocks[i].a, &amp;blocks[i].b, &amp;blocks[i].c);</span><br><span class="line">blocks[i].sort();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"blocks[%d] : a = %d, b = %d, c = %d\n"</span>, i, blocks[i].a, blocks[i].b, blocks[i].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> max = INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">max = <span class="built_in">std</span>::max(max, dp(i, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: maximum height = %d\n"</span>, cnt, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【写的时候的错误】"><a href="#【写的时候的错误】" class="headerlink" title="【写的时候的错误】"></a>【写的时候的错误】</h3><ul><li>数组开小了， $f$的第二维存三个元素但是只开到了$2$</li><li>三个数字排序写错……</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> DAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1154] 能量项链 - 区间DP</title>
      <link href="/2017/10/17/Codevs_1154/"/>
      <url>/2017/10/17/Codevs_1154/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1154/" target="_blank" rel="noopener">Codevs 1154 能量项链</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $n$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$ ，尾标记为$r$，后一颗能量珠的头标记为 $r$ ，尾标记为 $n$ ，则聚合后释放的能量为 $ m \times r \times n $（Mars单位），新产生的珠子的头标记为$m$，尾标记为$n$。</p><p>需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行是一个正整数$n(4 \le n \le 100)$，表示项链上珠子的个数。第二行是$n$个用空格隔开的正整数，所有的数均不超过$1000$。第$i$个数为第$i$颗珠子的头标记$(1 \le i \le N)$，当$i&lt;n$时，第$i$颗珠子的尾标记应该等于第$i+1$颗珠子的头标记。第$n$颗珠子的尾标记应该等于第$1$颗珠子的头标记。</p><p>至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>只有一行，是一个正整数$E(E \le 2.1 \times 10^9)$，为一个最优聚合顺序所释放的总能量。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>区间DP</p><p>题目中给的是一个环，可以考虑把这条链拆开，即枚举断点把问题转化到区间上，但是枚举断点需要$O(n)$，这样一来再加上枚举区间起点和区间长度以及区间断点（转移中的$k$）就是$O(n^4)$的复杂度，所以我们试着将长度翻倍，这样一来就不需要再 枚举断点了，复杂度就成了$O(n^3)$</p><p>设$f(l, r)$表示合并<strong>闭区间</strong>$[l, r]$所能得到的最大价值，则转移为</p><script type="math/tex; mode=display">f(l, r) = \max \{f(l, k) + f(k + 1, r) + a[l] \times a[k + 1] \times a[r + 1]\}</script><p>记忆化搜索即可</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> * <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;ans = f[l][r];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vis[l][r]) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">else</span> vis[l][r] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l == r) ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r - l == <span class="number">1</span>) ans = a[l] * a[r] * a[r + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, search(l, k) + search(k + <span class="number">1</span>, r) + a[l] * a[k + <span class="number">1</span>] * a[r + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">a[i + n] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[n * <span class="number">2</span>] = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">search(<span class="number">0</span>, <span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3657] 括号序列 - 区间DP</title>
      <link href="/2017/10/11/Codevs_3657/"/>
      <url>/2017/10/11/Codevs_3657/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/3657/" target="_blank" rel="noopener">Codevs 3657 括号序列</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>我们用以下规则定义一个合法的括号序列：</p><p>（1）空序列是合法的</p><p>（2）假如 $S$ 是一个合法的序列，则 $(S)$ 和 $[S]$ 都是合法的</p><p>（3）假如 $A$ 和 $B$ 都是合法的，那么 $AB$ 和 $BA$ 也是合法的</p><p> 现在给定一些由<code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>构成的序列 ，请添加尽量少的括号，得到一个合法的括号序列。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入包括号序列$S$。含最多$100$个字符（四种字符： <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>) ，都放在一行，中间没有其他多余字符。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>使括号序列 $S$ 成为合法序列需要添加最少的括号数量。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>区间DP</p><p>设$f(l, r)$表示使<strong>闭区间</strong>$[l, r]$合法所需添加的最少括号个数，转移不太好用一个式子描述，分两种情况看</p><ul><li><p>如果这个区间的左右端点可以匹配，即<code>(s[l] == &#39;(&#39; &amp;&amp; s[r] == &#39;)&#39;) || (s[l] == &#39;[&#39; &amp;&amp; s[r] == &#39;]&#39;)</code>，那么转移到$f(l + 1, r - 1)$</p></li><li><p>转移到$\min(f(l, k), f(k + 1, r)), k \in [l, r)$</p></li></ul><p>需要注意的是不管第一种转移满足不满足，都要考虑第二种转移，否则<code>[][]</code>会被转移到<code>][</code>，这样就需要添加两个括号了，但实际上显然这种情况是不需要添加括号的</p><p>边界为$f(i, r) = 1$，因为单独一个括号是不合法的，需要添加一个括号使之匹配</p><p>$f(l, r)$初始值都应该为$+\infty$</p><p>代码中的$len$枚举的是<strong>区间长度</strong>，要从$2$开始枚举，如果枚举<strong>偏移量</strong>的话，要从$1$开始枚举</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">f[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= length; len++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; length - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line"><span class="keyword">int</span> r = len + l - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;ans = f[l][r];</span><br><span class="line">ans = INT_MAX;</span><br><span class="line"><span class="keyword">if</span> ((s[l] == <span class="string">'('</span> &amp;&amp; s[r] == <span class="string">')'</span>) || (s[l] == <span class="string">'['</span> &amp;&amp; s[r] == <span class="string">']'</span>)) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::min(ans, f[l + <span class="number">1</span>][r - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; k++) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::min(ans, f[l][k] + f[k + <span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">0</span>][length - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3155] 连续和 - 序列DP / 最大连续子段和</title>
      <link href="/2017/10/10/Codevs_3155/"/>
      <url>/2017/10/10/Codevs_3155/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/3155/" target="_blank" rel="noopener">Codevs 3155 连续和</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定$n$个数 $a_1 , a_2 , \dots , a_n$</p><p>定义 </p><script type="math/tex; mode=display">f_{i,j} = a_i + a_{i + 1} + a_{i + 2} + \dots + a_{j-1} + a_j  (1 \le i \le j \le n)</script><p>求 $f_{i,j}$ 的最大值<br><a id="more"></a></p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行有$1$个数，$n$</p><p>第二行有$n$个数，$a_1 , a_2 , \dots , a_n$</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出只有一行，$f_{i,j}$ 的最大值</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设$f(i)$表示<strong>以$a[i]$为结尾的</strong>最大连续子段和,而不是<strong>到$a[i]$为止的</strong>最大连续子段和</p><p>则转移为</p><script type="math/tex; mode=display">f(i) = \max(f(i - 1) + a[i], a[i])</script><p>即要么自己作为一个子段，要么和前面的子段续起来</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"> f[i] = <span class="built_in">std</span>::max(a[i], f[i - <span class="number">1</span>] + a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"> max = <span class="built_in">std</span>::max(max, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 序列DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1220]数字三角形 - DP</title>
      <link href="/2017/10/10/Codevs_1220/"/>
      <url>/2017/10/10/Codevs_1220/</url>
      
        <content type="html"><![CDATA[<p>NOIp2017前的集训终于开始了，第一周决定跟着Hellc的脚步学习DP，先从简单开始</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1220/" target="_blank" rel="noopener">Codevs 1220 数字三角形</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有一个数字三角形，从顶部出发，在每一结点可以选择向左走或得向右走，一直走到底层，要求找出一条路径，使路径上的值最大。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行是数塔层数$n(1 \le n \le 100)$。</p><p>第二行起，按数塔图形，有一个或多个的整数，表示该层节点的值，共有$n$行。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出最大值。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设$f(i, j)$表示从$(i, j)$出发向下走的路径上的最大值，则转移为</p><script type="math/tex; mode=display">f(i, j) = \max(f(i + 1, j), f(i + 1, j + 1)) + a[i][j]</script><p>边界为$f(n, j) = a[n][j], j \in [1, n]$</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">f[n][j] = a[n][j]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"> f[i][j] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 12412] A Typical Homework(a.k.a Shi Xiong Bang Bang Mang) - 模拟</title>
      <link href="/2017/10/10/UVa_12412/"/>
      <url>/2017/10/10/UVa_12412/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/problem/UVA-12412" target="_blank" rel="noopener">A Typical Homework (a.k.a Shi Xiong Bang Bang Mang)</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><h1 id="略"><a href="#略" class="headerlink" title="略"></a><strong>略</strong></h1><p>Sh… Could you help me with it? Please keep secret!!I know that you won’t say NO to a poor little girl, boy.</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><h1 id="略-1"><a href="#略-1" class="headerlink" title="略"></a><strong>略</strong></h1><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><h1 id="略-2"><a href="#略-2" class="headerlink" title="略"></a><strong>略</strong></h1><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>模拟即可</p><h3 id="【不AC代码】"><a href="#【不AC代码】" class="headerlink" title="【不AC代码】"></a>【<del>不AC</del>代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> SID, CID;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rank, position, numberOfPassed;</span><br><span class="line"><span class="keyword">double</span> sum, average;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score[<span class="number">4</span>]; <span class="comment">// 0-&gt;Chinese, 1-&gt;Math, 2-&gt;English, 3-&gt;Program</span></span><br><span class="line"></span><br><span class="line">Student(<span class="built_in">string</span> SID, <span class="built_in">string</span> CID, <span class="built_in">string</span> name, <span class="keyword">int</span> *score) : SID(SID), CID(CID), name(name), rank(<span class="number">0</span>), sum(<span class="number">0</span>), average(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">this</span>-&gt;score[i] = score[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">this</span>-&gt;sum += <span class="keyword">this</span>-&gt;score[i];</span><br><span class="line"><span class="keyword">this</span>-&gt;average = <span class="keyword">this</span>-&gt;sum / <span class="number">4.0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;position = <span class="number">0</span>;</span><br><span class="line">numberOfPassed = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum &gt; a.sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">if</span> (score[i] &gt;= <span class="number">60</span>) numberOfPassed++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student&gt; v;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Welcome to Student Performance Management System (SPMS)."</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1 - Add"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2 - Remove"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"3 - Query"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"4 - Show ranking"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"5 - Show Statistics"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"0 - Exit"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the SID, CID, name and four scores. Enter 0 to finish."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> SID, CID;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> score[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; SID;</span><br><span class="line"><span class="keyword">if</span> (SID == <span class="string">"0"</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; CID &gt;&gt; name;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; score[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.count(SID)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Duplicated SID."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>  &#123;</span><br><span class="line">Student x(SID, CID, name, score);</span><br><span class="line">x.calc();</span><br><span class="line">v.push_back(x);</span><br><span class="line">s.insert(SID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter SID or name. Enter 0 to finish."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">"0"</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deleted;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;SID == tmp || it-&gt;name == tmp) &#123;</span><br><span class="line">deleted.push_back(it - v.begin());</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = deleted.begin(); it != deleted.end(); it++) &#123;</span><br><span class="line">v.erase(v.begin() + *it);</span><br><span class="line">s.erase((v.begin() + *it)-&gt;SID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">" student(s) removed."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter SID or name. Enter 0 to finish."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">"0"</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; rank;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;SID == tmp || it-&gt;name == tmp) &#123;</span><br><span class="line">it-&gt;position = it - v.begin();</span><br><span class="line"><span class="comment">// rank.push_back(*it);</span></span><br><span class="line">&#125;</span><br><span class="line">rank.push_back(*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stable_sort(rank.begin(), rank.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = rank.begin(); it != rank.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it == rank.begin()) v[it-&gt;position].rank = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;sum == (it - <span class="number">1</span>)-&gt;sum) v[it-&gt;position].rank = v[(it - <span class="number">1</span>)-&gt;position].rank;</span><br><span class="line"><span class="keyword">else</span> v[it-&gt;position].rank = it - rank.begin() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;SID == tmp || it-&gt;name == tmp) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;rank &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;SID &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;CID &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">cout</span> &lt;&lt; it-&gt;score[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;sum &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, it-&gt;average);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcWhole</span><span class="params">(<span class="keyword">int</span> lesson, <span class="keyword">double</span> &amp;average, <span class="keyword">int</span> &amp;passed, <span class="keyword">int</span> &amp;notPassed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">sum += it-&gt;score[lesson];</span><br><span class="line"><span class="keyword">if</span> (it-&gt;score[lesson] &gt;= <span class="number">60</span>) passed++;</span><br><span class="line"><span class="keyword">else</span> notPassed++;</span><br><span class="line">&#125;</span><br><span class="line">average = (<span class="keyword">double</span>)(sum) / v.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLesson</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Chinese"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mathematics"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"English"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">3</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Programming"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">statistics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter class ID, 0 for the whole statistics."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">"0"</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> passed = <span class="number">0</span>, notPassed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> average = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">calcWhole(i, average, passed, notPassed);</span><br><span class="line"></span><br><span class="line">printLesson(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Average Score: %.2lf\n"</span>, average);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of passed students: "</span> &lt;&lt; passed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of failed students: "</span> &lt;&lt; notPassed &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> passedThree = <span class="number">0</span>, passedTwo = <span class="number">0</span>, passedOne = <span class="number">0</span>, failedALL = <span class="number">0</span>, passedAll = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed &gt;= <span class="number">1</span>) passedOne++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed &gt;= <span class="number">2</span>) passedTwo++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed &gt;= <span class="number">3</span>) passedThree++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed == <span class="number">4</span>) passedAll++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed == <span class="number">0</span>) failedALL++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Overall:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed all subjects: "</span> &lt;&lt; passedAll &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed 3 or more subjects: "</span> &lt;&lt; passedOne &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed 2 or more subjects: "</span> &lt;&lt; passedTwo &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed 1 or more subjects: "</span> &lt;&lt; passedThree &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who failed all subjects: "</span> &lt;&lt; failedALL &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, passed = <span class="number">0</span>, notPassed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> average = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numberOfStudents = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;CID == tmp || it-&gt;SID == tmp) &#123;</span><br><span class="line">numberOfStudents++;</span><br><span class="line">sum += it-&gt;score[i];</span><br><span class="line"><span class="keyword">if</span> (it-&gt;score[i] &gt;= <span class="number">60</span>) passed++;</span><br><span class="line"><span class="keyword">else</span> notPassed++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">average = sum / (<span class="keyword">double</span>)(numberOfStudents);</span><br><span class="line"></span><br><span class="line">printLesson(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Average Score: %.2lf\n"</span>, average);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of passed students: "</span> &lt;&lt; passed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of failed students: "</span> &lt;&lt; notPassed &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> passedThree = <span class="number">0</span>, passedTwo = <span class="number">0</span>, passedOne = <span class="number">0</span>, failedALL = <span class="number">0</span>, passedAll = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;CID == tmp || it-&gt;SID == tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed &gt;= <span class="number">1</span>) passedOne++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed &gt;= <span class="number">2</span>) passedTwo++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed &gt;= <span class="number">3</span>) passedThree++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed == <span class="number">4</span>) passedAll++;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;numberOfPassed == <span class="number">0</span>) failedALL++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Overall:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed all subjects: "</span> &lt;&lt; passedAll &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed 3 or more subjects: "</span> &lt;&lt; passedOne &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed 2 or more subjects: "</span> &lt;&lt; passedTwo &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who passed 1 or more subjects: "</span> &lt;&lt; passedThree &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of students who failed all subjects: "</span> &lt;&lt; failedALL &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">printMenu();</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) add();</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">2</span>) remove();</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">3</span>) query();</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">4</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Showing the ranklist hurts students' self-esteem. Don't do that."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">5</span>) statistics();</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[清北Day5 T1] Cut - 数学 + 找规律</title>
      <link href="/2017/10/06/QB_DAY5_T1/"/>
      <url>/2017/10/06/QB_DAY5_T1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p>没有链接</p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>$A$ 和 $B$ 想要切蛋糕来吃,蛋糕可以看作一个 $m \times n$ 的矩形,由分割线划分。蛋糕由 $A$ 来切,他切蛋糕的方式分为两步:</p><ol><li><p>沿着蛋糕的某条分割线将蛋糕分成两半。</p></li><li><p>如果两块蛋糕大小一样,$A$ 吃掉其中的一块蛋糕,把另一块给 $B$ 吃,结束切蛋糕。否则从大块中切去较小块蛋糕那么大的部分并吃掉切下的部分,重复第二步。</p></li></ol><p><strong>另外 $A$ 不希望连续两次都从同一块蛋糕中切。</strong></p><p>求 $A$ 最多能吃多少单位蛋糕,每单位蛋糕就是一个 $1 \times 1$ 的单位矩形。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含两个整数 $m$ 和 $n$,$(1 \leq m, n \leq 10^9 )$</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出一个数 $c$,表示 $A$ 最多能吃到的蛋糕数量。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $40\%$ 的数据,$m, n \leq 1000$。</p><p>对于 $100\%$ 的数据,$m, n \leq 10^9$。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>本题中使用 $[a, b]$ 表示 两块蛋糕的大小分别为$a$和$b$</p><p>从后往前考虑，假如说最后分给$B$的蛋糕大小为$a$，那么最后一次分割完结果一定是$[a, a]$，倒数第二次就是$[a, 2a]$，因为两次不应该分割同一块蛋糕，所以倒数第三次就应该是$[3a, 2a]$，以此类推，倒数第四次就是$[5a, 3a]$，倒数第五次就是$[5a, 8a]$，写到这里应该就能看出一些规律了，分割的倒数第$k$次分割出的两块蛋糕就应该是$[F<em>{k-1}a, F</em>{k}a]$，其中$F_{i}$表示的是<a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin" target="_blank" rel="noopener">斐波那契数列</a>的第$i$项</p><p>那么我们想让自己留下的尽可能多，那就应该让$a$尽可能小，考虑第一次分割，应该分割成$[F<em>na, F</em>{n+1}a]$，由于是第一次分割，所以应该有$F<em>na + F</em>{n+1}a = n$，即$a \times (F<em>n + F</em>{n+1}) = n$，由斐波那契数列的定义可以知道</p><script type="math/tex; mode=display">F_n + F_{n+1} = F_{n+2}</script><p>所以稍微移项可得</p><script type="math/tex; mode=display">a = \frac{n}{F_{n+2}}</script><p>现在问题就转化成了找一个尽可能大的斐波那契数$F_i$，使$F_i | n$</p><p>在以上的分析中我们都只考虑了一条边，另一条边在最后的时候作为系数乘上去就可以了，两条边都算一遍最后取一个$\max$就可以了。</p><p>记得用<code>long long</code></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span>) f[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f[x] = f[x - <span class="number">2</span>] + f[x - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f[x] &gt;= <span class="number">100000000</span>) flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!flag) fib(cnt++);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % f[i] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; n / f[i]) &#123;</span><br><span class="line">ans = n / f[i];</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (m % f[i] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; m / f[i]) &#123;</span><br><span class="line">ans = m / f[i];</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (n - ans) * m);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (m - ans) * n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1144] 守望者的逃离 - 贪心</title>
      <link href="/2017/10/04/Codevs_1144/"/>
      <url>/2017/10/04/Codevs_1144/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1144/" target="_blank" rel="noopener">Codevs 1144 守望者的逃离</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。守望者的跑步速度为$17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在$1s$内移动$60m$，不过每次使用闪烁法术都会消耗魔法值$10$点。守望者的魔法值恢复的速度为$4/s$，只有处在原地休息状态时才能恢复。</p><p>现在已知守望者的魔法初值$M$，他所在的初始位置与岛的出口之间的距离$S$，岛沉没的时间$T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意：守望者跑步、闪烁或休息活动均以秒$(s)$为单位，且每次活动的持续时间为整数秒。距离的单位为米$(m)$。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>仅一行，包括空格隔开的三个非负整数$M$, $S$, $T$。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>包含两行：</p><p>第$1$行为字符串<code>Yes</code>或<code>No</code>（区分大小写），即守望者是否能逃离荒岛。</p><p>第$2$行包含一个整数。第一行为<code>Yes</code>（区分大小写）时表示守望者逃离荒岛的最短时间；</p><p>第一行为<code>No</code>（区分大小写）时表示守望者能走的最远距离。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>先考虑只闪烁不跳跃的情况，处理出<code>f</code>数组，$f(i)$表示在第$i$秒的时候跑的距离，如果魔法值不够就停下来，再考虑只跑步，如果发现某时刻跑步比瞬移优，那就选择跑步，到最后还没跑出去就是<code>No</code>了。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, s, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;m, &amp;s, &amp;t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (m &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + <span class="number">60</span>;</span><br><span class="line">m -= <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">m += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i] &lt; f[i - <span class="number">1</span>] + <span class="number">17</span>) f[i] = f[i - <span class="number">1</span>] + <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> (f[i] &gt;= s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n%d\n"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No\n%d\n"</span>, f[t]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[清北Day2 T1] video - 数学相关 + 组合数</title>
      <link href="/2017/10/02/QBXT_DAY2_T1/"/>
      <url>/2017/10/02/QBXT_DAY2_T1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p>没有链接</p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>pluto 喜欢看片,现在他的硬盘里有 $n$ 部片,但是由于他还要把妹,所以看片时间有限,他只能挑出其中的 $k$ 部片来看,他想知道有多少种不同的选片方案。方案数可能很大,答案对$10^9 + 7$取模后输出。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>一行两个整数,$n$ 和 $m$</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>一行一个整数,即所求答案</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $30\%$ 的数据,$n \leq 10$</p><p>对于 $60\%$ 的数据,$n \leq 3000$</p><p>对于 $100\%$ 的数据,$n \leq 2 \times 10^5$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>裸的组合数，化简一下直接求就好了，递推的话会T掉</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;d, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) d = a, x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">exgcd(b, a % b, d, y, x);</span><br><span class="line">y -= x * (a / b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d, x, y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">exgcd(a, mod, d, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">c</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)m * <span class="number">2</span> &gt; n) m = n - m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = n; i &gt; (n - m); i--) a = (a % MOD * i % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= m; i++) b = (b % MOD * i % MOD) % MOD;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %lld, b = %lld\n"</span>, a, b);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">inv(b, MOD);</span><br><span class="line"><span class="keyword">return</span> (a % MOD * (x + MOD) % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, c(n, m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[清北Day1 T2] polyLine - 数学相关</title>
      <link href="/2017/10/01/QB_DAY1_T2/"/>
      <url>/2017/10/01/QB_DAY1_T2/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p>没有链接</p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有若干个类似于下面的函数:</p><script type="math/tex; mode=display">y_i(x) =\begin{cases}k_i \cdot x + b_i, & \text{if $k_i \cdot x + b_i \ge 0$} \\0, & \text{if $k_i \cdot x + b_i < 0$}\end{cases}</script><p>定义 $n$ 个函数 $y_1(x)\dots y_n(x)$ 的对于任意 $x$ 的总和 </p><script type="math/tex; mode=display">s(x) = \sum_{i = 1}^n y_i(x)</script><p>很容易发现 $s(x)$ 的图象是多段线组成。给你 $n$ 个函数,你的任务是找出 $s(x)$ 图象不等于 $180$ 度的角的个数。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行一个整数 $n$,表示函数的个数。</p><p>接下来 $n$ 行, 每行包含两个空格隔开的整数 $k_i$ , $b_i$ , 表示第 $i$ 个函数的参数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出一行一个整数, 表示形成的多段线的图像中不等于 $180$ 度角的个数。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $30\%$ 的数据,$n \le 3000$。</p><p>对于 $100\%$ 的数据,$1 \le n \le 10^5 , −10^9 \le k_i , b_i \le 10^9$ 。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>说是一道数学题实际上并没有用到很多和数学相关的知识，题目中要求多段线的图像中不等于 $180$ 度角的个数，也就是求斜率变化的点的个数，通过观察解析式可以发现只有当某个函数$y_i(x)$的函数值变为零时斜率才会发生变化，现在问题就转化成了求这些函数里不同的零点个数。</p><p>这题对精度有一点要求，用<code>long double</code>就可以过了，不过写一个分数类可以完全避免精度问题。</p><p>求不同的数的个数直接<code>std::unique</code>就好了</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">freopen(<span class="string">"polyline.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"polyline.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> k, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%Lf%Lf"</span>, &amp;k, &amp;b);</span><br><span class="line"><span class="keyword">if</span> (k != <span class="number">0</span>) a.push_back(-b / k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(a.begin(), a.end());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">std</span>::unique(a.begin(), a.end()) - a.begin());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> tst</span></span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美好的一天</title>
      <link href="/2017/08/28/GoodDay/"/>
      <url>/2017/08/28/GoodDay/</url>
      
        <content type="html"><![CDATA[<p>今天是丁酉鸡年(2017)农历七月七日，是一年一度的七夕拜魁星的日子，为了表示纪念，我决定从今天开始</p><ul><li>尽量使用<code>vim</code>写代码</li><li>数组从<code>0</code>开始编号</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codeforces #428(div2) C] Journey - 数学期望</title>
      <link href="/2017/08/13/Codeforces_428_C/"/>
      <url>/2017/08/13/Codeforces_428_C/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codeforces.com/problemset/problem/839/C" target="_blank" rel="noopener">Codeforces #428(div2) Journey</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>There are $n$ cities and $n - 1$ roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.</p><p>Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren’t before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities.</p><p>Let the length of each road be $1$. The journey starts in the city $1$. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link <a href="https://en.wikipedia.org/wiki/Expected_value" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Expected_value</a>.</p><p>给定一棵树，每一条边的长度都是$1$，每一个点都可以到达与他直接相连的之前未访问过的点，访问每个点的概率相同，当周围没有满足条件的点的时候结束，求走过的总路径长度的数学期望。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>The first line contains a single integer $n (1 \leq n \leq 100000)$ — number of cities.</p><p>Then n - 1 lines follow. The i-th line of these lines contains two integers $u_i$ and $v_i (1 \leq u_i, v_i \leq n, u_i \neq v_i)$ — the cities connected by the $i$-th road.</p><p>It is guaranteed that one can reach any city from any other by the roads.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>Print a number — the expected length of their journey. The journey starts in the city $1$.</p><p>Your answer will be considered correct if its absolute or relative error does not exceed $10 ^{-6}$.</p><p>Namely: let’s assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\frac{|a - b|}{\max(1, b)} \leq 10^{-6}$.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>理解数学期望的含义之后做法就很明显了，最后停止的时候一定是在某个叶节点上，这样预处理出每个节点的深度，和到达每个点的概率，最后检查每一个叶节点，把深度与概率相乘后求和即可。</p><p>出题人给的正解用的是<code>DFS</code>，比较玄妙看的不是很懂</p><p>比赛的时候写了两种算法都很接近正解然而……</p><p>发现用<code>std::vector&lt;&gt;</code>存图好像很方便诶……</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> depth, size;</span><br><span class="line"><span class="keyword">bool</span> vis;</span><br><span class="line"><span class="keyword">double</span> probability;</span><br><span class="line"></span><br><span class="line">Edge *edges;</span><br><span class="line"></span><br><span class="line">Node() : depth(<span class="number">-1</span>), size(<span class="number">0</span>),vis(<span class="literal">false</span>), probability(<span class="number">1</span>), edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr = <span class="literal">NULL</span>, Node *to = <span class="literal">NULL</span>) : fr(fr), to(to) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">q.push(x);</span><br><span class="line">x-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">x-&gt;depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (!e-&gt;to-&gt;vis) &#123;</span><br><span class="line">e-&gt;to-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">e-&gt;to-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v - nodes == <span class="number">1</span>) e-&gt;to-&gt;probability = <span class="number">1.0</span> / v-&gt;size;</span><br><span class="line"><span class="keyword">else</span> e-&gt;to-&gt;probability = v-&gt;probability / (v-&gt;size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">addEdge(nodes + u, nodes + v);</span><br><span class="line">nodes[u].size++;</span><br><span class="line">nodes[v].size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfs(nodes + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodes[i].size == <span class="number">1</span> &amp;&amp; i != <span class="number">1</span>) &#123;</span><br><span class="line">sum += nodes[i].depth * nodes[i].probability;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codefoces #428(div2) B] Game of the Rows - 贪心</title>
      <link href="/2017/08/13/Codeforces_428_B/"/>
      <url>/2017/08/13/Codeforces_428_B/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codeforces.com/problemset/problem/839/Bv" target="_blank" rel="noopener">Codeforces #428(div2) Game of the Rows</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>Daenerys Targaryen has an army consisting of $k$ groups of soldiers, the $i$-th group contains $a_i$ soldiers. She wants to bring her army to the other side of the sea to get the Iron Throne. She has recently bought an airplane to carry her army through the sea. The airplane has n rows, each of them has $8$ seats. We call two seats neighbor, if they are in the same row and in seats ${1, 2}$, ${3, 4}$, ${4, 5}$, ${5, 6}$ or ${7, 8}$.</p><p>A row in the airplane Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats.</p><p>Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied.</p><p>飞机上有$n$排如图所示的座椅，现在有$k$个小队，每个小队有$a_i$个人，要给这些人排座位，要求不同小队的人不能相邻，问能否实现</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/20a11448a0afaf3655320120c369fcbc0e46769d.png" alt="pic1"></p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>The first line contains two integers $n$ and $k (1 \leq n \leq 10000, 1 \leq k \leq 100)$ — the number of rows and the number of groups of soldiers, respectively.</p><p>The second line contains $k$ integers $a_1, a_2, a_3 \dots a_k (1 \leq a_i \leq 10000)$, where $a_i$ denotes the number of soldiers in the $i$-th group.</p><p>It is guaranteed that $\sum_{i = 1}^k a_i \leq 8 \times n$.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>If we can place the soldiers in the airplane print <code>YES</code> (without quotes). Otherwise print <code>NO</code> (without quotes).</p><p>You can choose the case (lower or upper) for each letter arbitrary.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>贪心，考虑这样几种小队人数情况：大于等于$4$人，$3$人，$2$人，$1$人。</p><p>依次处理下面这几种情况。</p><p>对于大于等于$4$人的小队，以$4$人为一组安排，他们优先坐中间的四个位置，如果中间的座位已经满了，那就坐边上的两个位置。</p><p>对于$3$人的小队，处理方法与大于等于$4$人的小队相同。</p><p>对于$2$人的小队，他们优先坐边上的两个位置，如果边上没有位置但中间还有位置，那就把中间的位置拿出两个分配给他们，然后中间还剩下一个可用的座位，如果中间也没有位置了，那就把两人拆开，最后处理。</p><p>对于$1$人的小队，只要看看剩下的座位够不够用就可以了。</p><p>如果以上任意一步不能满足，那么就是<code>NO</code></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> have[<span class="number">5</span>], cnt[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">have[<span class="number">4</span>] = n;</span><br><span class="line">have[<span class="number">2</span>] = n * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (x &gt;= <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (have[<span class="number">4</span>] &gt; <span class="number">0</span>) have[<span class="number">4</span>]--, x -= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have[<span class="number">2</span>] &gt; <span class="number">0</span>) have[<span class="number">2</span>]--, x -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) cnt[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cnt[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (have[<span class="number">2</span>] &gt; <span class="number">0</span>) have[<span class="number">2</span>]--, cnt[<span class="number">2</span>]--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have[<span class="number">4</span>] &gt; <span class="number">0</span>) have[<span class="number">4</span>]--, cnt[<span class="number">2</span>]--, have[<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">else</span> cnt[<span class="number">2</span>]--, cnt[<span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt[<span class="number">1</span>] &gt; have[<span class="number">1</span>] + have[<span class="number">2</span>] + have[<span class="number">4</span>] * <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codefoces #271(div2) D] Flowers - 序列DP</title>
      <link href="/2017/07/30/Codeforces_271_D/"/>
      <url>/2017/07/30/Codeforces_271_D/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codeforces.com/contest/474/problem/D" target="_blank" rel="noopener">Codeforces #271(div2) Flowers</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>We saw the little game Marmot made for Mole’s lunch. Now it’s Marmot’s dinner time and, as we all know, Marmot eats flowers. At every dinner he eats some red and white flowers. Therefore a dinner can be represented as a sequence of several flowers, some of them white and some of them red.</p><p>But, for a dinner to be tasty, there is a rule: Marmot wants to eat white flowers only in groups of size k.</p><p>Now Marmot wonders in how many ways he can eat between a and b flowers. As the number of ways could be very large, print it modulo $1000000007 (10^9 + 7)$.</p><p>题目大意是说有一只土拨鼠爱吃花 <del>边</del> ，花有红白两种，如果吃白花，那么就一次吃$k$朵，如果吃红花，那么就一次吃一朵，$n$次询问在区间$[a, b]$中，共有多少种吃花方法。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>Input contains several test cases.</p><p>The first line contains two integers $t$ and $k (1  \leq  t, k  \leq  105)$, where $t$ represents the number of test cases.</p><p>The next $t$ lines contain two integers $a_i$ and $b_i$ $(1 \leq  a_i ≤\leq b_i \leq 105)$, describing the $i$-th test.</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>Print t lines to the standard output. The i-th line should contain the number of ways in which Marmot can eat between ai and bi flowers at dinner modulo $1000000007 (10^9 + 7)$.</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>考虑序列DP,设 $f(i)$ 表示吃到第 $i$ 朵花时的方案数，则转移为</p><script type="math/tex; mode=display">f(i) = f(i - 1) + f(i - k)</script><p>边界为$f(0) = 1$，初始化的时候$f(i) = f(i - 1)$</p><p>即考虑第$i$朵花是红花还是白花，处理完$f$数组之后求一下前缀和，就可以在$O(1)$的时间内回答每次询问了。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;k);</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i &gt;= k) f[i] = (f[i] % MOD + f[i - k] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">f[i] = (f[i - <span class="number">1</span>] % MOD + f[i] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((f[b] - f[a - <span class="number">1</span>]) + MOD) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 序列DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDSC Day5 T1] 小菜一碟的背包 - 背包DP</title>
      <link href="/2017/07/30/SDSC_Day5_T1/"/>
      <url>/2017/07/30/SDSC_Day5_T1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p>没有链接</p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>Blice和阿强巴是好朋友<br>但萌萌哒Blice不擅长数学,所以阿强巴给了她一些奶牛做练习</p><p>阿强巴有 $n$ 头奶牛,每头奶牛每天可以产一定量的奶,同时也需要一定量的草作为饲料</p><p>对于第 $i$ 头奶牛来说,它每天可以产 $v_i$ 升的奶,同时需要 $w_i$ 千克的草作为饲料</p><p>现在来自蚯蚓国的九条可怜想借一些奶牛,使借走的这些奶牛每天的总产奶量最大,但九条可怜很穷,每天最多只能提供$W_i$<br>千克的草作为饲料,而且她还需要对付跳蚤国的神刀手,所以她把这个问题交给了阿强巴,不不不……阿强巴觉得这个<br>问题太简单了,所以把这个问题交给了你</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行两个整数 $n$, $W$ ,表示奶牛的数量和每天最多能提供的草</p><p>接下来 $n$ 行,每行两个整数,第 $i$ 行表示第 $i$ 头奶牛的产奶量 $v_i$ 和食量 $w_i$</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>仅一行,输出一个整数,表示每天最大的总产奶量</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $20\%$ 的数据, $n \leq 10$</p><p>另有 $30\%$ 的数据, $W \leq 10000$</p><p>另有 $10\%$ 的数据, $w_i = w_1$</p><p>对于 $100\%$ 的数据, $1 \leq n \leq 100 , 1 \leq w_i , W \leq 10 ^ 9 , 1 \leq v_i \leq 10^7$</p><p>对于所有数据,均满足特殊限制:$w_1 \leq w_i \leq w_1 + 3$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>看上去就是裸的01背包，但是注意到 $ W \leq 10^9$，普通做法就算是用一维数组也是开不下的，所以试着对01背包稍微变形</p><p>注意到题目中给出了一条特殊限制$w_1 \leq w_i \leq w_1 + 3$，也就是说每一个牛的食量是不会比第一头牛的食量多三以上的，这样一来如果每一头奶牛的食量都减掉第一头牛的食量，并不会影响我们的决策，但是这时我们的需要提供的草就大大减少了，最多只需要$100<br>\times 3$</p><p>设状态 $f(i, j, k)$ 表示前 $i$ 头牛中选择 $j$ 头，消耗 $k$ 单位的草所获得的最大产奶量，则转移为：</p><script type="math/tex; mode=display">f(i, j, k) = \max(f(i + 1, j + 1, k + w_{i + 1}) + v_{i + 1}, f(i + 1, j, k))</script><p>实现上使用了记忆化搜索</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXN * <span class="number">3</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN][MAXN * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[MAXN], c[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, W, delta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (j * delta + k &gt; W) <span class="keyword">return</span> INT_MIN;</span><br><span class="line"><span class="keyword">if</span> (vis[i][j][k]) <span class="keyword">return</span> f[i][j][k];</span><br><span class="line"><span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vis[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">f[i][j][k] = <span class="built_in">std</span>::max(dp(i + <span class="number">1</span>, j, k), dp(i + <span class="number">1</span>, j + <span class="number">1</span>, k + c[i + <span class="number">1</span>]) + v[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[i][j][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;W);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v[i], &amp;c[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delta = c[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">c[i] -= delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[bzoj 1008] 越狱 - 排列组合</title>
      <link href="/2017/07/29/bzoj_1008/"/>
      <url>/2017/07/29/bzoj_1008/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1008" target="_blank" rel="noopener">bzoj 1008 越狱</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>监狱有连续编号为$[1, n]$的$n$个房间，每个房间关押一个犯人，有$m$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入两个整数$m, n$。</p><p>$1 \leq m \leq 10^8,1 \leq N \leq 10^{12}$</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>可能越狱的状态数，模$100003$取余</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>普通的组合问题，使用<strong>分步乘法计数原理</strong>，每一步考虑这个位置上有多少种选择，显然第一个位置有$m$种选择，剩下的位置因为不能与相邻位置相同，所以都只有$m - 1$种选择，答案就是　</p><script type="math/tex; mode=display">ans = m \times (m - 1) ^ {n - 1}</script><p>注意在取模的时候，减法分步取模的时候要记得加上一个 $mod$ 防止出现负数。</p><p>开始写的时候把$n$和$m$读入反了……</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mulMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>  a, <span class="keyword">long</span> <span class="keyword">long</span>  b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a % MOD) * (b % MOD)) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> fastPowMod(mulMod(a, a), b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> mulMod(fastPowMod(a, b - <span class="number">1</span>), a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (MOD + fastPowMod(m, n) % MOD - m * fastPowMod(m - <span class="number">1</span>, n - <span class="number">1</span>) % MOD) % MOD);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SDSC Day2 T1] 债务 - 暴力</title>
      <link href="/2017/07/28/SDSC_Day2_T1/"/>
      <url>/2017/07/28/SDSC_Day2_T1/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p>没有链接</p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>小 $G$ 有一群好朋友,他们经常互相借钱。假如说有三个好朋友 $A$, $B$, $C$。$A$ 欠 $B$ $20$ 元, $B$ 欠 $C$ $20 $元, 总债务规模为 $20 + 20 = 40$ 元。小 $G$ 是个追求简约的人,他觉得这样的债务太繁杂了。他认为,上面的债务可以完全等价为 $A$ 欠 $C$ $20$ 元,$B$ 既不欠别人,别人也不欠他。这样总债务规模就压缩到了 $20$ 元。<br>现在给定 $n$ 个人和 $m$ 条债务关系。小 $G$ 想找到一种新的债务方案,使得每个人欠钱的总数不变,或被欠钱的总数不变(但是对象可以发生变化),并且使得总债务规模最小。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件第一行两个数字 $n$, $m$,含义如题目所述。</p><p>接下来 $m$ 行,每行三个数字 $a_i$ , $b_i$ , $c_i$ ,表示 $a_i$ 欠 $b_i$ 的钱数为 $c_i$ 。</p><p>注意,数据中关于某两个人 $A$ 和 $B$ 的债务信息可能出现多次,将其累加即可。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件共一行,输出最小的总债务规模。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>根据债务关系建图，把边权转移到点上，起点点权减边权，终点点权加边权，最后<code>bfs</code>一遍把所有正点权相加即为答案。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">bool</span> vis;</span><br><span class="line">Edge *edges;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), vis(<span class="literal">false</span>), val(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to, <span class="keyword">int</span> w) :fr(fr), to(to), w(w) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"debt.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"debt.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">addEdge(nodes + u, nodes + v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123;</span><br><span class="line">e-&gt;fr-&gt;val -= e-&gt;w;</span><br><span class="line">e-&gt;to-&gt;val += e-&gt;w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodes[i].val &gt;= <span class="number">0</span>) sum += nodes[i].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【另】"><a href="#【另】" class="headerlink" title="【另】"></a>【另】</h4><p>感谢　Roller_dhw　同学提供的思路</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[bzoj 1015] 星球大战 - 并查集</title>
      <link href="/2017/07/27/bzoj_1015/"/>
      <url>/2017/07/27/bzoj_1015/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1015" target="_blank" rel="noopener">bzoj 1015　星球大战</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件第一行包含两个整数，$n(1 \leq n \leq  2 \times m)$ 和 $m(1 \leq m  \leq 200,000)$，分别表示星球的数目和以太隧道的数目。星球用 $[0, n-1]$的整数编号。接下来的$m$行，每行包括两个整数$x, y$，其中$(0 \leq x \neq y)$ 表示星球$x$和星球$y$之间有“以太”隧道，可以直接通讯。接下来的一行为一个整数$k$，表示将遭受攻击的星球的数目。接下来的$k$行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这$k$个数互不相同，且都在$0$到$n-1$的范围内。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>第一行是开始时星球的连通块个数。接下来的$k$行，每行一个整数，表示经过该次打击后现存星球的连通块个数。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>离线处理的逆序并查集。<br>对于末状态，先把一开始有的所有边存起来，图建好，记录下收到打击的星球，然后枚举每一条边，如果这条边的两端都没有受到打击，就在并查集里把他们合并。</p><p>之后逆序枚举操作，使用<code>sum</code>记录当前有多少个联通块，恢复一个点的时候首先增加一个联通块（这恢复出的点本身作为一个联通块），然后把这个点记做未被打击，枚举和它相关的边，每有一条边能与其他联通块联通，<code>sum--</code>。</p><p>每次操作后的<code>sum</code>存在<code>num</code>数组里，最后顺序输出，其中<code>num[0]</code>为最末状态，也就是我们算出的第一个<code>sum</code>值。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200000</span> + <span class="number">10</span>;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; graph[MAXM * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> star[MAXM * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> destroy[MAXM * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> num[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fr, to;</span><br><span class="line">&#125; edges[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> fr, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">graph[fr].push_back(to);</span><br><span class="line">graph[to].push_back(fr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ufs</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa[x] != x) fa[x] = find(fa[x]);</span><br><span class="line"><span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r1 = find(x);</span><br><span class="line"><span class="keyword">int</span> r2 = find(y);</span><br><span class="line"></span><br><span class="line">fa[r1] = r2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;edges[i].fr, &amp;edges[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// memset(destroy, false, sizeof(false));</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;star[i]);</span><br><span class="line">destroy[star[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">addEdge(edges[i].fr, edges[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ufs.init(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (destroy[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!destroy[graph[i][j]]) &#123; </span><br><span class="line">ufs.merge(i, graph[i][j]);</span><br><span class="line"><span class="comment">// printf("yes\n");</span></span><br><span class="line"><span class="comment">// printf("u = %d, v = %d\n", i, graph[i][j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!destroy[i] &amp;&amp; ufs.find(i) == i) sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">num[i] = sum;</span><br><span class="line"><span class="keyword">int</span> u = star[i];</span><br><span class="line"></span><br><span class="line">destroy[u] = <span class="literal">false</span>;</span><br><span class="line">sum++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool flag = false;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[u].size(); j++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = graph[u][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!destroy[v]) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(v) != ufs.find(u)) &#123;</span><br><span class="line">ufs.merge(v, u);</span><br><span class="line">sum--;</span><br><span class="line"><span class="comment">// flag = true;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if (!flag) sum++;</span></span><br><span class="line">&#125;</span><br><span class="line">num[<span class="number">0</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 13</span></span><br><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 1 6</span></span><br><span class="line"><span class="comment">// 6 5</span></span><br><span class="line"><span class="comment">// 5 0</span></span><br><span class="line"><span class="comment">// 0 6</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 3</span></span><br><span class="line"><span class="comment">// 3 4</span></span><br><span class="line"><span class="comment">// 4 5</span></span><br><span class="line"><span class="comment">// 7 1</span></span><br><span class="line"><span class="comment">// 7 2</span></span><br><span class="line"><span class="comment">// 7 6</span></span><br><span class="line"><span class="comment">// 3 6</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 4650] 破损的键盘 - 链表</title>
      <link href="/2017/07/25/codevs_4650/"/>
      <url>/2017/07/25/codevs_4650/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/4650/" target="_blank" rel="noopener">Codevs 4650 破损的键盘</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有一天，你需要打一份文件，但是你的键盘坏了，上面的<code>home</code>键和<code>end</code>键会时不时地按下，而你却毫不知情，甚至你都懒得打开显示器，当你打开显示器之后，出现在你的面前的是一段悲剧的文本。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入只有一行，即这份文件，这份文件只包含小写字母和<code>[</code>以及<code>]</code>，用<code>[</code>代替<code>home</code>键，用<code>]</code>代替<code>end</code>键。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>你的任务是在打开显示器之前，计算出这份悲剧的文档。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>直接用一个链表模拟即可。</p><p>链表的入门题目，借此熟悉一下<code>std::list&lt;&gt;</code>的相关操作。</p><ul><li><p>定义</p><p>下面的代码定义了一个名为<code>ls</code>的<code>int</code>类型的双向链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ls;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>插入和删除</p><p>链表的特色就是能快速在链表中的某个位置插入和删除元素，下面的代码使用在迭代器<code>it</code>所在指向的位置插入<code>5</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.insert(it, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>迭代器</p><p>下面的代码定义了一个<code>list</code>的迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;type&gt;::iterator iterator_name;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>成员函数</p><p>下面的代码使用成员函数<code>clear()</code>清空链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.clear();</span><br></pre></td></tr></table></figure></li></ul><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">list</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; ls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">list</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">ls.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator now = ls.begin();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">now = ls.begin();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">now = ls.end();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ls.insert(now, <span class="built_in">list</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">now = ls.begin();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = ls.begin(); it != ls.end(); it++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, *it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1043] 方格取数 - 棋盘DP</title>
      <link href="/2017/07/17/codevs-1043/"/>
      <url>/2017/07/17/codevs-1043/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1043/" target="_blank" rel="noopener">Codevs 1043 方格取数</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>设有$n \times n$的方格图$(n \leq 10)$,我们将其中的某些方格中填入正整数,而其他的方格中则放入数字$0$。</p><p>某人从图的左上角的$A$点出发，可以向下行走，也可以向右走，直到到达右下角的$B$点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字$0$）。</p><p>此人从$A$点到$B$点共走两次，试找出$2$条这样的路径，使得取得的数之和为最大。</p><p><img src="http://codevs.cn/media/image/problem/1043.png" alt="1"></p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入的第一行为一个整数 $n$（表示 $n \times n$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>只需输出一个整数，表示 $2$ 条路径上取得的最大的和。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p><del>虽然说是DP，但个人感觉更像暴力……</del></p><p>设状态 $f[i][j][k][l]$ 表示第一次走到 $(i, j)$ 第二次走到 $(k, l)$ 所得到的最大价值</p><p>状态转移方程为：</p><script type="math/tex; mode=display">f[i][j][k][l] = \max \begin{cases} f[i - 1][j][k - 1][l] \\[2ex] f[i - 1][j][k][l - 1] \\[2ex] f[i][j - 1][k - 1][l] \\[2ex] f[i][j - 1][k][l - 1]\end{cases}+\begin{cases}num[i][j] , &\text{$i = k \land j = l$}\\[2ex]num[i][j] + num[k][l] , &\text{$i \neq k \land j \neq l$}\end{cases}</script><p>最后要保证如果两条路线经过同一个点的话只把格子中的数取一次。</p><p>复杂度$O(n^4)$，对于原题的$n \leq 10$来说足够了</p><p>输入格式有点奇怪需要注意一下。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y, num;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;num) == <span class="number">3</span> &amp;&amp; x != <span class="number">0</span> &amp;&amp; y != <span class="number">0</span> &amp;&amp; num != <span class="number">0</span>) &#123;</span><br><span class="line">a[x][y] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; l++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;tmp = f[i][j][k][l];</span><br><span class="line">tmp = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(f[i - <span class="number">1</span>][j][k - <span class="number">1</span>][l], f[i][j - <span class="number">1</span>][k][l - <span class="number">1</span>]), <span class="built_in">std</span>::max(f[i][j - <span class="number">1</span>][k - <span class="number">1</span>][l], f[i - <span class="number">1</span>][j][k][l - <span class="number">1</span>]));</span><br><span class="line"><span class="keyword">if</span> (i == k &amp;&amp; j == l) tmp += a[i][j];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tmp += a[i][j];</span><br><span class="line">tmp += a[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][n][n][n]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 棋盘DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树学习笔记</title>
      <link href="/2017/07/16/SegmentTree-Learn/"/>
      <url>/2017/07/16/SegmentTree-Learn/</url>
      
        <content type="html"><![CDATA[<p>拖了很久的线段树学习笔记。</p><a id="more"></a><h3 id="【一些练习】"><a href="#【一些练习】" class="headerlink" title="【一些练习】"></a>【一些练习】</h3><p><a href="http://codevs.cn/problem/1080/" target="_blank" rel="noopener">Codevs 1080 线段树练习一</a></p><p><a href="http://codevs.cn/problem/1081/" target="_blank" rel="noopener">Codevs 1081 线段树练习二</a></p><p><a href="http://codevs.cn/problem/1082/" target="_blank" rel="noopener">Codevs 1082 线段树练习三</a></p><h3 id="【这是什么】"><a href="#【这是什么】" class="headerlink" title="【这是什么】"></a>【这是什么】</h3><p>线段树（SegmentTree）是一种用来维护区间信息的数据结构，可以快速的维护一些符合「区间加法」的信息，比如区间和，区间最值，而一些不符合「区间加法」的信息，比如区间众数，是不能用线段树维护的。</p><p>线段树是一棵二叉树，每一个节点看做一个区间，存储该区间的相关信息，左右子树递归的均分父节点的线段，就像这样：<br><img src="http://ojzeatu2s.bkt.clouddn.com/%E7%BA%BF%E6%AE%B5%E6%A0%91" alt="1"></p><h3 id="【常见操作】"><a href="#【常见操作】" class="headerlink" title="【常见操作】"></a>【常见操作】</h3><p>对于一棵线段树，它支持的操作通常有下面几种</p><ul><li>单点修改</li><li>区间修改</li><li>单点查询</li><li>区间查询</li></ul><h3 id="【原理】"><a href="#【原理】" class="headerlink" title="【原理】"></a>【原理】</h3><p>以下以维护区间和为例简述线段树的原理</p><p>对于一个静态的区间和查询问题，我们可以利用前缀和达到预处理$O(n)$，查询$O(1)$，但是我们考虑这个问题的动态版本，如果我们增加修改操作，前缀和就不那么靠谱了，因为我每进行一次修改，我的前缀和都要发生相应的改变，这样的复杂度显然没有变优。</p><p>这个时候，我们强大的线段树就要派上用场了。</p><h4 id="【单点修改】"><a href="#【单点修改】" class="headerlink" title="【单点修改】"></a>【单点修改】</h4><p>之前说过，线段树每一个节点维护一个区间的信息（区间端点，区间中点，区间和等），而一个大区间中的信息又可以由若干小区间（子节点）合并得到（线段树只能维护符合「区间加法」信息），这样一来，我对于某个单点，或者说某个区间，中信息的修改，实际上只会影响到这棵树上的一部分节点，那么剩下的节点我们就不去管它。比如对于上图，如果我们要修改5这个位置上的值，那我就直接修改他，然后5的变化会引起那些节点的变化呢？只会影响他的父节点，影响父节点的父节点等等，那么这个时候我们就可以一路合并上去，因为线段树是一棵二叉树，所以最多有$\log n$层，找到需要修改的节点需要$O(\log n)$，把信息合并上去也需要$O(\log n)$，那么我们说线段树单点修改的复杂度就是$O(\log n)$的</p><p>实现起来就像这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) sum += delta;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line"><span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="【单点查询】"><a href="#【单点查询】" class="headerlink" title="【单点查询】"></a>【单点查询】</h4><p>单点查询非常简单，只需要一路找到你需要的点就可以了，复杂度$O(\log n)$</p><p>实现起来就像这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> sum;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; mid) <span class="keyword">return</span> rc-&gt;query(index);</span><br><span class="line">           <span class="keyword">if</span> (index &lt; mid) <span class="keyword">return</span> lc-&gt;query(index);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有懒标记(下面会讲到)，记得把标记下放</p><p>实现起来就像这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> sum;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       pushDown();</span><br><span class="line">       <span class="keyword">if</span> (index &gt; mid) <span class="keyword">return</span> rc-&gt;query(index);</span><br><span class="line">           <span class="keyword">if</span> (index &lt; mid) <span class="keyword">return</span> lc-&gt;query(index);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="【区间修改】"><a href="#【区间修改】" class="headerlink" title="【区间修改】"></a>【区间修改】</h4><p>在区间修改这个操作当中，我们引入「懒标记」的概念，所谓「懒标记」，就是说我们在找到我们要修改的区间之后，我不真的去修改它，而是在它上面打上一个标记，表示<strong>这个区间中的信息应该被修改</strong>，而我们只在需要用到这个区间中的节点的信息的时候，才真正的修改它，也就是说，如果这个修改过的区间中的点从来没有被查询到，那么我为什么要真的去修改它呢？我只需要保证我查询能得到正确的结果就好了。</p><p>什么叫做<strong>需要用到这个区间中的节点的信息</strong>呢？简单来说就是<strong>本节点的统计信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新</strong>。</p><p>比如说，我要对$[1, 5]$这个区间中的每一个数都$+1$，那么我从根向下找，在代表区间$[1, 5]$的节点上打上一个$+1$的懒标记，表示这个区间中的每一个数都加一，然后这个节点中所维护的<code>sum</code>加五，因为下面总共有$5$个数，假如挨着一个个修改完再合并上来，那整个区间相当于加了$5$，这个时候，我的这一次区间修改就完成了，尽管我并没有真正的修改这个区间中的任何数。那么如果接下来的操作和这个区间完全没有关系的话，这个标记我就完全可以放在那里不管他，因为他不会影响我查询的结果，但是，如果说下面出现了一个操作是$[4, 5]$这个区间中所有的数$-1$怎么办？现在，就是我们所说的<strong>需要用到这个区间中的子区间的信息</strong>的时候。</p><p>现在我们还是一路向下找到$[1, 5]$这个区间，发现上面有个标记，但是我们要操作的区间在有标记的区间的下面，怎么办呢？我们把标记下放，先在他的左右子节点上同样的打上$+1$的标记，同样的修改子节点所维护的值，然后把这个节点的标记清空。标记下放完之后，新的标记就可以打在$[4, 5]$这个区间上了，这里注意的是像区间加某个数的标记可以叠加，但是像直接把这个区间里的数全部修改为某个数的标记，是不能叠加的，或者说是会前后覆盖的。</p><p>实现起来就像这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       lazy += delta;</span><br><span class="line">       sum += (r - l) * delta;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">           lc-&gt;addTag(lazy);</span><br><span class="line">           rc-&gt;addTag(lazy);</span><br><span class="line">           lazy = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       pushDown();</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">           addTag(delta);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">               lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), delta);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">               rc-&gt;modify(<span class="built_in">std</span>::max(mid, l), r, delta);</span><br><span class="line">           &#125;</span><br><span class="line">           update();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>上述代码上有个小技巧，就是解决「我修改的区间不是正好被线段树上的某个节点完全覆盖怎么办」这个问题。只需要把这个区间分割，直到能被某个节点完全覆盖为止就可以了，打完标记之后不要忘记向上合并信息。</p><h4 id="【区间查询】"><a href="#【区间查询】" class="headerlink" title="【区间查询】"></a>【区间查询】</h4><p>对于没有懒标记的区间查询，只需要一路向下查找查询区间，如果没有恰好被某个节点覆盖那就分割，最后合并两个区间的信息就好了。</p><p>实现起来就像这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == l &amp;&amp; <span class="keyword">this</span>-&gt;r == r) <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) ans += lc-&gt;query(l, <span class="built_in">std</span>::min(r, mid));</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) ans += rc-&gt;query(<span class="built_in">std</span>::max(mid, l), r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有懒标记呢？我们说查询也是<strong>需要用到这个区间中的子区间的信息</strong>的情况，所以需要把标记下放，唯一的区别就是多了一步<code>pushDown()</code></p><p>实现起来就像这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pushDown();</span><br><span class="line">        <span class="keyword">if</span> (l &lt; mid) ans += lc-&gt;query(l, <span class="built_in">std</span>::min(mid, r));</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) ans += rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="【实现】"><a href="#【实现】" class="headerlink" title="【实现】"></a>【实现】</h3><p>上面大概的讲了各个操作的实现，接下来说一下这个数据结构整体要怎么建立。</p><p>线段树就是一棵二叉树，所以我们使用经典的链表实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid, sum;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line">    </span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            sum = a[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>update</code>函数就是前面提到的「区间信息的合并」，如果是区间和的话就相加，如果是区间最大值就<code>std::max()</code>，以此类推。</p></li><li><p><code>build</code>函数是在递归建树，分割区间作为左右子树。</p></li><li><p>构造函数传两个参数，根据这两个参数构造一个区间，其中包含左右端点和区间中点。</p></li><li><p>对于需要支持区间修改的线段树，需要多保存一个<code>lazy</code>变量作为标记。</p></li><li><p>使用的时候需要建一个代表整个区间的根节点<code>SegmentTree root(1, n + 1)</code>， 然后<code>root.build()</code>建树。</p></li></ul><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l, r, mid, lazy, sum;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line">    SegmentTree(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        lazy = sum = <span class="number">0</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            sum = a[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        lazy += delta;</span><br><span class="line">        sum += (r - l) * delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">            lc-&gt;addTag(lazy);</span><br><span class="line">            rc-&gt;addTag(lazy);</span><br><span class="line">            lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r, <span class="keyword">long</span> <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">            addTag(delta);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), delta);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;modify(<span class="built_in">std</span>::max(mid, l), r, delta);</span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">rangeQuery</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) ans += lc-&gt;query(l, <span class="built_in">std</span>::min(mid, r));</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) ans += rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) sum += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line">        <span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">        update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> == <span class="number">1</span>) <span class="keyword">return</span> sum;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">                <span class="keyword">if</span> (index &gt; mid) <span class="keyword">return</span> rc-&gt;query(index);</span><br><span class="line">                <span class="keyword">if</span> (index &lt; mid) <span class="keyword">return</span> lc-&gt;query(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="【注意】"><a href="#【注意】" class="headerlink" title="【注意】"></a>【注意】</h3><ul><li><p>线段树在使用原始数据建完树之后，所有的操作都是在线段树上进行的，不会修改原始数据。</p></li><li><p>所有操作都可以写在结构里面作为成员函数</p></li><li><p>这里线段树表示的区间是左闭右开的，这样求区间中点直接 $\frac{l + r}{2}$ 就可以了</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1093] 花生采摘 - 枚举</title>
      <link href="/2017/07/16/codevs-1093/"/>
      <url>/2017/07/16/codevs-1093/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1093/" target="_blank" rel="noopener">Codevs 1093 花生采摘</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在告示牌背后，路边有一块花生田，花生植株整齐地排列成矩形网格。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”</p><p>我们假定多多在每个单位时间内，可以做下列四件事情中的一件：</p><p>1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；</p><p>2) 从一棵植株跳到前后左右与之相邻的另一棵植株；</p><p>3) 采摘一棵植株下的花生；</p><p>4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。</p><p>现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入第一行包括三个整数，$m$，$n$ 和 $k$，用空格隔开；表示花生田的大小为 $m \times n(1 \leq m, n \leq 20)$，多多采花生的限定时间为$K(0 \leq K \leq 1000)$个单位时间。接下来的$m$行，每行包括$n$个非负整数，也用空格隔开；第$i + 1$行的第$j$个整数$P<em>{ij}(0 \leq P</em>{ij} \leq 500)$表示花生田里植株$(i, j)$下花生的数目，$0$表示该植株下没有花生。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出包括一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>题面中说了采摘花生的顺序是一定的，所以排序之后从大到小枚举，如果采了这个花生还能回去那就采，不能就不采，从上一棵花生直接往回走。</p><p>两棵花生之间的距离为曼哈顿距离。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20</span> * <span class="number">20</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, num;</span><br><span class="line"></span><br><span class="line">Node(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> num = <span class="number">0</span>) : x(x), y(y), num(num) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num &gt; a.num;</span><br><span class="line">&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, lim;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;lim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line"><span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">nodes[cnt].x = i;</span><br><span class="line">nodes[cnt].y = j;</span><br><span class="line">nodes[cnt].num = k;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(nodes + <span class="number">1</span>, nodes + cnt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function">Node <span class="title">now</span><span class="params">(<span class="number">0</span>, nodes[<span class="number">1</span>].y, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">lim -= (calc(now, nodes[i]) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (lim &lt; nodes[i].x) <span class="keyword">break</span>;</span><br><span class="line">sum += nodes[i].num;</span><br><span class="line"></span><br><span class="line">now = nodes[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1017]乘积最大 - 划分DP</title>
      <link href="/2017/07/02/Codevs_1017/"/>
      <url>/2017/07/02/Codevs_1017/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p> <a href="http://codevs.cn/problem/1017/" target="_blank" rel="noopener">Codevs 1017 乘积最大</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p> 给出由$n$个数字组成的数字串，要求在其中插入$k$个乘号将其分为$k + 1$个部分，使得这些部分的乘积最大</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>程序的输入共有两行：</p><p>第一行共有$2$个自然数$n，k(6 \le n \le 40，1 \le k \le 6)$</p><p>第二行是一个长度为N的数字串。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出所求得的最大乘积</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>划分DP</p><p>设状态$f(n, k)$表示在前$n$个数字中插入$k$个乘号能获得的最大乘积。</p><p>则转移为</p><script type="math/tex; mode=display">f(i, j) = \max\{ f(i, j - 1) \times num[i + 1][n]\}</script><p>含义为在如果在$i$这个位置插入一个乘号，则答案为在前$i$个位置插入$j - 1$个乘号的最优结果乘上在$i$这个位置插入乘号后划分出的数。</p><p>计算的时候先预处理出每一个区间构成的数字是多少</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> &amp;ans = f[n][k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> num[<span class="number">0</span>][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vis[n][k]) &#123;</span><br><span class="line">vis[n][k] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, search(i, k - <span class="number">1</span>) * num[i + <span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;k, s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> bit = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &gt;= i; k--) &#123;</span><br><span class="line">num[i][j] += (s[k] - <span class="string">'0'</span>) * bit;</span><br><span class="line">bit *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, search(n - <span class="number">1</span>, k));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 划分DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[UVa 1674]Lightning Energy Report - LCA</title>
      <link href="/2017/06/17/lighting/"/>
      <url>/2017/06/17/lighting/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=825&amp;problem=4549&amp;mosmsg=Submission+received+with+ID+19532217" target="_blank" rel="noopener">UVa 1674 Lightning Energy Report</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给你一棵树，实现一个操作 <code>modify(a, b, c)</code> 使得 <code>a</code> 到 <code>b</code> 的路径上所有点的 <code>electrical energy</code> 加上 <code>c</code> ，问最终每个点上的能量值为多少</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><ul><li><p>树剖</p></li><li><p>不会树剖怎么办</p><ul><li>在节点上记录一个<code>mark</code>值， 对于每一个操作 <code>modify(a, b, c)</code> ，<code>a-&gt;mark += c</code>，<code>b-&gt;mark += c</code>，<code>lca(a, b)-&gt;mark -= c</code>，如果<code>lca(a, b)</code>不为根，那么<code>lca(a, b)-&gt;father-&gt;mark -= c</code></li><li>这样一来每个点的的能量值就是以这个点为根的子树的<code>mark</code>值的和，最后<code>DFS</code>一遍就可以求出来了</li><li><a href="http://codevs.cn/problem/4632/" target="_blank" rel="noopener">NOIP2015 运输计划</a>运用了相似的思想</li></ul></li></ul><ul><li><p>然而我的倍增LCA<code>TLE</code>了，效率瓶颈可能是倍增LCA，等学了TarjanLCA之后可能会重写一遍</p></li><li><p>以后必不可能做这种连题解都找不到的冷门题目</p></li></ul><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><p><code>TLE</code>代码，学了正解之后可能会有<code>AC</code>代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line">Edge *edges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lighting, mark;</span><br><span class="line"><span class="keyword">bool</span> vis;</span><br><span class="line"></span><br><span class="line">Node() : depth(<span class="number">0</span>), edges(<span class="literal">NULL</span>), lighting(<span class="number">0</span>), mark(<span class="number">0</span>), vis(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN], *f[MAXN][MAXLOG + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">x-&gt;depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">f[x - nodes][<span class="number">0</span>] = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (e-&gt;to-&gt;depth == <span class="number">0</span>) &#123;</span><br><span class="line">e-&gt;to-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">f[(e-&gt;to) - nodes][<span class="number">0</span>] = v;</span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i][j] = f[f[i][j - <span class="number">1</span>] - nodes][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">lca</span><span class="params">(Node *a, Node *b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a-&gt;depth &lt; b-&gt;depth) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a-&gt;depth &gt; b-&gt;depth) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAXLOG; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[a - nodes][i] &amp;&amp; f[a - nodes][i]-&gt;depth &gt;= b-&gt;depth) &#123;</span><br><span class="line">a = f[a - nodes][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAXLOG; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[a - nodes][i] != f[b - nodes][i]) &#123;</span><br><span class="line">a = f[a - nodes][i];</span><br><span class="line">b = f[b - nodes][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[a - nodes][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = x-&gt;mark;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != (x - nodes) &amp;&amp; f[i][<span class="number">0</span>] == x<span class="comment">/* &amp;&amp; !nodes[i].vis*/</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodes[i].vis) sum += nodes[i].lighting;</span><br><span class="line"><span class="keyword">else</span> sum += dfs(nodes + i, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">// printf("%d-&gt;sum = %d\n", (x - nodes), sum);</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">x-&gt;lighting = sum;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">nodes[i].depth = <span class="number">0</span>;</span><br><span class="line">nodes[i].edges = <span class="literal">NULL</span>;</span><br><span class="line">nodes[i].lighting = <span class="number">0</span>;</span><br><span class="line">nodes[i].vis = <span class="literal">false</span>;</span><br><span class="line">nodes[i].mark = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= MAXLOG; j++) &#123;</span><br><span class="line">f[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data=<span class="number">0</span>,w=<span class="number">1</span>; <span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'-'</span> &amp;&amp; (ch&lt;<span class="string">'0'</span> || ch&gt;<span class="string">'9'</span>)) ch=getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'-'</span>) w=<span class="number">-1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>) data=data*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line"><span class="keyword">return</span> data*w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="comment">// scanf("%d", &amp;t);</span></span><br><span class="line">t = IO::read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cases = <span class="number">1</span>; cases &lt;= t; cases++) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// scanf("%d", &amp;n);</span></span><br><span class="line">n = IO::read();</span><br><span class="line"></span><br><span class="line">init(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="comment">// scanf("%d%d", &amp;x, &amp;y);</span></span><br><span class="line">x = IO::read();</span><br><span class="line">y = IO::read();</span><br><span class="line"></span><br><span class="line">x++, y++;</span><br><span class="line">addEdge(nodes + x, nodes + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="comment">// scanf("%d", &amp;q);</span></span><br><span class="line">q = IO::read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="comment">// scanf("%d%d%d", &amp;a, &amp;b, &amp;c);</span></span><br><span class="line">a = IO::read();</span><br><span class="line">b = IO::read();</span><br><span class="line">c = IO::read();</span><br><span class="line"></span><br><span class="line">a++, b++;</span><br><span class="line"></span><br><span class="line">bfs(nodes + <span class="number">1</span>);</span><br><span class="line">prepare(n);</span><br><span class="line">Node* ancestors = lca(nodes + a, nodes + b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">// printf("%d &amp; %d 's lca -&gt; %d\n", a, b, (ancestors - nodes));</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line">(nodes + a)-&gt;mark += c;</span><br><span class="line">(nodes + b)-&gt;mark += c;</span><br><span class="line">ancestors-&gt;mark -= c;</span><br><span class="line"><span class="keyword">if</span> (ancestors-&gt;depth != <span class="number">1</span>) f[ancestors - nodes][<span class="number">0</span>]-&gt;mark -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef DBG</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">// printf("%d-&gt;mark = %d\n", i, nodes[i].mark);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rubbish = dfs(nodes + <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, cases);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[i].lighting);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 1 3</span></span><br><span class="line"><span class="comment">// 4 0</span></span><br><span class="line"><span class="comment">// 8 4</span></span><br><span class="line"><span class="comment">// 5 4</span></span><br><span class="line"><span class="comment">// 3 0</span></span><br><span class="line"><span class="comment">// 3 7</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 6 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 3 7 1</span></span><br><span class="line"><span class="comment">// 7 1 5</span></span><br><span class="line"><span class="comment">// 0 4 6</span></span><br><span class="line"><span class="comment">// 1 2 9</span></span><br><span class="line"><span class="comment">// 8 3 4</span></span><br><span class="line"><span class="comment">// 6 5 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 0 0 5</span></span><br><span class="line"><span class="comment">// 0 0 2</span></span><br><span class="line"><span class="comment">// 0 0 7</span></span><br><span class="line"><span class="comment">// 0 0 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2 1</span></span><br><span class="line"><span class="comment">// 0 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1 0 2</span></span><br><span class="line"><span class="comment">// 0 2 1</span></span><br><span class="line"><span class="comment">// 0 2 5</span></span><br><span class="line"><span class="comment">// 0 0 2</span></span><br></pre></td></tr></table></figure></p><h3 id="【其他】"><a href="#【其他】" class="headerlink" title="【其他】"></a>【其他】</h3><ul><li><del>不怎么可读</del>的对拍用标程(侵删)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 65536</span></span><br><span class="line"><span class="keyword">int</span> visited[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[MAXV];</span><br><span class="line"><span class="keyword">int</span> parent[MAXV], weight[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = findp(parent[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">joint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = findp(x), y = findp(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[x] &gt; weight[y])</span><br><span class="line">        weight[x] += weight[y], parent[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        weight[y] += weight[x], parent[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA</span></span><br><span class="line"><span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; Q[MAXV];<span class="comment">// query pair, input index - node</span></span><br><span class="line"><span class="keyword">int</span> LCA[<span class="number">131072</span>]; <span class="comment">// [query time] input query answer buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">// rooted-tree.</span></span><br><span class="line">    parent[u] = u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[u].size(); i++) &#123;<span class="comment">//son node.</span></span><br><span class="line">        <span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == p)<span class="keyword">continue</span>;</span><br><span class="line">        tarjan(v, u);</span><br><span class="line">        parent[findp(v)] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[Q[u][i].second]) &#123;</span><br><span class="line">            LCA[Q[u][i].first] = findp(Q[u][i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> weight[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = weight[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[u].size(); i++) &#123;<span class="comment">//son node.</span></span><br><span class="line">        <span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v == p)<span class="keyword">continue</span>;</span><br><span class="line">        sum += dfs(v, u, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight[u] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, y;</span><br><span class="line">    <span class="keyword">int</span> testcase, cases = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X[MAXV], Y[MAXV], K[MAXV];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;testcase);</span><br><span class="line">    <span class="keyword">while</span> (testcase--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            tree[x].push_back(y);</span><br><span class="line">            tree[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> weight[MAXV] = &#123;&#125;, extra[MAXV] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            visited[i] = <span class="number">0</span>, Q[i].clear();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;X[i], &amp;Y[i], &amp;K[i]);</span><br><span class="line">            Q[X[i]].push_back(make_pair(i, Y[i]));</span><br><span class="line">            Q[Y[i]].push_back(make_pair(i, X[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            extra[LCA[i]] += K[i];</span><br><span class="line">            weight[X[i]] += K[i];</span><br><span class="line">            weight[Y[i]] += K[i];</span><br><span class="line">            weight[LCA[i]] -= <span class="number">2</span> * K[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>, weight);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++cases);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, weight[i] + extra[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据生成器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span>;<span class="comment">// the number of nodes</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = <span class="number">10</span>;<span class="comment">// the number of groups</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">50000</span>;<span class="comment">// the number of modifies</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXC = <span class="number">10</span>;<span class="comment">// the largest power of lighting</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXF = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> father[MAXF];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (father[x] != x) father[x] = find(father[x]);</span><br><span class="line"><span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r1 = find(x);</span><br><span class="line"><span class="keyword">int</span> r2 = find(y);</span><br><span class="line">father[r1] = r2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"tmp.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t = (rand() % MAXT) + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> n = (rand() % MAXN) + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line"></span><br><span class="line">ufs.init(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = (rand() % n);</span><br><span class="line"><span class="keyword">int</span> b = (rand() % n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ufs.find(a) == ufs.find(b)) &#123;</span><br><span class="line">a = (rand() % n);</span><br><span class="line">b = (rand() % n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ufs.merge(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q = (rand() % MAXQ);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> a = (rand() % n);</span><br><span class="line"><span class="keyword">int</span> b = (rand() % n);</span><br><span class="line"><span class="keyword">int</span> c = (rand() % MAXC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对拍</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">g++ 1674.cpp -o 1674 -g</span><br><span class="line">g++ std.cpp -o std -g</span><br><span class="line">g++ maker.cpp -o maker -g</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">./maker&gt;tmp.in</span><br><span class="line">./std&lt;tmp.in&gt;std.out</span><br><span class="line"><span class="built_in">echo</span>  std did it</span><br><span class="line">./1674&lt;tmp.in&gt;my.out</span><br><span class="line"><span class="built_in">echo</span> i did it</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> diff my.out std.out ; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> AC</span><br><span class="line"><span class="comment"># echo ------ AC in -----</span></span><br><span class="line"><span class="comment"># cat tmp.in</span></span><br><span class="line"><span class="comment"># echo ------ my ------</span></span><br><span class="line"><span class="comment"># cat my.out</span></span><br><span class="line"><span class="comment"># echo ------ std ------</span></span><br><span class="line"><span class="comment"># cat std.out</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> WA</span><br><span class="line"><span class="built_in">echo</span> ------ WA <span class="keyword">in</span> -----</span><br><span class="line">cat tmp.in</span><br><span class="line"><span class="built_in">echo</span> ------ my ------</span><br><span class="line">cat my.out</span><br><span class="line"><span class="built_in">echo</span> ------ std ------</span><br><span class="line">cat std.out</span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[codevs 1135] 选择客栈 - 预处理</title>
      <link href="/2017/05/30/hotel/"/>
      <url>/2017/05/30/hotel/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1135/" target="_blank" rel="noopener">Codevs 1135 选择客栈</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>丽江河边有 $ n $ 家很有特色的客栈，客栈按照其位置顺序从$ 1 $ 到 $ n $ 编号。每家客栈都按照某一种色调进行装饰（总共 $ k $ 种），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。</p><p>两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $ p $。</p><p>他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $ p $ 元的咖啡店小聚。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>共 $ n + 1 $ 行。</p><p>第一行三个整数 $ n, k, p $ ，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；</p><p>接下来的 $ n $ 行，第 $ i + 1 $ 行两个整数，之间用一个空格隔开，分别表示 $ i $ 号客栈的装饰色调和 $ i $ 号客栈的咖啡店的最低消费。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出只有一行，一个整数，表示可选的住宿方案的总数。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p><del>这题~$O(n^3)$暴力能有60分</del></p><p>这题没有什么特别的算法，似乎乱搞就可以了，需要预处理出下面这些东西。</p><ul><li>对于每一个区间$(i, j)$，是否存在价格小于$p$的客栈。<ul><li>具体来说用<code>sum[i]</code>表示到 $i$ 号客栈为止有多少价格小于$p$的客栈，查询区间的时候就用<code>sum[j] - sum[i]</code>，不为$0$就说明这个区间里存在价格小于$p$的客栈。</li></ul></li><li>第 $i$ 号客栈的与他相同色调的前一个客栈，称为“前驱客栈”<ul><li>具体来说用<code>last[hotel[i].color]</code>表示与 $i$ 号客栈色调相同的最后一个客栈的编号，扫描一遍每次更新即可</li></ul></li><li>第 $i$ 号客栈之前有多少客栈和他色调相同<ul><li>在上一步预处理中可以顺便做到</li></ul></li></ul><p>预处理好之后只需要扫描一遍整个序列，枚举右边的那个客栈，每次检查他和他的前驱客栈所构成的区间里是否存在价格小于$p$的客栈，若存在则方案数加上前驱客栈前与他色调相同的客栈数，若不存在则将左端点变为前驱的前驱，直到为$0$。</p><p>最后答案为方案数。复杂度感觉在$O(n)$左右……</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hotel</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> color, price;</span><br><span class="line"><span class="keyword">int</span> pre, sum;</span><br><span class="line">Hotel() : color(<span class="number">0</span>), price(<span class="number">0</span>), pre(<span class="number">0</span>), sum(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125; hotels[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[MAXN], last[MAXK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k, p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;hotels[i].color, &amp;hotels[i].price);</span><br><span class="line"><span class="keyword">if</span> (hotels[i].price &lt;= p) sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[hotels[i].color] == <span class="number">0</span>) &#123;</span><br><span class="line">last[hotels[i].color] = i;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">hotels[i].pre = last[hotels[i].color];</span><br><span class="line">hotels[i].sum = hotels[hotels[i].pre].sum + <span class="number">1</span>;</span><br><span class="line">last[hotels[i].color] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (hotels[i].pre == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre = hotels[i].pre;</span><br><span class="line"><span class="keyword">while</span> (pre != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum[i] - sum[pre - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans += hotels[pre].sum;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = hotels[pre].pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1066]引水入城 - BFS + 贪心</title>
      <link href="/2017/05/12/flow/"/>
      <url>/2017/05/12/flow/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1066/" target="_blank" rel="noopener">Codevs 1066 引水入城</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个 $n$ 行 $m$ 列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的 蓄水池中。因此，只有与湖泊毗邻的第 $1$ 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提是，存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第 $n$ 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/1066.jpg" alt="img"></p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入的每行中两个数之间用一个空格隔开。 输入的第一行是两个正整数 $n$ 和 $m$ ，表示矩形的规模。 接下来 $n$ 行，每行 $m$ 个正整数，依次代表每座城市的海拔高度。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出有两行。如果能满足要求，输出的第一行是整数 $1$ ，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数 $0$ ，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>本题存在这样一个事实 ： 如果最后一行能被全部覆盖，那么第一行每一个点扩展来的一定是一条连续的线段。</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE20170512210843.png" alt="img2"></p><p>考虑反证，假设如图， $A$ 点到达的为图中的蓝色部分，而由于最后一行能被全部覆盖，所以中间空出的点一定会被另一个点到达，如 $B$，绿色的为路径，但 $A$ 想到达更靠右的部分则必须穿过绿色的路径，既然穿过了该条路径，那就一定可以沿着这条路经到达图中空出的点，与 $A$ 不能到达的假设矛盾，所以原命题成立。</p><p>在确认了这一点之后，只需要对第一行每一个点做一次 <code>BFS</code> 就可以在最后一行标记出若干线段，而问题就转化成了在若干条线段中选择尽量少的线段来覆盖一个区间。</p><p>接下来可贪心可 DP ，先把每个区间按左端点从小到大为第一关键字，右端点从大到小为第二关键字排序，贪心策略就是若这个位置被多个区间覆盖，那么我们优先选右端点更大的那一个。</p><p>设置一个变量表示“当前已经覆盖到的位置”，在剩下的线段中选出左端点小于等于这个位置的右端点最大的线段使用，直到区间被完全覆盖。</p><p>正确性显然。</p><p>另外在 <code>BFS</code> 的时候有一个重要的剪枝，如果一个点比他左边或右边的某个/某两个要低，那么我们就不去搜索它，因为它所到达的位置一定会被它旁边比他高的点到达。</p><p>还有在向队列里 <code>pop</code> <code>new</code> 出来的对象的指针的时候，一定要记得把它 <code>delete</code> 掉，不然会 <code>MLE</code> ，尤其是像这道题这样需要重复 <code>BFS</code> 多次的时候。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> altitude[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN], canBeVisited[MAXN], can[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">Node(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">Range(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>) : l(l), r(r) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Range &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l != a.l) <span class="keyword">return</span> l &lt; a.l;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> r &gt; a.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ranges[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x-&gt;x][x-&gt;y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X = v-&gt;x;</span><br><span class="line"><span class="keyword">int</span> Y = v-&gt;y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> v;</span><br><span class="line">v = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nX = X + dx[i];</span><br><span class="line"><span class="keyword">int</span> nY = Y + dy[i];</span><br><span class="line"><span class="keyword">if</span> ((nX &gt;= <span class="number">1</span>) &amp;&amp; (nX &lt;= n) &amp;&amp; (nY &gt;= <span class="number">1</span>) &amp;&amp; (nY &lt;= m) &amp;&amp; (altitude[nX][nY] &lt; altitude[X][Y]) &amp;&amp; (!vis[nX][nY])) &#123;</span><br><span class="line">q.push(<span class="keyword">new</span> Node(nX, nY));</span><br><span class="line">vis[nX][nY] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">altitude[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;altitude[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>((altitude[<span class="number">1</span>][i] &lt; altitude[<span class="number">1</span>][i - <span class="number">1</span>] &amp;&amp; (i != <span class="number">1</span>)) || (altitude[<span class="number">1</span>][i] &lt; altitude[<span class="number">1</span>][i + <span class="number">1</span>] &amp;&amp; (i != m))) &#123;</span><br><span class="line">can[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can[i]) &#123;</span><br><span class="line">init(n, m);</span><br><span class="line">bfs(<span class="keyword">new</span> Node(<span class="number">1</span>, i)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tot++;</span><br><span class="line">ranges[tot].l = ranges[tot].r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (vis[n][j]) &#123;</span><br><span class="line">canBeVisited[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!ranges[tot].l) &#123;</span><br><span class="line">ranges[tot].l = j;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ranges[tot].r = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ranges[tot].l &amp;&amp; !ranges[tot].r) tot--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!canBeVisited[i]) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n%d\n"</span>, cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(ranges + <span class="number">1</span>, ranges + tot + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>; <span class="keyword">int</span> to = <span class="number">0</span>; <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ranges[i].l &lt;= now + <span class="number">1</span>) &#123;</span><br><span class="line">            to = <span class="built_in">std</span>::max(to, ranges[i].r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now = to;</span><br><span class="line">            to = <span class="built_in">std</span>::max(to, ranges[i].r);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now != m) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1021]玛丽卡 - 最短路</title>
      <link href="/2017/04/04/Codevs_1021/"/>
      <url>/2017/04/04/Codevs_1021/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1021/" target="_blank" rel="noopener">Codevs 1021 玛丽卡</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。</p><p>因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。</p><p>在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。</p><p>麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。</p><p>玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。</p><p>编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间(用分钟表示)。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行有两个用空格隔开的数$N$和$M$，分别表示城市的数量以及城市间道路的数量。$1 \le N \le 1000，1 \le M \le N \times \frac{(N - 1)} {2} $。城市用数字$1$至$N$标识，麦克在城市$1$中，玛丽卡在城市$N$中。</p><p>接下来的$M$行中每行包含三个用空格隔开的数$A$，$B$和$V$。其中$1 \le A$，$B \le N$，$1 \le V \le 1000$。这些数字表示在$A$和城市$B$中间有一条双行道，并且在$V$分钟内是就能通过。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件的第一行中写出用分钟表示的最长时间，在这段时间中，无论哪条路在堵车，玛丽卡应该能够到达麦克处，如果少于这个时间的话，则必定存在一条路，该条路一旦堵车，玛丽卡就不能够赶到麦克处。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>枚举每一条路断开的情况，求最短路即可</p><p>需要注意的是我们可以在这个算法的基础上做一些简单而有效的优化，我们先跑一遍最短路，标记出最短路上的边，考虑删除某一条边的时候，如果它不在原图的最短路中，那就不要管他，因为删掉之后跑最短路出来的还是原图的最短路，所以只需要枚举原图中最短路里的边删除即可</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inNode[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; info;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;info&gt;, <span class="built_in">std</span>::greater&lt;info&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line">dis[x] = <span class="number">0</span>;</span><br><span class="line">pq.push(info(<span class="number">0</span>, x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">info x = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v = x.second;</span><br><span class="line"><span class="keyword">if</span> (dis[v] != x.first) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[v][i] != INT_MAX &amp;&amp; dis[i] &gt; dis[v] + a[v][i]) &#123;</span><br><span class="line">dis[i] = dis[v] + a[v][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">inNode[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq.push(info(dis[i], i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dis[i] = INT_MAX;</span><br><span class="line">vis[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">a[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dis[i] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">a[u][v] = a[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dijkstra(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------shortest is %d---------\n"</span>, dis[n]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DBG</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i = inNode[i]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d&lt;-"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i = inNode[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a[i][inNode[i]];</span><br><span class="line">a[i][inNode[i]] = a[inNode[i]][i] = INT_MAX;</span><br><span class="line"></span><br><span class="line">dijkstra(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, dis[n]);</span><br><span class="line"></span><br><span class="line">a[i][inNode[i]] = a[inNode[i]][i] = tmp;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1026]逃跑的拉尔夫 - BFS</title>
      <link href="/2017/03/03/escape/"/>
      <url>/2017/03/03/escape/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1026/" target="_blank" rel="noopener">Codevs 1026 逃跑的拉尔夫</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>年轻的拉尔夫开玩笑地从一个小镇上偷走了一辆车，但他没想到的是那辆车属于警察局，并且车上装有用于发射车子移动路线的装置。</p><p>那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。</p><p>编写程序，通过使用一张小镇的地图帮助警察局找到那辆车。程序必须能表示出该车最终所有可能的位置。</p><p>小镇的地图是矩形的，上面的符号用来标明哪儿可以行车哪儿不行。<code>.</code>表示小镇上那块地方是可以行车的，而符号<code>X</code>表示此处不能行车。拉尔夫所开小车的初始位置用字符的<code>*</code>表示，且汽车能从初始位置通过。</p><p>汽车能向四个方向移动：向北(向上)，向南(向下)，向西(向左)，向东(向右)。</p><p>拉尔夫所开小车的行动路线是通过一组给定的方向来描述的。在每个给定的方向，拉尔夫驾驶小车通过小镇上一个或更多的可行车地点。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件的第一行包含两个用空格隔开的自然数 $ R $ 和 $ C $，$ 1 \leq R \leq 50 $ ，$ 1 \leq C \leq 50 $，分别表示小镇地图中的行数和列数。</p><p>以下的R行中每行都包含一组 $ C $ 个符号(<code>.</code>或<code>X</code>或<code>*</code>)用来描述地图上相应的部位。</p><p>接下来的第 $ R + 2 $ 行包含一个自然数 $ N $ ，$ 1 \leq N \leq 1000 $，表示一组方向的长度。</p><p>接下来的N行幅行包含下述单词中的任一个：<code>NORTH</code>、<code>SOUTH</code>、<code>WEST</code>和<code>EAST</code>，表示汽车移动的方向，任何两个连续的方向都不相同。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件应包含用 $ R $ 行表示的小镇的地图(像输入文件中一样)，字符<code>*</code>应该仅用来表示汽车最终可能出现的位置。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>裸的BFS，唯一要注意的就是判重，不能像原先一样简单使用一个二维数组来做，因为实际上这个题不是要求完全不能访问之间走过的点（比如样例），而是在一个操作（即一个行走方向）中不能重复访问点，所以可以每进行一次操作就把<code>vis</code>数组初始化，但这题空间充足所以也可以使用一个三维数组<code>vis[x][y][z]</code>表示在第<code>z</code>次行动时<code>(x, y)</code>这个点是不是访问过，这样会更快（没有了$O(n ^ 2)$ 的初始化）。</p><p>我在一开始写的时候没有判重（辣鸡tst写BFS忘判重），结果在<code>TLE</code>之前先<code>MLE</code>了……</p><p>后来naive的加了普通的判重之后发现过不了样例了……</p><p>最后的代码很长，有很多重复的地方可以压缩，但是自己懒得搞了，就这样。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">Node(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXN][MAXN + <span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">q.push(<span class="keyword">new</span> Node(i, j));</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">a[i][j] = <span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> cmd[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line"><span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'N'</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (sum--) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) continue;</span></span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v-&gt;x - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j][v-&gt;y] == <span class="string">'X'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!vis[j][v-&gt;y][i]) &#123;</span><br><span class="line">tmp++;</span><br><span class="line">vis[j][v-&gt;y][i] = <span class="literal">true</span>;</span><br><span class="line">q.push(<span class="keyword">new</span> Node(j, v-&gt;y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = tmp, tmp = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (sum--) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) continue;</span></span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v-&gt;x + <span class="number">1</span>; j &lt; r; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j][v-&gt;y] == <span class="string">'X'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!vis[j][v-&gt;y][i]) &#123;</span><br><span class="line">tmp++;</span><br><span class="line">vis[j][v-&gt;y][i] = <span class="literal">true</span>;</span><br><span class="line">q.push(<span class="keyword">new</span> Node(j, v-&gt;y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = tmp, tmp = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'E'</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (sum--) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) continue;</span></span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v-&gt;y + <span class="number">1</span>; j &lt; c; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[v-&gt;x][j] == <span class="string">'X'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!vis[v-&gt;x][j][i]) &#123;</span><br><span class="line">tmp++;</span><br><span class="line">vis[v-&gt;x][j][i] = <span class="literal">true</span>;</span><br><span class="line">q.push(<span class="keyword">new</span> Node(v-&gt;x, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = tmp, tmp = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'W'</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (sum--) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) continue;</span></span><br><span class="line"><span class="comment">// if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v-&gt;y - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[v-&gt;x][j] == <span class="string">'X'</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!vis[v-&gt;x][j][i]) &#123;</span><br><span class="line">tmp++;</span><br><span class="line">vis[v-&gt;x][j][i] = <span class="literal">true</span>;</span><br><span class="line">q.push(<span class="keyword">new</span> Node(v-&gt;x, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = tmp, tmp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">a[v-&gt;x][v-&gt;y] = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Graphviz方便地绘制图形</title>
      <link href="/2017/02/25/Graphviz/"/>
      <url>/2017/02/25/Graphviz/</url>
      
        <content type="html"><![CDATA[<p>Graphviz是一个在linux下的一个能快速绘制流程图的工具，在写图论题的题解的时候，每一次都要费一番心思来画图，但是还有可能不那么美观，有了这个工具，就可以方便的完成这样的任务了。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Graphviz （Graph Visualization Software的缩写）是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。它提供了一种简单的描述图形的方法，并且可以为人类和计算机程序所理解。DOT语言文件通常是具有.gv或是.dot的文件扩展名。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在终端下使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install graphviz</span><br></pre></td></tr></table></figure></p><p>命令来安装graphviz </p><h3 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot -T&lt;type&gt; &lt;infile.dot&gt; -o &lt;outfile&gt;</span><br></pre></td></tr></table></figure><p>输入文件是<code>&lt;infile.dot&gt;</code>，生成的格式由<code>&lt;type&gt;</code>指定，生成的文件是<code>&lt;outfile&gt;</code>。</p><h3 id="DOT语言的简单用法"><a href="#DOT语言的简单用法" class="headerlink" title="DOT语言的简单用法"></a>DOT语言的简单用法</h3><h4 id="绘制无向图"><a href="#绘制无向图" class="headerlink" title="绘制无向图"></a>绘制无向图</h4><p>下面的代码被用作生成一张简单的无向图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph test &#123;</span><br><span class="line">1 -- 2 -- 3;</span><br><span class="line">    1 -- 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用关键字<code>graph</code>说明绘制的是一张无向图，用花括号扩起来需要描述的节点，相连的节点用<code>--</code>连接。</p><p>上面的那几行代码所绘制出的图形是这个样子的：</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/test.png" alt="pic1"></p><h4 id="绘制有向图"><a href="#绘制有向图" class="headerlink" title="绘制有向图"></a>绘制有向图</h4><p>下面的代码被用作生成一张简单的有向图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digraph test &#123;</span><br><span class="line">1 -&gt; 2 -&gt; 3;</span><br><span class="line">    1 -&gt; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发生的变化仅仅是<code>graph</code>变成了<code>digraph</code>，<code>--</code>变成了<code>-&gt;</code></p><p>上面的那几行代码所绘制出的图形是这个样子的：</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/test2.png" alt="pic2"></p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>如果graphviz只能做到这些那未免也太low了，我们还可以给点和边增加一些属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">1 [shape = box];</span><br><span class="line">    2 [style = filled, color = &quot;1, 1, 1&quot;];</span><br><span class="line">    3;</span><br><span class="line">    1 -&gt; 2 [label = &quot;10&quot;];</span><br><span class="line">    2 -&gt; 3 [label = &quot;5&quot;];</span><br><span class="line">    1 -&gt; 3 [style = dotted, label = &quot;20&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码所绘制出的图形是这样的：</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/test31.png" alt="pic3"></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>DOT支持C与C++风格的单行与多行注释，同时也支持Shell脚本风格的以#开头的注释</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/zh-cn/DOT%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">DOT语言 - 维基百科</a></p><p><a href="https://zh.wikipedia.org/zh-cn/graphviz" target="_blank" rel="noopener">Graphviz - 维基百科</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 4543]普通平衡树 - Splay</title>
      <link href="/2017/02/05/normalSplay/"/>
      <url>/2017/02/05/normalSplay/</url>
      
        <content type="html"><![CDATA[<p>这是一个（几乎完全）从 Hellc 那里抄来的Splay模板，虽然大概领会了原理但似乎还不能很好手动实现，先挂在这里给自己看。</p><a id="more"></a><p>写完Splay学习笔记之后就删掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Spaly</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node *fa, *ch[<span class="number">2</span>]; <span class="comment">//ch[0]-&gt;lc, ch[1]-&gt;rc</span></span><br><span class="line">        <span class="keyword">int</span> size, cnt;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> data = <span class="number">0</span>, <span class="keyword">int</span> cnt = <span class="number">1</span>) : data(data), size(cnt), cnt(cnt) &#123;</span><br><span class="line">            fa = ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            size = cnt;</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">0</span>]) size += ch[<span class="number">0</span>]-&gt;size;</span><br><span class="line">            <span class="keyword">if</span> (ch[<span class="number">1</span>]) size += ch[<span class="number">1</span>]-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span> == fa-&gt;ch[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Node *v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>) ch[d] = v;</span><br><span class="line">            <span class="keyword">if</span> (v) v-&gt;fa = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ch[d] ? ch[d]-&gt;size : <span class="number">0</span>;  <span class="comment">// 0-&gt;lc, 1-&gt;rc;</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; *root, nodes[MAXN];</span><br><span class="line"></span><br><span class="line">    Spaly() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(INT_MIN, <span class="number">0</span>);</span><br><span class="line">        root-&gt;addChild(<span class="keyword">new</span> Node(INT_MAX, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">        Node *old = v-&gt;fa;</span><br><span class="line">        <span class="keyword">int</span> d = v-&gt;relation();</span><br><span class="line">        <span class="keyword">if</span> (old-&gt;fa) old-&gt;fa-&gt;addChild(v, old-&gt;relation());</span><br><span class="line">        <span class="keyword">else</span> v-&gt;fa = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        old-&gt;addChild(v-&gt;ch[d ^ <span class="number">1</span>], d);</span><br><span class="line">        v-&gt;addChild(old, d ^ <span class="number">1</span>);</span><br><span class="line">        old-&gt;update();</span><br><span class="line">        v-&gt;update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(Node *v, Node *target = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (v-&gt;fa != target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;fa-&gt;fa != target) &#123;</span><br><span class="line">                rotate(v-&gt;relation() == v-&gt;fa-&gt;relation() ? v-&gt;fa : v);</span><br><span class="line">            &#125;</span><br><span class="line">            rotate(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">NULL</span>) root = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node *<span class="title">getMinOrMax</span><span class="params">(Node *v, <span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">// d == 0 ? min : max</span></span><br><span class="line">        <span class="keyword">while</span> (v-&gt;ch[d]) v = v-&gt;ch[d];</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">pre</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">        splay(v);</span><br><span class="line">        <span class="keyword">return</span> getMinOrMax(v-&gt;ch[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">succ</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">        splay(v);</span><br><span class="line">        <span class="keyword">return</span> getMinOrMax(v-&gt;ch[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node *v = root; v; v = v-&gt;ch[x &gt; v-&gt;data]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;data == x) &#123;</span><br><span class="line">                splay(v);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = root, *father = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;data == x) &#123;</span><br><span class="line">                v-&gt;cnt++, v-&gt;size++;</span><br><span class="line">                splay(v);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                father = v;</span><br><span class="line">                v = v-&gt;ch[x &gt; v-&gt;data];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *newNode = <span class="keyword">new</span> Node(x);</span><br><span class="line">        father-&gt;addChild(newNode, x &gt; father-&gt;data);</span><br><span class="line">        splay(newNode);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">        Node *preTmp = pre(v);</span><br><span class="line">        Node *succTmp = succ(v);</span><br><span class="line">        splay(preTmp);</span><br><span class="line">        splay(succTmp, preTmp);</span><br><span class="line">        succTmp-&gt;ch[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        succTmp-&gt;update();</span><br><span class="line">        preTmp-&gt;update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = search(x);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           v-&gt;cnt--; </span><br><span class="line">           v-&gt;size--; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            erase(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = insert(x);</span><br><span class="line">        <span class="keyword">int</span> ans = pre(v)-&gt;data;</span><br><span class="line">        erase (x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">succ</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = insert(x);</span><br><span class="line">        <span class="keyword">int</span> ans = succ(v)-&gt;data;</span><br><span class="line">        erase(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node *v = insert(x);</span><br><span class="line">        <span class="keyword">int</span> ans = v-&gt;getSize(<span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        erase(x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Node *v = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v-&gt;getSize(<span class="number">0</span>) + <span class="number">1</span> &lt;= k &amp;&amp; k &lt;= v-&gt;getSize(<span class="number">0</span>) + v-&gt;cnt) &#123;</span><br><span class="line">                splay(v);</span><br><span class="line">                <span class="keyword">return</span> v-&gt;data;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= v-&gt;getSize(<span class="number">0</span>)) &#123;</span><br><span class="line">                v = v-&gt;ch[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= v-&gt;getSize(<span class="number">0</span>) + v-&gt;cnt;</span><br><span class="line">                v = v-&gt;ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Spaly *splay = <span class="keyword">new</span> Spaly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : &#123;</span><br><span class="line">                splay-&gt;insert(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : &#123;</span><br><span class="line">                splay-&gt;erase(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, splay-&gt;rank(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, splay-&gt;select(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, splay-&gt;pre(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, splay-&gt;succ(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> Splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1702] 素数判定2 - MillerRabin素数快速判定</title>
      <link href="/2017/01/21/prime2/"/>
      <url>/2017/01/21/prime2/</url>
      
        <content type="html"><![CDATA[<p>关于素数(筛选/判定)的算法有很多，这篇文章主要讨论MillerRabin素数测试算法。</p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂被用作在 $O( \log n)$ 的时间内快速计算出 $a^b$ 的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> mulMod(fastPowMod(a, b - <span class="number">1</span>), a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(mulMod(a, a), b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中的<code>mulMod</code>是相乘取摸的另一个函数。</p><h3 id="费马小定理-Fermat-Theory"><a href="#费马小定理-Fermat-Theory" class="headerlink" title="费马小定理(Fermat Theory)"></a>费马小定理(Fermat Theory)</h3><p>假如$p$是质数，且$\gcd(a,p)=1$，那么$a^{p-1} \equiv 1 \pmod p$</p><p>事实上，费马小定理给出的是关于素数判定的<strong>必要非充分</strong>条件。</p><h2 id="MillerRabin"><a href="#MillerRabin" class="headerlink" title="MillerRabin"></a>MillerRabin</h2><p>MillerRabin素数判定法基于这样一个事实：取$S$次不超过$n - 1$的基$b$，若每次都存在$b^{n - 1} \equiv 1 \pmod n$，则$n$<strong>几乎一定</strong>是素数。</p><p>这里说的<strong>几乎一定</strong>说明这是一个概率算法，但是在OI中我们是可以放心使用的，因为我们选取的基越多，这个算法出错的概率就越低，而且实际上如果你每次都用前$7$个素数$(2, 3, 5, 7, 11, 13, 17)$进行测试，所有不超过$341550071728320$的数都是正确的。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://codevs.cn/problem/1702/" target="_blank" rel="noopener">Codevs 1702 素数判定2</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个数，他是素数么？设他为p满足$(p \leq 2^{63} - 1)$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的MillerRabin就可以过了，要注意的一点是这里的$p$在<code>long long</code>范围内，所以中间结果可能会爆<code>long long</code>，所以请使用快速乘法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prime[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inline long long mulMod(long long a, long long b) &#123;</span></span><br><span class="line"><span class="comment">//     return (long long)((a % mod) * (b % mod)) % mod;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mulMod</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123; </span><br><span class="line">            b--;</span><br><span class="line">            ans = (ans + a) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">        a = (a + a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> mulMod(fastPowMod(a, b - <span class="number">1</span>), a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(mulMod(a, a), b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">millerRabin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((mod &lt; <span class="number">2</span>) || (mod &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = fastPowMod(prime[i], mod - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;mod);</span><br><span class="line">    <span class="built_in">printf</span>(millerRabin() ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1088] 神经网络 - 拓扑排序</title>
      <link href="/2017/01/19/neural/"/>
      <url>/2017/01/19/neural/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1088/" target="_blank" rel="noopener">Codevs 1088　神经网络</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：</p><p><img src="http://codevs.cn/media/image/problem/1088.png" alt="network"></p><p>图中，$X_1 - X_3$是信息输入渠道，$Y_1 - Y_2$是信息输出渠道，$C_1$表示神经元目前的状态，$U_i$是阈值，可视为神经元的一个内在参数。</p><a id="more"></a><p>神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层，称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。图是一个简单的三层神经网络的例子。</p><p>兰兰规定，$C_i$服从公式：</p><script type="math/tex; mode=display">C_i = \sum_{(i, j) \in E}W_{ji}C_j - U_i</script><p>（其中n是网络中所有神经元的数目）</p><p>公式中的$W_{ji}$（可能为负值）表示连接$j$号神经元和$i$号神经元的边的权值。当$C_i$大于$0$时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为$C_i$。</p><p>如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。</p><p>现在，给定一个神经网络，及当前输入层神经元的状态$(C_i)$，要求你的程序运算出最后网络输出层的状态。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件第一行是两个整数$n(1 \leq n \leq 100)$和$p$。接下来$n$行，每行两个整数，第$i+1$行是神经元$i$最初状态和其阈值$(U<em>i)$，非输入层的神经元开始时状态必然为0。再下面$p$行，每行由两个整数$i$，$j$及一个整数$W</em>{ij}$，表示连接神经元$i$、$j$的边权值为$W_{ij}$。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件包含若干行，每行有两个整数，分别对应一个神经元的编号，及其最后的状态，两个整数间以空格分隔。仅输出最后状态非零的输出层神经元状态，并且按照编号由小到大顺序输出。<br>若输出层的神经元最后状态均为0，则输出<code>NULL</code>。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题乍一看给人一种很高端的感觉，实际上看明白题面之后其实就是一个类似于拓扑排序的题目，先找到所有没有入边的点，也就是输入层的点，依次向它连向的点输送信息，并每次吧它连向的点的入度减一，有入度为零的点就扔到队列里，出队的时候看看$C_i$是不是大于零，是就发送信息，不是就<code>continue</code>掉，队列空了之后找到输出层的点然后输出大于零的那部分就可以了。反正数据只有100的规模，怎么乱搞都是可以的嘛。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> now, threshold, inEdge;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">Edge *edges;</span><br><span class="line"></span><br><span class="line">Node() : now(<span class="number">0</span>), threshold(<span class="number">0</span>), inEdge(<span class="number">0</span>), flag(<span class="literal">false</span>), edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *fr, Node *to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">fr-&gt;edges = <span class="keyword">new</span> Edge(fr, to, w);</span><br><span class="line">to-&gt;inEdge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].now, &amp;nodes[i].threshold);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">addEdge(nodes + u, nodes + v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodes[i].inEdge == <span class="number">0</span>) &#123;</span><br><span class="line">q.push(nodes + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">e-&gt;to-&gt;inEdge--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!e-&gt;to-&gt;flag) &#123;</span><br><span class="line">e-&gt;to-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">e-&gt;to-&gt;now -= e-&gt;to-&gt;threshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e-&gt;to-&gt;now += (v-&gt;now * e-&gt;w);</span><br><span class="line"><span class="comment">// e-&gt;to-&gt;now -= v-&gt;threshold;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!e-&gt;to-&gt;inEdge &amp;&amp; e-&gt;to-&gt;now &gt; <span class="number">0</span>) &#123;</span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nodes[i].edges &amp;&amp; nodes[i].now &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, nodes[i].now);</span><br><span class="line">flag2 = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag2) <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> NOIp </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Markdown中插入本地图片</title>
      <link href="/2017/01/19/picture/"/>
      <url>/2017/01/19/picture/</url>
      
        <content type="html"><![CDATA[<p>在Markdown中插入本地图片的语法很简单，但是当我们把这篇文章作为一篇博客上传到网上的时候，他是找不到本地图片的，所以我们需要一些<del>特殊的</del>方法来解决这个问题</p><a id="more"></a><p>其实就是把这个图片先传到某个图床上然后复制它的外部链接，把这张图当做网络上的图片插入到Markdown中</p><p>这里我使用的是七牛云来作为一个图床，新建存储空间之后就可以在内容管理里上传图片了，在后面的 <em>操作</em> 中提供了 <em>复制外链</em>。</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/niu.png" alt="Pictures"></p><p>然后就可以使用正常的Markdown语法<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">name</span>](<span class="link">url</span>)</span><br><span class="line"></span><br><span class="line">eg：![<span class="string">Pictures</span>](<span class="link">http://ojzeatu2s.bkt.clouddn.com/niu.png</span>)</span><br></pre></td></tr></table></figure></p><p>来插入图片了。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux下使用hexo + coding搭建自己的博客</title>
      <link href="/2017/01/18/blog/"/>
      <url>/2017/01/18/blog/</url>
      
        <content type="html"><![CDATA[<p>不知不觉两个月没写博客了，其中有大部分的原因是自己太辣鸡根本搞不定博客而且学校文化课时间比较紧没有空去做，现在终于到了寒假，就一口气搞定了在自己的电脑上配置博客环境的问题</p><a id="more"></a><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我目前用的linux发行版是Deepin 15.3<br><img src="http://ojzeatu2s.bkt.clouddn.com/screenfetch.png" alt="screenfetch"><br>之前在集训的时候用过一阵Elementary OS，但是并不会用……于是后来就用了新人友好向Deepin</p><h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><h3 id="需要的东西"><a href="#需要的东西" class="headerlink" title="需要的东西"></a>需要的东西</h3><p>在安装<code>hexo</code>之前，需要先保证电脑里安装了<code>Node.js</code>和<code>Git</code></p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>安装<code>Node.js</code>的时候我们选择的工具是<code>nvm</code>，它是一个Node版本管理工具，可以方便的安装最新的Node</p><p>在终端中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash</span><br></pre></td></tr></table></figure><p>命令可以安装<code>nvm</code></p><p>在安装完成后可以看到这样一句话</p><blockquote><p>Close and reopen your terminal to start using nvm</p></blockquote><p>然后重启终端，使用<code>nvm install stable</code>命令来安装最新的稳定版</p><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>在终端中使用<code>sudo apt-get install git-core</code>命令即可安装Git</p><h4 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h4><p>在安装好上述程序之后就可以使用<code>npm install -g hexo-cli</code>命令来安装hexo</p><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>在处理好上面的那些东西之后就可以开始建站了，在<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">官网</a>里有详细的说明，我把博客的数据存放在了U盘里面，大概是这个样子</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/data.png" alt="Picture2"></p><p>其中我们用于存放文章的文件夹为<code>source/_posts</code>，简单来说就是在这个文件夹用<code>markdown</code>语法写好一篇文章之后就可以使用<code>hexo g -d</code>命令生成并上传新的内容了。</p><p>在做完了上面的那一点微小的工作之后，如果直接使用<code>hexo g -d</code>命令的话，他其实是不能正常使用的，比如说可能会这样</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/error1.png" alt="Picture3"></p><p>这个时候直接在自己的那个目录下使用<code>npm install</code>命令</p><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>在这个时候生成的网页并没有地方保存，所以我们在coding上新建一个Blog的项目，然后就可以把数据都扔在里面了</p><h4 id="SSH公钥"><a href="#SSH公钥" class="headerlink" title="SSH公钥"></a>SSH公钥</h4><p>虽然并不知道这是什么但是没了他似乎不行，按照<a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">这个网页</a>的指示来做就可以生成一个公钥，在<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>这个命令之后按四下回车，会得到一个正方形的图案，那就说明成功了，接下来使用<code>ssh-add ~/.ssh/id_rsa</code>命令就可以显示出来，把他复制到Coding的那个添加公钥页面就可以了</p><h4 id="copy-and-paste"><a href="#copy-and-paste" class="headerlink" title="copy and paste"></a>copy and paste</h4><p>在配置好了SSH公钥之后，直接使用<code>hexo g -d</code>会出现像这样的提示</p><p><img src="http://ojzeatu2s.bkt.clouddn.com/error2.png" alt="Picture4"></p><p>然后按照他提示的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></p><p>再试一次<code>hexo g -d</code>发现好像成功啦！</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIp2016游记</title>
      <link href="/2017/01/18/noip2016/"/>
      <url>/2017/01/18/noip2016/</url>
      
        <content type="html"><![CDATA[<p>这是一篇普通的游记，本来在NOIp之后没多久就写好了但是因为自己太辣鸡搞不定博客就拖到了现在……</p><a id="more"></a><h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>今天算是Noip前的最后一天，上午十点坐上TangSir租的大巴，经过三个多小时（？？）的颠（tui）簸（fei），顺利到了夏令营的时候曾经来过的日照一中。非常愉快的抽了考场考号，吃了午饭就回了宿舍，对了一下考场发现他们居然有人抽到连坐Orz。下午在宿舍里写模板，很愉快地敲了一遍<code>Dijkstra</code>和<code>SPFA</code>，不过没有网没法评测，但据Hellc说应该靠谱。</p><p>晚上是超级丰盛的晚饭但食欲不好并没怎么吃，晚饭后和SZ，iovo7，Hellc去操场走了一圈一路瞎扯感觉还是很愉快的。</p><p>晚上八点多试机，在门口等的时候超级慌，瞬间感觉自己什么都不会了（其实本来就什么都不会），进去之后发现是Win7系统，稍微有点开心，简单测试了一下<code>gdb</code>和<code>g++</code>应该都可用，重启了一次确认F盘不会还原，试着敲了一遍<code>LCA</code>居然稍微调了一下就过样例了，真是奥妙重重……不过机房并没有出现传闻中可怕的键盘声，可能是因为键盘太虚，也有可能是我太虚……我的键盘左shift键不太好用本来想换键盘但后来一想还是算了，坐在我右边的小哥把每个游戏都试了一边，不知道他来试机是试什么的（一定是太神了！！）。</p><p>晚上回去听Menci有Linux和Vim，iovo7有VS可以用，简直飞起。</p><p>睡觉之前看了一下背包，听神犇们讲了一些从来没听过的算法，感觉自己这辈子也没什么机会学，膜了一下就睡了。</p><h4 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h4><p>上午八点半开始考试，带了一大桶冰露进去，简单熟悉了一下电脑环境，调了一下Dev-c++的配置，打了一个背包和<code>Dijkstra</code>的板子，老师就公布了（奇怪的）密码。</p><p>喝水看题……<br>第一题应该是小模拟，链表？顺着找应该就没有什么问题了……写写写……二十分钟过去了……测一下样例结果没过EXM？！滚回去看题发现理解错题意，……改改改……十五分钟过去了……测一下过了样例，检查好文件放在一边。</p><p>喝水看题……<br>树？两点间路径？我好像会<code>LCA</code>！算一算复杂度好像不对，想了想好像没有什么好办法，不管了开始写……写写写……一个小时过去了……终于写出来了，试一试样例……样例二顺利过了但是样例一死循环？？先输出一下每对点<code>LCA</code>看看……<code>(2, 6)</code>这对点跑不出来，单步一下发现是没有及时退出循环，不过我怎么记得我以前写的<code>LCA</code>没有那一句照样飞快……瞬间开始虚……加了条件之后样例一也过了不过感觉超级虚……检查完文件放一边。</p><p>喝水看题……<br>换教室？难不成是借教室一样的区间操作？不对这个数学期望是什么鬼，怎么一股浓郁的DP气息？再往后看……路径？最短路？EXM？！什么鬼，瞬间感觉药丸，看一看部分分感觉似乎可骗，开始写暴力……飞速复制来之前的<code>Dijkstra</code>调试一下发现不对，似乎应该是最小生成树？改改改……这题里的教室改变怎么搞，<code>dfs</code>暴力枚举吧，写写写……新教室和旧教室间的边分离不出来了，怎么查询是否存在过来着，是不是要用<code>set</code>，可是<code>set</code>根本用不熟啊啊啊啊，这个时候老师说离结束还有15分钟了，看到满屏混乱的代码……完蛋，弃疗了，输出样例看看出题人能不能……</p><p>出了考场一讨论发现T2根本就没有那么简单，SZ树剖加线段树不知道是不是正解，听Menci说这难度不对估计上不了200（一定是谦虚），省实验的dalao说T2写了400+行……感觉自己好虚……第一年Noip难道就要滚粗了……悲伤辣么大……</p><p>晚上去阶梯教室学（tui）习（fei）了一会，学到了“磁场”……恩对，磁场。</p><p>回去之后没什么心情看板子就直接睡了。</p><h4 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h4><p>昨天晚上做了奇妙的梦，一觉醒来感觉无限虚。</p><p>在压缩包里看到AngryBrid瞬间就开始慌了，喝了口水冷静了一下老师就发密码了，恩仍然是没有什么意义的字符串。</p><p>喝水看题……<br>组合数？我知道组合数可以递推！NOIp之前刚好做过一道递推求组合数的题，于是非常愉快的开始写，写完之后打了暴力稍微手动对拍了一下，感觉似乎没有什么问题。</p><p>喝水看题……<br>这么长的题面是什么鬼，直接就是一道阅读理解题吧，仔细读完题第一反应是堆感觉似乎能拿不少分的样子,  然后就开始写 <code>std::priority_queue&lt;&gt;</code>。一开始在pq里作死传结构体但发现自己根本不会写什么比较器，然后一直段错误……时间不知不觉就过去了，在还有最后45分钟左右的时候还是没能调出来，然而T3还没开始看，这时候我已经慌到不能仔细思考了，出去洗了把脸冷静了一下，开始改成pq里传<code>int</code>，大概改了半个小时，第二部分的样例还是没过，感觉完蛋了，随便写了15分的骗分，最后一题直接输出了样例。</p><p>出考场讨论的时候都说Day2比Day1简单，感觉NOIp之前立的Flag生效了……只有我考挂了，估计连200都没有，三等滚粗……</p><p>总结一下的话应该是考场经验不够丰富，乱用自己并不熟悉的语言特性，心态爆炸没有及时调整，时间分配不好，没有仔细分析部分分，该骗的分也没有骗到。</p><h5 id="Update："><a href="#Update：" class="headerlink" title="Update："></a>Update：</h5><p>Day2T1忘分步取模，直接爆<code>longlong</code>，身败名裂。只能明年再战了。</p><h5 id="Update-2："><a href="#Update-2：" class="headerlink" title="Update 2："></a>Update 2：</h5><p>测了XJ的山寨数据，170，还没有学妹考的高……</p><h5 id="Update-3："><a href="#Update-3：" class="headerlink" title="Update 3："></a>Update 3：</h5><p>三考场出现重大失误导致全部爆零？？诶不对我好像就是三考场的，什么鬼，虽然考的不好但直接爆零不能接受（是不是传说不爆零就有三等来着）。 </p><h5 id="Update-4："><a href="#Update-4：" class="headerlink" title="Update 4："></a>Update 4：</h5><p>突然想到Day1T1好像是从1开始标的号，感觉要爆0，不过XJ数据是怎么给我评到80分的……</p><h5 id="Update-5"><a href="#Update-5" class="headerlink" title="Update 5:"></a>Update 5:</h5><p>终于下来成绩了，185，二等，明年再战拿一等吧。</p>]]></content>
      
      
      <categories>
          
          <category> NOIp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在NOIp2016之后</title>
      <link href="/2016/11/27/talk/"/>
      <url>/2016/11/27/talk/</url>
      
        <content type="html"><![CDATA[<p>有很多事情，在想象中发生的时候，神圣无比，而当真实的发生的时候，人们却总是失望的发现，他并不像想象中的那样神奇与壮观。</p><p>NOIp2016的到来就是如此。全一中的选手们，在很早之前就对这一天的到来精心设计了各种场面，于是，我们百年一中用倒计时的心态来等待着这一天的到来。在幻想中，是有些激动的。</p><a id="more"></a><p>但很快我们就发现，这所谓神奇的比赛，似乎只是一场全国限时的模拟赛而已，三个半小时过得飞快，在两天后返程的客车上，我出奇的困，于是倒头便睡，忘了这是一段旅程的结束，更是另一段旅行的开始。</p><p>但NOIp毕竟来了。</p><p>在此之前，我们都像一个个爬山的旅人，走过的路程陡峭无比，理想、欢笑、汗水、眼泪铺就的登山之路异常艰辛。在之前短短的一年中，不断有人停下来，离开队伍，选择放弃，当然也有新的力量加入进来。终于，在倒计时的指引下，我们相互搀扶着，到达了NOIp的山顶。</p><p>原本以为这山顶是一个可以休息的地方，上来了才发现，这不过是一个新的地平线，前方还有一个又一个的山顶，2017赛季的比赛才刚刚开始，而我们，则是千千万万选手中最普通的那几个，是在一轮轮残酷的筛选中，最早被筛选下来的那一批人。有人收获一等，光荣退役，有人颗粒无收，在叹息之后惨淡收场，每个人都有自己的选择，但这并不意味着我们会停下脚步，地平线从来只用来出发，于是我们只能简单回头看看，掸掸身上的的灰尘，又该上路了。</p><p>回首过去的一年，仔细查看自己的心路历程，发现其中的痛苦和快乐紧密的交织在一起。每一步都走的并不容易，有时甚至有想放弃的念头，痛苦自然会在这时候出现，但坚持住了，又向前迈出了一步，快乐就在我们回首望向自己那一条前进轨迹时出现了。痛苦与快乐在心中此起彼伏，恐怕就是我们每一个竞赛选手的心灵宿命，但只要每次回首时，都能看到自己坚定的步伐所留下的脚印，那继续前行时的痛苦，也便好忍受多了。</p><p>其我们别无选择不是吗。</p><p>NOIp2016的结束到现在也只是短短的时间，相信我们2015级老一辈的OI选手站在地平线上，多少还有些手足无措，多少还有些忐忑不安，没有人知道前路会是怎样的。</p><p>我想，LYOI一代又一代的选手们，不管是怎样的不受家长和老师的支持，经历过怎样的挫折与困难，在面对未来的时候，总会投入最多的希望和歌唱，因为我们知道自己追求的是什么，知道当我们在赛场上双手飞速敲击着键盘，将自己脑海中的构思转化成一行行构思精巧的代码的时候，比以往任何时刻都要接近自己的梦想。</p><p>有不少同学都退役了，高三的学姐学长们也回到教室捧起理化生的课本开始备战高考，LYOI的历史又翻过了一页，这算不算的上是一个时代呢？明年，又会是怎样的呢？</p><p>一切我们都不得而知。接下来的路，雾气依然很重，前方还是一如既往的模糊，但是，让我们出发吧！</p><p>走下去，就有希望！</p>]]></content>
      
      
      <categories>
          
          <category> NOIp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIp可能需要的板子</title>
      <link href="/2016/11/17/Rp++/"/>
      <url>/2016/11/17/Rp++/</url>
      
        <content type="html"><![CDATA[<p>现在离NOIp大概还有不到40个小时的时间了，感觉超级慌，所以打了写模板题，然后贴些板子上来，给自己稍微增加一点自信…… 还是很虚啊Orz</p><a id="more"></a><h2 id="【数学】"><a href="#【数学】" class="headerlink" title="【数学】"></a>【数学】</h2><h4 id="【快速幂】"><a href="#【快速幂】" class="headerlink" title="【快速幂】"></a>【快速幂】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">2769433</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mulMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a % MOD) * (b % MOD)) % MOD</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> fastPowMod(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastPowMod(n * n, m &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mulMod(fastPowMod(n, m - <span class="number">1</span>), n);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【Eratosthenes-筛法】"><a href="#【Eratosthenes-筛法】" class="headerlink" title="【Eratosthenes 筛法】"></a>【Eratosthenes 筛法】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> eratosthenes &#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i) &#123;</span><br><span class="line">        vis[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【欧几里得算法】"><a href="#【欧几里得算法】" class="headerlink" title="【欧几里得算法】"></a>【欧几里得算法】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【拓展欧几里得】"><a href="#【拓展欧几里得】" class="headerlink" title="【拓展欧几里得】"></a>【拓展欧几里得】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inilne <span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    d = a; x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    exgcd(a % b, b, d, y, x);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【欧拉函数】"><a href="#【欧拉函数】" class="headerlink" title="【欧拉函数】"></a>【欧拉函数】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ans = ans / n * (n - i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【图论】"><a href="#【图论】" class="headerlink" title="【图论】"></a>【图论】</h2><h4 id="【最短路】"><a href="#【最短路】" class="headerlink" title="【最短路】"></a>【最短路】</h4><h5 id="【Dijkstra】"><a href="#【Dijkstra】" class="headerlink" title="【Dijkstra】"></a>【Dijkstra】</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, Node*&gt; info;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt; info, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;info&gt;, <span class="built_in">std</span>::greater&lt;info&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line">x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">pq.push(info(<span class="number">0</span>, x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">info x = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"></span><br><span class="line">Node *v = x.second;</span><br><span class="line"><span class="keyword">if</span> (v-&gt;dis != x.first) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">Node *vi = e-&gt;to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v-&gt;dis + e-&gt;w &lt; vi-&gt;dis) &#123;</span><br><span class="line">vi-&gt;dis = v-&gt;dis + e-&gt;w;</span><br><span class="line">pq.push(info(vi-&gt;dis, vi));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【Floyd】"><a href="#【Floyd】" class="headerlink" title="【Floyd】"></a>【Floyd】</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][k] + a[k][j] &lt; a[i][j]) &#123;</span><br><span class="line">                a[i][j] = a[i][k] + a[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【SPFA】"><a href="#【SPFA】" class="headerlink" title="【SPFA】"></a>【SPFA】</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    q.push(x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123;</span><br><span class="line">                e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!e-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    q.push(e-&gt;to);</span><br><span class="line">                    e-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【最小生成树】"><a href="#【最小生成树】" class="headerlink" title="【最小生成树】"></a>【最小生成树】</h4><h5 id="【Kruskal】"><a href="#【Kruskal】" class="headerlink" title="【Kruskal】"></a>【Kruskal】</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> kruskal &#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(edges + <span class="number">1</span>; edges + m + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (find(edges[i].fr) != find(edges[i].to)) &#123;</span><br><span class="line">            merge(edges[i].fr, edges[i].to);</span><br><span class="line">            sum += edges[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【并查集】"><a href="#【并查集】" class="headerlink" title="【并查集】"></a>【并查集】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (father[x] != x) &#123;</span><br><span class="line">        father[x] = find(father[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r1 = find(x);</span><br><span class="line">    <span class="keyword">int</span> r2 = find(y);</span><br><span class="line">    father[r1] = r2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【区间操作】"><a href="#【区间操作】" class="headerlink" title="【区间操作】"></a>【区间操作】</h2><h4 id="【线段树】"><a href="#【线段树】" class="headerlink" title="【线段树】"></a>【线段树】</h4><h5 id="单点修改，区间查询"><a href="#单点修改，区间查询" class="headerlink" title="单点修改，区间查询"></a>单点修改，区间查询</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, mid, sum;</span><br><span class="line">SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">lc = rc = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">sum = a[l];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">sum += delta;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; mid) &#123;</span><br><span class="line">lc-&gt;modify(index, delta);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rc-&gt;modify(index, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">ans += lc-&gt;query(l, <span class="built_in">std</span>::min(mid, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">ans += rc-&gt;query(<span class="built_in">std</span>::max(mid, l), r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="区间修改，单点查询"><a href="#区间修改，单点查询" class="headerlink" title="区间修改，单点查询"></a>区间修改，单点查询</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, mid, sum, lazy;</span><br><span class="line">SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">sum = lazy = <span class="number">0</span>;</span><br><span class="line">lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">sum = a[l];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">lazy += delta;</span><br><span class="line">sum += (r - l) * delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">lc-&gt;addTag(lazy);</span><br><span class="line">rc-&gt;addTag(lazy);</span><br><span class="line"></span><br><span class="line">lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">addTag(delta);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">rc-&gt;modify(<span class="built_in">std</span>::max(mid, l), r, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pushDown();</span><br><span class="line"><span class="keyword">if</span> (index &lt; mid) &#123;</span><br><span class="line"><span class="keyword">return</span> lc-&gt;query(index);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rc-&gt;query(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="区间修改，单点查询-1"><a href="#区间修改，单点查询-1" class="headerlink" title="区间修改，单点查询"></a>区间修改，单点查询</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l, r, mid, lazy, sum;</span><br><span class="line">SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">SegmentTree(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r) : l(l), r(r) &#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">lazy = sum = <span class="number">0</span>;</span><br><span class="line">lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum = lc-&gt;sum + rc-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">sum = a[l];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">lazy += delta;</span><br><span class="line">sum += (r - l) * delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">lc-&gt;addTag(lazy);</span><br><span class="line">rc-&gt;addTag(lazy);</span><br><span class="line"></span><br><span class="line">lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r, <span class="keyword">long</span> <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">addTag(delta);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pushDown();</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">rc-&gt;modify(<span class="built_in">std</span>::max(mid, l), r, delta);</span><br><span class="line">&#125;</span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pushDown();</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">ans += lc-&gt;query(l, <span class="built_in">std</span>::min(mid, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">ans += rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> NOIp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[codevs 1137] 计算系数 - 数论相关 + 排列组合</title>
      <link href="/2016/11/14/calc/"/>
      <url>/2016/11/14/calc/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1137/" target="_blank" rel="noopener">codevs 1137 计算系数</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定一个多项式 $ (ax + by)^k $，请求出多项式展开后 $ x^n y^m $项的系数。<br><a id="more"></a></p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>共一行，包含 $ 5 $ 个整数，分别为 $ a $ ， $ b $ ，$ k $，$ n $，$ m $，每两个整数之间用一个空格隔开。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出共 $ 1 $ 行，包含一个整数，表示所求的系数，这个系数可能很大，输出对 $ 10007 $ 取模后的结果。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $ 30\% $ 的数据，有 $ 0 \leq k \leq 10 $；</p><p>对于 $ 50\% $ 的数据，有 $ a = 1 $ ，$ b = 1 $；</p><p>对于 $ 100\% $的数据，有 $ 0\leq k \leq 1000 $，$ 0 \leq n $, $ m \leq k $，且 $ n + m = k $ ，$ 0 \leq a $，$ b \leq 1000000 $。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题和之前的<a href="http://ilern.cf/phi/" target="_blank" rel="noopener">同余方程</a>一样，一看就是一道裸的数学题，一看题目描述就能想到二项式定理：</p><script type="math/tex; mode=display">\begin{align}(a + b)^n & = \sum_{i = 0}^n C_n^i a^{n - i}b^i \\ & = \sum_{i = 0}^n \frac{n!}{i!(n - i)!} a^{n - i}b^i \\ \end{align}</script><p>对于这题存在系数的 $ ax $ 和 $ by $ 把他们可以看做一个整体来做二项式定理，最后计算系数的时候别忘记乘上他们本来的系数就好了</p><p>经过使用二项式定理来展开，我们得到这样一个式子：</p><script type="math/tex; mode=display">\frac{k!}{m!(k - m)!} x^{k - m}y^m</script><p>所以发现题目中让求的多项式展开后 $ x^n y^m $ 项的系数其实就是 $C_k^m \times a^n \times b^m = \frac{k!}{m!(k - m)!} \times a^n \times b^m$ 所以这个时候就可以愉快的写一个阶乘函数然后去愉快的<code>TLE</code>和<code>RE</code>了。因为 $ k $ 是小于等于 $ 1000 $ 的，那么大的阶乘根本没法算 <del>听说你很会写高精度?</del> 所以要考虑其他方法。</p><p>查询百度百科之后，我们 <del>惊讶地</del> 发现组合数其实是可以递推的，也就是所谓的组合恒等式：</p><script type="math/tex; mode=display">C_m^n = C_{n - m}^n = C_{m - 1}^{n - 1} + C_m^{n - 1}</script><p>这样一来事情就变得简单了很多，只要递推就可以了，可以设<code>f(i, j)</code>表示 $ C_j^i $ , 按照上面的递推关系一直推到<code>f(m, k)</code>就可以了，注意边界条件为<code>f(0, 0) = 1</code>， <code>f(i, i) = 1</code></p><p>最后不要忘了乘上 $ a^n $ 和 $ b^m $ 两个系数，可以随便写个快速幂什么的……</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mulMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a % MOD) * (b % MOD)) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fastPowMod(mulMod(a, a), b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mulMod(fastPowMod(a, b - <span class="number">1</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, k, n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;a, &amp;b, &amp;k, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        f[<span class="number">0</span>][i] = f[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                f[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] % MOD + f[i][j - <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = (f[m][k] % MOD * fastPowMod(a, n) * fastPowMod(b, m)) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p>一开始推错式子没乘原来的那个系数，结果莫名其妙50分 ？？</p><p>我真是太弱了，这就快NOIp了感觉好虚……</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[codevs 4600] 程序自动分析 - 并查集 + map</title>
      <link href="/2016/11/13/analysis/"/>
      <url>/2016/11/13/analysis/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/4600/" target="_blank" rel="noopener">codevs 4600 程序自动分析</a></p><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p> 在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设 $ x_1 $，$ x_2 $ ，$ x_3 $，$ \dots $ 代表程序中出现的变量，给定 $ n $ 个形如 $ x_i = x_j $ 或 $ x_i \neq x_j $ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$ x_1 = x_2 $，$ x_2 = x_3 $，$ x_3 = x_4 $，$ x_1 \neq x_4 $，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p><p>现在给出一些约束满足问题，请分别对它们进行判定。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入文件的第 $ 1 $ 行包含 $ 1 $ 个正整数 $ t $，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：</p><p>第 $ 1 $ 行包含 $ 1 $ 个正整数 $ n $ ，表示该问题中需要被满足的约束条件个数。</p><p>接下来 $ n $ 行，每行包括 $ 3 $ 个整数 $ i $, $ j $ , $ e $ ,描述 $ 1 $ 个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $ e = 1 $，则该约束条件为$ x_i = x_j $；若$ e = 0 $，则该约束条件为 $ x_i \neq x_j $。</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出文件包括 $ t $ 行。</p><p>输出文件的第k行输出一个字符串<code>YES</code>或者<code>NO</code>（不包含引号，字母全部大写），<code>YES</code>表示输入中的第 $ k $ 个问题判定为可以被满足，<code>NO</code>表示不可被满足。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>$ 1 \leq n \leq 1000000 $</p><p>$ 1 \leq i,j \leq 1000000000 $</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这是<code>NOI2015</code>的一道神题，<code>Menci</code>神犇说这题应该放到普及组，真是太神啦%%%</p><p>方法很简单，就是把每一个相等的条件加到并查集里面，然后离线处理每一个不能的条件，如果都成立那就是<code>YES</code>，反之那当然就是<code>NO</code>了</p><p>但是有一个问题，就是 $ i $ 和 $ j $ 都非常大，开一个那么大的数组显然不靠谱，但是 $ n $ 却并不大，所以我们并不需要开一个很大的数组来存储并不多的数，只需要把他们区分开就好了，所以最多只需要 $ 2n $ 的空间，这个操作用 <code>std::map</code> 就可以轻松实现.</p><p>但是用我用<code>map</code>的时候<code>TLE</code>了，所以选择使用<code>std::tr1::unordered_map</code>，来加快速度</p><p>不过据说这个东西很容易被卡，所以还是尽量少用它比较好。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">&#125;cmd[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (father[x] != x) &#123;</span><br><span class="line">father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r1 = find(x);</span><br><span class="line"><span class="keyword">int</span> r2 = find(y);</span><br><span class="line">father[r1] = r2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!mp.count(x)) &#123;</span><br><span class="line">mp[x] = cnt;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">mp.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cmd[i].a = <span class="number">0</span>;</span><br><span class="line">cmd[i].b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, type;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;type);</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">a = getId(a);</span><br><span class="line">b = getId(b);</span><br><span class="line">merge(a, b);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">cmd[tot].a = getId(a);</span><br><span class="line">cmd[tot].b = getId(b);</span><br><span class="line">tot++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (find(cmd[i].a) == find(cmd[i].b)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> begin;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> STL </tag>
            
            <tag> 离散化 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[codevs 1138] 聪明的质监员 - 二分答案 + 前缀和</title>
      <link href="/2016/11/10/clever/"/>
      <url>/2016/11/10/clever/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1138/" target="_blank" rel="noopener">codevs 1138 聪明的质监员</a></p><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $ n $ 个矿石，从 $ 1 $ 到 $ n $ 逐一编号，每个矿石都有自己的重量 $ w_i $ 以及价值 $ v_i $。</p><p>检验矿产的流程是：</p><ol><li>给定 $ m $ 个区间 $ [L_i, R_i] $</li><li>选出一个参数 $ W $ </li><li>对于每一个区间，其检验值定义为<script type="math/tex; mode=display">Y_i = \sum_j 1 \times \sum_j v_j,j \in [L_i, R_i] , w_j \ge W</script></li><li>对于这一批矿产，其检验值为<script type="math/tex; mode=display">Y = \sum_i^m Y_i</script></li></ol><p>若这批矿产的检验结果与所给标准值 $ S $ 相差太多，就需要再去检验另一批矿产。质监员不想费时间去检验另一批矿产，所以他想通过调整参数 $ W $ 的值，让检验结果尽可能的靠近标准值 $ S $ ，即使得 $ S - Y $ 的绝对值最小。请你帮忙求出这个最小值。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含三个整数 $ n，m，S $，分别表示矿石的个数、区间的个数和标准值。<br>接下来的 $ n $ 行，每行 $ 2 $ 个整数，中间用空格隔开，第 $ i + 1 $ 行表示 $ i $ 号矿石的重量 $ w_i $ 和价值 $ v_i $ 。<br>接下来的 $ m $ 行，表示区间，每行 $ 2 $ 个整数，中间用空格隔开，第 $ i + n + 1 $ 行表示区间 $ [Li,Ri] $ 的两个端点 $ L_i $ 和 $ R_i $。注意：不同区间可能重合或相互重叠。）</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出只有一行，包含一个整数，表示所求的最小值。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $ 10\% $ 的数据， $ 1 \le n,m \le 10 $；</p><p>对于 $ 30\% $ 的数据，$ 1 \le n,m \le 500 $；</p><p>对于 $ 50\% $ 的数据，$ 1 \le n,m \le 5000 $；</p><p>对于 $ 70\% $ 的数据，$ 1 \le n,m \le 10000 $；</p><p>对于 $ 100\% $ 的数据，$ 1 \le n,m \le 200000,0 &lt; w_i,v_i \le 10^6,0 &lt; S \le 10^{12},1 \le L_i \le R_i \le n $ 。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><ul><li>这题怎么做?<ul><li>二分</li></ul></li><li>为什么可以二分？<ul><li>对于每一个 $ W $ 都可以由题目中提到的公式求出一个 $ Y_i $，显然 $ W $ 越大，能满足条件的 $ w_i $ 越少，所以 $ Y_i $ 越小，所以 $ Y_i $ 和 $ W $ 负相关，所以答案单调，所以可以二分</li></ul></li><li>怎么二分？<ul><li>二分的对象是 $ W $，目的是找到一个和 $ S $ 最接近的 $ Y $，二分边界设为 $[1,maxw)$ 。当二分出的 $ W $ 计算得到的 $ Y $ 大于 $ S $ 时，在左半部分继续二分，反之在右半部分二分</li></ul></li><li>我 <code>TLE</code> 了怎么办？<ul><li>在计算 $ Y $ 的时候顺便计算出在当前 $ W $ 下满足条件的 $ w_i $ 的前缀和，这样就可以每次 $ O(1) $ 查询了 </li></ul></li></ul><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w, v;</span><br><span class="line">&#125;things[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Area</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l, r;</span><br><span class="line">&#125;areas[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum1[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> w)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(sum1, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum1));</span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (things[i].w &gt;= w) &#123;</span><br><span class="line">sum1[i] = sum1[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + things[i].v;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum1[i] = sum1[i - <span class="number">1</span>];</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ans += (sum1[areas[i].r] - sum1[areas[i].l - <span class="number">1</span>]) * (sum[areas[i].r] - sum[areas[i].l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxw;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;things[i].w, &amp;things[i].v);</span><br><span class="line">maxw = <span class="built_in">std</span>::max(maxw, things[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;areas[i].l, &amp;areas[i].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = maxw;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = LLONG_MAX;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tmp = calc(w);</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; s) &#123;</span><br><span class="line">right = w - <span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">std</span>::min(ans, s - tmp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = w + <span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">std</span>::min(ans, tmp - s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[codevs 1285]宠物收养所 - 平衡树</title>
      <link href="/2016/11/09/pets/"/>
      <url>/2016/11/09/pets/</url>
      
        <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/1285/" target="_blank" rel="noopener">codevs 1285 宠物收养所</a></p><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>维护一种支持插入和删除元素、查询与一个值最接近的元素的数据结构</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行为一个正整数 $ n $，$ n \leq 80000 $，表示一年当中来到收养所的宠物和领养者的总数。接下来的 $ n $ 行，按到来时间的先后顺序描述了一年当中来到收养所的宠物和领养者的情况。每行有两个正整数 $ a,b $，其中 $ a = 0 $表示宠物，$ a = 1 $表示领养者，$ b $表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间待在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过 $ 10000 $ 个）</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和对 $1000000$ 取模以后的结果。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>传闻这是一道平衡树的入门题，但是只用到了正儿八经的平衡树的一部分功能，所以正好可以用 <code>std::set</code> 来解决</p><p><del>所以说其实是<code>set</code>的入门题</del></p><p>具体的做法就是按照题目要求的做，要注意的是<code>set</code>的迭代器是没有<code>operator-</code>的，但是有<code>operator--</code>，所以</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">s.insert(INT_MAX);</span><br><span class="line">s.insert(INT_MIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> type, data;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;type, &amp;data);</span><br><span class="line"><span class="keyword">if</span> (s.size() == <span class="number">2</span>) &#123;</span><br><span class="line">flag = type;</span><br><span class="line">s.insert(data);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type != flag) &#123;</span><br><span class="line"><span class="keyword">int</span> small = *(--s.lower_bound(data));</span><br><span class="line"><span class="keyword">int</span> big = *s.lower_bound(data);</span><br><span class="line"><span class="keyword">if</span> (data - small &lt;=  big - data &amp;&amp; small &gt; INT_MIN) &#123;</span><br><span class="line">ans += (data - small);</span><br><span class="line">ans %= MOD;</span><br><span class="line">s.erase(small);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans += (big - data);</span><br><span class="line">ans %= MOD;</span><br><span class="line">s.erase(big);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.insert(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p>感觉平衡树这种 <del>搞基</del> 高级数据结构可能这辈子都不会学到了，有那么一丝丝的小遗憾呢</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> STL </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3286]火柴排队 - 贪心 + 逆序对</title>
      <link href="/2016/11/07/match/"/>
      <url>/2016/11/07/match/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/3286/" target="_blank" rel="noopener">Codevs 3286 火柴排队</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有两盒火柴，每盒装有 $ n $ 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为 </p><script type="math/tex; mode=display">\sum_{i = 1}^n \left( a_i - b_i \right) ^2</script><p>其中 $ a_i $ 表示第一列火柴中第 $ i $ 个火柴的高度， $ b_i $ 表示第二列火柴中第 $ i $ 个火柴的高度。每列火柴中<strong>相邻</strong>两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 $ 99999997 $ 取模的结果。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>共三行，第一行包含一个整数 $ n $，表示每盒中火柴的数目。</p><p>第二行有 $ n $ 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。</p><p>第三行有 $ n $ 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出共一行，包含一个整数，表示最少交换次数对 $ 99999997 $ 取模的结果。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $ 10\% $ 的数据， $ 1 \leq n \leq 10 $；</p><p>对于 $ 30\% $ 的数据，$ 1 \leq n \leq 100 $；</p><p>对于 $ 60\% $ 的数据，$ 1 \leq n \leq 1000 $;</p><p>对于 $ 100\% $ 的数据，$ 1 \leq n \leq 1000000 \leq a_i, b_i \leq 2^{31} - 1 $</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>看到题目要求两列火柴间的距离最小，很自然的就能YY出一种方案：每一列中高度名次相同的对应放在一起，可以实现两列火柴间的距离最小。</p><p>证明如下：</p><p>设两列火柴间距离为 $ sum $ ，则：</p><script type="math/tex; mode=display">\begin{align}sum& = \sum_{i = 1}^n \left( a_i - b_i \right) ^2 \\& = \sum_{i = 1}^n \left( a_i^2 + b_i^2 - 2a_ib_i\right) \\& = \sum_{i = 1}^n a_i^2 + \sum_{i = 1}^n b_i^2 - 2\sum_{i = 1}^n a_ib_i\end{align}</script><p>所以题目要求 $ sum $ 最小，就是要求 $ \sum_{i = 1}^n a_ib_i $ 最大，这里存在的贪心策略是当 $a_1 &lt; a_2 &lt; a_3 &lt; \dots &lt; a_n $ 且 $ b_1 &lt; b_2 &lt; b_3 &lt; \dots &lt; b_n $<br>时上式最大。</p><p>考虑反证，假如存在 $ a<em>i &lt; a</em>{i + 1} $， $b<em>i &lt; b</em>{i + 1} $ 且 $a<em>{i + 1} \times b_i + b</em>{i + 1} \times a<em>i &gt; a_i \times b_i + a</em>{i + 1} \times b<em>{i + 1}$，则 $a_i \times (b</em>{i + 1} - b<em>i) &gt; a</em>{i + 1} \times (b<em>{i + 1} - b_i)$ 在 $a_i, b_i$ 均大于零的前提下，推得 $a</em>{i + 1} &lt; a_i$ ，与题设不符，命题不成立，所以贪心策略正确。</p><p>update:在我们学习了排序不等式之后不难发现，这其实就是所谓<code>顺序和</code>，而根据排序不等式容易得到上述结论。</p><p>然后，将两个序列分别排序，确定每对数的对应关系，明显，同时移动两个序列中的数等效于只移动一个序列中的数，那么，我们就保持一个序列不动，然后根据另外那个序列中的数对应的数的位置，重新定义一个数组，求逆序对个数，就是答案。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stick</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id, val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stick &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> val &lt; a.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;stk1[MAXN], stk2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mergeSort(a, l, mid);</span><br><span class="line">mergeSort(a, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">tmp[k++] = a[j++];</span><br><span class="line"><span class="comment">//ans += mid - i + 1;</span></span><br><span class="line">ans = (ans % MOD + mid % MOD - i % MOD + <span class="number">1</span> % MOD) % MOD;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp[k++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">tmp[k++] = a[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">tmp[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stk1[i].val);</span><br><span class="line">stk1[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;stk2[i].val);</span><br><span class="line">stk2[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(stk1 + <span class="number">1</span>, stk1 + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::sort(stk2 + <span class="number">1</span>, stk2 + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">t[stk2[i].id] = stk1[i].id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergeSort(t, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3731]寻找道路 - BFS</title>
      <link href="/2016/11/06/roadb/"/>
      <url>/2016/11/06/roadb/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/3731/" target="_blank" rel="noopener">Codevs 3731 寻找道路</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在有向图 $ G $ 中，每条边的长度均为 $ 1 $，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：</p><p>1．路径上的所有点的出边所指向的点都直接或间接与终点连通。</p><p>2．在满足条件 $ 1 $ 的情况下使路径最短。</p><p>注意：图 $ G $ 中可能存在重边和自环，题目保证终点没有出边。</p><p>请你输出符合条件的路径的长度。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行有两个用一个空格隔开的整数 $ n $ 和 $ m $，表示图有 $ n $ 个点和 $ m $ 条边。</p><p>接下来的 $ m $ 行每行 $ 2 $ 个整数 $ x,y $,之间用一个空格隔开，表示有一条边从点 $ x $ 指向点 $ y $。</p><p>最后一行有两个用一个空格隔开的整数 $ s,t $ ，表示起点为$ s $，终点为 $ t $ 。</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出 $ -1 $ 。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $ 30\% $的数据， $ 0 &lt; n \leq 10，0 &lt; m \leq 20 $；</p><p>对于 $ 60\% $的数据，$ 0 &lt; n \leq 100，0 &lt; m \leq 2000 $；</p><p>对于 $ 100\% $的数据，$ 0 &lt; n \leq 10,000，0 &lt; m \leq 200,000，0 &lt; x,y,s,t \leq n，x \neq t $。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p><del>两遍 <code>BFS</code> 就可以 <code>AC</code> la!</del></p><p>第一遍从终点开始 <code>BFS</code> 不能遍历到的点就是<strong>不与终点联通的点</strong>，把它们打上标记。</p><p>第二遍从起点开始 <code>BFS</code> ，每找到一个点就考虑它所连出的点，如果存在在第一遍 <code>BFS</code>中被标记过的点，那么这个点就是不合法的，不去搜索它。在 <code>Node</code> 结构体里记录一个 <code>dist</code> 值，每搜索一层就 <code>dist++</code> 最后终点的 <code>dist</code> 值就是要求的答案。 </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Edge *edges;</span><br><span class="line"><span class="keyword">bool</span> vis, can, imp;</span><br><span class="line"><span class="keyword">int</span> dist;</span><br><span class="line"></span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), vis(<span class="literal">false</span>), can(<span class="literal">false</span>), imp(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;nodes[MAXN], nodesB[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs1</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!v-&gt;vis) &#123;</span><br><span class="line">v-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">v-&gt;can = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(Node *v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Edge *e = v-&gt;edges; e; e = e-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(!e-&gt;to-&gt;can) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(Node *s, Node *t)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; Q;</span><br><span class="line">Q.push(s), s-&gt;vis = <span class="literal">true</span>, s-&gt;dist = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">Node *v = Q.front(); Q.pop();</span><br><span class="line"><span class="keyword">if</span>(v == t) <span class="keyword">return</span> v-&gt;dist;</span><br><span class="line"><span class="keyword">for</span>(Edge *e = v-&gt;edges; e; e = e-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(check(e-&gt;to) &amp;&amp; !e-&gt;to-&gt;vis)&#123;</span><br><span class="line">Q.push(e-&gt;to);</span><br><span class="line">e-&gt;to-&gt;dist = v-&gt;dist + <span class="number">1</span>;</span><br><span class="line">e-&gt;to-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">addEdge(nodes + x, nodes + y);</span><br><span class="line">addEdge(nodesB + y, nodesB + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;t);</span><br><span class="line"></span><br><span class="line">bfs1(nodesB + t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodesB[i].can == <span class="literal">true</span>) &#123;</span><br><span class="line">nodes[i].can = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*printf("-----------------------\n");</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">printf("%d: ", i);</span></span><br><span class="line"><span class="comment">for (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">printf("%d ", (e-&gt;to) - nodes);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("\n");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("-----------------------\n");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("-----------------------\n");</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">if (nodesB[i].can == true) &#123;</span></span><br><span class="line"><span class="comment">printf("%d can be found\n", i);</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">printf("%d can't be found\n", i);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("-----------------------\n");*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nodes[s].can == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs2(nodes + s, nodes + t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p>写的时候犯了一个沙茶错误，本来每搜一层 <code>dist++</code>，结果变成了每搜一个点 <code>sum++</code> 结果只过了前三个小数据。</p><p>在最初的版本里没有用节点的 <code>dist</code> 而是全局记录了一个 <code>sum</code>。</p><p>大概学到了 <code>BFS</code> 的正确姿势。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3728]联合权值 - 图论 + 枚举</title>
      <link href="/2016/11/05/links/"/>
      <url>/2016/11/05/links/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/3728/" target="_blank" rel="noopener">Codevs 3728 联合权值</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>无向连通图 $ G $ 有 $ n $ 个点，$ n - 1 $ 条边。点从 $ 1 $ 到 $ n $ 依次编号，编号为 $ i $ 的点的权值为$ W_i $，每条边的长度均为 $ 1 $  。图上两点 $ (u, v) $ 的距离定义为 $ u $ 点到 $ v $ 点的最短距离。对于图 $ G $ 上的点对 $ (u, v) $，若它们的距离为 $ 2 $ ，则它们之间会产生 $ W_u \times W_v $ 的联合权值。</p><p>请问图 $ G $ 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含 $ 1 $ 个整数 $ n $ 。</p><p>接下来 $ n - 1 $ 行，每行包含 $ 2 $ 个用空格隔开的正整数 $ u, v $，表示编号为 $ u $ 和编号为 $ v $ 的点之间有边相连。</p><p>最后 $ 1 $ 行，包含 $ n $ 个正整数，每两个正整数之间用一个空格隔开，其中第 $ i $ 个整数表示图 $ G $ 上编号为 $ i $ 的点的权值为 $ W_i $ </p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出共 $ 1 $ 行，包含 $ 2 $ 个整数，之间用一个空格隔开，依次为图 $ G $ 上联合权值的最大值</p><p>和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对 $ 10007 $ 取余。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>考虑能形成联合权值的点对，他们一定中间会经过一个点，所以最暴力的做法就是枚举每一个点和它周围的点，它周围的点两两之间都能形成联合权值，这样做就能拿到60分了（大概），但是这里可以用一种 <del>奇技淫巧</del> 来有效降低复杂度，考虑一个点 $ A $ 周围有 $A<em>1, A_2, A_3, A_4, A_5$ 五个点，设 $ A $ 点周围所有点的权值和(包括 $ A $ 点)为 $ S_A $ ,那么所形成的联合权值为 $ \sum</em>{i = 1}^5 A_i \times (S_A - A_i)$，其中 $ S_A $ 可以对于每个点枚举与他相连的点就可以预处理得到。</p><p>关于第一问，求最大的联合权值，一定是每个点周围的点形成的最大值的最大值，也就是说，对于每一个点都求出他周围的点所形成的联合权值的最大值，在对所有的最大值取<code>max</code>就可以得到，这个过程可以在预处理 $ S_A $ 的时候算出来</p><p>另外一点，可能会爆<code>int</code>,所以应该尽量使用<code>long long</code>,不过据说分步取模就不会爆<code>int</code>了，但是自己太弱分步取模写炸………………</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">10007</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Edge *edges;</span><br><span class="line"><span class="keyword">int</span> val, sum;</span><br><span class="line"> </span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), val(<span class="number">0</span>), sum(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;nodes[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line">Edge *next;</span><br><span class="line"> </span><br><span class="line">Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v, u);</span><br><span class="line">u-&gt;sum++;</span><br><span class="line">v-&gt;sum++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> max;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> summ;</span><br><span class="line"><span class="keyword">int</span> tmp1, tmp2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">addEdge(nodes + u, nodes + v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nodes[i].val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">tmp1 = <span class="number">0</span>;</span><br><span class="line">tmp2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123;</span><br><span class="line">a[i] += e-&gt;to-&gt;val;</span><br><span class="line"><span class="keyword">if</span> (e-&gt;to-&gt;val &gt; tmp1) &#123;</span><br><span class="line">tmp1 = e-&gt;to-&gt;val;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;to-&gt;val &gt; tmp2) &#123;</span><br><span class="line">tmp2 = e-&gt;to-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">max = <span class="built_in">std</span>::max(max, tmp1 * tmp2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="comment">//summ = ((e-&gt;to-&gt;val % MOD * (a[i] % MOD - e-&gt;to-&gt;val % MOD) % MOD) % MOD + summ % MOD) % MOD;</span></span><br><span class="line">summ += e-&gt;to-&gt;val * (a[i] - e-&gt;to-&gt;val);</span><br><span class="line">summ %= MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %lld"</span>, max, summ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p>开始的时候有一个奇奇怪怪的想法，题目中给出的是一棵树，在一棵树上和一个节点相距距离为2的点要么是他父亲的父亲，要么是他的兄弟，所以考虑在树上进行操作 <del>结果爆炸了</del> </p><p>不过看到黄学长的博客上写的算法似乎就是这样的做法 Orz</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1001]舒适的路线 - 并查集</title>
      <link href="/2016/11/02/comf/"/>
      <url>/2016/11/02/comf/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1001/" target="_blank" rel="noopener">Codevs 1001 舒适的路线</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>求一个无向图中两点间的一条路径使得其中最大边权和最小边权的比值尽量大，输出最大边与最小边的比值</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含两个正整数，$ n $ 和 $ m $。</p><p>接下来的M行每行包含三个正整数： $ x $，$ y $ 和 $ v $ $ (1 \leq x,y \leq N) $最后一行包含两个正整数 $ s $，$ t $，表示想知道从景点 $ s $ 到景点 $ t $ 最大最小速度比最小的路径。$ s $ 和 $ t $不可能相同</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>如果景点 $ s $ 到景点 $ t $ 没有路径，输出<strong>“IMPOSSIBLE”</strong>。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>$ N(1 &lt; N \leq 500)$</p><p>$ M(0 &lt; M \leq 5000)$</p><p>$ V_i $在 <code>int</code> 范围内</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p><del>这是 <code>Codevs</code> 上的第二道题，所以难度只比 <code>1000 A + B Problem</code> 高那么一点点</del></p><p>因为数据范围比较小，所以这题的正解是一个非常 <del>暴力</del> 精巧的暴力，考虑并查集，可以方便的确定一个图是否联通，先对所有的边按边权排序，从第一条边开始设为当前路径中最大的边，然后从大到小枚举剩下的边，每枚举一条边就用并查集把他的两个点合并，然后每次都判断一下两个目标节点是否联通，当这两个点终于联通的时候，我们就得到了一条路径，一开始设的最大边就是最大的，最后加入的那条边是最小的，这样就得到了<strong>当前路径中最大的边和最小的边</strong>，而且他们的比值是最小的，重复上述操作，遇到更小的比值就更新答案，直到每条边都作为最大边考虑过</p><p>另外一个问题就是要求输出一个既约分数，对分子和分母求一下 <code>gcd</code> 然后分子和分母同除 <code>gcd</code> 就实现了约分</p><p>最后一个问题就是在比较是否需要更新答案的时候要用 <code>double</code> 存储，其他地方都用 <code>int</code> 就好了</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfloat&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5000</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = DBL_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fr, to, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;edges[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(father[x] != x) &#123;</span><br><span class="line">father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r1 = find(x);</span><br><span class="line"><span class="keyword">int</span> r2 = find(y);</span><br><span class="line">father[r1] = r2;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">init(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;edges[i].fr, &amp;edges[i].to, &amp;edges[i].w);</span><br><span class="line">merge(edges[i].fr, edges[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (find(s) != find(t)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(edges + <span class="number">1</span>, edges + m + <span class="number">1</span>, Edge::cmp());</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans = INF;</span><br><span class="line"><span class="keyword">int</span> ansMax = <span class="number">0</span>, ansMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">init(n);</span><br><span class="line">ansMax = edges[i].w;</span><br><span class="line">merge(edges[i].fr, edges[i].to);</span><br><span class="line"><span class="keyword">if</span>(find(s) == find(t)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">merge(edges[j].fr, edges[j].to);</span><br><span class="line"><span class="keyword">if</span> (find(s) == find(t)) &#123;</span><br><span class="line">ansMin = edges[j].w;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">double</span>)ansMax / (<span class="keyword">double</span>)ansMin &lt; ans) &#123;</span><br><span class="line">ans = (<span class="keyword">double</span>)ansMax / (<span class="keyword">double</span>)ansMin;</span><br><span class="line"><span class="keyword">int</span> gcdd = gcd(ansMax, ansMin);</span><br><span class="line">ans1 = ansMax / gcdd;</span><br><span class="line">ans2 = ansMin / gcdd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ans2 != <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/%d\n"</span>, ans1, ans2);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (ans2 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p><code>60</code> 分卡了好久，最后花了一晚上生成数据对拍，最后发现是在枚举边的时候把 <code>m</code> 打成了 <code>n</code> 这种沙茶错误，自己好弱……<del>然而居然拍几千组数据都不带出错的真是迷</del></p><p>%%% Hellc %%%</p><p>%%% Menci %%%</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1380] 没有上司的舞会 - 树形DP</title>
      <link href="/2016/10/31/Dance/"/>
      <url>/2016/10/31/Dance/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1380/" target="_blank" rel="noopener">Codevs 1380 没有上司的舞会</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>Ural大学有 $ N $ 个职员，编号为 $ 1 \dots N $。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行一个整数 $ N $。$ ( 1 \leq N \leq 6000) $<br>接下来N行，第 $ i + 1 $ 行表示 $ i $ 号职员的快乐指数 $ R_i $。$(-128 \leq R_i \leq 127)$<br>接下来 $ N - 1 $ 行，每行输入一对整数 $ L,K $ 。表示 $ K $ 是 $ L $ 的直接上司。<br>最后一行输入$ 0 ,0 $。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出最大的快乐指数。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这是一道 <strong>树形</strong> DP的经典题目，其中存在明显的层次关系（上司和下属），所以可以构造一棵树来进行一些操作，但是一个节点的子节点的数目是不一定的，所以可以保存每一个节点的 <strong>最后一个子节点</strong> 并记录下该子节点的 <strong>下一个节点</strong> </p><p>在构造好一棵树之后就可以进行树形DP了，对于一个点只有两种情况即选或不选，所以设 $f(i, j) $ 表示第 $ i $ 号节点选或不选所能得到的最大价值，其中 $ j $ 等于 $ 0 $ 或 $ 1 $, 用 $ 1 $ 表示选，用 $ 0 $表示不选，可以得到状态转移方程为：</p><script type="math/tex; mode=display">f(i, j) =\begin{cases}\sum \max(f(i \rightarrow child)(0), f(i \rightarrow child)(1)),  & \text{if $j$ is 0} \\\[2ex]\sum f(i \rightarrow child)(0) + i \rightarrow value, & \text{if $j$ is 1}\end{cases}</script><p>其原理不难理解：当 $ j $ 等于 $ 1 $ 即 $ i $ 号点被选择时， $ i $ 号点的所有子节点都不能被选，结果就是所有子节点都不选所得到的价值总和加上 $ i $ 本身的价值；当 $ j $ 等于 $ 0 $ 即 $ j $ 号点不被选择时，他的子节点可选可不选，所以对于每一个子节点都要在选或不选中取一个较大值，再对他们求和。</p><p>边界条件为当 $ i $ 为叶节点时，$f(i, j) = \begin{cases} 0, &amp; \text{if j is 0}\[2ex] i \rightarrow value, &amp; \text{if j is 1} \end{cases}$</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Node *ch, *next;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">bool</span> isRoot;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">Node() &#123;</span><br><span class="line">ch = next = <span class="literal">NULL</span>;</span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line">isRoot = <span class="literal">true</span>;</span><br><span class="line">f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Node *v = ch; v; v = v-&gt;next) &#123;</span><br><span class="line">v-&gt;solve();</span><br><span class="line">f[<span class="number">0</span>] += <span class="built_in">std</span>::max(v-&gt;f[<span class="number">0</span>], v-&gt;f[<span class="number">1</span>]);</span><br><span class="line">f[<span class="number">1</span>] += v-&gt;f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>] += val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">x-&gt;next = y-&gt;ch;</span><br><span class="line">y-&gt;ch = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nodes[i].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">nodes[x].isRoot = <span class="literal">false</span>;</span><br><span class="line">addChild(nodes + x, nodes + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodes[i].isRoot) &#123;</span><br><span class="line">nodes[i].solve();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">std</span>::max(nodes[i].f[<span class="number">1</span>], nodes[i].f[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码在实现上没有用刚才提到的 $ f $ 数组，而是在<code>Node</code>结构体里加入了一个成员数组 $ f $ 来表示原来 $ f $ 数组中的第二维（选或不选），但里面存储的内容仍然和原来一样（这个点选或不选得到的最大价值）</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度计算模板</title>
      <link href="/2016/10/29/BigInt/"/>
      <url>/2016/10/29/BigInt/</url>
      
        <content type="html"><![CDATA[<p>在写完 <a href="http://codevs.cn/problem/1198/" target="_blank" rel="noopener">国王游戏</a> 之后，我们就得到了一个可以用的高精度模板，挂在这里先备用着好了，目前只支持正整数的高精度计算</p><a id="more"></a><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BASE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">BigInt(<span class="keyword">long</span> <span class="keyword">long</span> x) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v.push_back(x % <span class="number">10</span>);</span><br><span class="line">&#125;<span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str) &#123;</span><br><span class="line">v.reserve(str.length());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">v.push_back(str[i] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt() &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removePreZero</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(v.size() &gt; <span class="number">1</span> &amp;&amp; v.back() == <span class="number">0</span>) v.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (v.size() != a.v.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> v.size() &lt; a.v.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i] != a.v[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> v[i] &lt; a.v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(a &lt; *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; a);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span> || a &gt; *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(a &lt; *<span class="keyword">this</span>) &amp;&amp; !(a &gt; *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span>::max(a.v.size(), v.size()); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; a.v.size()) sum += a.v[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; v.size()) sum += v[i];</span><br><span class="line"></span><br><span class="line">ans.v.push_back(sum % BASE);</span><br><span class="line">sum /= BASE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum) ans.v.push_back(sum);</span><br><span class="line">ans.removePreZero();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator+=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this + a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//if a &lt; b, print '-', print b - a</span></span><br><span class="line">BigInt <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dif = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span>::max(a.v.size(), v.size()); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; v.size()) dif += v[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; a.v.size()) dif -= a.v[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dif &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ans.v.push_back(dif);</span><br><span class="line">dif = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans.v.push_back((dif + BASE) % BASE);</span><br><span class="line">dif = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans.removePreZero();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator-=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this - a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans;</span><br><span class="line"></span><br><span class="line">ans.v.resize(v.size() + a.v.size(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.v.size(); j++) &#123;</span><br><span class="line">ans.v[i + j] += v[i] * a.v[j];</span><br><span class="line">ans.v[i + j + <span class="number">1</span>] += ans.v[i + j] / BASE;</span><br><span class="line">ans.v[i + j] %= BASE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.removePreZero();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator*=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this * a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans, ret(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ans.v.resize(v.size(), <span class="number">0</span>);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">ret = ret * <span class="number">10</span> + v[i];</span><br><span class="line"><span class="keyword">while</span> (ret &gt;= a) &#123;</span><br><span class="line">ret = ret - a;</span><br><span class="line">ans.v[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans.removePreZero();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator/=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this / a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    </span><br><span class="line">    BigInt <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>) - (*<span class="keyword">this</span> / a) * a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> BigInt &amp;x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x.v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">out &lt;&lt; x.v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt; (<span class="built_in">std</span>::istream &amp;in, BigInt &amp;x) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">in &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">x = BigInt(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update：修正了<code>RemovePreZero()</code>中$0$会被当做前导<code>pop</code>的情况</p><p>update: 增加了对大整数取模运算的支持</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1198] 国王游戏 - 贪心 + 高精度 </title>
      <link href="/2016/10/28/King/"/>
      <url>/2016/10/28/King/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1198/" target="_blank" rel="noopener">Codevs 1198 国王游戏</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。</p><p>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含一个整数 $n$，表示大臣的人数。</p><p>第二行包含两个整数 $a$ 和 $b$  ，之间用一个空格隔开，分别表示国王左手和右手上的整数。</p><p>接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于$ 20 \% $的数据，有$1 \leq n \leq 10 $，$ 0 &lt; a,b &lt; 8 $；</p><p>对于 $ 40 \% $ 的数据，有$ 1 \leq n \leq 20 $ ， $ 0 &lt; a,b &lt; 8 $；</p><p>对于 $ 60 \% $ 的数据，有$ 1 \leq n \leq 100 $；</p><p>对于 $ 60 \% $ 的数据，保证答案不超过$ 10^9 $; </p><p>对于 $ 100 \% $ 的数据，有$ 1 \leq n \leq 1000 $ ，$ 0 &lt; a,b &lt; 10000 $。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题 <del>表面上</del> 是一道贪心的题目，但是真正奇怪的地方是高精度，之前只用<code>long long</code>被卡到<code>60</code>分，不过据超强的<code>Hellc</code>神犇说只要随便YY一下用两个<code>long long</code> <strong>拼起来</strong> 就可以不用高精度过掉了 Orz</p><h5 id="下面写题解"><a href="#下面写题解" class="headerlink" title="下面写题解:"></a>下面写题解:</h5><p>题目要求求最大值最小，第一反应是二分答案，但发现并不会（其实因为答案本身不具有单调性所以是不可二分的），看了题解明白了是贪心，但是贪心标准是玄学的将每个大臣的两只手上的价格相乘。</p><p>但要注意的一点是这样排序之后，最后一位大臣不一定就是得到金币最多的，要记录一个每个大臣之前的大臣的左手上的乘积（类似前缀和），再从头到尾扫一遍，得到最大值。</p><p>然后写一个高精度就可以了</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BASE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">BigInt(<span class="keyword">long</span> <span class="keyword">long</span> x) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v.push_back(x % <span class="number">10</span>);</span><br><span class="line">&#125;<span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str) &#123;</span><br><span class="line">v.reserve(str.length());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">v.push_back(str[i] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt() &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removePreZero</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(v.size() &gt;= <span class="number">1</span> &amp;&amp; v.back() == <span class="number">0</span>) v.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (v.size() != a.v.size()) &#123;</span><br><span class="line"><span class="keyword">return</span> v.size() &lt; a.v.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i] != a.v[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> v[i] &lt; a.v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(a &lt; *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; a);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> a &lt; *<span class="keyword">this</span> || a &gt; *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(a &lt; *<span class="keyword">this</span>) &amp;&amp; !(a &gt; *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span>::max(a.v.size(), v.size()); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; a.v.size()) sum += a.v[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; v.size()) sum += v[i];</span><br><span class="line"></span><br><span class="line">ans.v.push_back(sum % BASE);</span><br><span class="line">sum /= BASE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum) ans.v.push_back(sum);</span><br><span class="line">ans.removePreZero();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator+=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this + a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dif = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">std</span>::max(a.v.size(), v.size()); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; v.size()) dif += v[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; a.v.size()) dif -= a.v[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dif &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ans.v.push_back(dif);</span><br><span class="line">dif = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans.v.push_back((dif + BASE) % BASE);</span><br><span class="line">dif = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans.removePreZero();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator-=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this - a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans;</span><br><span class="line"></span><br><span class="line">ans.v.resize(v.size() + a.v.size(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.v.size(); j++) &#123;</span><br><span class="line">ans.v[i + j] += v[i] * a.v[j];</span><br><span class="line">ans.v[i + j + <span class="number">1</span>] += ans.v[i + j] / BASE;</span><br><span class="line">ans.v[i + j] %= BASE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.removePreZero();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator*=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this * a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInt &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">BigInt ans, ret(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ans.v.resize(v.size(), <span class="number">0</span>);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">ret = ret * <span class="number">10</span> + v[i];</span><br><span class="line"><span class="keyword">while</span> (ret &gt;= a) &#123;</span><br><span class="line">ret = ret - a;</span><br><span class="line">ans.v[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans.removePreZero();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*BigInt operator/=(const BigInt &amp;a) const &#123;</span></span><br><span class="line"><span class="comment">return *this = *this / a;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> BigInt &amp;x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x.v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">out &lt;&lt; x.v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt; (<span class="built_in">std</span>::istream &amp;in, BigInt &amp;x) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">in &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">x = BigInt(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Minister</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Minister &amp;a, <span class="keyword">const</span> Minister &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.l * a.r &lt; b.l * b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;minister[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;minister[<span class="number">0</span>].l, &amp;minister[<span class="number">0</span>].r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;minister[i].l, &amp;minister[i].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(minister + <span class="number">1</span>, minister + n + <span class="number">1</span>, Minister::cmp());</span><br><span class="line"></span><br><span class="line">BigInt max = <span class="number">1</span>;</span><br><span class="line">BigInt sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">sum = sum * minister[i].l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max = sum / minister[n].l / minister[n].r;</span><br><span class="line"><span class="keyword">if</span>(max &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">max = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf("%.0f", max);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现了一个 <del>比较完整的</del> 高精度类， 但是实际上很多功能在这题中用不到的，纯粹为了写高精度模板而写的</p><p><del>所以特别长</del></p><h3 id="【其他】"><a href="#【其他】" class="headerlink" title="【其他】"></a>【其他】</h3><p>在我刚开始写的时候直接naive地取了最后一位大臣为最优，结果A掉了，然而在我改成每次扫一遍判断后<code>TLE</code>了……</p><p>这是<code>TLE</code>代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;minister[<span class="number">0</span>].l, &amp;minister[<span class="number">0</span>].r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;minister[i].l, &amp;minister[i].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(minister + <span class="number">1</span>, minister + n + <span class="number">1</span>, Minister::cmp());</span><br><span class="line"></span><br><span class="line">BigInt max = <span class="number">1</span>;</span><br><span class="line">BigInt sum = minister[<span class="number">0</span>].l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">sum = sum * minister[i - <span class="number">1</span>].l;</span><br><span class="line">max = <span class="built_in">std</span>::max(max, sum / minister[i].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3287] 货车运输 - 最大生成树 + LCA</title>
      <link href="/2016/10/27/transport/"/>
      <url>/2016/10/27/transport/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>$A$ 国有 $n$ 座城市，编号从 $1$ 到 $n$，城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 $q$ 辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行有两个用一个空格隔开的整数 $n$，$m$，表示 $A$ 国有 $n$ 座城市和 $m$ 条道路。<br>接下来 $m$ 行每行 $3$ 个整数 $x$ 、$y$ 、$z$ ，每两个整数之间用一个空格隔开，表示从 $x $ 号城市到 $y$ 号城市有一条限重为 $z$ 的道路。注意：$x \neq y$，两座城市之间可能有多条道路。<br>接下来一行有一个整数 $q$，表示有 $q$ 辆货车需要运货。<br>接下来 $q$ 行，每行两个整数 $x$ 、$y$，之间用一个空格隔开，表示一辆货车需要从 $x$ 城市运输货物到 $y$ 城市，注意：$x \neq y$。</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出共有 $q$ 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出 $-1$ 。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>考虑在不超过限重的情况下运输的最大重量，显然受这条道路上最小值的限制，所以我们要找到一条道路使得 $x$ 到 $y$ 间的最小值最大，也就是要求出这个图中的<strong>最大生成树</strong>，其实现方法和<strong>最小生成树</strong>类似，同样可以使用<code>Kruskal</code>来高效解决，只要把排序的时候变成从大到小就可以了。</p><p>在求出最大生成树之后，就要在树上求出 $x$ , $y$之间的道路上的最小值，可以选择<code>BFS</code>一遍，但是多次询问这显然就不靠谱，所以考虑求<code>LCA</code>,并在求<code>LCA</code>的同时维护最小值，实现方法就是在<code>g</code>数组中把原先的求和操作变成求最小值操作。</p><p>需要注意的一点就是这个图可能会不连通，所以在<code>BFS</code>求深度的时候不能简单的从<code>1</code>号节点开始，否则会有无法到达的点，<code>f</code>数组中就会是一些奇怪的值，<del>然后就<code>RE</code>了</del></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Edge *edges;</span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line"></span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), depth(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;nodes[MAXN], *f[MAXN][MAXLOG + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v, u, w);</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UEdge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> UEdge &amp;a, <span class="keyword">const</span> UEdge &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;uEdges[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (father[x] != x) &#123;</span><br><span class="line">father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r1 = find(x);</span><br><span class="line"><span class="keyword">int</span> r2 = find(y);</span><br><span class="line">father[r1] = r2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (find(uEdges[i].u) != find(uEdges[i].v)) &#123;</span><br><span class="line">merge(uEdges[i].u, uEdges[i].v);</span><br><span class="line">addEdge(nodes + uEdges[i].u, nodes + uEdges[i].v, uEdges[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXLOG + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(x);</span><br><span class="line">    x-&gt;depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    f[x - nodes][<span class="number">0</span>] = x;</span><br><span class="line">    g[x - nodes][<span class="number">0</span>] = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e-&gt;to-&gt;depth == <span class="number">0</span>) &#123;</span><br><span class="line">                e-&gt;to-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">                f[(e-&gt;to) - nodes][<span class="number">0</span>] = v;</span><br><span class="line">                g[(e-&gt;to) - nodes][<span class="number">0</span>] = e-&gt;w;</span><br><span class="line">                q.push(e-&gt;to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f[i][j] = f[f[i][j - <span class="number">1</span>] - nodes][j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//g[i][j] = g[i][j - 1] + g[f[i][j - 1] - nodes][j - 1];</span></span><br><span class="line">            g[i][j] = <span class="built_in">std</span>::min(g[i][j - <span class="number">1</span>], g[f[i][j - <span class="number">1</span>] - nodes][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;depth &lt; y-&gt;depth) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;depth &gt; y-&gt;depth) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = MAXLOG; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[x - nodes][i] &amp;&amp; f[x - nodes][i]-&gt;depth &gt;= y-&gt;depth) &#123;</span><br><span class="line">                min = <span class="built_in">std</span>::min(min, g[x - nodes][i]);</span><br><span class="line">                x = f[x - nodes][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = MAXLOG; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[x - nodes][i] != f[y - nodes][i]) &#123;</span><br><span class="line">                min = <span class="built_in">std</span>::min(min, g[x - nodes][i]);</span><br><span class="line">                min = <span class="built_in">std</span>::min(min, g[y - nodes][i]);</span><br><span class="line">                x = f[x - nodes][i];</span><br><span class="line">                y = f[y - nodes][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        min = <span class="built_in">std</span>::min(min, g[x - nodes][<span class="number">0</span>]);</span><br><span class="line">        min = <span class="built_in">std</span>::min(min, g[y - nodes][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;uEdges[i].u, &amp;uEdges[i].v, &amp;uEdges[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(uEdges + <span class="number">1</span>, uEdges + m + <span class="number">1</span>, UEdge::Cmp());</span><br><span class="line"></span><br><span class="line">init(n);</span><br><span class="line">kruskal(m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nodes[i].depth == <span class="number">0</span>) bfs(nodes + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (find(x) != find(y)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(nodes + x, nodes + y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【写的时候犯的错误】"><a href="#【写的时候犯的错误】" class="headerlink" title="【写的时候犯的错误】"></a>【写的时候犯的错误】</h3><h5 id="1、邻接表写反了"><a href="#1、邻接表写反了" class="headerlink" title="1、邻接表写反了"></a>1、邻接表写反了</h5><p>本来应该是这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v, u, w);</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果被写成了这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(v, u, w);</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2、BFS的时候没有处理好图不连通的情况，Naive的从1号点开始搜索了"><a href="#2、BFS的时候没有处理好图不连通的情况，Naive的从1号点开始搜索了" class="headerlink" title="2、BFS的时候没有处理好图不连通的情况，Naive的从1号点开始搜索了"></a>2、<code>BFS</code>的时候没有处理好图不连通的情况，Naive的从<code>1</code>号点开始搜索了</h5><h3 id="【吐槽】"><a href="#【吐槽】" class="headerlink" title="【吐槽】"></a>【吐槽】</h3><p><del>调了一个下午，我选择狗带</del></p><p>cyr太神啦，交了两次就A了！</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LCA </tag>
            
            <tag> 最大生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1217] 借教室 - 线段树 + 卡常数</title>
      <link href="/2016/10/25/codevs-1217/"/>
      <url>/2016/10/25/codevs-1217/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1217/" target="_blank" rel="noopener">Codevs 1217 借教室</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来$n$天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j, s_j, t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行包含两个正整数$n, m$，表示天数和订单的数量。</p><p>第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。</p><p>接下来有$m$行，每行包含三个正整数$d_j, s_j, t_j$，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>如果所有订单均可满足，则输出只有一行，包含一个整数 $0$ 。否则（订单无法完全满足）输出两行，第一行输出一个负整数$-1$，第二行输出需要修改订单的申请人编号。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>建立线段树维护区间最小值，一旦某个区间在修改之后最小值变为了负数那么这个方案就是不可满足的。</p><p>裸的线段树可以得到95分，在加入一些常数优化之后就可以A了。</p><p>比如我的代码自己是写的<code>max</code>和<code>min</code>，没有用<code>algorithm</code>里面的那个，结果就过掉了。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">minn</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">maxx</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, min, lazy, mid;</span><br><span class="line">SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">min = INT_MAX, lazy = <span class="number">0</span>, mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">min = minn(lc-&gt;min, rc-&gt;min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">min = a[l];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTags</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">lazy += delta;</span><br><span class="line">min -= delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">lc-&gt;addTags(lazy);</span><br><span class="line">rc-&gt;addTags(lazy);</span><br><span class="line"></span><br><span class="line">lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) &#123;</span><br><span class="line">addTags(delta);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pushDown();</span><br><span class="line"><span class="keyword">if</span> (l &lt; mid) &#123;</span><br><span class="line">lc-&gt;modify(l, minn(r, mid), delta);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">rc-&gt;modify(maxx(l, mid), r, delta);</span><br><span class="line">&#125;</span><br><span class="line">update();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SegmentTree <span class="title">st</span><span class="params">(<span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">st.build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)  &#123;</span><br><span class="line"><span class="keyword">int</span> delta, l, r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;delta, &amp;l, &amp;r);</span><br><span class="line">st.modify(l, r + <span class="number">1</span>, delta);</span><br><span class="line"><span class="keyword">if</span> (st.min &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n%d"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1287] 矩阵乘法 - 矩阵乘法</title>
      <link href="/2016/10/23/Matrix/"/>
      <url>/2016/10/23/Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1287/" target="_blank" rel="noopener">Codevs 1287 矩阵乘法</a></p><p>这是一道矩阵乘法的模板题，题目没有什么好说的，但是可以正好通过这个题目来学习一下矩阵乘法。</p><a id="more"></a><h3 id="【正文】"><a href="#【正文】" class="headerlink" title="【正文】"></a>【正文】</h3><p>在学习矩阵的时候，先学习了矩阵的加法、减法和数乘，都非常的简单和正常，只要每个对应位置做对应的操作就好了，然而到了乘法的时候，事情就开始变得奇♂怪起来了</p><blockquote><p>两个矩阵的乘法仅当第一个矩阵 $ A $ 的列数和另一个矩阵 $ B $ 的行数相等时才能定义。如 $ A $是 $ m \times p $矩阵， $ B $ 是 $ p \times n $ 矩阵，它们的乘积 $ C $ 是一个 $ m\times p $ 矩阵，它的一个元素$ C_{i, j} $由下面的运算得到：</p><script type="math/tex; mode=display">C_{ij} = \sum_{k = 1}^p A_{i, k}B_{k, j}</script></blockquote><p>这是什么鬼定义！为什么两个矩阵相乘会是这个鬼！根本就记不住好吧！<br>关于为什么两个矩阵相乘会变成这个鬼，实际上是这个样子的：<strong>矩阵本身就是线性方程式的简单表示法，它和线性方程式是一一对应的</strong></p><p>比如这是一个线性方程组：</p><script type="math/tex; mode=display">\left\{ \begin{array}{c}2x + y = 3    \\4x + 3y = 7\end{array}\right.</script><p>矩阵的最初目的本来就是为这样的方程组提供一个简写形式，上面的方程组可以简写为这样的矩阵的形式</p><script type="math/tex; mode=display">\left(  \begin{array}{ccc}    2 & 1 \\    4 & 3   \end{array}\right)\times \left(  \begin{array}{ccc}    x \\    y   \end{array}\right)= \left(  \begin{array}{ccc}    3 \\    7   \end{array}\right)</script><p>上面这个式子就基本说明了矩阵乘法的规则，在想不起来怎么做的时候自己写一个方程组然后变一下型就能想起来了</p><p>在<a href="http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html" target="_blank" rel="noopener">这篇文章</a>和<a href="http://www.matrix67.com/blog/archives/4294" target="_blank" rel="noopener">这篇文章</a>中比较详细的推导并证明了矩阵乘法的计算方式.</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> sizeX, sizeY;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span>* (<span class="keyword">const</span> Matrix &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="function">Matrix <span class="title">c</span><span class="params">(sizeX, b.sizeY)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sizeX; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.sizeY; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sizeY; k++) &#123;</span><br><span class="line">c.<span class="built_in">array</span>[i][j] += <span class="built_in">array</span>[i][k] * b.<span class="built_in">array</span>[k][j];       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix(<span class="keyword">int</span> sizeX, <span class="keyword">int</span> sizeY) : sizeX(sizeX), sizeY(sizeY) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ai, aj;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ai, &amp;aj);</span><br><span class="line"><span class="function">Matrix <span class="title">a</span><span class="params">(ai, aj)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ai; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aj; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a.<span class="built_in">array</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bi, bj;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;bi, &amp;bj);</span><br><span class="line"><span class="function">Matrix <span class="title">b</span><span class="params">(bi, bj)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bi; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bj; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b.<span class="built_in">array</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">c</span><span class="params">(ai, bj)</span></span>;</span><br><span class="line">c = a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*printf("The first matrix:\n");</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= ai; i++) &#123;</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= aj; j++) &#123;</span></span><br><span class="line"><span class="comment">printf("%d ", a.array[i][j]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("\n");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("The second matrix:\n");</span></span><br><span class="line"><span class="comment">for (int i = 1; i &lt;= bi; i++) &#123;</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt;= bj; j++) &#123;</span></span><br><span class="line"><span class="comment">printf("%d ", b.array[i][j]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("\n");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c.sizeX; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c.sizeY; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, c.<span class="built_in">array</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码实现上构造了一个矩阵类，并通过运算符重载使其支持乘法。还有一些细节，在乘法计算的三重循环中，对于一个$ m \times p $矩阵 $ A $，$ p \times n $ 矩阵 $ B $ ，第一重循环枚举 $ m $，第二重循环枚举 $ n $ ，第三重循环枚举 $ p $. </p><h3 id="【剩下的部分】"><a href="#【剩下的部分】" class="headerlink" title="【剩下的部分】"></a>【剩下的部分】</h3><p>矩阵乘法究竟有什么用呢？只要能计算乘法就可以计算幂，只要能计算幂就能用快速幂，所以就可以用矩阵快速幂来优化<strong>齐次线性递推</strong>的计算，将复杂度优化至 $ O(k^3 logn) $</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1048] 石子归并 - 区间DP</title>
      <link href="/2016/10/21/merge/"/>
      <url>/2016/10/21/merge/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1048/" target="_blank" rel="noopener">Codevs 1048 石子归并</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>有 $ n $ 堆石子排成一列，每堆石子有一个重量 $ w<em>i $,每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和 $ w_i + w</em>{i - 1} $ 。问安排怎样的合并顺序，能够使得总合并代价达到最小。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行一个整数 $ n (n \leq 100) $</p><p>第二行n个整数 $ w_1,w_2 \dots w_n(w_i \leq 100) $</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>一个整数表示最小合并代价</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><blockquote><p>这是一道区间DP入门题 ——  Hellc</p></blockquote><p>那我们就暂且认为这是一道区间DP的入门题，考虑按区间长度进行转移，设 $ f(l, r) $ 表示将闭区间 $ [l, r] $ 合并的最小代价，则状态转移为</p><script type="math/tex; mode=display">f(l, r) = \min\{f(l, k), f(k + 1, r)\} + sum(l ,r), k \in [l, r)</script><p>其中 $ sum(l, r) $ 表示 $ l $ 到 $ r $ 的区间和， 即</p><script type="math/tex; mode=display">sum(l ,r) = \sum_{i = l} ^ r w_i</script><p>边界条件为</p><script type="math/tex; mode=display">f(i, i) = 0</script><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a[r];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">return</span> a[r] - a[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l++) &#123;</span><br><span class="line"><span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d, %d] : \n"</span>, l, r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"   from: [%d, %d] + [%d, %d]\n"</span>, l, k, k + <span class="number">1</span>, r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">min = <span class="built_in">std</span>::min(f[l][k] + f[k + <span class="number">1</span>][r], min);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min != INT_MAX)&#123;</span><br><span class="line">f[l][r] = min + sum(l, r);</span><br><span class="line">&#125; <span class="keyword">else</span> f[l][r] = sum(l, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">1</span>][n]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1068] 乌龟棋 - 背包DP</title>
      <link href="/2016/10/20/chess/"/>
      <url>/2016/10/20/chess/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1068/" target="_blank" rel="noopener">Codevs 1068 乌龟棋</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>乌龟棋的棋盘是一行$ n $个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$ n $格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。乌龟棋中 $ m $ 张爬行卡片，分成4种不同的类型，每种类型的卡片上分别标有1、2、3、4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的 分数总和。求最多能得到多少分。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入的每行中两个数之间用一个空格隔开。 第1行2个正整数 $ n $ 和 $ m $ ，分别表示棋盘格子数和爬行卡片数。 第2行 $ n $ 个非负整数，其中 $ a_i $ 表示棋盘第 $ i $ 个格子上的分数。 第3行 $ m $ 个整数，$ b_1,b_2 \dots b_m $，表示 $ m $ 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光 $ m $ 张爬行卡片。</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出一行一个整数</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于 $ 30 \% $ 的数据有 $ 1 \leq n \leq 30 $，$ 1 \leq m \leq 12 $。</p><p>对于 $ 50 \% $ 的数据有 $ 1 \leq n \leq 120 $，$ 1 \leq m \leq 50 $，且 $ 4 $ 种爬行卡片，每种卡片的张数不会超过 $ 20 $。</p><p>对于 $ 100 \% $ 的数据有 $ 1 \leq n \leq 350 $ ，$ 1 \leq m \leq 120 $ ，且 $ 4 $ 种爬行卡片，每种卡片的张数不会超过 $ 40 $，$ 0 \leq ai \leq 100$ ，$ 1 \leq i \leq n $ ，$ 1 \leq bi \leq 4 $，$ 1 \leq i \leq m $。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>传说这是一道背包DP题，然而我并不知道是为什么。</p><p>因为最多只有 $ 4 $ 种卡片，所以我们可以使用四维数组 $ f[i][j][k][l] $ 来表示当前使用 $ i $ 张 $ 1 $ 号卡片，$ j $ 张 $ 2 $ 号卡片，$ k $ 张 $ 3 $ 号卡片，$ l $ 张 $ 4 $ 号卡片所获得的最大价值</p><p>状态转移为</p><script type="math/tex; mode=display">f(i, j, k, l) = \max\begin{cases}f(i - 1, j, k, l)    \\\[2ex]f(i, j - 1, k, l)    \\\[2ex]f(i, j, k - 1, l)    \\\[2ex]f(i, j, k, l - 1)    \end{cases}+a(i \times 1 + j \times 2 + k \times 3 + l \times 4)</script><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">350</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXM];</span><br><span class="line"><span class="keyword">int</span> f[MAXX][MAXX][MAXX][MAXX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[<span class="number">0</span>]);</span><br><span class="line">b[b[<span class="number">0</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b[<span class="number">1</span>]; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= b[<span class="number">2</span>]; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= b[<span class="number">3</span>]; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= b[<span class="number">4</span>]; l++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i) maxx = maxx &gt; f[i - <span class="number">1</span>][j][k][l] ? maxx : f[i - <span class="number">1</span>][j][k][l];</span><br><span class="line"><span class="keyword">if</span> (j) maxx = maxx &gt; f[i][j - <span class="number">1</span>][k][l] ? maxx : f[i][j - <span class="number">1</span>][k][l];</span><br><span class="line"><span class="keyword">if</span> (k) maxx = maxx &gt; f[i][j][k - <span class="number">1</span>][l] ? maxx : f[i][j][k - <span class="number">1</span>][l];</span><br><span class="line"><span class="keyword">if</span> (l) maxx = maxx &gt; f[i][j][k][l - <span class="number">1</span>] ? maxx : f[i][j][k][l - <span class="number">1</span>];</span><br><span class="line">f[i][j][k][l] = maxx + a[i + <span class="number">2</span> * j + <span class="number">3</span> * k + <span class="number">4</span> * l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[b[<span class="number">1</span>]][b[<span class="number">2</span>]][b[<span class="number">3</span>]][b[<span class="number">4</span>]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【其他】"><a href="#【其他】" class="headerlink" title="【其他】"></a>【其他】</h3><p>每次重新计算 $maxx$ 时一定要记得先初始化为 $ 0 $ ，每一次都要初始化</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1058]合唱队形 - 序列DP</title>
      <link href="/2016/10/19/Codevs_1058/"/>
      <url>/2016/10/19/Codevs_1058/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>$n$位同学站成一排，音乐老师要请其中的$(n-k)$位同学出列，使得剩下的$k$位同学排成合唱队形。</p><p>合唱队形是指这样的一种队形：设$k$位同学从左到右依次编号为$1，2 \dots K$，他们的身高分别为$t<em>1，t_2，…，t_k$，  则他们的身高满足$t_1&lt; \dots &lt; t_i &gt; t</em>{i+1} &gt; \dots &gt;t_k(1 \leq i \leq k)$。</p><p>你的任务是，已知所有$n$位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><a id="more"></a><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行是一个整数$n(2 \leq N \leq 100)$，表示同学的总数。第一行有$n$个整数，用空格分隔，第$i$个整数$t_i(130 \leq t_i \leq 230)$是第$i$位同学的身高(厘米)。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于$50\%$的数据，保证有$n \leq 20$</p><p>对于$100\%$的数据，保证有$n \leq 100$。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>正着跑一边<code>LIS</code>反着跑一遍<code>LIS</code>，然后枚举中间点选出最大值即可，反正$n$这么小随便怎么搞都可以啦。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN], f[MAXN], g[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *tmp, <span class="keyword">int</span> *in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">tmp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] &gt; in[j] &amp;&amp; tmp[j] + <span class="number">1</span> &gt; tmp[i]) &#123;</span><br><span class="line">tmp[i] = tmp[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">b[n - i + <span class="number">1</span>] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lis(<span class="number">1</span>, n, f, a);</span><br><span class="line">lis(<span class="number">1</span>, n, g, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt;= f[i] + g[n - i + <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">max = f[i] + g[n - i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n - max);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 序列DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 2370] 小机房的树 - 最近公共祖先 + 倍增</title>
      <link href="/2016/10/17/LCA/"/>
      <url>/2016/10/17/LCA/</url>
      
        <content type="html"><![CDATA[<p>倍增算法的上一部分：<br><a href="http://ilern.coding.me/428/%E5%80%8D%E5%A2%9E/" target="_blank" rel="noopener">利用倍增算法加速区间操作</a></p><h3 id="【倍增算法求LCA】"><a href="#【倍增算法求LCA】" class="headerlink" title="【倍增算法求LCA】"></a>【倍增算法求LCA】</h3><p>LCA(Lowest Common Ancestors), 字面意思为“最近公共祖先”</p><blockquote><p>对于有根树$T$的两个结点$u$、$v$，最近公共祖先$LCA(T, u, v)$表示一个结点$x$，满足$x$是$u$、$v$的祖先且$x$的深度尽可能大。</p></blockquote><a id="more"></a><p>设 $f(i, j)$ 表示 $i$ 号节点向上跳 $2^j$ 步所到达的节点的编号，则可以用下面的式子递推得到</p><script type="math/tex; mode=display">f(i, j) = f(f(i, j - 1), j - 1)</script><p>在处理的时候先$DFS$一遍处理出每个节点的深度，然后开始让两个节点中较深的那一个向上跳直到两个节点到<strong>同一深度</strong>，然后让两个节点一起向上跳， 直到两个节点到<strong>重合前的前一层</strong>， 向上再走一步， 到达的就是两个点的最近公共祖先。</p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>树上有N个节点，节点标号为0到N-1，已知从某个节点爬到其父亲节点要花费 c 的能量（从父亲节点爬到此节点也相同），找出一条花费精力最短的路</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>第一行一个$n$，接下来$n-1$行每一行有三个整数$u，v， c$ 。表示节点$u$ 爬到节点 $v$ 需要花费 $c$ 的精力。<br>第$n+1$行有一个整数$m$表示有$m$次询问。接下来$m$行每一行有两个整数$ u, v $表示两只虫子所在的节点。</p><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>一共有$m$行，每一行一个整数，表示对于该次询问所得出的最短距离。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>$1 \leq n \leq 50000$</p><p>$1 \leq m \leq 75000$ </p><p>$0 \leq c \leq 1000$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>已知在一棵树上两个节点间的简单路径是唯一的，就是经过LCA的那一条，所以只需要求出LCA并且顺便维护两个点在跳到LCA之前所经过的路径和就好了</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line">Edge *edges;</span><br><span class="line"></span><br><span class="line">Node() : depth(<span class="number">0</span>), edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN], *f[MAXN][MAXLOG + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXLOG + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v, u ,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">x-&gt;depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">f[x - nodes][<span class="number">0</span>] = x;</span><br><span class="line">g[x - nodes][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span>(e-&gt;to-&gt;depth == <span class="number">0</span>) &#123;</span><br><span class="line">e-&gt;to-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">f[(e-&gt;to) - nodes][<span class="number">0</span>] = v;</span><br><span class="line">g[(e-&gt;to) - nodes][<span class="number">0</span>] = e-&gt;w;</span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i][j] = f[f[i][j - <span class="number">1</span>] - nodes][j - <span class="number">1</span>];</span><br><span class="line">g[i][j] = g[i][j - <span class="number">1</span>] + g[f[i][j - <span class="number">1</span>] - nodes][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(Node *x, Node *y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x-&gt;depth &lt; y-&gt;depth) &#123;</span><br><span class="line"><span class="built_in">std</span>::swap(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x-&gt;depth &gt; y-&gt;depth) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAXLOG; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[x - nodes][i] &amp;&amp; f[x - nodes][i]-&gt;depth &gt;= y-&gt;depth) &#123;</span><br><span class="line">sum += g[x - nodes][i];</span><br><span class="line"></span><br><span class="line">x = f[x - nodes][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = MAXLOG; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[x - nodes][i] != f[y - nodes][i]) &#123;</span><br><span class="line">sum += g[x - nodes][i];</span><br><span class="line">sum += g[y - nodes][i];</span><br><span class="line"></span><br><span class="line">x = f[x - nodes][i];</span><br><span class="line">y = f[y - nodes][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum += g[x - nodes][<span class="number">0</span>];</span><br><span class="line">sum += g[y - nodes][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">u++, v++;</span><br><span class="line">addEdge(nodes + u, nodes + v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfs(nodes + <span class="number">1</span>);</span><br><span class="line">build(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">x++, y++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(nodes + x, nodes + y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【写的时候犯的错误】"><a href="#【写的时候犯的错误】" class="headerlink" title="【写的时候犯的错误】"></a>【写的时候犯的错误】</h3><p>1、数组从 1 开始编号，编号不统一</p><p>2、在<code>lca()</code>中<code>sum</code>和<code>x</code>的修改顺序颠倒了</p><p>3、取节点编号的时候把<code>x - nodes</code>写成了<code>nodes - x</code>结果就段错误了</p><p>4、在<code>bfs()</code>中只给<code>f</code>数组赋了初值而没有初始化<code>g</code>数组</p><h3 id="【对代码内容的一点说明】"><a href="#【对代码内容的一点说明】" class="headerlink" title="【对代码内容的一点说明】"></a>【对代码内容的一点说明】</h3><p>$f(i, j)$表示从$i$号节点向上跳$2^j$步后到达的节点</p><p>$g(i, j)$表示从$i$号节点向上跳$2^j$步后所经过的路径和</p><p>树用邻接表存，因为在这道题当中树的形态是不重要的</p><p>数组从 1 开始编号，而题目中是从 0 开始编号的，所以有些地方会 <del>+1s</del> 加一</p><p>MAXLOG是树最大层数，数值上等于节点数的以二位底的对数</p><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p>%%% Hellc大神，自己调了一上午没过的题，Hellc半个小时就调过了，真是太神啦！</p><p>自己还是太弱……不过似乎学到了一些实用的调试技巧，以后要尝试应用在自己调试的过程中。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1200] 同余方程 - 数论相关 + 逆元</title>
      <link href="/2016/10/16/phi/"/>
      <url>/2016/10/16/phi/</url>
      
        <content type="html"><![CDATA[<h3 id="【传送门】"><a href="#【传送门】" class="headerlink" title="【传送门】"></a>【传送门】</h3><p><a href="http://codevs.cn/problem/1200/" target="_blank" rel="noopener">Codevs 1200 同余方程</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>求关于方程$ax \equiv 1 \pmod b$的最小正整数解</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入只有一行，包含两个正整数$a$, $b$, 中间用一个空格间隔开</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出只有一行一个正整数$x_0$, 即最小正整数解, 输入数据保证一定有解</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>对于$40\%$的数据，$2 \leq b \leq 1000$</p><p>对于$60\%$的数据，$2 \leq b \leq 50000000$</p><p>对于$100\%$的数据，$2 \leq a, b \leq 2000000000$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这是一道数论题, 题目要求解一个简单的同余方程, 出题人很良心地让$ax$ 与 $1$ 同余, 这样题目就变成了裸的求逆元, 解法也就不止一种了</p><h4 id="算法一【欧拉定理求逆元】"><a href="#算法一【欧拉定理求逆元】" class="headerlink" title="算法一【欧拉定理求逆元】"></a>算法一【欧拉定理求逆元】</h4><p>欧拉定理：</p><script type="math/tex; mode=display">a^{\varphi(b)} \equiv 1 \pmod b</script><p>稍微变形可得：</p><script type="math/tex; mode=display">a \times a^{\varphi(b) - 1} \equiv 1 \pmod b</script><p>会发现这里的$a^{\varphi(b) - 1}$就是我们要求的$x$, 用快速幂算一下就可以了。</p><p>$\varphi(n)$是什么?它叫做欧拉函数, 表示的是不大于$n$的正整数中与$n$互质的数的个数……</p><h4 id="算法二-【拓展欧几里得求逆元】"><a href="#算法二-【拓展欧几里得求逆元】" class="headerlink" title="算法二 【拓展欧几里得求逆元】"></a>算法二 【拓展欧几里得求逆元】</h4><p>这种算法据说常数会比用欧拉函数来求要小一些, 所以对于求逆元来说更优一些</p><p>留坑待填……</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">int</span> ans = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">n /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mulMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((x % b) * (y % b)) % b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> mulMod(fastPowMod(m, n<span class="number">-1</span>), m);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fastPowMod(mulMod(m, m), n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = phi(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, fastPowMod(a, x - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【最后】"><a href="#【最后】" class="headerlink" title="【最后】"></a>【最后】</h3><p><a href="https://5261.github.io/Basic-Number-Theory-1/" target="_blank" rel="noopener">这是Hellc关于数论的博客1</a></p><p><a href="https://5261.github.io/Basic-Number-Theory-2/" target="_blank" rel="noopener">这是Hellc关于数论的博客2</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> NOIp </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何编写数据生成器并实现对拍</title>
      <link href="/2016/10/13/DO/"/>
      <url>/2016/10/13/DO/</url>
      
        <content type="html"><![CDATA[<p>在算法竞赛的过程中， 常常会遇到自己想出了一个复杂度低的算法但却不能严格证明其正确性的情况， 或者说一道题调试了很久就是有那么一两个点过不去， 这个时候常会让人有种弃疗的冲动， 所以这个时候一个简单而有用的技巧就非常有用了，就是传说中的对拍</p><a id="more"></a><p>所谓对拍， 就是指让两个程序同时运行， 比较他们的输出， 如果出现不同， 就停止。 比如说在竞赛中不能确定高效的算法是否真的正确， 就可以写一个暴力， 让他们同时运行， 如果出现了不一样的输出， 那么肯定说明这两个程序中至少有一个写错了， 这时我们得到了一组使程序错误的数据， 然后就可以面向数据调试了。</p><p>在实现对拍之前，我们首先需要一个数据生成器，可以自己产生随机数据，输出到标程和自己程序的输入文件中， 再调用Windows下的<code>fc</code>命令比较标程和自己程序的输出文件， 相同就再生成一组，再运行一次， 直到找到不同为止。</p><p>下面是一个例子：<br>对于音乐会的等待这道 <del>毒瘤</del> 题目， 可以用这样的数据生成器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"in.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> n = rand() % MAX;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = rand() % INT_MAX;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而对拍程序就像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">system(<span class="string">"datamaker.exe"</span>);</span><br><span class="line">system(<span class="string">"1823.exe"</span>);</span><br><span class="line">system(<span class="string">"1823_b.exe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"fc out1.txt out2.txt"</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error!%d"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷 1823]音乐会的等待 - 单调栈</title>
      <link href="/2016/10/12/Stack/"/>
      <url>/2016/10/12/Stack/</url>
      
        <content type="html"><![CDATA[<h3 id="【入场券】"><a href="#【入场券】" class="headerlink" title="【入场券】"></a>【入场券】</h3><p><a href="https://www.luogu.org/problem/show?pid=1823" target="_blank" rel="noopener">洛谷 1823 音乐会的等待</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>$N$个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人$A$和$B$，如果他们是相邻或他们之间没有人比$A$<strong>或</strong>$B$高，那么他们是可以互相看得见的。</p><p>写一个程序计算出有多少对人可以互相看见。</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入的第一行包含一个整数$N (1 \leq N \leq 500000)$, 表示队伍中共有$N$个人。</p><p>接下来的$N$行中，每行包含一个整数，表示人的高度，以毫微米(等于$10 ^ {-9}$米)为单位，每个人的调度都小于$2^{31}$毫微米。这些高度分别表示队伍中人的身高。</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出仅有一行，包含一个数$S$，表示队伍中共有$S$对人可以互相看见。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>考虑维护一个单调递减的单调栈。</p><p>在第$i$个人进入时， 栈里保存的是能和$i$互相看到的人。</p><p>先从栈顶向下搜索， 遇到不比$i$ 高的就把答案加一，当遇到第一个比$i$高的人的时候再加一， 退出循环。</p><p>然后再从栈顶开始向下找， 在栈里一个个弹出比$i$矮的人， 因为为了维护栈内元素的单调性， 如果栈中存在比$i$矮的人，当$i$ 进来之后他就会被$i$挡住， 后面的人就再也不能看到他了， 这个时候保存他是没有意义的， 反而会在第一步统计答案的过程中被多加进去。</p><p>另外特别要注意的一点就是当栈中存在身高相等的人，后边的人是两个人都能看到的（计入答案），所以这个时候不存在挡住的情况（不弹出），所以这样的情况只计入答案但不弹出。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">a[++cnt] = x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; x) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(a[cnt] &lt; x &amp;&amp; cnt &gt;= <span class="number">1</span>) cnt--;</span><br><span class="line"></span><br><span class="line">a[++cnt] = x;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【吐槽】"><a href="#【吐槽】" class="headerlink" title="【吐槽】"></a>【吐槽】</h3><p>这题虽然是一个裸的单调栈结果我却写了两个晚上， 交了20多次才AC，开始试图使用<code>std::stack</code>， 后来又尝试<code>std::vector</code>, 但是因为迭代器不会用所以爆炸了 orz ,最后无奈只能手动实现单调栈（虽然并不难写）， 就是这样一道并不难写代码只有短短30几行的题莫名其妙困住了多名LYOI选手， 最后还是Menci神犇一遍AC %%%</p><p>另外就是在做这题的过程中收获到了各种各样的错误信息， 甚至18AC 2TLE， 最后把一个<code>for</code>循环改成<code>while</code>循环就莫名其妙AC了， 真是神奇……</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1044]拦截导弹 - 序列DP</title>
      <link href="/2016/10/12/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/"/>
      <url>/2016/10/12/%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h3><p><a href="http://codevs.cn/problem/1044/" target="_blank" rel="noopener">Codevs 1044 拦截导弹</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹</p><h3 id="【输入描述】"><a href="#【输入描述】" class="headerlink" title="【输入描述】"></a>【输入描述】</h3><p>输入导弹依次飞来的高度（雷达给出的高度数据是不大于 $ 30000 $ 的正整数）</p><a id="more"></a><h3 id="【输出描述】"><a href="#【输出描述】" class="headerlink" title="【输出描述】"></a>【输出描述】</h3><p>输出这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><h3 id="【数据范围及提示】"><a href="#【数据范围及提示】" class="headerlink" title="【数据范围及提示】"></a>【数据范围及提示】</h3><p>导弹的高度$\leq 30000$，导弹个数$\leq 20$</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>这道题目的第一问是非常经典的“最长<strong>不上升</strong>子序列”问题, 有复杂度为$O(n ^ 2)$的算法和$O(nlogn)$的算法， 其中$O(n ^ 2)$的算法很容易想到， 用$d[i]$表示以$i$为<strong>结尾</strong>的最长<strong>不上升</strong>子序列长度， 状态转移为</p><script type="math/tex; mode=display">d(i) = \max \{0, d(j) | j < i, A_i \leq A_j\} + 1</script><p>初始化时每个$i$的$d[i] = 1$</p><p>类似的， 还有“最长<strong>不下降</strong>子序列”， “最长<strong>上升</strong>子序列”， “最长<strong>下降</strong>子序列”， 解决方法都是类似的。甚至说要求一个序列的最长<strong>不下降</strong>子序列只要把这个序列倒序存储然后求一下新序列的最长<strong>上升</strong>子序列就好了。</p><p>至于第二问……可以看做是最长链的最小划分，根据某玄学的$Dilworth$定理:</p><blockquote><p>反链是一种偏序集，其任意两个元素不可比；而链则是一种任意两个元素可比的偏序集。Dilworth定理说明，存在一个反链A与一个将序列划分为链族P的划分，使得划分中链的数量等于集合A的基数。当存在这种情况时，对任何至多能包含来自P中每一个成员一个元素的反链，A一定是此序列中的最大反链。同样地，对于任何最少包含A中的每一个元素的一个链的划分，P也一定是序列可以划分出的最小链族。偏序集的宽度被定义为A与P的共同大小。<br>另一种Dilworth定理的等价表述是：在有穷偏序集中，任何反链最大元素数目等于任何将集合到链的划分中链的最小数目。一个关于无限偏序集的理论指出，在此种情况下，一个偏序集具有有限的宽度w，当且仅当它可以划分为最少w条链。反链是一种偏序集，其任意两个元素不可比；而链则是一种任意两个元素可比的偏序集。Dilworth定理说明，存在一个反链A与一个将序列划分为链族P的划分，使得划分中链的数量等于集合A的基数。当存在这种情况时，对任何至多能包含来自P中每一个成员一个元素的反链，A一定是此序列中的最大反链。同样地，对于任何最少包含A中的每一个元素的一个链的划分，P也一定是序列可以划分出的最小链族。偏序集的宽度被定义为A与P的共同大小。<br>另一种Dilworth定理的等价表述是：在有穷偏序集中，任何反链最大元素数目等于任何将集合到链的划分中链的最小数目。一个关于无限偏序集的理论指出，在此种情况下，一个偏序集具有有限的宽度w，当且仅当它可以划分为最少w条链。</p></blockquote><p><del>显然我根本看不懂它在说什么</del> 可知， <em>链的最少划分数 = 反链的最长长度。</em> 所以只要求出最长<strong>不上升</strong>子序列的反链也就是最长<strong>下降</strong>子序列的长度就好了， 这个时候我们只需要把整个序列倒过来然后再跑一边第一问的代码，代码都不用改</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;const int MAXN = 20 + 5;int a[MAXN], d[MAXN], tmp[MAXN], f[MAXN];int main() {    int cnt = 1;    while(scanf(&quot;%d&quot;, &amp;a[cnt]) == 1) {        cnt++;    }    for(int i = 1; i &lt; cnt; i++) {        tmp[i] = a[cnt - i];    }    for(int i = 1; i &lt; cnt; i++) {        d[i] = 1; f[i] = 1;        for(int j = 1; j &lt; i; j++) {            if(tmp[j] &lt; tmp[i] &amp;&amp; d[j] + 1 &gt; d[i]) {                d[i] = d[j] + 1;            }            if(a[j] &lt;= a[i] &amp;&amp; f[j] + 1 &gt; f[i]) {                f[i] = f[j] + 1;            }        }    }    int max1 = d[1], max2 = f[1];    for(int i = 1; i &lt; cnt; i++) {        if(max1 &lt; d[i]) {            max1 = d[i];        }        if(max2 &lt; f[i]) {            max2 = f[i];        }    }    printf(&quot;%d\n%d&quot;, max1, max2);    return 0;}</code></pre><h3 id="【吐槽】"><a href="#【吐槽】" class="headerlink" title="【吐槽】"></a>【吐槽】</h3><p>再刚开始写这道题的时候， 听信了辣鸡参考书《信息学奥赛一本通》p273上的题解，错误的算成了最长<strong>不下降</strong>子序列的长度， 结果每次输出的结果和样例正好相反 Orz</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 序列DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习题整理</title>
      <link href="/2016/10/10/problems2/"/>
      <url>/2016/10/10/problems2/</url>
      
        <content type="html"><![CDATA[<p>整理了在国庆集训期间的习题，以后加油慢慢啃掉</p><p>完成度(12 / 17)</p><ul><li>[x] <strong>音乐会的等待</strong> —— 单调栈</li><li>[x] <strong>POJ 2823 Sliding Window</strong> —— 单调队列</li><li>[ ] <strong>Codevs 3622 假期</strong> —— 并查集优化</li><li>[x] <strong>Codevs 4600 程序自动分析</strong> —— 并查集</li><li>[ ] <strong>POJ 1456 Supermarket</strong>—— 贪心 + 并查集优化</li><li>[x] <strong>POJ 3264 Balanced Lineup</strong> ——ST表求RMQ</li><li>[x] <strong>线段树练习1~5</strong> —— 线段树</li><li>[x] <strong>POJ 2777 Count Color</strong> —— 线段树</li><li>[x] <strong>POJ 3468 A Simple Problem with Integers</strong> —— 线段树</li><li>[x] <strong>Codevs 2152 滑雪</strong> —— 普通DP</li><li>[x] <strong>Codevs 1102 采药</strong>—— 背包DP</li><li>[ ] <strong>POJ 1952 BUY LOW, BUY LOWER</strong> —— 线性DP</li><li>[x] <strong>POJ 1738 石子归并</strong> —— 区间DP</li><li>[x] <strong>Codevs 1380 没有上司的舞会</strong> —— 树形DP</li><li>[ ] <strong>POJ 2486 Apple tree</strong> —— 树形DP</li><li>[ ] <strong>POJ 2152 Fire</strong> —— 树形DP</li><li>[x] <strong>POJ 2367 Genealogical tree</strong> —— 拓扑排序</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[codevs 2833]奇怪的梦境 - 拓扑排序</title>
      <link href="/2016/09/25/sort/"/>
      <url>/2016/09/25/sort/</url>
      
        <content type="html"><![CDATA[<h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给出$n$个按钮，和其中要求的顺序关系， 判断是否存在拓扑序列</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://codevs.cn/problem/2833/" target="_blank" rel="noopener">codevs 2833 奇怪的梦境</a></p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>裸 <del>水</del> 的拓扑排序，每在拓扑序列中加入一个点就 <code>sum++</code> ， 最后要求的不在拓扑序列中的数目就直接用总数减掉就好了</p><p>在实现上使用了邻接表（乱搞）我也不知道为什么会这么长orz</p><a id="more"></a><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Edge *edges;</span><br><span class="line"><span class="keyword">int</span> num; </span><br><span class="line"></span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), num(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr, *to;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u, v);</span><br><span class="line">v-&gt;num++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Edge *e = u-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">e-&gt;to-&gt;num--;</span><br><span class="line"><span class="comment">//delete e;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">addEdge(nodes + u, nodes + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nodes[i].num == <span class="number">0</span>) &#123;</span><br><span class="line">q.push(nodes + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">sum++;</span><br><span class="line"></span><br><span class="line">delEdge(v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span>(e-&gt;to-&gt;num == <span class="number">0</span>) &#123;</span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sum == n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"o(∩_∩)o"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"T_T\n%d"</span>, n - sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 3538 &amp;&amp; Codevs 1696]奇怪的函数 - 二分答案</title>
      <link href="/2016/09/16/%E4%BA%8C%E5%88%862/"/>
      <url>/2016/09/16/%E4%BA%8C%E5%88%862/</url>
      
        <content type="html"><![CDATA[<h3 id="codevs-3538-amp-amp-codevs-1696-奇怪的函数"><a href="#codevs-3538-amp-amp-codevs-1696-奇怪的函数" class="headerlink" title="codevs 3538 &amp;&amp; codevs 1696 奇怪的函数"></a>codevs 3538 &amp;&amp; codevs 1696 奇怪的函数</h3><h4 id="【题目链接】"><a href="#【题目链接】" class="headerlink" title="【题目链接】"></a>【题目链接】</h4><p><a href="http://codevs.cn/problem/3538/" target="_blank" rel="noopener">codevs 3538 奇怪的函数</a><br><a href="http://codevs.cn/problem/1696/" target="_blank" rel="noopener">codevs 1696 奇怪的函数</a></p><h4 id="【题目内容】"><a href="#【题目内容】" class="headerlink" title="【题目内容】"></a>【题目内容】</h4><p>使得$x^x$达到或超过$n$位数字的最小正整数$x$是多少? $n \leq 2 000 000 000$ (2后面9个0)</p><a id="more"></a><h4 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h4><p>当时学分治的时候的一道没写的例题，突然想起来就花点时间A掉了.</p><p>在codevs 1696中给出了一个公式可以来求一个数的位数，大概长这个样子：</p><script type="math/tex; mode=display">ans = \lfloor n \times \log_{10}n \rfloor + 1</script><p>知道了这个公式那就好办了，二分答案，边界直接设$1$到$2 000 000 000$就可以，因为最坏递归计算$log_22 000 000 000 \thickapprox 31$次 </p><p>另外就是因为$n$很大所以尽量用<code>long long</code>否则 <del>可能</del> 会 <del>莫名</del> 狗带</p><h4 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">2000000000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//if(n == 1) return 1;</span></span><br><span class="line"><span class="comment">//return floor(n * log10(n)) + 1;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">floor</span>(n * <span class="built_in">log10</span>(n)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> l, <span class="keyword">long</span> <span class="keyword">long</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, l);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(calc(mid) &gt;= n) &#123;</span><br><span class="line">func(l, mid);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">func(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, MAXN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIp历届题目</title>
      <link href="/2016/09/11/NOIp/"/>
      <url>/2016/09/11/NOIp/</url>
      
        <content type="html"><![CDATA[<h3 id="NOIP"><a href="#NOIP" class="headerlink" title="NOIP"></a>NOIP</h3><p>完成度(54 / 80）</p><ul><li><p>2016</p><ul><li>[x] 玩具谜题 </li><li>[ ] 天天爱跑步</li><li>[x] 换教室</li><li>[x] 组合数问题</li><li>[x] 蚯蚓</li><li>[x] 愤怒的小鸟</li></ul></li><li><p>2015</p><ul><li>[x] 神奇的幻方</li><li>[x] 信息传递</li><li>[ ] 斗地主</li><li>[x] 跳石头</li><li>[ ] 子串</li><li>[ ] 运输计划</li></ul></li><li><p>2014</p><ul><li>[x] 生活大爆炸版石头剪刀布</li><li>[x] 联合权值</li><li>[ ] 飞扬的小鸟</li><li>[x] 无线网络发射器选址</li><li>[x] 寻找道路</li><li>[ ] 解方程</li></ul></li><li><p>2013</p><ul><li>[x] 转圈游戏</li><li>[x] 火柴排队</li><li>[x] 货车运输</li><li>[x] 积木大赛</li><li>[x] 花匠</li><li>[ ] 华容道</li></ul></li><li><p>2012</p><ul><li>[x]  Vigenère 密码<a id="more"></a></li><li>[x] 国王游戏</li><li>[ ] 开车旅行</li><li>[x] 同余方程</li><li>[x] 借教室</li><li>[ ] 疫情控制</li></ul></li><li><p>2011</p><ul><li>[x] 铺地毯</li><li>[x] 选择客栈</li><li>[ ] mayan 游戏</li><li>[x] 计算系数</li><li>[x] 聪明的质检员</li><li>[ ] 观光公交</li></ul></li><li><p>2010</p><ul><li>[x] 机器翻译</li><li>[x] 乌龟棋</li><li>[x] 关押罪犯</li><li>[x] 饮水入城</li></ul></li><li><p>2009</p><ul><li>[x] 潜伏者</li><li>[x] Hankson 的趣味题</li><li>[ ] 最优贸易</li><li>[ ] 靶型数独</li></ul></li><li><p>2008</p><ul><li>[x] 笨小猴</li><li>[x] 火柴棒等式</li><li>[x] 传纸条</li><li>[ ] 双栈排序</li></ul></li><li><p>2007</p><ul><li>[x] 统计数字</li><li>[ ] 字符串的展开</li><li>[x] 矩阵取数游戏</li><li>[ ] 树网的核</li></ul></li><li><p>2006</p><ul><li>[x] 能量项链</li><li>[x] 金明的预算方案</li><li>[ ] 作业调度方案</li><li>[ ] 2k进制数</li></ul></li><li><p>2005</p><ul><li>[x] 谁拿了最多奖学金</li><li>[ ] 过河</li><li>[ ] 篝火晚会</li><li>[ ] 等价表达式</li></ul></li><li><p>2004</p><ul><li>[x] 津津的储蓄计划</li><li>[x] 合并果子</li><li>[x] 合唱队形</li><li>[ ] 虫食算</li></ul></li><li><p>2003</p><ul><li>[x] 神经网络</li><li>[ ] 侦探推理</li><li>[x] 加分二叉树</li><li>[ ] 传染病控制</li></ul></li><li><p>2002</p><ul><li>[x] 均分纸牌</li><li>[x] 字串变换</li><li>[x] 自由落体</li><li>[ ] 矩形覆盖</li></ul></li><li><p>2001</p><ul><li>[x] 一元三次方程求解</li><li>[x] 数的划分</li><li>[x] 统计单词个数</li><li>[ ] Car的旅行路线</li></ul></li><li><p>2000</p><ul><li>[x] 进制转换</li><li>[x] 乘积最大</li><li>[x] 单词接龙</li><li>[x] 方格取数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于结构体</title>
      <link href="/2016/09/11/struct/"/>
      <url>/2016/09/11/struct/</url>
      
        <content type="html"><![CDATA[<p>听 Hellc 神犇讲了结构体，写来总结一下</p><p>在c++当中，允许用户自定义结构体，结构体就是一个可以包含不同数据类型的一个结构，它是一种可以自己定义的数据类型，定义一个 结构体 就相当于定义了一个自己的 类型 ，可以对其进行一些方便的操作</p><a id="more"></a><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>当我们定义了一个结构体时，其中通常会有一些成员变量，来描述这个这个类型的数据的某一部分，比如对于一个学生，我们建立一个<code>Student</code>结构体(类)，其中包含<code>name</code>和<code>birthday</code>两个成员，分别描述这个学生的姓名和生日<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> birthday;</span><br><span class="line">&#125;student, *student_1;</span><br></pre></td></tr></table></figure></p><p>对于每一个成员，我们可以使用<code>.</code>运算符,通过 <code>student.name</code> 这种语法从一个结构体中获得；类似的，当我们拥有一个指向某个<code>Student</code>类型的指针的时候，可以使用 <code>-&gt;</code> 运算符，通过 <code>student_1-&gt;name</code> 这种语法来获得某一个成员变量，相当于 <code>*student_1.name</code>。</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>在 c++ 当中，除了允许在结构体中包含一些成员变量，还允许一个结构体中有成员函数。成员变量相当于这个结构的某一个部分，那么成员函数就是可以对这个结构进行的一些操作。 <del>就像车.轮子和车.开车()</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> birthday;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">2016</span> - birthday);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure><p>在上面这个结构体中，定义了一个成员函数，用来输出这个学生的年龄，因为成员函数也是结构体中的一个成员，所以同样可以用<code>.</code> 和 <code>-&gt;</code> 运算符来访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> birthday;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">2016</span> - birthday);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st, *st_1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st_1 = <span class="keyword">new</span> Student();<span class="comment">// 否则st_1作为一个野指针指向0x00000000这个地址，不能直接访问，会段错误；</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;st.birthday);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;st_1-&gt;birthday);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, st.birthday);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, st_1-&gt;birthday);</span><br><span class="line">    st.printAge();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    st_1-&gt;printAge();</span><br><span class="line">    <span class="keyword">delete</span> st_1;<span class="comment">// new出来的东西要记得delete掉，这是一个好习惯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的成员函数，它与结构体的名称相同，在每次定义该结构体类型的变量的时候都会被调用，作用就是 构造 一个该结构体类型的变量</p><p>下面的代码演示了使用构造函数讲一个分数结构体初始化为 $\frac{1}{1}$ 如果不使用构造函数，在结构体定义在全局的情况下会默认初始化为$0$，但是定义在局部，就会被初始化为一个莫名其妙的数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    Number() &#123;</span><br><span class="line">        a = b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d / %d"</span>, number.a, number.b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>c++当中提供了很多运算符， 但这些运算符只能滋磁c++内置的类型，对于自己定义的类型，可以使用“重载运算符”的方法为自定义的类型定义运算符，比如可以对刚才的分数结构体定义加减乘除等运算</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些习题</title>
      <link href="/2016/08/29/problems/"/>
      <url>/2016/08/29/problems/</url>
      
        <content type="html"><![CDATA[<p>很久以前Menci同学整理的 <del>水</del> 习题，但是因为 <del>懒</del> 没时间所以一直没有做……</p><p>完成度(21 / 25)</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul><li>[x] <a href="http://codevs.cn/problem/2010/" target="_blank" rel="noopener">codevs 2010  求后序遍历</a></li><li>[ ] <a href="http://codevs.cn/problem/1094/" target="_blank" rel="noopener">codevs 1094 FBI树</a></li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li>[x] <a href="http://codevs.cn/problem/1063/" target="_blank" rel="noopener">codevs 1063 合并果子</a></li><li>[x] <a href="http://codevs.cn/problem/2573/" target="_blank" rel="noopener">codevs 2573 黑匣子</a></li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><ul><li>[x] <a href="http://codevs.cn/problem/1073/" target="_blank" rel="noopener">codevs 1073 家族</a></li><li>[x] <a href="http://codevs.cn/problem/3554/" target="_blank" rel="noopener">codevs 3554 犯罪团伙</a></li><li>[x] <a href="http://codevs.cn/problem/4600/" target="_blank" rel="noopener">codevs 4600 程序自动分析 NOI 2013</a></li></ul><h4 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h4><ul><li>[x] <a href="http://codevs.cn/problem/2370/" target="_blank" rel="noopener">codevs 2370 小机房的树</a></li><li>[x] <a href="http://codevs.cn/problem/1036/" target="_blank" rel="noopener">codevs 1036 商务旅行</a></li><li>[x] <a href="http://codevs.cn/problem/3287/" target="_blank" rel="noopener">codevs 3287 货车运输 NOIp 2013</a></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h4><ul><li>[x] <a href="http://codevs.cn/problem/1019/" target="_blank" rel="noopener">codevs 1019 集合论与图论</a></li><li>[x] <a href="http://codevs.cn/problem/3554/" target="_blank" rel="noopener">codevs 3554 犯罪团伙</a></li><li>[x] <a href="http://codevs.cn/problem/1173/" target="_blank" rel="noopener">codevs 1173 最优贸易 NOIp 2009</a></li><li>[x] <a href="http://codevs.cn/problem/3731/" target="_blank" rel="noopener">codevs 3731 寻找道路 NOIp 2014</a></li><li>[x] <a href="http://codevs.cn/problem/4511/" target="_blank" rel="noopener">codevs 4511 信息传递 NOIp 2015</a></li><li>[x] <a href="http://codevs.cn/problem/3278/" target="_blank" rel="noopener">codevs 3278 联合权值 NOIp 2014</a></li></ul><h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><ul><li>[x] <a href="http://codevs.cn/problem/1077/" target="_blank" rel="noopener">codevs 1077 多源最短路</a> </li><li>[x] <a href="http://codevs.cn/problem/1557/" target="_blank" rel="noopener">codevs 1557 热浪</a> </li><li>[ ] <a href="http://codevs.cn/problem/2059/" target="_blank" rel="noopener">codevs 2059 逃出克隆岛</a></li><li>[ ] <a href="http://codevs.cn/problem/4175/" target="_blank" rel="noopener">codevs 4175 收费站</a> </li><li>[ ] <a href="http://codevs.cn/problem/4416/" target="_blank" rel="noopener">codevs 4416 FFF团卧底的后宫</a> </li></ul><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li>[x] <a href="http://codevs.cn/problem/1231/" target="_blank" rel="noopener">codevs 1231 最优布线问题</a></li><li>[x] <a href="http://codevs.cn/problem/1001/" target="_blank" rel="noopener">codevs 1001 舒适的路线 HAOI 2006</a></li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li>[x] <a href="http://codevs.cn/problem/2763/" target="_blank" rel="noopener">codevs 2763 封路</a></li><li>[x] <a href="http://codevs.cn/problem/2833/" target="_blank" rel="noopener">codevs 2833 奇怪的梦境</a></li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分学习笔记</title>
      <link href="/2016/08/20/premixSum/"/>
      <url>/2016/08/20/premixSum/</url>
      
        <content type="html"><![CDATA[<h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><h4 id="前缀和-Prefix-Sum"><a href="#前缀和-Prefix-Sum" class="headerlink" title="前缀和 (Prefix Sum)"></a>前缀和 (Prefix Sum)</h4><p>对于一维数组数组a，前缀和sum[i]表示从开始到a[i]的所有数字的和(包括a[i])</p><h4 id="差分-difference）"><a href="#差分-difference）" class="headerlink" title="差分(difference）"></a>差分(difference）</h4><p>差分，又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。</p><a id="more"></a><h3 id="【前缀和-Prefix-Sum-】"><a href="#【前缀和-Prefix-Sum-】" class="headerlink" title="【前缀和 (Prefix Sum)】"></a>【前缀和 (Prefix Sum)】</h3><p>对于一维数组数组a，前缀和<code>sum[i]</code>表示从开始到<code>a[i]</code>的所有数字的和(包括$a[i]$).(数列的前$i$项和)</p><p>递推求前缀和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，对于二维数组b，前缀和<code>sum[i][j]</code>表示所有<code>b[m][n]</code>$(1 \leq m \leq i, i \leq n \leq k)$的和(包括$b[m][n]$).</p><div class="table-container"><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td></tr></tbody></table></div><p>对于上面这个二维数组B，前缀和数组B’为</p><div class="table-container"><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">3</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">12</td><td style="text-align:center">21</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">27</td><td style="text-align:center">45</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">48</td><td style="text-align:center">78</td></tr></tbody></table></div><p>递推求前缀和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum[<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">        sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i - <span class="number">1</span>][j - <span class="number">1</span>]+b[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【差分-difference-】"><a href="#【差分-difference-】" class="headerlink" title="【差分(difference)】"></a>【差分(difference)】</h3><blockquote><p>差分，又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数$f(x)$ 映射到$f(x+a)-f(x+b)$ 。差分运算，相应于微分运算，是微积分中重要的一个概念。总而言之，差分对应离散，微分对应连续。差分又分为前向差分和逆向差分两种。</p></blockquote><p>比如，在一个等差数列${ a<em>n }$中，公差$d$定义为$a_i - a</em>{i - 1}$，这就是一种简单的差分。</p><p>对于一个一维数组，如果我们要求区间[i .. k]的和，可以用一个循环加起来，但是这样是比较耗时间的，如果我们利用前缀和，只需要用<code>sum[k] - sum[i-1]</code>就可以快速得到答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = sum[k] - sum[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>对于一个二维数组，也可以进行同样的操作。下面的代码演示了如何求一个二维数组a中从$a[x][y]$到$a[x1][y1]$所有数值的和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = sum[x1][y1] - sum[x - <span class="number">1</span>][y1] - sum[x1][y - <span class="number">1</span>] + sum[x - <span class="number">1</span>][y - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="【用差分实现区间操作】"><a href="#【用差分实现区间操作】" class="headerlink" title="【用差分实现区间操作】"></a>【用差分实现区间操作】</h3><p>如果我们想让我们的数据结构支持一个<code>add(l, r, v)</code>的操作，即让一个区间中的所有数都加上一个数或减去一个数，该怎么操作呢，当然可以使用强(xuan)大(xue)的线段树，但是据说在NOIp阶段不会考，实际上这个操作可以利用差分来解决</p><p>设A数组为 </p><script type="math/tex; mode=display">A=\{2, 3, 1, 4, 5, 2, 6\}</script><p>C数组为修改数组，表示 $[1..n]$ 这些元素都加上 $c[i]$ 这个数</p><script type="math/tex; mode=display">C=\{ 1, 4, 3, -1, -4\}</script><p>S数组为C数组的前缀和数组</p><script type="math/tex; mode=display">S=\{1, 5, 8, 7, 3, 3, 3\}</script><p>对于每一个<code>add(l, r, a)</code>我们对$[L,R]$区间进行加$a$操作，在$C[L]$处加上$a$，在$C[R+1]$处减去$a$</p><p>最后求序列的每个位置变成了多少，只要看一下这个位置上$C$数组的前缀和就可以。</p><p>对于二维数组，处理方法也是类似的</p><blockquote><p>对于一个$n \times m$的表格，要求支持操作<code>add(x1,y1,x2,y2,a)</code>，表示对于以$(x1,y1)$为左下角,$(x2,y2)$为右上角的矩形区域，每个元素都加上$a$。问最后的表格的样子</p></blockquote><p>用数组$C$存修改信息。在$C[x1][y1]$处加上$a$，在$C[x2+1][y1]$和$C[x1][y2+1]$处减$a$，在$C[x2+1][y2+1]$再加上$a$。<br>最后$(i,k)$位置上的数值就是$C$数组在$(i,k)$位置的前缀和。</p><p><del>最后贴段代码好了</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> sum[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, sum[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------------\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">int</span> x1, y1;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x1, &amp;y1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----------------\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = sum[x1][y1] - sum[x - <span class="number">1</span>][y1] - sum[x1][y - <span class="number">1</span>] + sum[x - <span class="number">1</span>][y - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIp2015跳石头 - 二分答案</title>
      <link href="/2016/08/17/stone/"/>
      <url>/2016/08/17/stone/</url>
      
        <content type="html"><![CDATA[<p>在很多求最大值最小或者求最小值最大的问题中，不是那么容易地可以直接构造解，但判断一个解是否合法却很容易，这个时候通常考虑二分答案。</p><p>所谓二分答案就是在答案可能的区间里“猜”一个答案，然后验证这个答案是否合法，在每次取中点的情况下，复杂度是$O(log_2n)$，是完全可以接受的。</p><p>比如 NOIp2015 DAY2 T1 跳石头 就是一道很好的利用了二分答案的题目</p><p>传送门:<a href="https://lyoi.menci.moe/problem/5" target="_blank" rel="noopener">NOIp2015 D2 T1 跳石头</a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>【题目描述】<br>一年一度的“跳石头”比赛又要开始了！</p><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $ N $ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p>【输入描述】<br>输入文件第一行包含三个整数 $ L,N,M $，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。<br><a id="more"></a></p><p>接下来 $ N $ 行，每行一个整数，第 $ i $ 行的整数 $ D_i $（$ 0 &lt; D_i &lt; L $）表示第 $ i $ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同 一个位置。</p><p>【输出描述】<br>输出文件只包含一个整数，即最短跳跃距离的最大值</p><p>【输入样例】</p><blockquote><p>25 5 2<br>2<br>11<br>14<br>17<br>21</p></blockquote><p>【输出样例】</p><blockquote><p>4</p></blockquote><p>【数据范围及提示】<br>对于 $ 20\% $ 的数据，$ 0 \leq M \leq N \leq 10 $。<br>对于 $ 50\% $ 的数据，$ 0 \leq M \leq N \leq 100 $。<br>对于 $ 100\% $ 的数据，$ 0 \leq M \leq N \leq 50,000 $，$ 1 \leq L \leq 1,000,000,000 $。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看到最大值最小或者最小值最大之类的问题，很容易想到是二分答案。</p><p>具体说明:假设我们已经知道答案是k，也就是满足最小的距离最大为$k$，那么最终搬走石头以后任意两个石头之间的距离都是大于等于$k$的,那么我们只要检验是否能搬走$m$块石头使得满足$k$就可以了。</p><p>首先，题目告诉我们，起点石头也就是$0$是固定的，然后如果我们搬走一个石头$i$的话，如果左边的石头已经满足答案$k$，那么移除$i$对答案是没有影响的，因为到左边石头的距离只会变大，不可能小于$k$。</p><p>对于当前的石头$i$，下一块石头为$j$，$pre[i]$为$i$上一块石头，$sub[j]$为$j$下一块石头</p><p>有两种可能：<br>1.$i$到$j$的距离小于等于$k$,也就是不满足答案，那么我们要做的是，移除$j$。</p><p>因为$i$到$pre[i]$是大于等于$k$的，那么$j$到$pre[i]$一定也大于等于$k$，但是$i$都不一定满足$i$到$sub[j]$的距离大于等于$k$，更不谈离$sub[j]$更近的$j$了，所以为了之后的石头考虑，我们需要移除$j$。</p><p>2.$i$到$j$的距离大于$k$，也就是$i$,$j$之间已经符合条件了，那么就可以什么都不动了。</p><p>因为$i$到$j$的距离已经大于$k$了，所以对于$j$之后每一块石头，都是满足条件的，所以$i$对检验答案并没有什么影响了，那$j$如何考虑呢？$j$之后就会成了下一个$i$，再如上文分两种情况处理了。</p><p>所以具体就是二分答案$k$，然后$O(n)$检验，总复杂度$O(nlogL)$。</p><p>最后还有一个小问题，二分的区间怎么确定？因为对数的增长是非常慢的，所以区间稍微取大一点也没有关系，对于这题来说直接取$L$就可以了，这样还顺便解决了$n=0$的问题</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], L, M, stk[MAXN], tp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    tp = <span class="number">0</span>;</span><br><span class="line">    stk[++tp] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] - a[stk[tp]] &gt;= mid) &#123;</span><br><span class="line">            stk[++tp] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L - a[stk[tp]] &lt; mid) &#123;</span><br><span class="line">        --tp;</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans &lt;= M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;n, &amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = L, mid, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">            ans = mid; </span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用倍增算法加速区间操作</title>
      <link href="/2016/08/13/%E5%80%8D%E5%A2%9E/"/>
      <url>/2016/08/13/%E5%80%8D%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="【倍增算法求RMQ】"><a href="#【倍增算法求RMQ】" class="headerlink" title="【倍增算法求RMQ】"></a>【倍增算法求RMQ】</h3><p>RMQ(Range Minimum/Maximum Quary)，顾名思义，即为区间最值查询，主要用来解决对于长度为$n$的数列$A$,求解其中$i,j$之间的最大/最小值的问题</p><p>在这之前先考虑这个问题的暴力解法</p><p>1.每次暴力<del>膜</del>扫描数组，复杂度$O(n)$.<br>2.开一个二维数组，对于每一个区间的数预处理进数组中，这基于这样一个原理，对于一个数组，其中前$m$个数中的最大/最小值等于前$m-1$个数的最大/最小值和第$m$个数相比产生的最大/最小值，复杂度$O(n^2)$预处理，$O(1)$查询.</p><p>这么low的算法怎么能满足我们呢(大雾),我们需要更加强悍的算法.</p><a id="more"></a><h4 id="ST表（Sparse-Table）"><a href="#ST表（Sparse-Table）" class="headerlink" title="ST表（Sparse Table）"></a>ST表（Sparse Table）</h4><p>以求最大值为例，设$A$数组存储我们待求最大值的序列，$f[i][j]$表示从第$i$个数字开始，往后第$2^j$个数字中的最大值是多少.</p><p>为什么要是往后$2^j$个数呢，在学习多重背包时，提到过二进制拆分，比如对于$7(111_2)$,可以拆分成$1(001_2)$、$2(010_2)$、$4(100_2)$这三个数，通过这三个数就可以表示出1到7之间的所有整数，而这三个数正好就是$2^0$,$2^1$,$2^2$,所以，按照这个方法，我们从小到大枚举$j$,每次处理$f[i][j]$的时候，都可以保证$f[i][0..j-1]$都是已经处理好的.</p><p>注意$2^j \leq n$，因此$f$数组的元素不超过$nlog_2n$,并且每一项都可以在常数时间内解决，总复杂度为$O(nlog_2n)$.</p><p>【预处理代码】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RMQ_init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= i + (i &lt;&lt; j) - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">std</span>::max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就预处理好了$f$数组， 但是该怎样进行查询呢，我们的$f$数组保存的是区间中的最大/最小值，假如说要查询的区间为$(i,j)$,则设$k = \lfloor log_2(i + j - 1) \rfloor$，要查询的结果为$max(f[i][k], f[j - 2 ^ k + 1][k])$</p><p>为什么$k$是这样一个奇怪的取值？对于区间$(i, j)$，它的长度不一定正好是$2$的整数倍，这样可以得到两个<strong>最长的 比总区间短的 覆盖查询区间的 区间</strong> 两个区间中的最大值中的较大值一定是总区间的最大值</p><p>【查询代码】<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= r - l + <span class="number">1</span>) k++;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以快速完成区间最值查询（RMQ）的任务了</p><p>但是，这个算法存在一定的局限性，对于区间和之类的信息无法进行维护，这就需要用到一种<del>玄学</del>神奇的数据结构——线段树，（单纯对于区间和可以考虑使用前缀和）然而据说NOIp是不会考线段树的，然后就没有然后了</p><h3 id="【倍增查找LCA】"><a href="#【倍增查找LCA】" class="headerlink" title="【倍增查找LCA】"></a>【倍增查找LCA】</h3><p>还没有开始写(xue)OVO</p><p>2016.10.17 20:29 写完啦！</p><p>传送门<a href="http://ilern.coding.me/428/LCA/" target="_blank" rel="noopener">[Codevs 2370] 小机房的树 - 最近公共祖先 + 倍增</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 区间操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Codevs 1120] 采药 - 背包DP </title>
      <link href="/2016/08/10/01%E8%83%8C%E5%8C%85/"/>
      <url>/2016/08/10/01%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h4 id="codevs-1102-采药"><a href="#codevs-1102-采药" class="headerlink" title="codevs 1102 采药"></a>codevs 1102 采药</h4><ul><li>题目描述：<br>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”<br>如果你是辰辰，你能完成这个任务吗</li></ul><a id="more"></a><ul><li><p>题目链接：<br><a href="http://codevs.cn/problem/1102/" target="_blank" rel="noopener">codevs 1102 采药</a></p></li><li><p>题解<br>最基本的01背包问题，，设$w[i]$表示第$i$件物品的体积，$c[i]$表示第$i$件物品的价值，状态转移方程为</p><script type="math/tex; mode=display">f(i,v) = max(f(i-1, v),f(i-1,v-w[i])+c[i])</script><p>其中用$f(i,v)$表示在前$i$件物品中选择占用体积为$v$所能获得的最大价值</p></li><li><p>代码</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXV 1100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[MAXN];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXV]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,i,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[i], &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = m; v &gt; <span class="number">0</span>; v--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &lt;= v) &#123;</span><br><span class="line">                f[i][v] = <span class="built_in">std</span>::max(f[i - <span class="number">1</span>][v],f[i - <span class="number">1</span>][v - w[i]] + c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][v] = f[i - <span class="number">1</span>][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[n][m]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线处理的逆序并查集</title>
      <link href="/2016/08/09/%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86%E7%9A%84%E9%80%86%E5%BA%8F%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2016/08/09/%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86%E7%9A%84%E9%80%86%E5%BA%8F%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://lyoi.menci.moe/problem/66" target="_blank" rel="noopener">七夕的分组</a></p><h3 id="七夕的分组"><a href="#七夕的分组" class="headerlink" title="七夕的分组"></a>七夕的分组</h3><p>【题目描述】<br>七夕到了，FFF 团开始活动了。</p><p>FFF 团是一个有组织的团体——所有团员按照团长的指挥分为若干个组。今年七夕，由于新加入FFF团的人越来越多，FFF 团需要重新分组。<br><a id="more"></a></p><p>FFF 团的分组方式为：开始时，所有团员为一个分组，在一个图上，他们由一些Edge相连；之后，团长会每次去掉一条 Edge。在图上同一个联通块内的人为同一组。</p><p>Jrisme 很害怕FFF团，因此他偷听了FFF团分组的全过程，他希望能在途中询问你，当前时刻下：</p><ol><li>$ u_i $ 和 $ v_i $ 两名团员是否在同一组中；</li><li>当前有多少个组。</li></ol><p>【输入描述】<br>第一行两个整数 $ n $、$ m $，表示 FFF 团有 $ n $ 名团员，通过 $ m $ 条 Edge 相连；<br>之后的 $ m $ 行，每行两个整数 $ u_i $、$ v_i $ 表示有一条从 $ u_i $ 到 $ v_i $ 的无向边。<br>之后一行一个整数 ，表示有 $ q $ 次操作；<br>之后的 $ q $ 行，每行表示一次操作，为以下几种格式之一：</p><ol><li><code>F i</code> 表示 FFF 团团长命令去掉第 $ i $ 条边（边的编号按照读入顺序，从 $ i $ 开始）；</li><li><code>FF u v</code> 表示 Jrisme 询问第 $ u $ 和第 $ v $ 号团员是否在同一组中；</li><li><code>FFF</code> 表示 Jrisme 询问当前有多少个组；</li></ol><p>【输出描述】<br>为了表示你对 FFF 团的虔诚，你需要在输出文件的第一行输出「<code>FFF!</code>」。<br>之后的若干行，对于每个第二种操作，如果第 $ u $ 和第 $ v $ 号团员在同一组中，输出<code>true</code>，否则输出<code>false</code>；对于每个第三种操作，输出一个整数，表示当前有多少个组；每个输出占一行。</p><p>【输入样例】</p><blockquote><p>4 3<br>1 2<br>2 3<br>3 4<br>4<br>F 1<br>FF 2 3<br>F 3<br>FFF</p></blockquote><p>【输出样例】</p><blockquote><p>FFF!<br>true<br>3</p></blockquote><p>【数据范围及提示】<br>对于 $ 10\% $ 的数据，$ q = 0 $；<br>对于 $ 30\% $ 的数据，$ n, m, q \leq 10 $；<br>对于另外 $ 20\% $ 的数据，所有第一种操作均在第二、三种操作前；<br>对于另外 $ 20\% $ 的数据，没有第二种操作；<br>对于另外 $ 20\% $ 的数据，没有第三种操作；<br>对于 $ 100\% $ 的数据，$ 1 \leq n \leq 50000, 0 \leq m \leq 200000, 1 \leq q \leq 100000, 1 \leq u_i, v_i \leq n $；<br>保证没有重边和自环。</p><p><strong>由于某些原因，本题只有六组数据。</strong></p><ul><li>题解<br><del>这题一看就是并查集嘛</del><br>初看此题有种并查集的感觉，但又有些不同，并查集可以方便支持的是“并”与“查”两种操作，但是题目中要求的是“去掉某一条边”，我们并没有“拆查集”，所以需要一些特殊的技巧来实现这些操作。<br>就是传说中的离线处理的逆序并查集。<br>所谓离线处理，就是先把每一条命令存下来，全部读完之后再处理。<br>然后拆边操作，则可以看做倒序的加边操作，所以就可以从末状态开始利用并查集来加边，最后倒过来输出各种询问的结果</li><li>代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == a[x] ? x : a[x] = find(a[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> y)</span> </span>&#123; a[find(x)] = find(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> find(x) == find(y); &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">bool</span> del;</span><br><span class="line">&#125; E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> type, u, v, i, ans;</span><br><span class="line">&#125; Q[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;E[i].u, &amp;E[i].v), E[i].u--, E[i].v--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">Q[i].type = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q[i].i), Q[i].i--;</span><br><span class="line">E[Q[i].i].del = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">Q[i].type = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Q[i].u, &amp;Q[i].v), Q[i].u--, Q[i].v--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Q[i].type = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf(" %d\n", Q[i].type);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = n;</span><br><span class="line"></span><br><span class="line">ufs.init(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!E[i].del &amp;&amp; !ufs.test(E[i].u, E[i].v)) &#123;</span><br><span class="line">ufs.merge(E[i].u, E[i].v);</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = q - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (Q[i].type == <span class="number">0</span> &amp;&amp; !ufs.test(E[Q[i].i].u, E[Q[i].i].v)) &#123;</span><br><span class="line">ufs.merge(E[Q[i].i].u, E[Q[i].i].v);</span><br><span class="line">cnt--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Q[i].type == <span class="number">1</span>) Q[i].ans = ufs.test(Q[i].u, Q[i].v);</span><br><span class="line"><span class="keyword">else</span> Q[i].ans = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"FFF!"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Q[i].type == <span class="number">1</span>) <span class="built_in">puts</span>(Q[i].ans ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Q[i].type == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Q[i].ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Menci的标程，自己写的版本以后再放出来吧……</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路学习笔记</title>
      <link href="/2016/08/05/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2016/08/05/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>最近做了好多需要用到最短路的题，但是其实我是不会写最短路的[滑稽]，所以现在要学一下[严肃]<br><a id="more"></a></p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><h4 id="【模板题】"><a href="#【模板题】" class="headerlink" title="【模板题】"></a>【模板题】</h4><p><a href="http://codevs.cn/problem/1077/" target="_blank" rel="noopener">Codevs1077 多源最短路</a></p><p><a href="http://codevs.cn/problem/1557/" target="_blank" rel="noopener">Codevs1557 热浪</a></p><p><a href="http://codevs.cn/problem/1021/" target="_blank" rel="noopener">Codevs1021 玛丽卡</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="【邻接矩阵】"><a href="#【邻接矩阵】" class="headerlink" title="【邻接矩阵】"></a>【邻接矩阵】</h4><p>对于一张图，最简单的存储方式就是邻接矩阵，它用一个二维数组实现，$graph[u][v] = w$ 表示从$u$到$v$有一条边权为$w$的有向边</p><h4 id="【邻接表】"><a href="#【邻接表】" class="headerlink" title="【邻接表】"></a>【邻接表】</h4><p>对于一张图，可以使用邻接矩阵来存储，但是如果节点数特别多，邻接矩阵的效率会异常低下，要找到一条边需要遍历整个数组，所以我们需要更强(N)大(B)的存储方式邻接表。</p><p>邻接表使用链表实现，有一个Node结构体存储点的相关信息，其中必不可少的是一个Node所连接的最后一条出边；有一个Edge结构体存储边的相关信息，比如起点，终点，边权等，其中必不可少的是一个Edge的下一条边。</p><p>这样就实现了基于指针的邻接表，优点是灵活，需要什么直接在结构体里加就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="comment">//可以在结构体里添加其他东西</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line">    </span><br><span class="line">    Node() : edges(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    Node *fr;</span><br><span class="line">    Node *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : to(to), w(w), next(fr-&gt;edges) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="【Floyd】"><a href="#【Floyd】" class="headerlink" title="【Floyd】"></a>【Floyd】</h4><p>floyd是最简单的最短路算法，能够计算出图中任意两点间的最短路，<del>这其实是一个DP算法</del>，核心代码只有四行，缺点是复杂度达到了$O(n^3)$，这在很大程度上是不能接受的，(热浪交上去会T3个点)，如果数据范围小可以选择.</p><p>传送门:<a href="http://ilern_blog.leanote.com/post/%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E4%BC%B0%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">根据数据范围估算时间复杂度</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dis[i][j] = <span class="built_in">std</span>::min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中$k$枚举的是$i$到$j$的中间点,一定要写在最外面.</p><h4 id="【Dijkstra-heap】"><a href="#【Dijkstra-heap】" class="headerlink" title="【Dijkstra_heap】"></a>【Dijkstra_heap】</h4><p>dijkstra是一个单源最短路算法，可以用$O(MlogN)$的时间求出从起点到其他每个点的最短路,(把dijkstra交上去就可以过了),但是因为dijkstra是基于贪心的，所以不能处理负边权的情况,常使用堆(优先队列)来优化</p><p>在Dijkstra中边权要么全正，要么全负，有正有负考虑SPFA</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Node *S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;Node*, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node*&gt;, Node::Comp&gt; Q;</span><br><span class="line">    <span class="comment">//优先队列需要队列中的元素支持比较操作，虽然指针支持比较，但显然比较的不是我们想比较的东西所以需要传入一个自定义的比较器</span></span><br><span class="line"></span><br><span class="line">    S-&gt;d = <span class="number">0</span>, Q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        Node *v = Q.top(); Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(v-&gt;done) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">else</span> v-&gt;done = <span class="literal">true</span>;<span class="comment">//done是一个访问标记，说明这个点的最短路已经确定</span></span><br><span class="line">        <span class="keyword">for</span>(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e-&gt;to-&gt;d &gt; v-&gt;d + e-&gt;w) &#123;</span><br><span class="line">                e-&gt;to-&gt;d = v-&gt;d + e-&gt;w;<span class="comment">//d为从起点到当前点的最短路径的估计值，进行一轮“松弛操作”</span></span><br><span class="line"></span><br><span class="line">                Q.push(e-&gt;to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一号点的最短路，热浪直接交上去会WA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">5000</span>;    <span class="comment">//节点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;  <span class="comment">//每个点的初始最短路径估计为正无穷</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Edge *edges; <span class="comment">//最后一条出边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis;<span class="comment">//最短路径估计</span></span><br><span class="line"><span class="keyword">bool</span> visited;<span class="comment">//访问标记</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node *a, <span class="keyword">const</span> Node *b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-&gt;dis &gt; b-&gt;dis;</span><br><span class="line">&#125;<span class="comment">//比较器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), dis(INF), visited(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;nodes[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr;<span class="comment">//起点</span></span><br><span class="line">Node *to;<span class="comment">//终点</span></span><br><span class="line"><span class="keyword">int</span> w;<span class="comment">//边权</span></span><br><span class="line"></span><br><span class="line">Edge *next;<span class="comment">//下一条边</span></span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u,v,w);<span class="comment">//无向图，边要正着加一次反着加一次</span></span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v,u,w);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;Node*,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node*&gt;,Node::comp&gt; pq;</span><br><span class="line"></span><br><span class="line">x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">pq.push(x);</span><br><span class="line"><span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">Node *v = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"><span class="comment">//v-&gt;visited == true ? continue; : v-&gt;visited = true;</span></span><br><span class="line"><span class="keyword">if</span>(v-&gt;visited == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">v-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="comment">//e-&gt;to-&gt;dis = std::max(e-&gt;to-&gt;dis, v-&gt;dis +　e-&gt;w);</span></span><br><span class="line"><span class="keyword">if</span>(e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123;</span><br><span class="line">e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w;</span><br><span class="line"></span><br><span class="line">pq.push(e-&gt;to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pq.push(e-&gt;to);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);<span class="comment">//n is the number of nodes,m is the number of edges</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">addEdge(nodes + u,nodes + v,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">dijkstra(nodes + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,nodes[i].dis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【SPFA】"><a href="#【SPFA】" class="headerlink" title="【SPFA】"></a>【SPFA】</h4><p>SPFA用两重循环，一重枚举每一个点，一重枚举每一条边，进行$n - 1$轮松弛后得到单源最短路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//热浪代码，直接交上去是可以过的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">Edge *edges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis;</span><br><span class="line"><span class="keyword">bool</span> inQueue;</span><br><span class="line"></span><br><span class="line">Node() : edges(<span class="literal">NULL</span>), dis(INF), inQueue(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">Node *fr;</span><br><span class="line">Node *to;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">next = fr-&gt;edges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">u-&gt;edges = <span class="keyword">new</span> Edge(u,v,w);</span><br><span class="line">v-&gt;edges = <span class="keyword">new</span> Edge(v,u,w);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line"></span><br><span class="line">x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">x-&gt;inQueue = <span class="literal">true</span>;</span><br><span class="line">q.push(x);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">Node *v = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">v-&gt;inQueue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span>(e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123;</span><br><span class="line">e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!e-&gt;to-&gt;inQueue) &#123;</span><br><span class="line">q.push(e-&gt;to);</span><br><span class="line">e-&gt;to-&gt;inQueue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;x,&amp;y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">addEdge(nodes + u,nodes + v,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SPFA(nodes + x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,nodes[y].dis);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结和吐槽"><a href="#总结和吐槽" class="headerlink" title="总结和吐槽"></a>总结和吐槽</h3><h4 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h4><h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><p> 空间复杂度$O(N^2)$<br> 时间复杂度$O(N^3)$<br> 支持负边权</p><p> 时间复杂度高但是编码难度低(然而并没有什么用)<br> 是不是可以拿来跑暴力</p><h5 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><p> 空间复杂度$O(M)$<br> 时间复杂度$O(MlogN)$<br> 不支持负边权</p><p> 堆优化之后时间复杂度优秀，结合邻接表之后空间复杂度优秀，但是不支持负边权(不过问题不大,没有负权时首选Dijkstra)</p><h5 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h5><p> 空间复杂度$O(M)$<br> 时间复杂度$O(NM)$<br> 支持负权</p><p> 存在负权时好像只剩下这个选择了……<br> 据说时间复杂度得不到保证……<br> 据说NOIp是绝对不会卡SPFA的，但是真要是卡了那也没办法……<br> 据说改成双端队列会更快，不过我也不知道为什么……</p><h4 id="【吐槽】"><a href="#【吐槽】" class="headerlink" title="【吐槽】"></a>【吐槽】</h4><p>1.指针好难写，总是爆出莫名其妙的错误，不过理解之后看起来也挺舒服的</p><p>2.本来总结想打个表 <del>@各单位提供丰富</del> 但是Markdown的表格好难写……是真的难写。<del>所以最后放弃了</del></p><p>3.终于写完了</p><p>4.完结撒花</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据数据范围估算时间复杂度</title>
      <link href="/2016/08/05/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2016/08/05/%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>在算法竞赛中，算法的优劣直接决定了最终的得分，但在想不出正解的情况下，一个不那么优秀的算法也是可以得到部分分数的，在一道算法竞赛的题目中通常都会给出几个层次的数据范围，而我们就可以根据数据范围来合理设计算法的时间复杂度<br><a id="more"></a></p><ul><li><p>$N \leq 20$ ============  $O(2^N)$</p></li><li><p>$20 &lt; N \leq 100$ ===== $O(N^3)$</p></li><li><p>$100 &lt; N \leq 1000$ === $O(N^2)$</p></li><li><p>$10000 &lt; N \leq 10^5$ ==$O(nlogn)$</p></li><li><p>$10^5 &lt; N \leq 10^8$======$O(n)$</p></li><li><p>$N &gt; 10^8$=============$O(logn)$ </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法的典型应用 - 区间类问题</title>
      <link href="/2016/08/05/%E8%B4%AA%E5%BF%83and%E5%8C%BA%E9%97%B4/"/>
      <url>/2016/08/05/%E8%B4%AA%E5%BF%83and%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="区间选择问题"><a href="#区间选择问题" class="headerlink" title="区间选择问题"></a>区间选择问题</h3><h4 id="codevs-1214-线段覆盖-amp-amp-codevs-1643-线段覆盖3"><a href="#codevs-1214-线段覆盖-amp-amp-codevs-1643-线段覆盖3" class="headerlink" title="codevs 1214 线段覆盖 &amp;&amp; codevs 1643 线段覆盖3"></a>codevs 1214 线段覆盖 &amp;&amp; codevs 1643 线段覆盖3</h4><ul><li>题目描述<br>给定$x$轴上的$n$ $(0&lt;n&lt;100)$ 条线段，每个线段由它的二个端点$a_i$和$b_i$确定，$i = 1,2, \dots n$.这些坐标都是区间$(-999，999)$的整数。有些线段之间会相互交叠或覆盖。请你编写一个程序，从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点。所谓的内部公共点是指一个点同时属于两条线段且至少在其中一条线段的内部（即除去端点的部分）。</li></ul><a id="more"></a><ul><li><p>输入描述<br>输入第一行是一个整数$n$。接下来有$n$行，每行有二个空格隔开的整数，表示一条线段的二个端点的坐标。</p></li><li><p>输出描述<br>输出第一行是一个整数表示最多剩下的线段数。</p></li><li><p>题目连接<br><a href="http://codevs.cn/problem/1214/" target="_blank" rel="noopener">codevs 1214 线段覆盖</a><br><a href="http://codevs.cn/problem/1643/" target="_blank" rel="noopener">codevs 1643 线段覆盖3</a></p></li></ul><p>显然我们要做的就是找出尽量多的两两不相交的区间。</p><p>考虑先按照右端点排序，然后从左往右取不相交的区间。能选就选，不能选就跳过<del>废话</del></p><blockquote><p>简要证明正确性，假如我们能选该区间 $x$ 而不选，而选择的后面的某个区间 $y$，那么考虑 $x$ 和 $y$ 的关系，如果它们没有交集，那么多选一个 $x$ 更合算；假如有交集，那么将 $y$ 换成 $x$ 后，结果不会更劣，这是因为后面所有与 $x$ 冲突的区间必然与 $y$ 冲突，故该贪心策略可以得到最优解。</p></blockquote><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Area</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">bool</span> done;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Area &amp;a, <span class="keyword">const</span> Area &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Area() : l(<span class="number">0</span>), r(<span class="number">0</span>), done(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;area[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;area[i].l, &amp;area[i].r);</span><br><span class="line">    <span class="keyword">if</span> (area[i].l &gt; area[i].r) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(area[i].l, area[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::sort(area + <span class="number">1</span>, area + n + <span class="number">1</span>, Area::cmp());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (area[i].l &gt;= area[now].r) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">    now = i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 3 快捷键总结</title>
      <link href="/2016/08/05/sublime%20text%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2016/08/05/sublime%20text%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>以下是个人总结不完全的快捷键总汇，祝愿各位顺利解放自己的鼠标。<br><a id="more"></a></p><h3 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h3><p><strong>Ctrl+D</strong> 选中光标所占的文本，继续操作则会选中下一个相同的文本。</p><p><strong>Alt+F3</strong> 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。</p><p><strong>Ctrl+L</strong> 选中整行，继续操作则继续选择下一行，效果和 <strong>Shift + ↓</strong> 效果一样。</p><p><strong>Ctrl + Shift + L</strong> 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。</p><p><strong>Ctrl + Shift + M</strong> 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。</p><p><strong>Ctrl + M</strong> 光标移动至括号内结束或开始的位置。</p><p><strong>Ctrl + Enter</strong> 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。</p><p><strong>Ctrl + Shift + Enter</strong> 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。</p><p><strong>Ctrl + Shift + [</strong> 选中代码，按下快捷键，折叠代码。</p><p><strong>Ctrl + Shift + ]</strong> 选中代码，按下快捷键，展开代码。</p><p><strong>Ctrl + K + 0</strong> 展开所有折叠代码。</p><p><strong>Ctrl + ←</strong> 向左单位性地移动光标，快速移动光标。</p><p><strong>Ctrl + →</strong> 向右单位性地移动光标，快速移动光标。</p><p><strong>shift + ↑</strong> 向上选中多行。</p><p><strong>shift + ↓</strong> 向下选中多行。</p><p><strong>hift + ←</strong> 向左选中文本。</p><p><strong>Shift + →</strong> 向右选中文本。</p><p><strong>Ctrl + Shift + ←</strong> 向左单位性地选中文本。</p><p><strong>Ctrl + Shift + →</strong> 向右单位性地选中文本。</p><p><strong>Ctrl + Shift + ↑</strong> 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</p><p><strong>Ctrl + Shift + ↓</strong> 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</p><p><strong>Ctrl + Alt + ↑</strong> 向上添加多行光标，可同时编辑多行。</p><p><strong>Ctrl + Alt + ↓</strong> 向下添加多行光标，可同时编辑多行。</p><h3 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h3><p><strong>Ctrl + J</strong> 合并选中的多行代码为一行。举个栗子：将多行格式的$CSS$属性合并为一行。</p><p><strong>Ctrl + Shift + D</strong> 复制光标所在整行，插入到下一行。</p><p><strong>Tab</strong> 向右缩进。</p><p><strong>Shift + Tab</strong> 向左缩进。</p><p><strong>Ctrl + K + K</strong> 从光标处开始删除代码至行尾。</p><p><strong>Ctrl + Shift + K</strong> 删除整行。</p><p><strong>Ctrl + /</strong> 注释单行。</p><p><strong>Ctrl + Shift + /</strong> 注释多行。</p><p><strong>Ctrl + K + U</strong> 转换大写。</p><p><strong>Ctrl + K + L</strong> 转换小写。</p><p><strong>Ctrl + Z</strong> 撤销。</p><p><strong>Ctrl + Y</strong> 恢复撤销。</p><p><strong>Ctrl + U</strong> 软撤销，可以撤销一些<em>操作</em>。</p><p><strong>Ctrl + F2</strong> 设置书签</p><p><strong>Ctrl + T</strong> 左右字母互换。</p><p><strong>F6</strong> 单词检测拼写</p><h3 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h3><p><strong>Ctrl + F</strong> 打开底部搜索框，查找关键字。</p><p><strong>Ctrl + shift + F</strong> 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。</p><p><strong>Ctrl + P</strong> 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。</p><p><strong>Ctrl + G</strong> 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。</p><p><strong>Ctrl + R</strong> 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。</p><p><strong>Ctrl + ：</strong> 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</p><p><strong>Ctrl + Shift + P</strong> 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。</p><p><strong>Esc</strong> 退出光标多行选择，退出搜索框，命令框等。</p><h3 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h3><p><strong>Ctrl + Tab</strong> 按文件浏览过的顺序，切换当前窗口的标签页。</p><p><strong>Ctrl + PageDown</strong> 向左切换当前窗口的标签页。</p><p><strong>Ctrl + PageUp</strong> 向右切换当前窗口的标签页。</p><p><strong>Alt + Shift + 1</strong> 窗口分屏，恢复默认1屏（非小键盘的数字）</p><p><strong>Alt + Shift + 2</strong> 左右分屏-2列</p><p><strong>Alt + Shift + 3</strong> 左右分屏3列</p><p><strong>Alt + Shift + 4</strong> 左右分屏4列</p><p><strong>Alt + Shift + 5</strong> 等分4屏</p><p><strong>Alt + Shift + 8</strong> 垂直分屏-2屏</p><p><strong>Alt + Shift + 9</strong> 垂直分屏-3屏</p><p><strong>Ctrl + K + B</strong> 开启/关闭侧边栏。</p><p><strong>F11</strong> 全屏模式</p><p><strong>Shift + F11</strong> 免打扰模式</p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>资源搬运自豆瓣<br>网址：<a href="https://www.douban.com/note/362268947/" target="_blank" rel="noopener">https://www.douban.com/note/362268947/</a><br>传送门：<a href="https://www.douban.com/note/362268947/" target="_blank" rel="noopener">Sublime Text 3 快捷键总结（拿走）</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> Sublime Text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法的典型应用 - 归并排序 &amp;&amp; 求逆序对</title>
      <link href="/2016/08/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>虽然STL中的<code>&lt;algorithm&gt;</code>为我们提供了方便的排序函数，但是我们还是<del>闲的</del>想自己手动实现一个排序，并用它<strong>顺便</strong>算一算逆序对。</p><p>归并排序的大致思路就是把一个无序表分成两个无序表，再把两个无序表用<strong>某种特殊的方法</strong>变成两个有序表，再用<strong>另一种特殊的方法</strong>把两个有序表合并成一个有序表。</p><a id="more"></a><p>归并排序的时间复杂度为$O(nlogn)$,是速度仅次于快速排序的稳定排序方式，但是需要$O(n)$的辅助空间。</p><p>那么这两种特殊的方法是如何实现的呢？在第一个特殊方法中要求我们对数组的一半分别进行排序，所以想对整个数组排序需要先对数组的一半排序，那么想对数组的一半排序需要对数组一半的一半排序……这显然用递归就可以简单的实现，所以我们现在主要的问题就只剩下如何把两个有序表合并成一个有序表。</p><p>逐元素比较：把较小的元素加到辅助数组中(所以会有<del>蜜汁</del>$O(n)$的空间)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>,k=left;  <span class="comment">//k的初值要设成left</span></span><br><span class="line"><span class="keyword">while</span>((i &lt;= mid) &amp;&amp; (j &lt;= right))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt;= a[j])</span><br><span class="line">    &#123;</span><br><span class="line">        c[k] = a[i];k++;i++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">    &#123;</span><br><span class="line">        c[k] = a[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">c[k] = a[i];i++;k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">c[k] = a[j];j++;k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left == right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">merge_sort(a,left,mid);</span><br><span class="line">merge_sort(a,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=left,j=mid+<span class="number">1</span>,k=left;               <span class="comment">//k的初值要设成left</span></span><br><span class="line"><span class="keyword">while</span>((i &lt;= mid) &amp;&amp; (j &lt;= right))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt;= a[j])</span><br><span class="line">    &#123;</span><br><span class="line">        c[k] = a[i];k++;i++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">    &#123;</span><br><span class="line">        c[k] = a[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">c[k] = a[i];i++;k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">c[k] = a[j];j++;k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m=left;m&lt;=right;m++)</span><br><span class="line">&#123;</span><br><span class="line">a[m] = c[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge_sort(a,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>之前提到过写归并排序可以<strong>顺便</strong>求一下逆序对问题</p><blockquote><p>设$ A $为一个有$ n $个数字的有序集 $(n&gt;1)$，其中所有数字各不相同。<br>如果存在正整数 $i, j$ 使得$ 1 ≤ i &lt; j ≤ n $而且 $A[i]&gt;A[j]$，则$<a[i], a[j]>$ 这个有序对称为的一个逆序对，也称作逆序数。</a[i],></p></blockquote><p>当然可以两重循环来做，但是可以在归并排序的过程中顺便解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> a[N],tmp[N];  </span><br><span class="line"><span class="keyword">int</span> ans;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = l;  </span><br><span class="line">    <span class="keyword">int</span> j = m + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> k = l;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            tmp[k++] = a[j++];  </span><br><span class="line">            ans += m - i + <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            tmp[k++] = a[i++];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m) tmp[k++] = a[i++];  </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = a[j++];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)  </span><br><span class="line">        a[i] = tmp[i];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">        Merge_sort(l,m);  </span><br><span class="line">        Merge_sort(m+<span class="number">1</span>,r);  </span><br><span class="line">        Merge(l,m,r);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n,T,tt=<span class="number">1</span>;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);  </span><br><span class="line">    <span class="keyword">while</span>(T--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);  </span><br><span class="line">        ans = <span class="number">0</span>;  </span><br><span class="line">        Merge_sort(<span class="number">0</span>,n<span class="number">-1</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>,tt++,ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法的典型应用 - 二分查找</title>
      <link href="/2016/08/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2016/08/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>STL 中排序(<code>std::sort()</code>)与去重(<code>std::unique()</code>)的实现为我们的信息检索创造了方便.</p><p>对于信息的检索我们不难想到暴力的算法，即用一个数组存储所有数据，遍历这个数组查看是否有需要的数据存在，在数据已经排序好的情况下，查找一个元素的最坏时间复杂度为$O(n)$，而如果查找多个元素，我们就会得到一个爆炸的复杂度……</p><a id="more"></a><p>所以我们需要一个简单而有效的优化，那就是二分查找。<br>二分查找利用分治的思想，先查找中间元素，如果待查找数据大于中间数据，则查找前半部分，反之则查找后半部分，因为每一次都会把查找的范围减半，所以二分查找的期望时间复杂度为$O(logn)$.加上排序的预处理($O(nlogn)$),总复杂度为$O(logn+nlogn)$.</p><p>二分查找可以递归，但是一般写成非递归的。</p><p>&lt;例题&gt;<br> <a href="http://codevs.cn/problem/1230/" target="_blank" rel="noopener">codevs 1230 元素查找</a></p><p> 代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line">mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &gt; x)</span><br><span class="line">&#123;</span><br><span class="line">right=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>( find(a,<span class="number">1</span>,n+<span class="number">1</span>,x) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后注意一点，用二分查找之前一定要记得排序！用二分查找之前一定要记得排序！用二分查找之前一定要记得排序！</p><p><del>当然如果你要用STL里的<code>lower_pound()</code>也可以。</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
