<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Advice for Applying Machine Learning]]></title>
    <url>%2F2022%2F01%2F22%2FAdvice-for-Applying-Machine-Learning%2F</url>
    <content type="text"><![CDATA[评价与修正机器学习算法的一些方法 评价模型对于回归问题, 利用测试数据计算代价函数, 例如 J(\Theta) = \frac{1}{2m_{test}} \sum^{m_{test}}_{i=1} (h_\Theta(x_{test}^{(i)}) - y_{test}^{(i)}) ^ 2代价函数越小, 则说明模型越好. 对于分类问题, 定义一个误差函数, 表明分类错误的情况 \begin{equation} err(h_{\Theta}(x), y) = \begin{cases} 1 &(h_{\Theta}(x) > 0.5 &and& y = 0) &or& (h_{\Theta}(x) < 0.5 &and& y = 1) \\ 0 &\text{otherwise} \end{cases} \end{equation}最终的代价函数为 \text{TestError} = \frac{1}{m_{test}} \sum^{m_{test}}_{i=1} err(h_\Theta(x_{test}^{(i)}) - y_{test}^{(i)})代价函数越小表示分类错误越少, 模型越好 训练集 交叉验证集 测试集训练集用于计算代价函数, 利用梯度下降等方法, 来找到使代价函数最小的参数 交叉验证集验证用于模型的选择，更具体地来说，验证集并不参与学习参数的确定，也就是验证集并没有参与梯度下降的过程。验证集只是为了选择超参数，比如网络层数、网络节点数、迭代次数、学习率这些都叫超参数。比如在k-NN算法中，$k$值就是一个超参数。所以可以使用验证集来求出误差率最小的$k$。 图上面的部分表示我们拥有的数据，而后我们对数据进行了再次分割，主要是对训练集，假设将训练集分成5份（该数目被称为折数，5-fold交叉验证），每次都用其中4份来训练模型，粉红色的那份用来验证4份训练出来的模型的准确率，记下准确率。然后在这5份中取另外4份做训练集，1份做验证集，再次得到一个模型的准确率。直到所有5份都做过1次验证集，也即验证集名额循环了一圈，交叉验证的过程就结束。算得这5次准确率的均值。留下准确率最高的模型，即该模型的超参数是什么样的最终模型的超参数就是这个样的。 测试集仅在最后作为评估模型训练结果时使用, 不参与训练与交叉验证 Bias and variance两种错误的诊断当多项式次数过低, 就会导致对数据的拟合程度差, 导致欠拟合 随着增加多项式次数, 训练误差会逐渐减小, 但是在超过某个最佳值时, 会导致交叉验证误差上升, 也就是拟合程度过高, 泛化能力差, 导致过拟合 规格化项与两种错误 上图中的规格化项应为 \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2$m$为数据组数, $n$为参数个数 过大的$\lambda$导致误差函数总是很大, 造成欠拟合 过小的$\lambda$相当于没有这个规格化项, 会造成过拟合 学习曲线训练集的大小对与上述两个问题也有影响 对于神经网络参数较少 - 可能会欠拟合 - 计算量小 参数较多 - 可能会过拟合 - 计算量大 - 利用规格化项增加$\lambda$可以解决过拟合 总结 High Bias High Variance 表现 欠拟合 过拟合 原因 多项式次数低 / 规格化项参数大 多项式次数高 / 规格化项参数小(接近0) 训练误差$J_{train}(\Theta)$ 高 低 交叉验证误差$J_{CV}(\Theta)$ 高 高 随着训练集的增大 测试误差下降, 训练误差升高, 最后两者相仿, 高于期望的错误率 测试误差下降, 训练误差升高, 最后两者仍有区别, 但训练误差接近于期望的错误率 解决方法 更多特征 / 高次数的多项式 / 减少$\lambda$ 更多训练数据 / 更少的特征 / 增加$\lambda$ 低复杂度 高复杂度 high bias low bias low variance high variance]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MachineLearning Ex4 BP ALgorithm]]></title>
    <url>%2F2022%2F01%2F21%2FMachineLearning-Ex4-BP-ALgorithm%2F</url>
    <content type="text"><![CDATA[实现反向传播算法实现手写数字识别 每一个数字是一个$20 \times 20$像素的灰度图片, 展开输入为$400$维列向量, 输出为一个数字, 一共$5000$组数据作为训练集. 数据结构 $J$ 是代价函数$J(\Theta)$​的值, 定义 J = J(\Theta) = \frac{1}{m}\sum_{i = 1}^m\sum_{k=1}^K \left[-y_k^{(i)} \log(h_{\theta}(x^{i})_k) - (1-y_k^{(i)}) \log(1-h_\theta(x^{i})_k) \right] + \frac{\lambda}{2m}\left[\sum_{j=1}^{25}\sum_{k=1}^{400}(\Theta_{jk}^{(1)})^2 + \sum_{j=1}^{25}\sum_{k=1}^{400}(\Theta_{jk}^{(2)})^2\right] $i$是第$i$组数据, $k$是第$k$个标签, $h_{\theta}$是输出层的值 第二项是正则化项, 目的是防止过拟合. 简单地说，就是在代价函数后面加一个小尾巴惩罚项，比如在线性回归函数中：$\displaystyle J(\theta) = \frac{1}{2m}\left[\sum_{i=1}^m(h(x_i) - y_i)^2 + \frac{\lambda}{2m} \theta^2\right]$其中 $\lambda$ 称为惩罚项系数。小尾巴前面那项是我们原本的代价函数，现在加上了惩罚项后，我们要使得代价函数最小，则后面的小尾巴也必须要小，小尾巴小的话，那么 $\theta$ 就不能太大，如果 $\theta$ 很小的话，那么那个 $\theta$ 所在的项就接近于0了，也就可以近似地看成没有了那个特征。 $\Theta^{(1)}$是输入层到隐层中每条线的权值, $25$行 $401$列, 因为输入层有$400$个节点, 隐藏层有$25$个节点 $\Theta^{(2)}$是隐层到输出层中每条线的权值, $10$行 $26$列, 因为隐藏层有 $25$ 个节点, 输出层有 $10$ 个节点 $X$是所有训练集, 一组数据是一个行向量 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134% nnCostFunction.mfunction [J grad] = nnCostFunction(nn_params, ... input_layer_size, ... hidden_layer_size, ... num_labels, ... X, y, lambda)%NNCOSTFUNCTION Implements the neural network cost function for a two layer%neural network which performs classification% [J grad] = NNCOSTFUNCTON(nn_params, hidden_layer_size, num_labels, ...% X, y, lambda) computes the cost and gradient of the neural network. The% parameters for the neural network are "unrolled" into the vector% nn_params and need to be converted back into the weight matrices. % % The returned parameter grad should be a "unrolled" vector of the% partial derivatives of the neural network.%% Reshape nn_params back into the parameters Theta1 and Theta2, the weight matrices% for our 2 layer neural networkTheta1 = reshape(nn_params(1:hidden_layer_size * (input_layer_size + 1)), ... hidden_layer_size, (input_layer_size + 1));Theta2 = reshape(nn_params((1 + (hidden_layer_size * (input_layer_size + 1))):end), ... num_labels, (hidden_layer_size + 1));% Setup some useful variables% 训练集的大小m = size(X, 1); % You need to return the following variables correctly J = 0;Theta1_grad = zeros(size(Theta1));Theta2_grad = zeros(size(Theta2));% ====================== YOUR CODE HERE ======================% Instructions: You should complete the code by working through the% following parts.%% Part 1: Feedforward the neural network and return the cost in the% variable J. After implementing Part 1, you can verify that your% cost function computation is correct by verifying the cost% computed in ex4.m%% Part 2: Implement the backpropagation algorithm to compute the gradients% Theta1_grad and Theta2_grad. You should return the partial derivatives of% the cost function with respect to Theta1 and Theta2 in Theta1_grad and% Theta2_grad, respectively. After implementing Part 2, you can check% that your implementation is correct by running checkNNGradients%% Note: The vector y passed into the function is a vector of labels% containing values from 1..K. You need to map this vector into a % binary vector of 1's and 0's to be used with the neural network% cost function.%% Hint: We recommend implementing backpropagation using a for-loop% over the training examples if you are implementing it for the % first time.%% Part 3: Implement regularization with the cost function and gradients.%% Hint: You can implement this around the code for% backpropagation. That is, you can compute the gradients for% the regularization separately and then add them to Theta1_grad% and Theta2_grad from Part 2.for i = 1:m % m组训练数据 a1 = [1; X(i, :)']; % a1 (401 * 1) z2 = Theta1 * a1; % Theta1 (25 * 401) a1 (401 * 1) z2 (25 * 1) a2 = [1; sigmoid(z2)]; % a2 (26 * 1) z3 = Theta2 * a2; % Theta2 (10 * 26) a2 (26 * 1) z3 (10 * 1) h = sigmoid(z3); yy = zeros(num_labels, 1); yy(y(i)) = 1; for k = 1:num_labels J = J + (-yy(k) * log(h(k)) - ((1 - yy(k)) * log(1 - h(k)))); endforendforJ = J * (1 / m);% -------------------------------------------------------------oldTheta1 = Theta1(:, 2:end);oldTheta2 = Theta2(:, 2:end);J = J + (lambda / (2 * m)) * (trace(oldTheta1 * oldTheta1') + trace(oldTheta2 * oldTheta2'));% -------------------------------------------------------------for t = 1:m a1 = [1; X(t, :)']; % a1 (401 * 1) z2 = Theta1 * a1; % Theta1 (25 * 401) a1 (401 * 1) z2 (25 * 1) a2 = [1; sigmoid(z2)]; % a2 (26 * 1) z3 = Theta2 * a2; % Theta2 (10 * 26) a2 (26 * 1) z3 (10 * 1) a3 = sigmoid(z3); % a3 10 * 1 yy = zeros(num_labels, 1); yy(y(t)) = 1; delta3 = a3 - yy; % delta3 10 * 1 % delta2 = Theta2(:, 2 : end)' * delta3; delta2 = Theta2' * delta3; delta2 = delta2(2:end); delta2 = delta2 .* sigmoidGradient(z2); % Theta2' 26 * 10 delta3 10 * 1 z2 25 * 1 Theta1_grad = Theta1_grad + delta2 * a1'; Theta2_grad = Theta2_grad + delta3 * a2';endforTheta1_grad = Theta1_grad ./ m;Theta2_grad = Theta2_grad ./ m;% -------------------------------------------------------------Theta1(:, 1) = 0;Theta2(:, 1) = 0;Theta1_grad = Theta1_grad + (lambda / m) * Theta1;Theta2_grad = Theta2_grad + (lambda / m) * Theta2;% =========================================================================% Unroll gradientsgrad = [Theta1_grad(:) ; Theta2_grad(:)];end 12345678910111213141516171819% sigmoidGradientfunction g = sigmoidGradient(z)%SIGMOIDGRADIENT returns the gradient of the sigmoid function%evaluated at z% g = SIGMOIDGRADIENT(z) computes the gradient of the sigmoid function% evaluated at z. This should work regardless if z is a matrix or a% vector. In particular, if z is a vector or matrix, you should return% the gradient for each element.g = zeros(size(z));% ====================== YOUR CODE HERE ======================% Instructions: Compute the gradient of the sigmoid function evaluated at% each value of z (z can be a matrix, vector or scalar).g = sigmoid(z) .* (1 - sigmoid(z));% =============================================================end 123456789101112131415161718192021222324252627282930% randInitalizeWeights.mfunction W = randInitializeWeights(L_in, L_out)%RANDINITIALIZEWEIGHTS Randomly initialize the weights of a layer with L_in%incoming connections and L_out outgoing connections% W = RANDINITIALIZEWEIGHTS(L_in, L_out) randomly initializes the weights % of a layer with L_in incoming connections and L_out outgoing % connections. %% Note that W should be set to a matrix of size(L_out, 1 + L_in) as% the first column of W handles the "bias" terms%% You need to return the following variables correctly W = zeros(L_out, 1 + L_in);% ====================== YOUR CODE HERE ======================% Instructions: Initialize W randomly so that we break the symmetry while% training the neural network.%% Note: The first column of W corresponds to the parameters for the bias unit%epsilon_init = 0.12W = rand(L_out + L_in) * 2 * epsilon_init - epsilon_init;% =========================================================================end]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[std::heap 学习]]></title>
    <url>%2F2021%2F09%2F10%2Fstd-heap-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这个标题其实是错的,因为并没有heap这一个容器 但是有堆相关的一些作用在序列上的操作 std::make_heap将一个数组变成一个堆 可以传入一个比较函数自定义大根堆还是小根堆 $O(n)$ std::push_heap插入元素 $O(\log n)$ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt; int main()&#123; std::vector&lt;int&gt; v &#123; 3, 1, 4, 1, 5, 9 &#125;; std::make_heap(v.begin(), v.end()); std::cout &lt;&lt; "v: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; v.push_back(6); std::cout &lt;&lt; "before push_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::push_heap(v.begin(), v.end()); std::cout &lt;&lt; "after push_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n';&#125; vector在最后插入后调用这个函数 std::pop_heap弹出元素 调用后最大元素被放在数组末尾, 然后pop_back就能得到最大元素 $O(\log n)$ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt; int main()&#123; std::vector&lt;int&gt; v &#123; 3, 1, 4, 1, 5, 9 &#125;; std::make_heap(v.begin(), v.end()); std::cout &lt;&lt; "v: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; std::pop_heap(v.begin(), v.end()); // moves the largest to the end std::cout &lt;&lt; "after pop_heap: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n'; int largest = v.back(); v.pop_back(); // actually removes the largest element std::cout &lt;&lt; "largest element: " &lt;&lt; largest &lt;&lt; '\n'; std::cout &lt;&lt; "heap without largest: "; for (auto i : v) std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\n';&#125; Output: 1234v: 9 5 4 1 1 3 after pop_heap: 5 3 4 1 1 9 largest element: 9heap without largest: 5 3 4 1 1 std::sort_heapmake_heap后调用, 将整个数组排序, 相当于调用了很多次pop_heap, 直到堆里只有一个元素 $O(n\log n)$ std::is_heap判断指定序列是不是堆 $O(n)$]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 2020 年春季考试]]></title>
    <url>%2F2021%2F09%2F10%2FPAT-2020-%E5%B9%B4%E6%98%A5%E5%AD%A3%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[真题练习第四套 PrimeDay给一个日期, 问从最高位依次去掉一位后是不是质数 题解模拟即可, 用python很方便 代码12345678910111213141516171819202122232425262728from math import sqrtdef isPrime(x: int) -&gt; bool: if x &lt; 2: return False else: for i in range(2, int(sqrt(x) + 1)): if x % i == 0: return False return Trueif __name__ == '__main__': x = input() flag = True while len(x) &gt;= 1: tmp = int(x) if isPrime(tmp): print(x, 'Yes') else: flag = False print(x, 'No') x = x[1:] if flag == True: print('All Prime!') The Judger游戏规则是有$n$个人进行$m$轮报数, 每轮报数的规则是 之前没有出现过 必须是之前出现过的两个数的差 谁报数不满足规则就淘汰, 在每一轮结束时给出这一轮有没有人淘汰 题解按照规则模拟, 关键部分是如何判定合法, 第一条很简单用set存, 第二条一开始想的是每新来一个数就把他和之前所有数做差, 放到可选的集合中, 再有新来的数就在集合里找, 理所应当的TLE了. 一个数是之前出现过的两个数的差, 除了直接这样找外, 还可以转换成一个数与之前某个出现过的数相加的和曾经出现过, 这样就从 $O(n^2)$​ 变成了 $O(n)$​, 就过了. 学到两点 std::unordered_set比普通set更快 一种转化 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;// #include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;const int maxn = 10 + 10;const int maxm = 1000 + 10;std::unordered_set&lt;int&gt; exist;int players[maxn][maxm];bool out[maxn];int main() &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); exist.insert(x); exist.insert(y); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;players[i][j]); &#125; &#125; int cnt = 0; for (int j = 0; j &lt; m; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; if (out[i]) continue; int tmp = players[i][j]; if (exist.count(tmp) == 0) &#123; out[i] = true; for (auto x : exist) &#123; if (exist.count(x + tmp) == 1) &#123; exist.insert(tmp); out[i] = false; break; &#125; &#125; &#125; else out[i] = true; if (out[i]) &#123; printf("Round #%d: %d is out.\n", j + 1, i + 1); cnt++; &#125; &#125; &#125; if (cnt == n) printf("No winner.\n"); else &#123; printf("Winner(s):"); for (int i = 0; i &lt; n; i++) &#123; if (!out[i]) printf(" %d", i + 1); &#125; &#125; return 0;&#125; Safari Park一个动物园里面有很多区域, 可能有一些区域连在一起, 现在想在每个区域放上动物, 要求相邻的区域中动物种类不能相同, 而且动物种类要恰好$k$种 题解建图然后遍历一下每条边 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;set&gt;const int MAXN = 500 + 10;int regin[MAXN];struct Edge &#123; int u, v; Edge(int u, int v) : u(u), v(v) &#123;&#125;&#125;;std::vector&lt;Edge*&gt; edges;int main() &#123; int n, r, k; scanf("%d%d%d", &amp;n, &amp;r, &amp;k); for (int i = 0; i &lt; r; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); edges.push_back(new Edge(u, v)); &#125; std::set&lt;int&gt; st; int m; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; st.clear(); for (int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;regin[j]); st.insert(regin[j]); &#125; if (st.size() &gt; k) printf("Error: Too many species.\n"); else if (st.size() &lt; k) printf("Error: Too few species.\n"); else &#123; bool flag = true; for (auto e : edges) &#123; if (regin[e-&gt;u] == regin[e-&gt;v]) &#123; printf("No\n"); flag = false; break; &#125; &#125; if (flag) printf("Yes\n"); &#125; &#125; return 0;&#125; Replacement Selection题目非常长. 而且看不懂 描述的是外部排序的一种算法, 在王道数据结构里有讲, 但是王道书上用的实现方法需要用到一种特殊的数据结构, 不适用于这个问题 这个算法的核心思想是把数据分成一轮一轮进行排序, 这个题目就是要给出划分一轮一轮的过程 题解重点在于理解题意 Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run. 假设我们要升序排序, 如果下一个数不比刚刚输出的数小, 他就可以被加入到这一轮中 For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. 例如我们要排序这一串数, 内存一次只能存下三个数 we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. 先把前三个数加到工作队列中, 从中选出最小的一个, 也就是$11$ Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 } 现在空出了一个位置, 因为$96 &gt; 11$, 所以可以放到工作队列中 After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. 再选出最小的一个, 是$81$, 现在待排序列中的下一个数是$12$,比$81$小, 所以不要, 把他空过去, 先找个地方暂存一下, 下一轮再来处理. 工作队列里现在是$94$​和$96$​, 这一轮没有进来的. $94$​出去, 看下一个是$99$​, 可以进来, 队列变成$96$​和$99$​, 然后$96$​出去, 看下一个是$35$​, 不行, 把他和$12$​放到一起作为下一轮处理, $96$​出去, $99$​出去, 队列空了, 待排序序列也没有了, 还有一个二轮序列, 把他们都扔到工作队列中, 按照刚才的方式再处理一遍就可了 但是这个例子还是简单了, 样例中有个$28$的处理一直看不懂 刚才的过程抽象成代码就是四个序列, 题目给出的待排序序列, 优先队列, 长度为$m$​, 目的是选出最小的 这轮排序的序列 下轮排序的序列 注意是下轮排序的序列长度最多不会超过$m$​, 所以筛选完之后可以全部扔到优先队列里​ 不会超过$m$是因为在不往优先队列里放元素的时候它也在往外出, 出$m$​次就空了, 空了就该开始下一轮 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAXN = 100000 + 10;std::vector&lt;int&gt; nowTurn, nextTurn;std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq;int a[MAXN];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; int index = 0; while (index &lt; m) &#123; pq.push(a[index++]); &#125; int cnt = 0; while (cnt &lt; n) &#123; int now = pq.top(); pq.pop(); cnt++; nowTurn.push_back(now); if (index &lt; n) &#123; if (a[index] &gt; now) pq.push(a[index++]); else nextTurn.push_back(a[index++]); &#125; if (pq.empty()) &#123; for (int i = 0; i &lt; nowTurn.size(); i++) &#123; printf("%d%c", nowTurn[i], " \n"[i == nowTurn.size() - 1]); &#125; nowTurn.clear(); for (auto x : nextTurn) &#123; pq.push(x); &#125; nextTurn.clear(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 2020 年秋季考试]]></title>
    <url>%2F2021%2F09%2F10%2FPAT-2020-%E5%B9%B4%E7%A7%8B%E5%AD%A3%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[真题练习第三套 Panda and PP Milk熊猫排排喝牛奶, 体重越高奶量越大, 相邻的熊猫必须满足这个规则, 最少200, 每次最少加100求满足条件的最小总奶量 题解一开始想的是找一个下降的序列, 下降到底部给200, 然后反着隔一个加100但是这样是不行的, 如果序列是上升的, 就没有这个规律了所以反着再做一遍, 两个取最大 可惜这样也是不行的 考虑左边的邻居, 先满足左边, 如果比左边的大就加一百, 和左边相等就不变, 比左边小就变成200. 再考虑右边, 做法一样, 然后两个数组同一个位置取其中较高的那个即可既满足左边有满足右边 学到两点 序列问题要敢于暴力 正着一遍反着一边取最高 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;const int MAXN = 10000 + 10;struct pandas &#123; int w, m;&#125; p[MAXN];std::vector&lt;int&gt; v1, v2;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;p[i].w); &#125; p[0].m = 200; v1.push_back(p[0].m); for (int i = 1; i &lt; n; i++) &#123; if (p[i].w &gt; p[i - 1].w) p[i].m = p[i - 1].m + 100; else if (p[i].w == p[i - 1].w) p[i].m = p[i - 1].m; else p[i].m = 200; v1.push_back(p[i].m); &#125; p[n - 1].m = 200; v2.push_back(p[n - 1].m); for (int i = n - 2; i &gt;= 0; i--) &#123; if (p[i].w &gt; p[i + 1].w) p[i].m = p[i + 1].m + 100; else if (p[i].w == p[i + 1].w) p[i].m = p[i + 1].m; else p[i].m = 200; v2.push_back(p[i].m); &#125; std::reverse(v2.begin(), v2.end()); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; // printf("%d ", std::max(v1[i], v2[i])); ans += std::max(v1[i], v2[i]); &#125; // printf("\n"); printf("%d\n", ans); return 0;&#125; How Many Ways to Buy a Piece of Land买地, 每块地有一个价格, 每次选连续的一段买, 给定手里的钱问有多少种购买方案 题解前缀和 代码12345678910111213141516171819202122232425#include &lt;cstdio&gt;const int MAXN = 10000 + 10;int a[MAXN];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); if (i == 1) a[i] = x; else a[i] = a[i - 1] + x; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; if (a[j] - a[i - 1] &lt;= m) ans++; &#125; &#125; printf("%d\n", ans);&#125; Left-View of Binary Tree给定中序和前序遍历, 求这棵树从左边看的节点, 也就是找到左边没有别的节点的节点 题解建树, 经典操作了, 注意要用递归的方式, 函数返回节点的指针. 所谓最左边的节点, 就是层次遍历中每一层最先被加入进来的节点 学到一点 注意建树操作 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;const int MAXN = 20 + 10;int inorder[MAXN], preorder[MAXN];struct Node &#123; int id; Node *lc, *rc; int depth; Node(int id) : id(id) &#123; lc = rc = nullptr; depth = 0; &#125;&#125;;Node* build(int l1, int r1, int l2, int r2) &#123; if (l1 &gt; r1) return nullptr; Node *root = new Node(preorder[l1]); // printf("%d\n", root-&gt;id); int tmp = 0; while (inorder[l2 + tmp] != root-&gt;id) tmp++; root-&gt;lc = build(l1 + 1, l1 + tmp, l2, tmp - 1); root-&gt;rc = build(l1 + tmp + 1, r1, l2 + tmp + 1, r2); return root;&#125;void pre(Node *root) &#123; printf("%d\n", root-&gt;id); if (root-&gt;lc) pre(root-&gt;lc); if (root-&gt;rc) pre(root-&gt;rc);&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;inorder[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;preorder[i]); Node *root = build(0, n - 1, 0, n - 1); // pre(root); std::queue&lt;Node*&gt; q; q.push(root); int nowDep = -1; std::vector&lt;int&gt; ans; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); if (v-&gt;depth &gt; nowDep) &#123; ans.push_back(v-&gt;id); nowDep = v-&gt;depth; &#125; if (v-&gt;lc) &#123; v-&gt;lc-&gt;depth = v-&gt;depth + 1; q.push(v-&gt;lc); &#125; if (v-&gt;rc) &#123; v-&gt;rc-&gt;depth = v-&gt;depth + 1; q.push(v-&gt;rc); &#125; &#125; for (int i = 0; i &lt; ans.size(); i++) &#123; printf("%d%c", ans[i], " \n"[i == ans.size() - 1]); &#125; return 0;&#125; Professional Ability Test很多科目有前置关系, 完成一个科目回有相应的代价和收益, 给出K个询问, 问能不能找到一条学习路径, 使得代价最小的前提下收益最高 题解其实就是一个最短路问题, 做的时候没读清楚题, 以为给出的询问是要按顺序完成, 其实每个都是单独的, 里面这种前置问题的描述很像拓扑排序, 但是其实就是一个有向边而已, 对于多个能直达的点用一个虚拟节点把他们连接起来, 然后跑单源最短路径 学到一点: 增加虚拟节点, 转换为单源最短路径 代码自己的代码没有写好 总之就是一个简单的迪杰斯特拉]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 2020 年冬季考试]]></title>
    <url>%2F2021%2F09%2F10%2FPAT-2020-%E5%B9%B4%E5%86%AC%E5%AD%A3%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[真题练习第二套 The Closest Fibonacci Number和给定的$n$的差的绝对值最小的斐波那契数​ 题解直接递推 代码1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;int main() &#123; int n; scanf("%d", &amp;n); int a[2] = &#123;1, 1&#125;; int cnt = 0; while (a[0] &lt; n &amp;&amp; a[1] &lt; n) &#123; a[cnt % 2] = a[0] + a[1]; cnt++; &#125; if (std::abs(a[0] - n) &lt; std::abs(a[1] - n)) printf("%d\n", a[0]); else if(std::abs(a[0] - n) &gt; std::abs(a[1] - n)) printf("%d\n", a[1]); else printf("%d\n", std::min(a[0], a[1])); return 0;&#125; Subsequence in Substring给一个字符串, 一个子序列, 问出现这个子序列的最短的子串是哪个, 答案不唯一就输出最左边的 题解暴力, 但不是枚举每个子串, 当子串第一个字符和子序列第一个字符匹配的时候再往下继续比 最开始考虑的是字串第一个字符和最后一个字符匹配的时候进行比较, 实际上找到所有匹配开头的字符和匹配结尾的字符再组合,复杂度就高出很多 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;climits&gt;using std::cin;using std::cout;using std::endl;using std::string;int main() &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; std::vector&lt;int&gt; st; int ansst = 0, anslen = INT_MAX; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == p[0]) &#123; int index = 0; for (int j = i; j &lt; s.size(); j++) &#123; if (s[j] == p[index]) index++; if (index == p.size() &amp;&amp; (j - i) + 1 &lt; anslen) &#123; ansst = i; anslen = (j - i) + 1; &#125; &#125; &#125; &#125; cout &lt;&lt; s.substr(ansst, anslen); return 0;&#125; File Path模拟一个文件树, 找指定的文件 题解模拟即可,这种模拟题写起来很舒服 读取一行是getline(cin, s) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using std::cin;using std::cout;using std::string;struct FileSys &#123; FileSys *fa; string name; std::vector&lt;FileSys*&gt; ch; FileSys(string name) : name(name) &#123; fa = nullptr; &#125; FileSys(string name, FileSys *fa) : name(name), fa(fa) &#123; ; &#125;&#125;;void find(string s, FileSys *root, FileSys **target) &#123; if (root-&gt;name == s) &#123; (*target) = root; return; &#125; if (root-&gt;ch.empty()) return; for (auto x : root-&gt;ch) &#123; find(s, x, target); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; getchar(); FileSys *root = new FileSys("0000"); int nowD = 1; FileSys* nowFa = root; for (int i = 0; i &lt; n; i++) &#123; string s; std::getline(cin, s); if (i == 0) continue; int d = s.size() - 4; if (d == nowD) nowFa-&gt;ch.push_back(new FileSys(s.substr(d, 4), nowFa)); else if (d &gt; nowD) &#123; nowD = d; nowFa = nowFa-&gt;ch.back(); nowFa-&gt;ch.push_back(new FileSys(s.substr(d, 4), nowFa)); &#125; else if (d &lt; nowD) &#123; while (nowD &gt; d) &#123; nowFa = nowFa-&gt;fa; nowD--; &#125; nowFa-&gt;ch.push_back(new FileSys(s.substr(d, 4), nowFa)); &#125; &#125; int k; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; string s; cin &gt;&gt; s; FileSys *target = nullptr; find(s, root, &amp;target); if (target == nullptr) cout &lt;&lt; "Error: " &lt;&lt; s &lt;&lt; " is not found.\n"; else &#123; std::stack&lt;FileSys*&gt; stk; do &#123; stk.push(target); target = target-&gt;fa; &#125; while(target != nullptr); while (!stk.empty()) &#123; cout &lt;&lt; stk.top()-&gt;name; stk.pop(); if (!stk.empty()) cout &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; "\n"; &#125; &#125; return 0;&#125; Chemical Equation给出一些反应物, 一些目标生成物, 一些方程式, 求一个最短的反应方式, 每种反应物只能用一次 题解其实是一个类似于八皇后的搜索问题, 当时做的时候以为方程可以相接, 也就是一个方程的产物可以接着用来作为原料, 但是题意要求就用给出的方程式. 其中反应物只能用一次,也就是这个反应用了, 下个反应用不了,有没有别的方案可以完成,就回溯. 问题在于有多种解的时候, 要求要有最小的反应序列 A sequence ${ a_1,⋯,a_m } $is said to be smaller than another sequence ${ b_1,⋯,b_n }$ if there exists $1\le i \le \min(m,n)$ so that $a_j = b_j$ for all $j &lt; i$, and $a_i&lt;b_i$​​. 如果存在这样一个$i$, 在这个$i$之前所有的都相等, 但是第$i$个小, 那整个串就小, 不考虑长度的问题 对于样例我的输出是 12303 + 09 -&gt; 0801 + 05 -&gt; 0304 -&gt; 04 样例输出是 12302 + 03 + 05 -&gt; 0801 + 09 + 16 -&gt; 0304 -&gt; 04 可以看出第一个反应中我不是最小的, 也就导致了第二个反应中五号元素能被继续使用 我的排序方案是按照长度排序, 换成按照反应物序号排序似乎更合题意 只需一个小小的改动 学到了 说白了还是英文读题不细, 遇到不懂的多读几遍, 时间是够的 处理字符串用sstream 代码代码只有部分正确, 估计就是这个最短没把握好 测试点 结果 得分 耗时 内存 0 答案错误 0 4.00 ms 320 KB 1 答案错误 0 5.00 ms 448 KB 2 答案正确 2 4.00 ms 316 KB 3 答案正确 2 4.00 ms 316 KB 4 答案正确 2 5.00 ms 312 KB 5 答案错误 0 5.00 ms 308 KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;bool haveReactants[100];int reactant[100];int product[100];struct Equation &#123; std::vector&lt;int&gt; reactants; int product; bool operator&lt;(const Equation &amp;a) const &#123; return this-&gt;reactants.size() &lt; a.reactants.size(); &#125;&#125; equations[100 + 10];bool judge(Equation eq) &#123; for (auto x : eq.reactants) &#123; if (!haveReactants[x]) return false; &#125; return true;&#125;bool flag = false;void dfs(int cur, int n, int m, int k, std::vector&lt;Equation&gt; &amp;ans) &#123; if (flag) return; if (cur == m) &#123; for (auto x : ans) &#123; for (int i = 0; i &lt; x.reactants.size(); i++) &#123; printf("%02d%s", x.reactants[i], i == x.reactants.size() - 1 ? " -&gt; " : " + "); &#125; printf("%02d\n", x.product); &#125; flag = true; return; &#125; for (int i = 0; i &lt; k + n; i++) &#123; if (equations[i].product == product[cur] &amp;&amp; judge(equations[i])) &#123; for (auto x : equations[i].reactants) &#123; haveReactants[x] = false; &#125; ans.push_back(equations[i]); dfs(cur + 1, n, m, k, ans); for (auto x : equations[i].reactants) &#123; haveReactants[x] = true; &#125; ans.pop_back(); &#125; &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;reactant[i]); haveReactants[reactant[i]] = true; &#125; int m; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;product[i]); &#125; int k; scanf("%d", &amp;k); getchar(); for (int i = 0; i &lt; k; i++) &#123; std::string s; std::getline(std::cin, s); std::stringstream ss(s); int reactant; std::string op; do &#123; ss &gt;&gt; reactant; equations[i].reactants.push_back(reactant); ss &gt;&gt; op; &#125; while(op != "-&gt;"); int product; ss &gt;&gt; product; equations[i].product = product; &#125; for (int i = 0; i &lt; n; i++) &#123; equations[k + i].reactants.push_back(reactant[i]); equations[k + i].product = reactant[i]; &#125; // for (int i = 0; i &lt; k; i++) &#123; // for (auto x : equations[i].reactants) &#123; // printf("%d ", x); // &#125; // printf("-&gt;%d\n", equations[i].product); // &#125; std::sort(equations, equations + k + m); std::vector&lt;Equation&gt; ans; dfs(0, n, m, k, ans); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 2021 年春季考试]]></title>
    <url>%2F2021%2F09%2F10%2FPAT-2021-%E5%B9%B4%E6%98%A5%E5%AD%A3%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[真题练习第一套 Arithmetic Progression of Primes给一个上界, 求一个指定长度的由质数组成的等差数列, 要求数列第一项尽可能大 题解先筛出所有的质数, 从小到大枚举公差, 从后向前枚举末项 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;const int MAXN = 100000 + 10;bool isPrime[MAXN];void getPrime() &#123; isPrime[1] = isPrime[0] = false; for (int i = 2; i &lt;= MAXN; i++) &#123; if (!isPrime[i]) continue; for (int j = i * 2; j &lt;= MAXN; j += i) &#123; isPrime[j] = false; &#125; &#125;&#125;int main() &#123; int n, maxp; scanf("%d%d", &amp;n, &amp;maxp); memset(isPrime, true, sizeof(isPrime)); getPrime(); std::vector&lt;int&gt; prime; for (int i = 0; i &lt;= maxp; i++) &#123; if (isPrime[i]) prime.push_back(i); &#125; if (n == 0) &#123; printf("%d\n", prime.back()); return 0; &#125; else if (n == 1) &#123; printf("%d\n", prime.back()); return 0; &#125; int num = 0; int d = maxp / (n - 1); int nowP = 0; bool flag = false; while (d &gt;= 1) &#123; for (int i = prime.size() - 1; i &gt;= 0; i--) &#123; num = 1; nowP = prime[i]; while (nowP - d &gt;= 2 &amp;&amp; isPrime[nowP - d]) &#123; num++; nowP = nowP - d; if (num == n) &#123; flag = true; break; &#125; &#125; if (flag) break; &#125; if (flag) break; d--; &#125; if (!flag) printf("%d\n", prime.back()); else &#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d%c", nowP + d * i, " \n"[i == n - 1]); &#125; &#125; return 0;&#125; Lab Access Scheduling题解代码Structure of Max-Heap给一个最大堆, 询问其中一些节点之间的关系, 是不是父子 兄弟之类 题解先建堆, cpp似乎可以用heap, 需要学习 然后处理指令, 指令比较复杂, 用sstream 处理 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//// Created by Taisitong on 2021/9/5.//#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;sstream&gt;struct Heap&#123; static const int HEAP_SIZE = 1000 + 10; int heap[HEAP_SIZE]; int size; Heap() &#123; memset(heap, 0, sizeof(heap)); size = 0; &#125; void adjust() &#123; int p = size; while (p &gt; 1 &amp;&amp; heap[p] &gt; heap[p / 2]) &#123; std::swap(heap[p], heap[p / 2]); p /= 2; &#125; &#125; void insert(int x) &#123; heap[++size] = x; adjust(); &#125; void getId(int &amp;index_x, int &amp;index_y, int x, int y) &#123; for (int i = 1; i &lt;= size; i++) &#123; if (heap[i] == x) index_x = i; if (heap[i] == y) index_y = i; &#125; &#125; bool isRoot(int x) &#123; return size &gt;= 1 &amp;&amp; heap[1] == x; &#125; bool isSibling(int x, int y) &#123; int index_x = 0, index_y = 0; getId(index_x, index_y, x, y); if (index_x == 0 || index_y == 0) return false; else &#123; if (index_y &lt; index_x) std::swap(index_x, index_y); return (index_x % 2 == 0 &amp;&amp; index_y == index_x + 1); &#125; &#125; bool isParentOf(int x, int y) &#123; int index_x = 0, index_y = 0; getId(index_x, index_y, x, y); if (index_x == 0 || index_y == 0) return false; else return (index_y / 2 == index_x); &#125; bool isLeftChildOf(int x, int y) &#123; int index_x = 0, index_y = 0; getId(index_x, index_y, x, y); if (index_x == 0 || index_y == 0) return false; else return index_x == index_y * 2; &#125; bool isRightChildOf(int x, int y) &#123; int index_x = 0, index_y = 0; getId(index_x, index_y, x, y); if (index_x == 0 || index_y == 0) return false; else return index_x == index_y * 2 + 1; &#125;&#125;;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); Heap heap; for (int i = 0; i &lt; n; i++) &#123; int x; scanf("%d", &amp;x); heap.insert(x); &#125; getchar(); for (int i = 0; i &lt; m; i++) &#123; std::string s; std::getline(std::cin, s); std::stringstream ss(s); int x, y; std::string op; ss &gt;&gt; x &gt;&gt; op; if (op == "and") &#123; ss &gt;&gt; y; printf("%d", heap.isSibling(x, y)); &#125; else &#123; ss &gt;&gt; op; ss &gt;&gt; op; if (op == "root") &#123; printf("%d", heap.isRoot(x)); &#125; else &#123; if (op == "parent") &#123; ss &gt;&gt; op; ss &gt;&gt; y; printf("%d", heap.isParentOf(x, y)); &#125; else if (op == "left") &#123; ss &gt;&gt; op; ss &gt;&gt; op; ss &gt;&gt; y; printf("%d", heap.isLeftChildOf(x, y)); &#125; else if (op == "right") &#123; ss &gt;&gt; op; ss &gt;&gt; op; ss &gt;&gt; y; printf("%d", heap.isRightChildOf(x, y)); &#125; &#125; &#125; &#125; return 0;&#125; Recycling of Shared Bicycles给一个图, 从零号点开始遍历, 每次选一个离当前点最近的点,给出需要的总花费 可能点不可达, 给出不可达的点 题解多元最短路 做的时候没读懂题, 没写出来 代码]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常数项级数]]></title>
    <url>%2F2021%2F04%2F11%2F%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常数项级数的研究核心在于其敛散性判定，若收敛，其值为多少。 首先给出定义和五条性质，对于所有级数都适用，但是不够方便，于是分类研究，正项级数四种方法，交错级数一种方法，任意项级数一种方法（绝对收敛一定收敛）。 拿到一个级数首先判断类型，对于不同类型的级数采用不同的方法。 定义无穷级数 \sum_{n=1}^\infty u_n的实质是部分和$s_n$的极限 \lim_{n \to \infty} s_n因此可以用定义来判定常数项级数的敛散性，即求数列极限。 例子判定 \sum_{n=1}^\infty \ln(1 + \frac{1}{n})的敛散性，取部分和： \begin{align} s_n &= \sum_{i=1}^n \ln(\frac{i+1}{i}) \\ &= \ln[(\frac{2}{1})(\frac{3}{2}) \cdots (\frac{n}{n-1})(\frac{n+1}{n})] \\ &= \ln(n+1) \end{align}对部分和取极限： \lim_{n\to\infty}s_n = \lim_{n \to \infty} \ln(n+1) = \infty显然是发散的 性质 一个收敛级数的每一项都乘一个常数$k$，则新级数的值为原来的$k$倍 两个数列 都收，和差收 都发，和差不一定 一收一发，和差发 相当于一个极限存在加一个极限不存在，最终结果极限不存在 级数的敛散性与其前面有限项无关，与其后面无穷多项有关 去掉任意有限项不影响级数的敛散性 收敛级数中任意加括号，结果仍然收敛，值不变 加括号相当于在原来的级数中去掉了有限项，由上一条可知去掉有限项对级数的敛散性和值不会产生任何影响 若级数收敛，则通项趋于零 如果不趋于零，往后就会越加越多，肯定不会收敛 级数收敛的必要条件 反之不成立 调和级数$\sum_{n=1}^\infty \frac{1}{n}$ 通项趋于零，但是发散 审敛法正项级数基本定理$\sum_{n=1}^\infty u_n$ 收敛，则$s_n$上有界 因为级数本质是部分和的极限，正向级数部分和一定单增，单增数列极限存在则必有上界 比较审敛法一般方法 大收小收 小发大发 通常需要进行适当的放缩 极限形式 \lim_{n\to \infty} \frac{u_n}{v_n} = l $l$ 为非零常数，两个级数“同阶”，同敛散 $l = 0$，下面的更大，一般方法 $l = \infty$，上面的更大，一般方法 通常需要将已知敛散性的级数作为一个参照标准，最常用的： \sum_{n=1}^\infty \frac{1}{n^p}, p > 1 \text{收敛}，p \leq 1 \text{发散} \sum_{n=1}^\infty aq^n, q < 1 \text{收敛}，q \geq 1 \text{发散}比值法 / 根值法不需要依赖别的已知级数 \lim_{n\to\infty} \frac{u_{n+1}}{u_n} = \rho \lim_{n\to\infty} \sqrt[n]{u_n} = \rho大于一发散，小于一收敛，等于一不确定 带有$n!$ 用比值 带有$a^n, n^n$ 用根值 方法的选择 方法 优点 缺点 特点 1， 2 适用范围广 需要找别的级数还要找的恰当，不方便 $n^p$ $\ln n$ 3， 4 方便，不需要依赖其他级数 适用范围狭窄，有些简单的级数无法判断 $a^n$ $n^n$ $n!$ 拿到题目先考虑34，不能再考虑12 交错级数 \sum_{n=1}^\infty (-1)^{n-1} u_n只有一种方法，莱布尼茨准则 两个条件： 通项单调减 通项趋于零 都满足则收敛，是收敛的充分条件 若已知交错级数收敛，可推出通项极限为零，不一定能推出通项单调减 任意项级数任意项级数的正数项和负数项都应当有无穷多项，若其中某一类有有限项，则去掉有限项不影响级数的敛散性，即可轻松转化为正项级数的判定。 解决任意项级数的敛散性，考虑转化成正项级数，对原级数的每一项取绝对值。原级数和取绝对值之后的正项级数之间有没有什么联系呢？ 有以下结论： 取绝对值后的正项级数若收敛，原级数一定收敛（绝对收敛） 原级数收敛，取绝对值后的正项级数不一定收敛（条件收敛） 条件收敛的级数所有正项/负项构成的级数一定发散 $\sum_{n=1}^\infty u_n$收敛 $\sum_{n=1}^\infty \frac{u_n + |u_n|}{2}$ 发散，看成两个级数的和，第一个级数是原级数的一半，收敛；第二个级数是绝对值级数，发散；收敛加发散结果发散 $\sum_{n=1}^\infty \frac{u_n - |u_n|}{2}$同理，发散 拿到一个任意项级数，先取绝对值，看看是不是收，收则原级数一定收，发则不能确定，此时往往回到定义和性质 技巧 可以使用等价 \begin{align} \sum_{n=1}^\infty \frac{1}{\sqrt{n}} \ln(1 + \frac{1}{n}) &= \lim_{n \to \infty} \sum_{k = 1}^n \frac{1}{\sqrt{k}} \ln(1+\frac{1}{k})\\ &= \lim_{n \to \infty} \sum_{k=1}^n \frac{1}{\sqrt{k}} \cdot \frac{1}{k} \\ &= \lim_{n \to \infty} \sum_{k=1}^n \frac{1}{k^{3/2}} \end{align} 接下来利用P级数判定 拆项，利用两个级数和差的性质 题目中给出一个级数的通项乘别人的极限存在，一定写成通项除别人的形式 若存在常数$p&gt;1$，使得 $\lim{n\to \infty} n^p a_n$ 存在，则 $\sum{n=1}^\infty a_n$ 收敛 改写成 \lim_{n\to \infty} \frac{a_n}{\frac{1}{n^p}} = A \geq 0$A&gt;0$时，由比较审敛法的极限形式可以得$a_n$和$\frac{1}{n^p}$同敛散 $A = 0$时，上面小下面大，大的收小的一定收]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>无穷级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 146 LRU缓存机制]]></title>
    <url>%2F2021%2F03%2F27%2FLeetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[实现一个LRU Cache 【思路】使用哈希表实现$O(1)$查找，可以用各种语言自带的map存储一个&lt;int, *Node&gt;键值对 $O(1)$的插入删除使用链表实现，对于一个查询操作，先在哈希表中查找到元素的指针，然后在链表中找到其值，并把该元素移动到链表的头部 链表的头部表示最近使用，尾部表示最近最久未被使用，正好符合LRU的规则，当Cache满的时候就将链表中最后一个位置删除 插入操作总是要插入到链表的头部 为了方便获取到整个链表的头和尾，使用双向链表 把某个节点从中间移动到头部可以先删掉这个节点然后再在头部插入 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package mainimport "fmt"type Node struct &#123; before, next *Node value int key int&#125;func newNode(key, value int) *Node &#123; return &amp;Node&#123; before: nil, next: nil, value: value, key: key, &#125;&#125;type LRUCache struct &#123; cache map[int]*Node capacity int size int head *Node tail *Node&#125;func Constructor(capacity int) LRUCache &#123; var ret = LRUCache&#123; cache: make(map[int]*Node), capacity: capacity, size: 0, head: newNode(0, 0), tail: newNode(0, 0), &#125; ret.head.next = ret.tail ret.tail.before = ret.head return ret&#125;func (this *LRUCache) Get(key int) int &#123; if _, ok := this.cache[key]; !ok &#123; return -1 &#125; node, _ := this.cache[key] this.moveToHead(node) return node.value&#125;func (this *LRUCache) Put(key int, value int) &#123; if node, ok := this.cache[key]; ok &#123; node.value = value this.moveToHead(node) &#125; else &#123; node := newNode(key, value) this.cache[key] = node this.addToHead(node) this.size++ if this.size &gt; this.capacity &#123; removed := this.removeTail() delete(this.cache, removed.key) this.size-- &#125; &#125;&#125;func (this *LRUCache) removeNode(node *Node) &#123; node.before.next = node.next node.next.before = node.before&#125;func (this *LRUCache) addToHead(node *Node) &#123; node.before = this.head node.next = this.head.next this.head.next.before = node this.head.next = node&#125;func (this *LRUCache) moveToHead(node *Node) &#123; this.removeNode(node) this.addToHead(node)&#125;func (this *LRUCache) removeTail() *Node &#123; node := this.tail.before this.removeNode(node) return node&#125;func main() &#123; cache := Constructor(2) cache.Put(1, 1) //[&#123;1: 1&#125;] cache.Put(2, 2) //[&#123;1: 1&#125;, &#123;2, 2&#125;] val1 := cache.Get(1) fmt.Println(val1) cache.Put(3, 3) //[&#123;1: 1&#125;, &#123;3, 3&#125;] val2 := cache.Get(2) fmt.Println(val2) cache.Put(4, 4) //[&#123;3: 3&#125;, &#123;4, 4&#125;] val3 := cache.Get(1) fmt.Println(val3) val4 := cache.Get(3) fmt.Println(val4) val5 := cache.Get(4) fmt.Println(val5)&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本积分公式]]></title>
    <url>%2F2021%2F03%2F12%2F%E5%9F%BA%E6%9C%AC%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[积分学的基础，基本积分公式 幂函数 \int x^\alpha \mathop{}\!\mathrm{d}x = \frac{1}{\alpha + 1} x^{\alpha+1} + C非常简单，最容易想到的求导逆运算。注意其中$\alpha \neq -1$ 特别地， \int x^{-1} \mathop{}\!\mathrm{d}x = \int \frac{1}{x} \mathrm{d}x = \ln |x| + C指数函数 \int a^x \mathop{}\!\mathrm{d}x = \frac{1}{\ln a}a^x + C特别地， \int e^x \mathop{}\!\mathrm{d}x = e^x + C对数函数 \int \ln x \mathop{}\!\mathrm{d}x = x \ln x - \int x \mathop{}\!\mathrm{d} \ln x = x \ln x - \int x \cdot\frac{1}{x} \mathop{}\!\mathrm{d}x = x\ln x - x + C用到了分部积分法 三角函数 \begin{align} \int \sin x \mathop{}\!\mathrm{d}x &= -\cos x + C \\ \int \cos x \mathop{}\!\mathrm{d}x &= \sin x + C \\ \int \tan x \mathop{}\!\mathrm{d}x &= \int \frac{\sin x}{\cos x} \mathop{}\!\mathrm{d}x = -\int \frac{1}{\cos x} \mathop{}\!\mathrm{d}\cos x = -\ln |\cos x| + C \\ \int \cot x \mathop{}\!\mathrm{d}x &= \int \frac{\cos x}{\sin x} \mathop{}\!\mathrm{d}x = \int \frac{1}{\sin x} \mathop{}\!\mathrm{d}x = \ln |\sin x| + C \\ \int \sec x\mathop{}\!\mathrm{d}x &= \int \frac{\sec x(\sec x + \tan x)}{\sec x + \tan x}\mathop{}\!\mathrm{d}x = \int \frac{\mathop{}\!\mathrm{d}(\sec x + \tan x)}{\sec x + \tan x} = \ln |\sec x + \tan x| + C \\ \int \csc x\mathop{}\!\mathrm{d}x &= \int \frac{\csc x(\csc x + \cot x)}{\csc x + \cot x}\mathop{}\!\mathrm{d}x = \int \frac{\mathop{}\!\mathrm{d}(\csc x + \cot x)}{\csc x + \cot x} = -\ln |\csc x + \cot x| + C \\ \end{align}前两条非常简单 中间两条用到了凑微分的方法 最后两条常人难以想到，很依靠人类智慧 $1+x^2 \or 1-x^2$$1 + x^2$ \int \frac{1}{1 + x^2} \mathop{}\!\mathrm{d}x = \arctan x + C推广： \int \frac{1}{a^2 + x^2} \mathop{}\!\mathrm{d} x = \int \frac{1}{a^2(1 + \frac{x^2}{a^2})}\mathop{}\!\mathrm{d}x = \frac{1}{a^2} \int \frac{1}{1 + (\frac{x}{a})^2}\mathop{}\!\mathrm{d}x = \frac{1}{a^2} \cdot a \cdot \frac{\mathop{}\!\mathrm{d}(\frac{x}{a})}{1 + (\frac{x}{a})^2} = \frac{1}{a} \arctan \frac{x}{a} + C(a > 0)$1 - x^2$ \int \frac{1}{1 - x^2} \mathop{}\!\mathrm{d}x = \frac{1}{2} \int (\frac{1}{1 - x} + \frac{1}{1 + x}) \mathop{}\!\mathrm{d}x = \frac{1}{2}(-\ln|1 - x| + \ln|1 + x|) + C = \frac{1}{2} \ln|\frac{1 + x}{1 - x}| + C推广： \int \frac{1}{a^2 - x^2} \mathop{}\!\mathrm{d}x = \frac{1}{2a} \int (\frac{1}{a-x} + \frac{1}{a+x}) \mathop{}\!\mathrm{d}x = \frac{1}{2a}\ln|\frac{a+x}{a-x}| + C$\sqrt{1-x^2}$ \int \frac{1}{\sqrt{1-x^2}} \mathop{}\!\mathrm{d}x = \arcsin x + C推广： \int \frac{1}{\sqrt{a^2 - x^2}} \mathop{}\!\mathrm{d}x = \frac{1}{a}\int \frac{1}{\sqrt{1-(\frac{x}{a})^2}} \mathop{}\!\mathrm{d}x = \int \frac{\mathop{}\!\mathrm{d}(\frac{x}{a})}{\sqrt{1-(\frac{x}{a})^2}} = \arcsin \frac{x}{a} + C \int \frac{1}{\sqrt{x^2 + a^2}} \mathop{}\!\mathrm{d}x = \ln(x + \sqrt{x^2 + a^2}) + C \int \frac{1}{\sqrt{x^2 - a^2}} \mathop{}\!\mathrm{d}x = \ln |x + \sqrt{x^2 - a^2}| + C]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凹凸性与拐点]]></title>
    <url>%2F2021%2F03%2F10%2F%E5%87%B9%E5%87%B8%E6%80%A7%E4%B8%8E%E6%8B%90%E7%82%B9%2F</url>
    <content type="text"><![CDATA[函数的二阶导数值如何影响函数的凹凸性 定理一： 设函数$f(x)$在区间$[a,b]$上连续，$(a,b)$内二阶可导， 如果在区间$(a,b)$上$f’’(x)&gt;0$，那么$f(x)$在$[a,b]$上是凸函数（图像为凹的） 如果在区间$(a,b)$上$f’’(x)&lt;0$，那么$f(x)$在$[a,b]$上是凹函数（图像为凸的） 证明： 设$f’’(x) &gt; 0$，则对于 $\forall x_1 &lt; x_2 \in I$，取$\xi_1 \in (x_1, \frac{x_1 + x_2}{2}), \xi_2 \in (\frac{x_1 + x_2}{2}, x_2)$根据拉格朗日中值定理 \exists \xi_1 \in (x_1, \frac{x_1 + x_2}{2}), f(\frac{x_1 + x_2}{2}) - f(x_1) = f'(\xi_1)\frac{x_2 - x_1}{2} \\ \exists \xi_2 \in (\frac{x_1 + x_2}{2}, x_2), f(x_2) - f(\frac{x_1 + x_2}{2}) = f'(\xi_2)\frac{x_2 - x_1}{2}两式相减 f(x_1) + f(x_2) - 2f(\frac{x_1 + x_2}{2}) = [f'(\xi_2) - f'(\xi_1)]\frac{x_2 - x_1}{2}又 \begin{align} & \because f''(x) > 0, \xi_1 < \xi_2\\[2ex] & \therefore f'(\xi_1) < f'(\xi_2) \\[2ex] & \therefore f'(\xi_2) - f'(\xi_1) > 0 \\[2ex] & \therefore [f'(\xi_2) - f'(\xi_1)]\frac{x_1 + x_2}{2} >0 \\[2ex] & \therefore f(x_1) + f(x_2) - 2f(\frac{x_1 + x_2}{2}) > 0 \\[2ex] & \therefore f(x_1) + f(x_2) > 2f(\frac{x_1 + x_2}{2}) \end{align}满足凸函数定义]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数的四则运算法则]]></title>
    <url>%2F2021%2F03%2F06%2F%E5%AF%BC%E6%95%B0%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[导数四则运算法则的推导，$u$ 和 $v$ 均可导 加减 \begin{align} (u \pm v)' &= \lim_{\Delta x \to 0} \frac{(u(x + \Delta x) \pm v(x + \Delta x)) - (u(x) \pm v(x))}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{(u(x + \Delta x) - u(x)) }{\Delta x} \pm \lim_{\Delta x \to 0} \frac{(v(x + \Delta x) - v(x))}{\Delta x} \\[2ex] &= u' \pm v' \end{align}乘乘法和除法都是凑了一项，感觉很巧妙 \begin{align} (uv)' &= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x + \Delta x) - u(x)v(x)}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x + \Delta x) - u(x + \Delta x)v(x)}{\Delta x} + \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - u(x)v(x)}{\Delta x}\\[2ex] &= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)[v(x + \Delta x) - v(x)]}{\Delta x} + \lim_{\Delta x \to 0} \frac{v(x)[u(x + \Delta x) - u(x)]}{\Delta x} \\[2ex] &= u(x) \lim_{\Delta x \to 0} \frac{v(x + \Delta x) - v(x)}{\Delta x} + v(x) \lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} \\[2ex] &= uv' + vu' \end{align}第三步到第四步，因为$v(x)$与极限中的变量$\Delta x$无关，因此可以提到极限的外面，这样右边的式子容易看出就是$v(x)u’(x)$，问题在于左边的部分。 根据连续的定义，$\lim_{\Delta x \to 0}u(x + \Delta x) = u(x)$，这样就可以先计算这个因子的极限然后提到外面来，得到和右边相同的结构了。 除第二步到第三步同样用到了函数连续的定义 \begin{align} (\frac{u}{v})' &= \lim_{\Delta x \to 0} \frac{\frac{u(x + \Delta x)}{v(x + \Delta x)} - \frac{u(x)}{v(x)}}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - v(x + \Delta x)u(x)}{\Delta x \cdot v(x + \Delta x)v(x)} \\[2ex] &= \frac{1}{v^2(x)} \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - v(x + \Delta x)u(x)}{\Delta x} \\[2ex] &= \frac{1}{v^2(x)} [\lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - u(x)v(x)}{\Delta x} + \frac{u(x)v(x) - v(x + \Delta x)u(x)}{\Delta x}] \\[2ex] &= \frac{1}{v^2(x)} [v(x)\lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} + u(x)\lim_{\Delta x \to 0} \frac{v(x) - v(x + \Delta x)}{\Delta x}] \\[2ex] &= \frac{1}{v^2(x)} [v(x)\lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} - u(x)\lim_{\Delta x \to 0} \frac{v(x + \Delta x) - v(x)}{\Delta x}] \\[2ex] &= \frac{vu' - uv'}{v^2} \end{align}]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本初等函数的导数]]></title>
    <url>%2F2021%2F03%2F05%2F%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本初等函数导数的证明 / 推导 很大程度上是因为手痒想写 $\LaTeX$ 了 指数函数 \begin{align} (a^x)' &= \lim_{\Delta x \to 0} \frac{a^{x + \Delta x} - a^x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{a^x(a^{\Delta x} - 1)}{\Delta x} \\[2ex] &= a^x \lim_{\Delta x \to 0} \frac{\Delta x \ln a}{\Delta x} \\[2ex] &= a^x \ln a \\ \end{align}特殊地，$(e^x)’ = e^x$ 另外也可两边取对数然后同时求导 \begin{align} & y = a^x \\ & \ln y = x \ln a \\ & \frac{\mathrm{d}}{\mathrm{d} x} \ln y = \frac{\mathrm{d}}{\mathrm{d} x} x \ln a\\ & \frac{1}{y} \cdot \frac{\mathrm{d} y}{\mathrm{d} x} = \ln a\\ & \frac{\mathrm{d} y}{\mathrm{d} x} = y \ln a = a^x \ln a \end{align}幂函数两边取对数然后同时求导 \begin{align} & y = x^a\\ & \ln y = \ln x^a = a\ln x\\ & \frac{\mathrm{d}}{\mathrm{d} x} \ln y = \frac{\mathrm{d}}{\mathrm{d} x} a \ln x\\ & \frac{1}{y} \cdot \frac{\mathrm{d} y}{\mathrm{d} x} = \frac{a}{x}\\ & \frac{\mathrm{d} y}{\mathrm{d} x} = \frac{ay}{x} = \frac{a x^a}{x} = ax^{a - 1} \end{align}对数函数 \begin{align} (\log_ax)' &= \lim_{\Delta x \to 0} \frac{\log_a (x + \Delta x) - \log_a x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\log_a \frac{x + \Delta x}{x}}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\frac{\ln \frac{x + \Delta x}{x}}{\ln a}}{\Delta x} \\[2ex] &= \frac{1}{\ln a} \lim_{\Delta x \to 0} \frac{\ln \frac{x + \Delta x}{x}}{\Delta x} \\[2ex] &= \frac{1}{\ln a} \lim_{\Delta x \to 0} \frac{\ln (1 + \frac{\Delta x}{x})}{\Delta x} \\[2ex] &= \frac{1}{x\ln a} \end{align}特殊地，$(\ln x)’ = \frac{1}{x}$ 三角函数三角函数的导数证明需要熟悉以下三角变换 / 恒等式： \sin(\alpha \pm \beta) = \sin \alpha \cos \beta \pm \cos \alpha \sin \beta \cos(\alpha \pm \beta) = \cos \alpha \cos \beta \mp \sin \alpha \sin \beta \sin^2 x + \cos^2 x = 1 \sec^2 x = 1 + \tan^2 x = \frac{\cos^2 x}{\cos^2 x} + \frac{\sin^2 x}{\cos^2 x} = \frac{1}{\cos^2 x} \csc^2 x = 1 + \cot^2 x = \frac{\sin^2 x}{\sin^2 x} + \frac{\cos^2 x}{\sin^2 x} = \frac{1}{\sin^2 x}先证明“正”相关函数，对应的“余”相关函数在其基础上略微修改即可，思路相似。 正正弦 \begin{align} (\sin x)' &= \lim_{\Delta x \to 0} \frac{\sin(x + \Delta x) - \sin x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\sin x \cos \Delta x + \cos x \sin \Delta x - \sin x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\sin x(\cos \Delta x - 1) + \cos x \sin \Delta x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\sin x(\cos \Delta x - 1)}{\Delta x} + \lim_{\Delta x \to 0} \frac{\cos x \sin \Delta x}{\Delta x} \\[2ex] &= \sin x \lim_{\Delta x \to 0} \frac{\cos \Delta x - 1}{\Delta x} + \cos x \\[2ex] &= \cos x \end{align}正切 \begin{align} (\tan x)' &= (\frac{\sin x}{\cos x})' \\[2ex] &= \frac{\cos x \cos x - \sin x (-\sin x)}{\cos^2x} \\[2ex] &= \frac{1}{\cos^2 x} \\[2ex] &= \sec^2x \end{align}正割 \begin{align} (\sec x)' &= (\frac{1}{\cos x})' \\[2ex] &= \frac{\sin x}{\cos^2 x} \\[3ex] &= \tan x \sec x \end{align}反正弦 \begin{align} & y = \arcsin x, x = \sin y \\ & \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{\cos y} = \frac{1}{\sqrt{1 - \sin^2 y}} = \frac{1}{\sqrt{1 - x^2}} \end{align}反正切 \begin{align} & y = \arctan x, x = \tan y \\ & \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{\sec^2 y} = \frac{1}{1 + \tan^2 y} = \frac{1}{1 + x^2} \end{align}余余弦 \begin{align} (\cos x)' &= \lim_{\Delta x \to 0} \frac{\cos(x + \Delta x) - cos x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\cos x \cos \Delta x - \sin x \sin \Delta x - \cos x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\cos x(\cos \Delta x - 1) - \sin x \sin \Delta x}{\Delta x} \\[2ex] &= \lim_{\Delta x \to 0} \frac{\cos x(\cos \Delta x - 1)}{\Delta x} - \lim_{\Delta x \to 0} \frac{\sin x \sin \Delta x}{\Delta x} \\[2ex] &= \cos x \lim_{\Delta x \to 0} \frac{\cos \Delta x - 1}{\Delta x} - \sin x \\[2ex] &= -\sin x \end{align}余切 \begin{align} (\cot x)' &= (\frac{\cos x}{\sin x})' \\[2ex] &= \frac{-\sin x \sin x - \cos x \cos x}{\sin^2x} \\[2ex] &= -\frac{1}{\sin^2 x} \\[2ex] &= -\csc^2x \end{align}余割 \begin{align} (\csc x)' &= (\frac{1}{\sin x})' \\[2ex] &= \frac{-\cos x}{\sin^2 x} \\[3ex] &= -\cot x \csc x \end{align}反余弦 \begin{align} & y = \arccos x, x = \cos y \\ & \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{-\sin y} = -\frac{1}{\sqrt{1 - \cos^2 y}} = -\frac{1}{\sqrt{1 - x^2}} \end{align}反余切 \DeclareMathOperator{\arccot}{arccot} \begin{align} & y = \arccot x, x = \cot y \\ & \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{-\csc^2 y} = -\frac{1}{1 + \cot^2 y} = -\frac{1}{1 + x^2} \end{align}]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七和弦]]></title>
    <url>%2F2021%2F01%2F19%2F%E4%B8%83%E5%92%8C%E5%BC%A6%2F</url>
    <content type="text"><![CDATA[七和弦关于七和弦自己的部分理解与总结 众所周知，构成三和弦的三个音依次成三度关系，以最简单的大三和弦和小三和弦为例： 大三和弦根音和三音相距一个大三度，三音和五音相距一个小三度，根音和五音相距一个纯五度， 小三和弦根音和三音相距一个小三度，三音和五音相距一个大三度，根音和五音相距一个纯五度， 也就是说仅仅是和弦的三音决定了和弦的色彩，五音是不变的 而七和弦，仅仅是在三和弦的基础上增加了七音，然后根据七音距离根音的不同音程关系具体分为很多种类]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>乐理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NJU ics 2020 概要]]></title>
    <url>%2F2021%2F01%2F12%2FNJU-ics-2020-%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[填坑 PA1 - 开天辟地的篇章：最简单的计算机实现x86的寄存器很关键的一张图 123456789101112typedef struct &#123; struct &#123; uint32_t _32; uint16_t _16; uint8_t _8[2]; &#125; gpr[8]; //relreg_t === uint32_t rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi; vaddr_t pc;&#125; x86_CPU_state; 希望下面的每一个寄存器（eax…）能和上面结构体中的结构进行对应 x86寄存器的这种结构很适合用union来表达 123456789101112131415161718typedef struct &#123; union &#123; struct &#123; union &#123; uint32_t _32; uint16_t _16; uint8_t _8[2]; &#125; &#125; gpr[8]; //relreg_t === uint32_t struct &#123; rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi; &#125;; &#125;; vaddr_t pc;&#125; x86_CPU_state; reg_test()是如何测试你的实现的? reg_l,reg_w,reg_b是/nemu/src/isa/x86/local-include/reg.h定义的三个宏，分别对应32位、16位、8位寄存器 给每一个32位寄存器赋一个随机值，然后依次检查其低16位低8位的值，最后检查pc 在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?循环for (; n &gt; 0; n--)，传入-1使得这个循环总是成立，所以会执行完全部的指令 完善调试器单步执行12345678static int cmd_si(char *args) &#123; char *arg = strtok(NULL, " "); int n = atoi(arg); cpu_exec(n); return 0;&#125; 打印寄存器1234567891011static int cmd_info(char *args) &#123; char *arg = strtok(NULL, " "); if (!strcmp(arg, "r")) &#123; //for registers isa_reg_display(); &#125; else if (!strcmp(arg, "w")) &#123; //for watch point ; &#125;&#125; 1234567891011121314void isa_reg_display() &#123; int i; for (i = R_EAX; i &lt;= R_EDI; i ++) &#123; printf("%-8s %-16x %-16d\n", regsl[i], reg_l(i), reg_l(i)); &#125; for (i = R_AX; i &lt;= R_DI; i ++) &#123; printf("%-8s %-16x %-16d\n", regsw[i], reg_w(i), reg_w(i)); &#125; for (i = R_AL; i &lt;= R_BH; i ++) &#123; printf("%-8s %-16x %-16d\n", regsb[i], reg_b(i), reg_b(i)); &#125;&#125; 扫描内存 注意要#include &quot;../../../include/memory/vaddr.h&quot; PA1第一阶段到此结束 表达式求值实现算术表达式的词法分析RTFC找到这部分的执行逻辑 表达式求值相关代码位于/home/leyan/ics2020/nemu/src/monitor/debug/expr.c，在./ui.c中#include &quot;expr.h&quot;，./expr.h中只有一个函数声明word_t expr(char*, char*)，也就是说在./ui.c中所有表达式求值的功能都由expr()这个函数来进行。 词法分析的任务相对简单，只需要把token类型写进枚举中，rule数组中存放由正则表达式和类型组成的规则 对表达式进行匹配的部分框架已经写好了，只需要对于识别出的token一次扔到tokens数组中即可，有些特殊的token需要特殊处理，例如TK_NOTYPE，表示空格，空格在词法解析中会被忽略，因此直接break就行。 这里有一个小坑就是strncpy不会包含最后的\0，需要手动加上。 实现算术表达式的递归求值递归求值的部分文档里写的很清晰，只要填框架就行了，目前没有发现坑。 实现表达式生成器这一部分的代码在/nemu/tools/gen-expr.c中，大体的思路就是先生成表达式字符串，在把它塞进这样一个C语言代码字符串里： 123456&quot;#include &lt;stdio.h&gt;\n&quot;&quot;int main() &#123; &quot;&quot; unsigned result = %s; &quot;&quot; printf(\&quot;%%u\&quot;, result); &quot;&quot; return 0; &quot;&quot;&#125;&quot;; 然后输出到文件里，调用gcc编译运行并获得输出结果。 一些细节： 如何保证表达式进行无符号运算? 先进行有符号运算最后转成无符号数 如何生成长表达式, 同时不会使buf溢出? 设定一个上限，超过了就返回 如何过滤求值过程中有除0行为的表达式? 调用gcc的时候把所有警告视为错误，这样system的返回值不为零，就不会写进文件里 有了表达式生成器就可以测试之前的递归求值了 PA1阶段2到此结束 监视点监视点的功能是监视一个表达式的值何时发生变化。 扩展算数表达式求值功能123456789101112&lt;expr&gt; ::= &lt;decimal-number&gt; | &lt;hexadecimal-number&gt; # 以&quot;0x&quot;开头 | &lt;reg_name&gt; # 以&quot;$&quot;开头 | &quot;(&quot; &lt;expr&gt; &quot;)&quot; | &lt;expr&gt; &quot;+&quot; &lt;expr&gt; | &lt;expr&gt; &quot;-&quot; &lt;expr&gt; | &lt;expr&gt; &quot;*&quot; &lt;expr&gt; | &lt;expr&gt; &quot;/&quot; &lt;expr&gt; | &lt;expr&gt; &quot;==&quot; &lt;expr&gt; | &lt;expr&gt; &quot;!=&quot; &lt;expr&gt; | &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt; | &quot;*&quot; &lt;expr&gt; # 指针解引用 这个部分硬写就行，重点是单目运算符的实现，框架中给出了思路，在正则匹配的阶段是无法区分乘号*和解引用*的，需要在识别出token之后，求值之前，把解引用标识出来 解引用是单目运算，因此左边不能是数字或右括号 在寻找主运算符的过程中，要注意单目运算符的优先级高，找主运算符时应该跳过 负数的处理也类似 实现监视点监视点池就是一个链表，注意删除的时候判断空，否则会触发段错误 没什么好说的，就是一些链表操作、 调试的建议 总是使用-Wall和-Werror 尽可能多地在代码中插入assert() assert()无法捕捉到error时, 通过printf()输出可疑的变量, 期望能观测到error printf()不易观测error时, 通过GDB理解程序的精确行为 断点的工作原理在PA中可以用w pc == ADDR来模拟断点，但是这样会影响效率 How debuggers work: Part 2 - Breakpoints 这篇文章介绍了GDB打断点的原理，简要概括如下： 断点通过软中断（trap / software interrupts）实现 发生中断时，CPU会保存当前的状态，跳转到一个事先确定的处理相应中断的程序的位置 硬件中断和软件中断都是如此 断点通过一种特殊的trap——int3来实现 这里的int不是类型，而是x86对于trap指令的一种术语，指的是对预先定义的处理程序的调用，interrupt int指令可以跟一个8位的操作数，这个操作数表明了中断的编号，理论上可以有$2^8 = 256$种中断，我们关心的中断是三号中断int3 int3称为trap to debugger 当进程执行int3指令时，OS会停止当前的进程，并向他发送一个SIGTRAP信号 思考题： x86的int3指令不带任何操作数, 操作码为1个字节, 因此指令的长度是1个字节. 这是必须的吗? 假设有一种x86体系结构的变种my-x86, 除了int3指令的长度变成了2个字节之外, 其余指令和x86相同. 在my-x86中, 上述文章中的断点机制还可以正常工作吗? 为什么? 如何阅读手册查阅手册回答 EFLAGS寄存器中的CF位是什么意思? Figure 2-8. EFLAGS Register CF：Carry Flag 进位标志 ModR/M字节是什么? ModR/M是x86指令中的一个字节 x86指令的一般格式如下: 12345678+-----------+-----------+-----------+--------+------+------+------+------------+-----------+|instruction| address- | operand- |segment |opcode|ModR/M| SIB |displacement| immediate || prefix |size prefix|size prefix|override| | | | | ||-----------+-----------+-----------+--------+------+------+------+------------+-----------|| 0 OR 1 | 0 OR 1 | 0 OR 1 | 0 OR 1 |1 OR 2|0 OR 1|0 OR 1| 0,1,2 OR 4 |0,1,2 OR 4 || - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|| number of bytes |+------------------------------------------------------------------------------------------+ 除了opcode(操作码)必定出现之外, 其余组成部分可能不出现, 而对于某些组成部分, 其长度并不是固定的. 但给定一条具体指令的二进制形式, 其组成部分的划分是有办法确定的, 不会产生歧义(即把一串比特串看成指令的时候, 不会出现两种不同的解释). 去手册中查询指令的一般格式 17.2 Instruction Format ModR/M 和 SIB 字节跟在 opcode 后面， 包括以下信息 指令中要使用的索引类型或者寄存器号 要使用的寄存器或者用来选择指令的更多信息 base, index, 和 scale 的相关信息 ModR/M 字节包括三部分信息: mod field, 占用字节的两个最高位, 和 r/m field 结合表示32个可能的值: 8个寄存器和和24个 index mode。 The reg field, 占用 mod field 接下来的三位，决定是寄存器号还是 opdode 的额外3位，取决于 opcode 的第一个字节。 The r/m field, 占用三个最低位, 决定寄存器是操作数的位置或者可以与上述字段结合形成寻址模式编码的一部分。 mov指令的具体格式是怎么样的? 12345678910111213141516171819202122Opcode Instruction Clocks Description88 /r MOV r/m8,r8 2/2 Move byte register to r/m byte89 /r MOV r/m16,r16 2/2 Move word register to r/m word89 /r MOV r/m32,r32 2/2 Move dword register to r/m dword8A /r MOV r8,r/m8 2/4 Move r/m byte to byte register8B /r MOV r16,r/m16 2/4 Move r/m word to word register8B /r MOV r32,r/m32 2/4 Move r/m dword to dword register8C /r MOV r/m16,Sreg 2/2 Move segment register to r/m word8E /r MOV Sreg,r/m16 2/5,pm=18/19 Move r/m word to segment registerA0 MOV AL,moffs8 4 Move byte at (seg:offset) to ALA1 MOV AX,moffs16 4 Move word at (seg:offset) to AXA1 MOV EAX,moffs32 4 Move dword at (seg:offset) to EAXA2 MOV moffs8,AL 2 Move AL to (seg:offset)A3 MOV moffs16,AX 2 Move AX to (seg:offset)A3 MOV moffs32,EAX 2 Move EAX to (seg:offset)B0 + rb ib MOV reg8,imm8 2 Move immediate byte to registerB8 + rw iw MOV reg16,imm16 2 Move immediate word to registerB8 + rd id MOV reg32,imm32 2 Move immediate dword to registerC6 ib MOV r/m8,imm8 2/2 Move immediate byte to r/m byteC7 iw MOV r/m16,imm16 2/2 Move immediate word to r/m wordC7 id MOV r/m32,imm32 2/2 Move immediate dword to r/m dword 统计代码行数1find ./ -name "*.[ch]" | xargs wc -l &gt; statistic PA0 时的代码行数: PA1到此结束 PA2 - 简单复杂的机器: 冯诺依曼计算机系统先给出了一段YEMU的代码，其中模拟了最简单的计算机 123456// 定义指令格式typedef union &#123; struct &#123; uint8_t rs : 2, rt : 2, op : 4; &#125; rtype; struct &#123; uint8_t addr : 4 , op : 4; &#125; mtype; uint8_t inst;&#125; inst_t; 这部分定义了指令格式，其中用到了位域（Bit field）的结构 RTFCisa-cpu-exec()中，代码首先定义了一个DecodeExecState类型的结构体变量s, 它用于存放在执行一条指令过程中的译码和执行信息 123456789101112131415161718192021222324252627typedef struct &#123; uint32_t opcode; vaddr_t seq_pc; // sequential pc uint32_t is_jmp; vaddr_t jmp_pc; Operand src1, dest, src2; int width; rtlreg_t tmp_reg[4]; ISADecodeInfo isa;&#125; DecodeExecState;typedef struct &#123; uint32_t type; int width; union &#123; uint32_t reg; word_t imm; sword_t simm; &#125;; rtlreg_t *prg; /* 为了提高性能, 我们在Operand结构体中定义了一个RTL寄存器的指针preg, 用于直接指向那些已经存在的RTL寄存器. 例如如果在进行译码的时候发现操作数是eax寄存器, 那么只需要通过让preg指向cpu.eax, 将来就可以直接通过preg来访问到正确的操作数了, 而不需要通过rtl_mv()来将cpu.eax读到别处, 从而避免引入额外的开销. */ rtlreg_t val; char str[OP_STR_SIZE];&#125; Operand; 部分isa相关信息存放在ISADecodeInfo中12345678// decodetypedef struct &#123; bool is_operand_size_16; uint8_t ext_opcode; const rtlreg_t *mbase; rtlreg_t mbr; word_t moff;&#125; x86_ISADecodeInfo; 这里定义的是x86_ISADecodeInfo，但是在代码中直接用的是ISADecodeInfo，是因为 include/isa.h:13:typedef concat(__ISA__, _ISADecodeInfo) ISADecodeInfo; 这样可以让框架代码不随ISA而改变 concat(x, y)同样是一个宏，作用是把两个字符串x,y拼在一起，也就是说concat(x86, _ISADecodeInfo) == x86_ISADecodeInfo 取指取指实质上就是读内存，在pc指向的位置读一条长度为len的指令，返回读到的指令 Debug状态下会把指令的每一个字节放到一个外部数组log_bytebuf[]中。 这里读内存使用的是vaddr_ifetch()，看上去是读虚拟内存，实际上现阶段都是直接访问物理内存。 1234567891011121314static inline uint32_t instr_fetch(vaddr_t *pc, int len) &#123; //read address uint32_t instr = vaddr_ifetch(*pc, len);#ifdef DEBUG uint8_t *p_instr = (void *)&amp;instr; int i; for (i = 0; i &lt; len; i ++) &#123; extern char log_bytebuf[]; strcatf(log_bytebuf, "%02x ", p_instr[i]); &#125;#endif (*pc) += len; return instr;&#125; 译码译码实质上就是查表，把取出的指令的opcode提取出来，然后根据opcode去查表确定指令类型，这里用一个很大的switch-case来进行，其中用到了一些宏。 这些宏先设置操作数的宽度，再进行操作数译码 12345678910// empty decode helper#define decode_empty(s)#define IDEXW(idx, id, ex, w) CASE_ENTRY(idx, concat(decode_, id), concat(exec_, ex), w)#define IDEX(idx, id, ex) IDEXW(idx, id, ex, 0)#define EXW(idx, ex, w) IDEXW(idx, empty, ex, w)#define EX(idx, ex) EXW(idx, ex, 0)#define EMPTY(idx) EX(idx, inv)#define CASE_ENTRY(idx, id, ex, w) case idx: set_width(s, w), id(s), ex(s); break; 这些宏一个套一个，最终都是来自CASE_ENTRY，其中的s是DecodeExecState *s，他被用作这些函数的参数，且总叫做s。 例如： IDEXW(0x80, I2E, gp1, 1) == CASE_ENTRY(0x80, decode_I2E, exec_gp1, 1) IDEX(0x81, I2E, gp1) == IDEXW(0x80, I2E, gp1, 0) == CASE_ENTRY(0x81, decode_I2E, exec_gp1, 0) EX(0x0f, 2byte_esc) == EXW(0x0f, 2byte_esc, 0) == IDEXW(0x0f, empty, 2byte_esc, 0) == CASE_ENTRY(0x0f, decode_empty, exec_2byte_esc, 0) 其中的decode_开头的函数都是译码辅助函数 执行#define def_EHelper(name) void concat(exec_, name) (DecodeExecState *s)，用于执行，exec_开头的都是执行辅助函数。 更新PC下一条指令有静态动态两种，默认情况下取指结束后s-&gt;seq_pc会指向下一条静态地址，如果有跳转指令，s-&gt;jmp_pc会指向下一条动态指令，真正修改的时候调用update_pc()即可。 使用RTL表示指令行为 RTL寄存器 PA1中已经实现 在NEMU中, RTL寄存器只有以下这些 不同ISA的通用寄存器(在nemu/include/isa/$ISA.h中定义) id_src, id_src2和id_dest中的操作数内容val(在nemu/include/cpu/decode.h中定义). 临时寄存器s0, s1, s2和t0(在nemu/include/rtl/rtl.h中定义) 零寄存器rz(在nemu/src/monitor/cpu-exec.c中定义), 它的值总是0 x86的ISA相关译码信息中的内存基地址mbr RTL指令 1#define def_rtl(name, ...) void concat(rtl_, name)(DecodeExecState *s, __VA_ARGS__) 以def_rtl_compute_reg_imm(add)为例，完全展开为 123456789static inline void rtl_add(DecodeExecState *s, rtlreg_t* dest, const rtlreg_t* src1, const rtlreg_t* src2) &#123; //*dest = c_add(*src1, *src2); *dest = (*src1) + (*src2);&#125;static inline void rtl_addi(DecodeExecState *s, rtlreg_t* dest, const rtlreg_t* src1, const sword_t imm) &#123; //*dest = c_add(*src1, imm); *dest = (*src1) + (imm);&#125; 请整理一条指令在NEMU中的执行过程 si 1 cpu_exec(n=1) at src/monitor/cpu_exec.c isa_exec_once() at src/isa/x86/exec/exec.c fetch_decode_exec (s=0x7ffffffed860) at src/isa/x86/exec/exec.c:144 instr_fetch (pc=0x7ffffffed864, len=1) at src/isa/x86/exec/exec.c:144 取指 此时s-&gt;seq_pc往后移动了一个字节 读到了opcode，放在s中的opcode中 IDEX(0xb8, mov_I2r, mov) 指令是移动立即数到寄存器 set_width (width=0, s=0x7ffffffed860) at src/isa/x86/exec/exec.c:108 s-&gt;src1.width = s-&gt;dest.width = s-&gt;src2.width = width; //width = 4 设置操作数宽度 decode_mov_I2r (s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:166 开始译码操作数 decode_op_r (load_val=0 &#39;\000&#39;, op=0x7ffffffed8b8, s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:167 load_val = 0表示这个操作数不需要存储到s中供后续使用 operand_reg (s=0x7ffffffed860, width=4, r=0, load_val=0 &#39;\000&#39;, op=0x7ffffffed8b8) at src/isa/x86/exec/../local-include/decode.h:8 找出要用到的寄存器 在x86中, 通用寄存器都有自己的编号,I2r形式的指令把寄存器编号也放在指令的第一个字节里面, 我们可以通过位运算将寄存器编号抽取出来; r = s-&gt;opcode &amp; 0x7 == 0 decode_op_I (load_val=1 &#39;\001&#39;, op=0x7ffffffed870, s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:168 imm即为指令中的立即数，是指令的后四个字节，使用instr_fetch(&amp;s-&gt;seq_pc, op-&gt;width)获取，此时seq_pc又往后移动了四个字节。 operand_imm (width=&lt;optimized out&gt;, imm=&lt;optimized out&gt;, load_val=&lt;optimized out&gt;,op=&lt;optimized out&gt;, s=&lt;optimized out&gt;) at src/isa/x86/exec/../local-include/decode.h:40 把立即数写到s中合理的位置 执行指令调用exec_move()，位于/src/isa/x86/exec/data-mov.h 更新PC 实现指令 CALL rel32这里遇到的第一个障碍就是call指令，查看x86手册，其中给出了执行过程 1234567891011IF rel16 or rel32 type of callTHEN (* near relative call *) IF OperandSize = 16 THEN Push(IP); EIP := (EIP + rel16) AND 0000FFFFH; ELSE (* OperandSize = 32 *) Push(EIP); EIP := EIP + rel32; FI;FI; EIP是当前的指令地址，先压到栈中（push），再将EIP后移rel32 条指令 个字节 从上面的反汇编看就是从10000a往后走5条指令，到了100014 这里完全是我看错了，其实是往后走了5个字节，从下一条指令算起，这样下面的main函数的跳转也解释的通了。 PUSH通过trl_push来实现，rtl_push位于nemu/src/isa/x86/local-include/rtl.h 12345678910111213141516171819IF StackAddrSize = 16THEN IF OperandSize = 16 THEN SP := SP - 2; (SS:SP) := (SOURCE); (* word assignment *) ELSE SP := SP - 4; (SS:SP) := (SOURCE); (* dword assignment *) FI;ELSE (* StackAddrSize = 32 *) IF OperandSize = 16 THEN ESP := ESP - 2; (SS:ESP) := (SOURCE); (* word assignment *) ELSE ESP := ESP - 4; (SS:ESP) := (SOURCE); (* dword assignment *) FI;FI; 1234static inline def_rtl(push, const rtlreg_t* src1) &#123; //esp &lt;- esp - 4 //M[esp] &lt;- src1&#125; esp是栈顶指针 除了PUSH imm以外还需要实现PUSH r32，也就是10014的指令，将ebp的值入栈，ebp是栈基址，新的函数开始时应当把旧的栈基址保存下来然后把新的栈基址设为和栈顶一致，也就是10014和10015做的事情。 这个指令比较特殊因为它没有操作数，在处理的时候特判一下opcode，把要push的内容设置成ebp。更通用的push r32还没有实现。 SUB r/m16, imm8SUB做的事情是把第一个操作数减去第二个操作数，结果放在第一个操作数中，设置相应的FLAG。 当第二个操作数是立即数时要先进行符号扩展，扩展到和第一个操作数位数一样。 运行第一个C程序]]></content>
      <categories>
        <category>计算机系统基础</category>
      </categories>
      <tags>
        <tag>计算机系统基础</tag>
        <tag>计算机组成原理</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习笔记 物理层]]></title>
    <url>%2F2020%2F12%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[复习笔记，学的时候没整理，欠的还是要还 基本概念物理层的四个特性 机械特性 接口的形状尺寸、引线数目、排列方式 电气特性 各条线上电压的范围 功能特性 某个电压代表的具体含义 过程特性 对于不同功能的各种事件出现的顺序 两种信号 数字信号 不连续变化的信号，是离散的 模拟信号 连续变化的信号 基带信号 基本频带信号，包含较多的低频分量 / 直流分量，不易在信道中传输 带通信号 基带信号经过调制后把低频转化为高频 两种调制方法 基带调制 编码，把数字信号转换为另一种形式的数字信号 带通调制 利用载波进行调制，把基带信号移动到较高频段，转换为模拟信号 其他码元比特率波特率编码方式 不归零制 NRZ有电压表示1，无电压表示0 效率高，但是接收方不易同步 归零制 RZ发送窄脉冲，发送完归零 把时钟信号包含在内，但是大部分的数据带宽被浪费了 曼彻斯特编码每一位的中间进行一次跳变，向上向下分别代表0和1 差分曼彻斯特编码每一位的中间进行一次跳变，这次跳变用来时钟同步 每一位开始进行一次跳变，这次有无跳变表示0和1 非归零反相编码 NRZI信号反转与否代表0和1 USB使用NRZI编码进行传输 不具有自同步特性，但可以使用前同步码的方式进行同步 对于连续的多个1，需要进行比特填充，每7个连续的1之后插一个0 带通调制方法调幅 调频 调相 正交振幅调制 信道极限传输速率信道极限传输速率： C = W \log_2(1 + \frac{S}{N})$W$ 为带宽，单位是Hz $S$ 为信号的平均功率 $N$ 为信道内部高斯噪声功率 信噪比信号的平均功率比上噪声的平均功率 \frac{S}{N}以分贝为单位的信噪比 10 \log_{10} (\frac{S}{N})给出分贝计算出比值，进而计算出极限传输速率 香农公式理论上讲，只要信道传输速率低于信道极限传输速率，就一定能实现无差错传输 在存在高斯白噪声的信道中，最大传输速率为 \begin{align} C &= B \times \log_2(1 + \frac{S}{N}) \\ &= B \times \log_2(1 + \frac{S}{n_0 B}) \end{align}也就是说噪声功率是受带宽影响的，当带宽增大时，噪声也会随之增大，因此无法无限制提高带宽 传输媒体 双绞线 有屏蔽的双绞线 STP 无屏蔽的双绞线 UTP 光纤 单模光纤 高能量、长距离，需要激光源，成本高 1310nm 1510nm 多模光纤 传输速度低、距离短、整体性能差，但成本低 850nm 地面微波接力 卫星通信 信道复用技术频分复用每个用户被分配一个频带,不同的用户在相同时间内使用不同的频带 时分复用把时间划分为若干时分复用帧,每一个用户所占用的时隙周期性出现\ 又分同步时分复用和异步时分复用 时分复用中时隙预先分配且保持不变,可能会造成时隙浪费 统计时分复用又叫异步时分复用 能够动态按需分配时隙 波分复用一根光纤上同时传送多个不同的光载波 波分复用就是光的频分复用 使用掺铒光纤放大器 码分复用 / 码分多址CDMA 码分多址 每个站有自己的码片序列,对于1,发送自己码片的源码,对于0,发送自己码片的二进制反码(按位取反) 码片序列中用-1表示0 各个站点之间的码片相互正交 S \cdot T = \frac{1}{m} \sum_{i=1}^m S_iT_i = 0任何一个码片向量和该码片向量自己的规格化内积都是1 S \cdot S = \frac{1}{m}\sum_{i=1}^mS_iS_i = \frac{1}{m}\sum_{i=1}^m S_i^2 = 1任何一个码片向量和该码片反码的向量的规格化内积值为-1 题目共有四个站进行码分多址CDMA通信.四个站的码片序列为：A.(-1 -1 -1 +1 +1 -1 +1 +1) B.(-1 -1 +1 -1 +1 +1 +1 -1)C.(-1 +1 -1 +1 +1 +1 -1 -1) D.(-1 +1 -1 -1 -1 -1 +1 -1)现收到这样的码片序列：（-1 +1 -3 +1 -1 -3 +1 +1）.问哪个站发送了数据?发送数据的站发送的是1,还是0? 分别计算正交和,结果是1说明发了1,结果是-1说明发了0,结果是0说明没发 其他数字传输系统 PCM 方法取样量化编码 SONET 同步光纤网]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习指北]]></title>
    <url>%2F2020%2F12%2F27%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[期末复习用，主要是上课画的重点 Chapter 1 导论buffer 和 Cache 的区别与联系 Buffer是系统两端处理速度平衡（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。 Cache则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。 软中断 Chapter 2 操作系统结构Chapter3 进程Chapter 4 线程Chapter 5 同步Chapter 6 进程调度Chapter 7 死锁]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习笔记-运输层]]></title>
    <url>%2F2020%2F12%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络中最难/复杂的部分 概述运输层考虑的是两个应用进程间的逻辑通信，端到端的通信，端口到端口的通信 运输层支持复用和分用，不同进程向下提供给网络层，使用一样的服务，由网络层传上来的内容经过运输层的分用发给不同进程 TCP提供一条全双工的可靠信道 UDP提供不可靠信道，但是胜在快 DCCP提供双向单播拥塞控制连接但不可靠的协议，无连接不可靠但仍有拥塞控制 SCTP 是面向消息的， 在socket种TCP只能绑定一个IP，但SCTP可以绑定多个IP，只要其中由一对IP能通， 这条SCTP连接就还可用 多流独立有序、无序传输 需要四次握手 使用心跳机制来管理路径的可用性，如果一条连接上的连续传输失败次数大于连接最大重传次数，就会通知应用程序并关闭连接 UDP User Datagram Protocol只在IP之上增加了 复用分用、差错检测 的功能 不提供 确认 和 重传 的功能，这两个功能需要序号，然而UDP不带序号 主要特点无连接 使用尽最大努力交付，不可靠 面向报文 没有拥塞控制，UDP无连接且不带拥塞控制不代表只要无连接就不带拥塞控制 UDP支持一对一、一对多、多对一、多对多的交互通信 UDP的首部开销小，只有8字节，而TCP有20字节 如何理解UDP是面向报文的UDP把应用层交下来的报文添加头部后就交给网络层，应用层交给UDP多长的报文UDP就发送多长的报文，既不合并，也不拆分 接收方接收到UDP报文后去掉头部后一次交付给上层，一次交付一个完整的报文 因此应用层应当选择恰当的报文长度，若太长则会引发IP分片，若太短则使IP首部相对过大，传输效率低 UDP首部 计算检验和时需要把伪首部和UDP数据报连接在一起，检验和是为了检测整个UDP报文是否出错 伪首部是为了二次验证 计算检验和时先填充、然后以两个字节为单位对整个UDP报文进行二进制反码求和 TCP Transport Control Protocol面向连接，提供点对点的全双工服务 使用socket连接，socket包括IP地址和端口号 TCP提供可靠交付的服务，有顺序控制、重发机制、端到端校验和、拥塞控制的功能 TCP面向字节流 报文段格式 序号 TCP的每一个字节都有一个序号，首部中的序号字段是本报文段发送的数据的第一个字节的序号 确认号 期望收到对方的下一个报文段的数据的第一个字节的序号 数据偏移（首部长度） 以四字节为计算单位 保留 目前全为0 六个标志位 URG 紧急标志，表明高优先级的数据，不排队、不进缓存、直接提交 ACK 确认标志，当ACK为1时确认号才有效 PSH 推送标志，用不到 RST 复位标志，出现重大差错，需要重新建立连接 SYN 同步标志， 表示是一个连接请求或连接接受报文 FIN 终止标志，用于释放连接 窗口 以字节为单位，告知对方自己的接受能力，从而使对方设置发送窗口的大小 16位，两个字节，因此窗口最大为$2^{16} - 1$ 检验和 检验首部和数据部分，计算时要在报文段的前面加上12字节的伪首部 紧急指针 配合URG使用，指出紧急数据共有多少字节 选项 选项的一般格式为类型一字节、长度一字节、信息若干字节，总和最长40字节 MSS Maximum Segment Size TCP报文中数据字段的最大长度，可以限制分片的产生，两个方向的MSS可以不同 窗口扩大选项，窗口最大$2^{16} - 1$，有些长肥管道的时延带宽积非常大，即使窗口到达最大也无法填满信道，此时可以使用窗口扩大因子进行扩大。 窗口扩大因子实际是移位数，假设TCP头部中的通告窗口大小为$N$，窗口扩大因子（位移数）是$M$，那么TCP报文段的实际接收通告窗口大小为：$N \times 2 ^ M$。M的取值范围为0 ～ 14 这样能把窗口最大 扩大到$2^{16 + 14} = 2^{30} = 1G$ 没有那么细致，毕竟只是移位 时间戳，防止序列号回绕，乱序时间判断的依据，计算RTT SACK，4号表示支持SACK，5号是SACK的内容，最多三个SACK块 填充 整个首部长度需要是4字节的整数倍 可靠传输停止等待协议 （自动重传请求 ARQ协议 Automatic Repeat Request）A向B发送一个分组，B收到后向A进行确认，A收到确认后发送下一个分组 A发送结束后设置一个超时重传计时器 &lt;第一个计时器&gt; , 超过等待时间没有收到确认就认为分组丢失，重新发送 A发送后需要保存一个刚刚发送的报文的副本，收到B的确认后再撤销计时器和副本 分组和确认分组都需要编号，从而明确收到的确认分组对应于发出去的哪个分组 分组正确到达B但是没有收到确认，存在两种可能 确认丢失，重传之后B丢弃重复分组，再次发送确认； 确认迟到，B收到重传的重复分组，丢弃，A收到迟到的确认报文，什么也不做 缺点信道利用率很低，利用率为Ｕ，则 U = \frac{T_D}{T_D + RTT + T_A}其中$T_D$是发送时间，$T_A$是发送ACK的时间 可以使用流水线传输的方式提高效率、 连续ARQ协议累计确认只对按序到达的最后一个分组发送确认 优点是及时确认丢失也不必重传，前面的ACK丢失，后续的ACK可能足以确认前面的报文段了 缺点是不能向发送方反映出接受方已经城阙收到的所有分组的信息 Go back N部分分组丢失后发送方只收到一个靠前的ACK，此时需要退回来重传已经发送过的N个分组 以字节为单位的滑动窗口最大为$2^{16}-1$ 发送方和接收方各有一个缓冲（Buffer） 对于发送方而言，其缓冲数据内的数据可以分为四类 其中第二类和第三类在一个发送窗口中 收到累计确认后，窗口右移 对于接收方而言，他的缓冲数据中存在三类，已接收，未接受准备接收，未接受未准备接收 所谓已接收实际意味着已发送确认，ACK由TCP协议栈回复，不需要等进程回复，因此不存在已接收未回复 其中未接受准备接收就是接收窗口，似乎说成未确认准备确认更合适一些？ 发送窗口和接收窗口的关系 利用滑动窗口实现可靠传输最基本的传输可靠性来自于确认重传机制，滑动窗口是实现确认重传的一种方式 发送端只有在收到对端发送的对于己方发送窗口内的字节的ACK且前面全都完成确认的情况下窗口的左边界才会移动（绕） 对于已有的确认不能撤销，因此左边沿不能左移 右边沿通常是不动和右移，在收到缩小窗口大小的信号后可能左移，但是非常不推荐 举个例子 Buffer 和窗口的关系 三个要点 发送窗口根据对方的接收窗口进行设置， 但是两者并不总是相等，因为网络传送窗口值是有延迟的 对于不按序到达的数据，TCP通常是临时存放在接收窗口中，在字节流中缺少的字节收到后再交付给上层（SACK？） 接收方必须支持累计确认，可以适当推迟确认，也可以捎带确认、 超时重传时间 RTO 的选择为什么需要考虑超时重传时间？ 重传时间过短会引起不必要的重传，占用资源；重传时间过长会导致空闲，降低传输效率 TCP通过RTT来计算RTO \begin{align} newRTO &= newRTT_S + 4 \times newRTT_D \\ newRTT_S & = (1 - \alpha)RTT_S + \alpha RTT \\ newRTT_D & = (1 - \beta)RTT_D + \beta |RTT_ S - RTT|\ \end{align}第一次测量到$RTT$时，$RTT_S = RTT$，$RTT_D = \frac{RTT}{2}$ 因此第一次测量到$RTT$时，$RTO = RTT + 4 \times \frac{RTT}{2} = 3RTT$ 因为$newRTT_D$需要用到$RTT_S$，所以应该先算，如果先算$RTT_S$，旧的值就被覆盖了 $\alpha = \frac{1}{8}, \beta = \frac{1}{4}$ 一个题目 假定TCP在开始建立连接时，发送方设定的超时重传时间$RTO = 6s$ （1）当发送方收到对方的连接确认报文段时，测量出$RTT$样本值为$1.5s$，计算现在的$RTO$值 （2）当发送方发送数据报文段并收到确认时，测量出$RTT$样本值为$2.5s$，计算现在的$RTO$值 首先要明确$RTO$的计算和初始值没有任何关系，$6s$ 是一个干扰数据 第一问： 第一次测得 $RTT$ 时 $RTO = 3RTT = 4.5s$ 此时$RTT_S = 1.5, RTT_D = 0.75$ 第二问： $newRTT_D = \frac{3}{4} \times 0.75 + \frac{1}{4}|1.5 - 2.5| = \frac{13}{16}$ $newRTT_S = \frac{7}{8} \times 1.5 + \frac{1}{8} \times 2.5 = \frac{26}{16}$ $newRTO = newRTT_S + 4RTT_D = \frac{78}{16} = 4.875$ Karn 算法计算RTT时，如果报文段重传了就不计入往返时间样本 存在一个问题，如果由于某种神秘力量，时延突然增加，在原本的时间内就收不到确认，发起重传，但是重传的RTT又不被采用，就会导致一直无法更新重传时间 修正的 Karn 算法每重传一次，RTO就增大一些 newRTO = \gamma RTO, \gamma = 2选择确认SACK双方必须事先商定好 在选项部分中指明收到的 不连续字节块 的边界 一个SACK报文最多只能指明三个字节块的边界信息 首部选项部分长度最多四十字节，一个边界用掉四字节，去掉类型和长度 流量控制控制发送方不要发得太快 利用滑动窗口实现流量控制对于接收方发出的每一个ACK，都包含自己的接收窗口大小，表示自己还能接受多少数据，发送方收到之后调整自己的发送窗口 会带来死锁的局面，当接收窗口为0时发送端便不再发送数据，但是如果接收方之后发送的非零窗口大小的报文丢失了，发送端就永远无法得知接收端已经准备好接收数据，从而产生死锁的情况 持续计时器为了解决死锁的情况，TCP为每一个连接设置了一个持续计时器 &lt;第二个计时器&gt; 如果持续计时器到时，发送方就向接收方发送一个零窗口探测报文段，若不是零，则在AC中告知，如果仍然是零，发送方就重设计时器 流量控制下的传输效率 / 发送时机 维护一个MSS Max Segment Size，缓冲中存放的数据大于MSS时组装成一个TCP报文发出去 发送方的进程显式push 发送方设置一个发送计时器，把缓冲中的数据装入报文段（长度不超过MSS） Nagle 算法对于小数据量的传送，Nagle算法会将他们写入缓冲区，累计到一定数目后再一起发送 12345678if有新資料要傳送 if訊窗大小&gt;= MSS and可傳送的資料&gt;= MSS 立刻傳送完整MSS大小的segment else if管線中有尚未確認的資料 在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列 else 立即傳送資料 在任意时刻，网络中最多只能有一个未被确认的小段，在收到确认后才会发送，也就是说发送的频率取决于RTT，是一种自时钟，ACK返回越快，数据传输也就越快。 糊涂窗口综合征由于发送方发送能力差（产生数据慢）或者接收方处理能力差（消耗数据慢）导致了发送窗口越来越小，以至于一次只能发送一个字节，造成巨大的浪费 发送端采用Nagle算法进行问题避免，发送端累计数据到MSS之后进行发送 接收端采用David D Clark&#39;s solution进行问题避免，暂时关闭接收窗口直到有能容纳MSS的空间；或者使用延迟确认的方法，不立即发送ACK，发送端会一直等待，直到接收方空间够了再发送ACK 拥塞控制拥塞是一个系统性的问题，仅仅优化局部往往难以解决问题 流量控制是局部，拥塞控制是全局 拥塞控制并不能真正控制拥塞，只是让拥塞晚一点来 拥塞控制是动态的问题 慢开始 &amp; 拥塞避免基于窗口的拥塞控制 发送方维护一个拥塞窗口cwnd，其随着网络状态动态变化，发送方的窗口为对方的接收窗口和拥塞窗口的较小值 只要没有出现拥塞，拥塞窗口就再增大一点，以便发送更多的分组，一旦出现拥塞，拥塞窗口就减小一点 工作流程 初始情况下设置拥塞窗口大小为1 MSS 每收到一个新的报文段的确认，窗口大小加一（以MSS为单位） 是一个一个增加的，但是在一个传输轮次中的表现是经过一个轮次窗口大小加倍 一个传输轮次就是一个RTT 这段时间cwnd以指数规律增长 随着cwnd不断增加，会到达一个阈值，之后每一轮cwnd只增加一 这个部分为拥塞避免，方法为加法增大 当网络拥塞发生后，cwnd回到初始值，阈值被重新设定为网络拥塞发生时cwnd大小的一般，重新进行慢开始 减小阈值的操作被称为乘法减小 快重传接收方每收到一个失序报文段后就立即发送重复确认，这样可以让发送方尽早直到有报文段没有到达接收方 发送方只要连续三次收到重复确认，就重发 没有取消超时重传计时器，但是在部分情况下可以更快重发 快恢复发送方收到三个重复确认后立即执行乘法减小，修改阈值，但是此时并不从一开始，而是直接从新的阈值开始进行加法增大 超时执行慢开始，三个重复确认执行快恢复 算法Tahoe旧的算法，没有快恢复，在恢复丢失数据报期间不能发送新的数据包，因为此时的已发送未确认大于窗口值 Reno相比Tahoe增加了快恢复 NewRenoReno提出的快速恢复算法提高了包丢失后的吞吐量和健壮性，但缺陷是它只考虑了只丢失一个包的情形，只要丢失了一个包，就被认为是发生了一次拥塞。 在实际的网络中，一旦发生拥塞，会丢弃大量的包。如果采用Reno算法，它会认为网络中发生了多次拥塞，则会多次将cwnd和ssthresh减半，造成吞吐量极具下降，当发送窗口小于3时，将无法产生足够的ACK来触发快重传而导致超时重传，超时是很严重的事情。 在只丢失一个数据包的情况下，NewReno和Reno的处理方法是一致的，而在同一个时间段丢失了多个包时，NewReno做出了改进。Reno快速恢复算法中，发送方只要收到一个新的ACK就会退出快速恢复状态而进入拥塞避免阶段，NewReno算法中，只有当所有丢失的包都重传并收到确认后才退出。 NewReno提出了PACK和RACK，在重传完成之前的ACK都是PACK，只有收到RACK之后才会结束快恢复 SACKReno的衍生版本，允许使用SACK来告知接收端自己收到了哪些部分 但是对于肠肥管道而言，每次告知对方自己收到了哪些部分的代价是很大的，此时的SACK会消耗大量的资源 随机早期检测 RED Random Early Detection网络的主体部分是通信子网，上述算法都是从端系统的角度来考虑的，其实对拥塞影响最大的是路由器的丢弃算法。 RED将路由器的到达队列划分为了三个部分 通常而言最大阈值是最小阈值的两倍，如果阈值设置不合适，RED也会引起类似于尾部丢弃导致的全局震荡 对于P丢弃，P并不是一个确定的值，而是会随着当前的平均队列长度不断变化 平均队列长度的计算 newL_{AV} = (1 - \delta) L_{AV} + \delta L$L$表示当前队列长度的样本，$L_{AV}$是旧的平均队列长度，计算方式和RTO的计算很像，$\delta$ 是零到一之间的数。 TCP的建立与释放大名鼎鼎的三次握手 TCP的连接实际上是一种虚连接，只是维护一些状态值而已 SYN=1的报文段不携带数据，但是要消耗掉一个序号，因为SYN报文段需要确认，而确认是需要序号的 ACK报文段可以携带数据（捎带确认），但是如果不携带数据，则不消耗序号，因为不需要对ACK进行确认 说白了序号就是为了确认，不需要确认就不用序号 主动关闭一方发送的序号不是随机值,而是发送到这个值了 被动关闭放的ACK不消耗序号 此时TCP连接处于半关闭状态 在左侧发送完最后的确认之后进行一个$2 \times MSL$的计时,使用时间等待计时器 &lt;第三个计时器&gt; MSL为最长报文段寿命 这个计时器是为了保证A发送的最后一个ACK能到达B,且这个连接持续时间中的所有报文段在网络中失效 为了防止TCP出现长时间的空闲,通常还有一个保活计时器 &lt;第四个计时器&gt; 超时之后每隔一段时间发送一个探测报文段,发送十个探测报文段还没有收到响应就假定客户除了故障,主动终止TCP连接 TCP 有限状态机]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验笔记（五）]]></title>
    <url>%2F2020%2F12%2F17%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[调了很久之后发现是shmget()写成了semget()导致共享内存段attach失败，但是Shell没给提示，一开始以为是死锁了各种检查信号量，最后gdb跑了一下发现是段错误了，顺便学习了怎样用gdb调试多进程并发的程序 信号量用于同步和互斥 当信号量用于表示资源数量协助我们进行资源分配与回收时，不一定只在零一之间变动 用到的函数12345#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int semflg); 创建信号量集合 1int semctl(int semid, int semnum, int cmd, ...) semnum是信号量的下标，cmd是操作的动作 cmd使用SETVALUE设置某个信号量的值 cmd使用SETALL设定一组信号量的值 NOWAIT进行一个尝试，不阻塞 UNDO意外退出没有V的时候会自动V，推荐使用 并发时进程映像的替换exec函数族 execl(const char *path, const char *arg, ...) 参数数量不确定 execv(const char *path, char *const argv[]) 拿指定的静态的可执行文件，覆盖当前进程的进程映像中的代码和数据，除了PID以外全都换了 不创建新的进程 fork之前，父子进程需要共享的内存、信号量、管道，要打开 信号量与共享内存共用并使用信号量同步作业以随机间隔生成随机字母并完成大小写转换 三进程并发，进程1生成字母，进程2大小写转换，进程3输出转换结果，每生成一个随机字母流水线就动一圈 进程1和进程2之间用共享内存段shm_1通信，进程2和进程3之间用共享内存段shm_2通信 使用四个信号量分别实现两个共享内存段的互斥访问与访问同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//sem30.c#include "sem3.h"int main(int argc, char* argv[]) &#123; int semid, shm1_id, shm2_id, semkey, shm1_key, shm2_key; int p1, p2, p3; union semun arg; semkey = ftok(PATH_FOR_FTOK, 'X'); shm1_key = ftok(PATH_FOR_FTOK, 'Y'); shm2_key = ftok(PATH_FOR_FTOK, 'Z'); semid = semget(semkey, 4 ,IPC_CREAT | 0600); shm1_id = shmget(shm1_key, SHM_SIZE, IPC_CREAT | 0600); shm2_id = shmget(shm2_key, SHM_SIZE, IPC_CREAT | 0600); arg.array = (unsigned short*)malloc(sizeof(unsigned short) * 4); arg.array[0] = 1; //mutex arg.array[1] = 0; // arg.array[2] = 1; arg.array[3] = 0; //the second arg is ignored semctl(semid, 0, SETALL, arg); p1 = fork(); if (p1) &#123; p2 = fork(); if (p2) &#123; p3 = fork(); if (p3) &#123; waitpid(p1, NULL, 0); waitpid(p2, NULL, 0); waitpid(p3, NULL, 0); semctl(semid, 0, IPC_RMID); shmctl(shm1_id, IPC_RMID, NULL); shmctl(shm2_id, IPC_RMID, NULL); free(arg.array); printf("\n"); &#125; else &#123; //chlid3 execl("./sem33", argv[1], NULL); &#125; &#125; else &#123; //child2 execl("./sem32", argv[1], NULL); &#125; &#125; else &#123; //child1 execl("./sem31", argv[1], NULL); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//sem31.c#include "sem3.h"#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;int main(int argc, char *argv[]) &#123; int semkey, shm1_key, semid, shm1_id; int seed; char c, *shm1_addr = NULL; semkey = ftok(PATH_FOR_FTOK, 'X'); shm1_key = ftok(PATH_FOR_FTOK, 'Y'); semid = semget(semkey, 0, IPC_EXCL); shm1_id = shmget(shm1_key, 0, IPC_EXCL); seed = getpid(); int i; for (i = 1; i &lt;= atoi(argv[0]); i++) &#123; do &#123; c = (char)(rand_r(&amp;seed) % 128); &#125; while(!isalpha(c)); printf("Random letter %c\n", c); P(semid, 0); // printf("sem31: P(sem0)\n"); shm1_addr = (char*)shmat(shm1_id, NULL, 0); // printf("%p\n", shm1_addr); // printf("sem31: ated\n"); // printf("c = %c\n", c); shm1_addr[0] = c; // printf("sem31: done\n"); shmdt(shm1_addr); // printf("sem31: deted\n"); // printf("sem31: try to V(sem0)\n"); V(semid, 0); // printf("sem31: V(sem0) try to V(sem1)\n"); V(semid, 1); // printf("sem31: I will sleep\n"); sleep(rand_r(&amp;seed) % 5 + 1); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//sem32.c#include "sem3.h"#include &lt;ctype.h&gt;int main(int argc, char *argv[]) &#123; int semkey, shm1_key, shm2_key, semid, shm1_id, shm2_id; char c, *shm1_addr = NULL, *shm2_addr = NULL; semkey = ftok(PATH_FOR_FTOK, 'X'); shm1_key = ftok(PATH_FOR_FTOK, 'Y'); shm2_key = ftok(PATH_FOR_FTOK, 'Z'); semid = semget(semkey, 0, IPC_EXCL); shm1_id = shmget(shm1_key, 0, IPC_EXCL); shm2_id = shmget(shm2_key, 0, IPC_EXCL); int i; for (i = 1; i &lt;= atoi(argv[0]); i++) &#123; // printf("sem2: try to P(sem1)\n\twaiting\n"); P(semid, 1); // printf("sem2: try to P(sem0)\n"); P(semid, 0); shm1_addr = (char*)shmat(shm1_id, NULL, 0); c = shm1_addr[0]; shmdt(shm1_addr); printf("read c = %c\n", c); V(semid, 0); // printf("sem2: V(sem0)\n"); if (islower(c)) c = toupper(c); else c = tolower(c); P(semid, 2); shm2_addr = (char*)shmat(shm2_id, NULL, 0); shm2_addr[0] = c; shmdt(shm2_addr); V(semid, 2); V(semid, 3); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728//sem33.c#include "sem3.h"int main(int argc, char *argv[]) &#123; int semkey, shm2_key, semid, shm2_id; char c, *shm2_addr = NULL; semkey = ftok(PATH_FOR_FTOK, 'X'); shm2_key = ftok(PATH_FOR_FTOK, 'Z'); semid = semget(semkey, 0, IPC_EXCL); shm2_id = shmget(shm2_key, 0, IPC_EXCL); int i; for (i = 1; i &lt;= atoi(argv[0]); i++) &#123; P(semid, 3); P(semid, 2); shm2_addr = (char*)shmat(shm2_id, NULL, 0); c = shm2_addr[0]; printf("After transform %c\n", c); shmdt(shm2_addr); V(semid, 2); &#125; return 0;&#125; 需要注意的是信号量的使用，四个信号量分别为 信号量 初始值 用途 sem0 1 互斥 shm_1 sem1 0 同步进程1进程2 sem2 1 互斥 shm_2 sem3 0 同步进程2进程3 进程1需要先获得shm_1的互斥访问权，等待信号量sem0，将生成的随机字母写入shm_1，然后释放信号量sem0 进程2必须在进程1之后进行，因此进程2应当先等待信号量sem1，进程1在结束后会signal(sem1)唤醒进程2；被唤醒之后进程2取得对shm_1的互斥访问权，读取字母并进行大小写转换，然后释放sem0；接下来进程2取得对shm_2的互斥访问权，把转换后的结果写入shm_2，释放信号量sem1 进程3必须在进程2之后进行，因此进程2应当先等待信号量sem3，进程2在结束后会signal(sem3)唤醒进程3；被唤醒之后进程3取得对shm_2的互斥访问权，读取字母并进行大小写转换，然后释放sem2； P操作为wait，V操作为signal，两个操作写在单独的文件里 12345678910111213141516//sem3pv.c#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int P(int semid, int semnum) &#123; struct sembuf sops = &#123;semnum, -1, SEM_UNDO&#125;; return semop(semid, &amp;sops, 1);&#125;int V(int semid, int semnum) &#123; struct sembuf sops = &#123;semnum, +1, SEM_UNDO&#125;; return semop(semid, &amp;sops, 1);&#125; 整个作业分为五个c文件和一个头文件 使用makefile进行自动化编译 12345678910111213141516171819202122232425all: sem31 sem32 sem33 sem30.PHONY: allsem31: sem31.c sem3pv.o sem3.h gcc -c sem31.c gcc -o sem31 sem31.o sem3pv.o -gsem32: sem32.c sem3pv.o sem3.h gcc -c sem32.c gcc -o sem32 sem32.o sem3pv.o -gsem33: sem33.c sem3pv.o sem3.h gcc -c sem33.c gcc -o sem33 sem33.o sem3pv.o -gsem30: sem30.c sem3.h gcc -c sem30.c gcc -o sem30 sem30.o -gsem3pv.o: sem3pv.c gcc -c sem3pv.c -gclean: rm *.o]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验笔记（四）]]></title>
    <url>%2F2020%2F12%2F10%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[消息队列通信。消息队列还是经常能听到的一个东西，比如弹幕系统实际上就是一个MQ 消息队列本质是一个128个元素的指针数组 同一条消息只能被摘一次 挂 消息块 摘 消息块 摘没有的消息块会阻塞 当有期待的消息块被挂上去，被唤醒，摘下来 例子12345678910111213141516171819//msg_c.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; int key; key = ftok("/boot", 'a'); msgget(key, IPC_CREAT | 0600); return 0;&#125; 和共享内存块相似，需要先获取一个key，使用一个系统文件和一个字符进行拼接 IPC_CREAT | 0600 表示创建的消息队列拥有者可读写，其他人不可读写执行 IPC_CREAR | 0666 表示创建的消息队列所有人均可读写 1234567891011121314151617181920212223242526272829303132//msg_s.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/wait.h&gt;#define SIZE 100 //size of msgstruct msgbuf &#123; long mtype; //消息编号 &gt; 0 char text[SIZE]; //消息内容&#125;;int main(int argc, char *argv[]) &#123; int key, msqid, i; struct msgbuf msg; key = ftok("/boot", 'a'); msqid = msgget(key, IPC_EXCL); msg.mtype = atoi(argv[1]); strcpy(msg.text, argv[2]); msgsnd(msqid, &amp;msg, SIZE, 0); return 0;&#125; 挂消息到消息队列需要把消息进行封装，就是代码中的msgbuf 先获取消息队列，msgget(key_t key, int msgflg)，IPC_EXCL表示获取一个已经存在的消息队列 挂消息到消息队列，msgsnd(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)，把msg的地址传进去，本质是往指针数组中增加一个元素 12345678910111213141516171819202122232425262728293031//msg_r.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/wait.h&gt;#define SIZE 100struct msgbuf &#123; long mtype; char text[SIZE]; //size of msg&#125;;int main(int argc, char *argv[]) &#123; int p, key, msqid; struct msgbuf msg; key = ftok("/boot", 'a'); msqid = msgget(key, IPC_EXCL); msgrcv(msqid, &amp;msg, SIZE, atoi(argv[1]), 0); printf("%s\n", msg.text); return 0;&#125; 摘 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int main() &#123; int msqid, key; key = ftok("/boot", 'a'); msqid = msgget(key, IPC_EXCL); msgctl(msqid, IPC_RMID, NULL); return 0;&#125; 删除消息队列，先获取然后调用msgctl(int msqid, int cmd, msqid_ds *buf)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验笔记（三）]]></title>
    <url>%2F2020%2F12%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[管道通信是有局限的，共享内存段和消息队列提供了更灵活的进程间通信方式不过非要说最灵活可能还是用socket 共享内存通信与消息队列通信使用管道进行通信的局限只能在有家族关系的进程间进行通信 大小只有4K，不好传输过大的 Socket一般用于用户进程间的通信 IP+端口可以唯一定位一台主机上的一个进程，把IP设定为127.0.0.1，可以实现本机间的两个进程通信 IPC一般用于系统间的通信 信号量使用集合的方式进行管理，Semaphores Set 共享内存 Shared Memory Segment 消息队列 Message Queue 管道由操作系统进行管理 IPC需要自己手工管理 用到的函数int shmget(key_t key, size_t size, int shmflg); 创建一个新的共享内存段 / 关联已有的共享内存段，返回一个共享内存段的ID void *shmat(int shmid, const void *shmaddr, int shmflg); 获得共享内存段的地址，通常和脱离配合使用。 int shmdt(const void *shmaddr); 脱离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。 int shmctl(int shmid, int cmd, struct shmid_ds *buf); 操作共享内存段，如果要进行更细致的操作需要用到，在实验中用来删除共享内存段，cmd设定为IPC_RMID 写是覆盖写，读是多次读。 读多少次都不会影响数据的存在，用于进程间的一对多通信，多个进程先后去读结果是一样的。 权限在创建共享内存段时，可以指明共享内存段的权限 1shmget(shm_key, SHM_SIZE, IPC_CREAT | 0600) 在flag后面或上一个八进制数，这里的数字含义和chomd的数字含义相同，例如0600代表创建者可读可写 生成Key操作系统中唯一标识共享内存段 1234#include &lt;sys/ipc.h&gt;#include &lt;sys/types.h&gt;key_t ftok(const char *pathname, int proj_id); ftok()使用一个路径和一个项目编号来生成一个唯一的 system V 进程间通信的 key 通常情况下pathname选择一个所有Linux都有的路径，比如/boot，proj_id因为只会用到低8位，通常选择一个字符常量 对于同样的参数会得到同样的key 例子123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/wait.h&gt;#define KEY 3456#define SIZE 1024int main() &#123; char *shm_addr = NULL; //0600 only for this user's process //0666 for all process int shm_id; shm_id = shmget(KEY, SIZE, IPC_CREAT | 0600); pid_t p; p = fork(); if (p) &#123; //parent wait(0); shm_addr = (char*)shmat(shm_id, NULL, 0); printf("%s\n", shm_addr); shmdt(shm_addr); //control //destroy the shared memory segment shmctl(shm_id, IPC_RMID, NULL); &#125; else &#123; //chlid //get the address of shared memory segment //shmat() shm_addr = (char*)shmat(shm_id, NULL, 0); strcpy(shm_addr, "This is a message"); shmdt(shm_addr); &#125; return 0;&#125; 构建一个多进程并发的环境，实现共享内存段通信]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验笔记（二）]]></title>
    <url>%2F2020%2F11%2F26%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[信号中断被封装成信号，多个不同的中断被封装成一个信号。 层次 称呼 硬件层次 中断 操作系统层次 信号 应用程序层次 事件 信号可以用编号、名称表示，名称是编号的宏。 mask过滤信号，每个进程都有对signal的mask，滤掉的就忽略，没有滤掉的就响应 signal() 返回信号处理程序的入口指针，signal()根据编号设置信号处理程序 实际是修改进程PCB中的信号表中的函数指针 注意唤醒的时刻，4和alarm有一秒停顿，alarm和5没有间隔，说明收到信号之后进程被立即唤醒 信号什么时候到来和signal()没有关系 kill()给某个进程发信号 1kill -9 PID 发9号信号给进程，表示终止进程，不能被拦截或忽略 exit()杀死自己，返回0 进程软中断通信信号是传送给进程的一种事件通知，Linux 系统中所有信号均定义在头文件 中。 信号发生时，Linux 内核可以采取下面 3 种动作之一： 忽略信号 大部分信号可以被忽略，除 SIGSTOP 信号和 SIGKILL 例外； 捕获信号 指定动作； 信号默认动作起作用。 编写程序，使用系统调用 fork()创建两个子进程，再用系统调用 signal()让父进程捕捉键盘上发出的中断信号(即按 ctrl+c 或是 ctrl+\键)，5 秒钟内若父进程未接收到这两个软中断的某一个，则父进程用系统调用 kill()向两个子进程分别发送软中断信号 SIGUSR1 和 SIGUSR2，子进程获得对应的软中断信号，然后分别输出下列信息后终止： Child process (pid=?) be killed！ 21Child process (pid=?) be killed！ 父进程调用wait()等待两个子进程终止后，输出以下信息，结束进程执行： Parent process (pid=?) finished！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void parent_stop() &#123; printf("Parent process (pid = %d) be killed (get SIGINT / SIGQUIT)\n", getpid()); exit(0);&#125;void child_stop() &#123; printf("Chlid process (pid = %d) be killed\n", getpid()); exit(0);&#125;int main() &#123; pid_t p1, p2; p1 = fork(); if (p1) &#123; //parent p2 = fork(); if (p2) &#123; //parent signal(SIGINT, parent_stop); signal(SIGQUIT, parent_stop); printf("This is Parent process, pid = %d\n", getpid()); printf("parent sleep\n"); sleep(3); printf("parent get up\n"); kill(p1, SIGUSR1); printf("kill p1\n"); kill(p2, SIGUSR2); printf("kill p2\n"); waitpid(p1, NULL, 0); waitpid(p2, NULL, 0); printf("Parent process %d terminated\n", getpid()); &#125; else &#123; //child2 printf("This is chlid process 2, pid = %d\n", getpid()); signal(SIGUSR1, child_stop); signal(SIGUSR2, child_stop); printf("child2 sleep\n"); sleep(6); printf("child2 get up\n"); &#125; &#125; else &#123; //child1 printf("This is child process 1, pid = %d\n", getpid()); signal(SIGUSR1, child_stop); signal(SIGUSR2, child_stop); printf("child1 sleep\n"); sleep(6); printf("child1 get up\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据清洗中空格的处理]]></title>
    <url>%2F2020%2F11%2F18%2F%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%AD%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[pandas中使用fillna()或者drop()来填充或丢弃包含空值的行和列，但是pandas只认为numpy.nan是空值，实际情况里可能使用空格等空字符来代表空值，这时需要一些特殊处理 原始数据中存在空格 df是一个DataFrame，以DataFrame中的列名为索引可以得到一个Series，其中有一个apply方法可以修改其中的值 apply方法为一个高阶函数，接受一个函数func为参数，对Series中的每个元素调用func “””Invoke function on values of Series. Can be ufunc (a NumPy function that applies to the entire Series)or a Python function that only works on single values. Parametersfunc : function Python function or NumPy ufunc to apply.convert_dtype : bool, default True Try to find better dtype for elementwise function results. If False, leave as dtype=object.args : tuple Positional arguments passed to func after the series value.**kwds Additional keyword arguments passed to func. ReturnsSeries or DataFrame If func returns a Series object the result will be a DataFrame. See AlsoSeries.map: For element-wise operations.Series.agg: Only perform aggregating type operations.Series.transform: Only perform transforming type operations. ExamplesCreate a series with typical summer temperatures for each city. s = pd.Series([20, 21, 12],… index=[‘London’, ‘New York’, ‘Helsinki’])sLondon 20New York 21Helsinki 12dtype: int64 Square the values by defining a function and passing it as anargument to apply(). def square(x):… return x ** 2s.apply(square)London 400New York 441Helsinki 144dtype: int64 Square the values by passing an anonymous function as anargument to apply(). s.apply(lambda x: x ** 2)London 400New York 441Helsinki 144dtype: int64 Define a custom function that needs additional positionalarguments and pass these additional arguments using theargs keyword. def subtract_custom_value(x, custom_value):… return x - custom_value s.apply(subtract_custom_value, args=(5,))London 15New York 16Helsinki 7dtype: int64 Define a custom function that takes keyword argumentsand pass these arguments to apply. def add_custom_values(x, **kwargs):… for month in kwargs:… x += kwargs[month]… return x s.apply(add_custom_values, june=30, july=20, august=25)London 95New York 96Helsinki 87dtype: int64 Use a function from the Numpy library. s.apply(np.log)London 2.995732New York 3.044522Helsinki 2.484907dtype: float64“”” 了解了apply()函数之后，就可以替换原先的空格为np.nan了123456789101112131415161718import pandas as pdimport numpy as npdf = pd.read_csv('./newFile.csv', encoding='gbk')# none_score = (df['成绩'].isnull()) | (df['成绩'].apply(lambda x: str(x).isspace()))# df_null = df[none_score]# print(df_null)## df_not_null = df[~none_score]# data1 = df_not_null# data1.to_csv('./cleaned_newFile.csv', encoding='utf-8_sig', index=None)df['成绩'] = df['成绩'].apply(lambda x: np.nan if str(x).isspace() else x)df = df.fillna(0)df.to_csv('./cleaned_newFile.csv', encoding='utf-8_sig', index=None)print('Done') 清洗之后，原本的空值被替换成了0]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>数据清洗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验笔记（一）]]></title>
    <url>%2F2020%2F11%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[进程管理fork（）创建子进程，继承父进程fork()之后的的指令序列，复制父进程的数据部分 123456789101112131415161718//test1.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; int p, x = 100; printf("Hello world\n"); p = fork(); if (p) &#123; x = 200; printf("This is parent, x = %d\n", x); &#125; else &#123; x = 300; printf("This is child, x = %d\n", x); &#125; return 0;&#125; 通过汇编语言可以很容易理解fork()具有两个返回值的事情，p = fork()是两条指令，而子进程会执行函数调用call fork之后的所有指令，这样子进程和父进程的p就是不一样的。 当创建失败时fork()会返回-1，为了鲁棒性应该判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.file "test1.c" .section .rodata.LC0: .string "Hello world".LC1: .string "This is parent, x = %d\n".LC2: .string "This is child, x = %d\n" .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc leal 4(%esp), %ecx .cfi_def_cfa 1, 0 andl $-16, %esp pushl -4(%ecx) pushl %ebp .cfi_escape 0x10,0x5,0x2,0x75,0 movl %esp, %ebp pushl %ecx .cfi_escape 0xf,0x3,0x75,0x7c,0x6 subl $20, %esp movl $100, -16(%ebp) subl $12, %esp pushl $.LC0 call puts addl $16, %esp call fork ;子进程会执行的部分 movl %eax, -12(%ebp) cmpl $0, -12(%ebp) je .L2 movl $200, -16(%ebp) subl $8, %esp pushl -16(%ebp) pushl $.LC1 call printf addl $16, %esp jmp .L3.L2: movl $300, -16(%ebp) subl $8, %esp pushl -16(%ebp) pushl $.LC2 call printf addl $16, %esp.L3: movl $0, %eax movl -4(%ebp), %ecx .cfi_def_cfa 1, 0 leave .cfi_restore 5 leal -4(%ecx), %esp .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size main, .-main .ident "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609" .section .note.GNU-stack,"",@progbits 下面的代码会构成怎样的进程树？ 1234fork();fork();fork();fork(); getpid()获得当前进程的进程号 getppid()获得父进程的进程号 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int p; p = fork(); if (p == -1) &#123; printf("Error\n"); exit(0); &#125; if (p) &#123; //parent sleep(1); //running to blocked printf("This is parent, my pid = %d, my child = %d\n", getpid(), p); &#125; else &#123; //child printf("This is child, my pid = %d, my parent = %d\n", getpid(), getppid()); &#125; return 0;&#125; 发现子进程的父进程编号不对，这是因为在执行子进程之前父进程已经执行结束，此时子进程称为孤儿进程Orphan Process，父进程被设置成了1305号进程 查看所有进程发现1305号为upstart进程，用于接管孤儿进程 但是维基百科上说孤儿进程会被init进程或者systemd进程接管 想要父进程不那么快结束，可以使用sleep(1)让父进程进入阻塞状态一秒钟 多进程并发 框架的搭建 分别完成两个进程的功能 互斥和同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;int main() &#123; pid_t p1, p2; p1 = fork(); if (p1 == -1) &#123; perror("fork error"); exit(EXIT_FAILURE); &#125; if (p1) &#123; //parent p2 = fork(); if (p2) &#123; int i = 1; while (i &lt;= 26) &#123; printf("print from parent process: %d\n", i); i++; sleep(1); &#125; //parent &#125; else &#123; //child2 char ch2 = 'a'; while (ch2 &lt;= 'z') &#123; printf("print from Child process 2: %c\n", ch2); ch2++; sleep(1); &#125; &#125; &#125; else &#123; //child1 char ch1 = 'A'; while (ch1 &lt;= 'Z') &#123; printf("print from Child process 1: %c\n", ch1); ch1++; sleep(1); &#125; &#125; return 0;&#125; 缓冲区缓冲区长度为一行，\n表示一行结束，会刷新缓冲区 fflush() 刷新缓冲区 普通进程只往缓冲区写数据，往屏幕写数据是操作系统的事情 多个进程的缓冲区共用 两个进程并发的执行情况 wait()1234#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *wstatus); 父进程一旦调用了wait()就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait()就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait()就会一直阻塞在这里，直到有一个出现为止。 僵尸进程对于一个进程，当其进行结束时，进入终止状态，此时操作系统的进程表中还留有子进程的PCB。 如果此时父进程没有wait()，PCB将会保留，会导致资源泄露。 管道123456789#include &lt;unistd.h&gt;/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */struct fd_pair &#123; long fd[2];&#125;;struct fd_pair pipe();//on other architecturesint pipe (int fd[2]); fd参数会被设置成两个文件描述符，f[0]表示读，f[1]表示写 pipe会自动保持同步 管道面向字节流 管道只允许单向通信（单工？ 使用管道进行进程间通信1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;int main() &#123; pid_t p1, p2; int fd1[2]; pipe(fd1); p1 = fork(); if (p1 &lt; 0) &#123; perror("fork Error"); exit(EXIT_FAILURE); &#125; if (p1) &#123; //parent int fd2[2]; pipe(fd2); p2 = fork(); if (p2) &#123; //parent char ch; while (read(fd1[0], &amp;ch, sizeof(char))) &#123; printf("Parent: got data from child1\n"); write(fd2[1], &amp;ch, sizeof(char)); printf("Parent: sent data to child2\n"); &#125; &#125; else &#123; //child2 char ch; while (read(fd2[0], &amp;ch, sizeof(char))) &#123; printf("child2: Got the char, print to the screen\n"); if (isupper(ch)) ch = tolower(ch); else ch = toupper(ch); //putchar(ch); printf("%c\n", ch); printf("child2: Done\n"); &#125; &#125; &#125; else &#123; //child1 //printf("child1: Waiting for input: \n"); while (1) &#123; char ch = getchar(); if (isalpha(ch)) &#123; printf("child1: Got the char '%c', sent to the parent process\n", ch); write(fd1[1], &amp;ch, sizeof(char)); &#125; else if (isspace(ch)) &#123; continue; &#125; else printf("char %c, ascii code %d is invaild\n", ch, ch); //printf("child1: Waiting for input: \n"); &#125; &#125; return 0;&#125; 三进程并发，父进程拥有两个管道，子进程一负责从键盘读取输入，通过管道1发送给父进程，父进程通过管道2把输入发送给子进程2，子进程2进行大小写转换并输出。 子进程一进行输入过滤，不符合条件的输入会被忽略。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习笔记-内存管理]]></title>
    <url>%2F2020%2F11%2F11%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习笔记-网络层]]></title>
    <url>%2F2020%2F11%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[内容贼多 网络层提供的两种服务 网络层向运输层提供服务 网络保证可靠 or 端系统保证可靠 网络负责可靠交互 虚电路 和电路交换类似，都需要建立连接，有电路交换的特点 但是电路交换具有排他性，虚电路没有，所以称为虚电路 虚电路建立逻辑上的连接，分组沿着逻辑上的连接进行分组转发 网络负责最大努力交互 因特网真正的设计思路 不提供服务质量的承诺，只进行最大努力、无连接的数据报服务 可能出错、丢失、重复、失序 出错由ICMP解决 尽最大努力交付的好处 路由器可以比较简单，价格低廉 运输层负责差错处理、流量控制 网络的造假大大降低，运行方式灵活，能适用多种应用 虚电路与数据报的对比 虚电路 数据报 思路 网络保证可靠通信 端系统保证可靠通信 连接 有 无 终点地址 只有建立连接时使用 每个分组都有终点的完整地址 分组转发 同一条虚电路的分组按照同一路由进行转发 每个分组独立选择路由进行转发 当节点故障时 所有通过故障接待您的虚电路均不能工作 出故障的节点可能会丢失分组，一些路由可能会发生变化 分组的顺序 总是按照顺序到达终点 到达顺序不一定按照发送顺序 差错处理 / 流量控制 可以由网络负责， 也可以由主机负责 主机负责 IP配套使用的三个协议 地址解析协议 ARP Address Reesolution Protocol IP地址转换为MAC地址 IP协议族的较下层 网际控制报文协议 ICMP Internet Control Message Protocol 控制信息 IP协议族的较上层 忘记组管理协议 IGMP Internet Group Management Protocol 实现多播/组播 IP协议族的较上层 中间设备 扩展 转发器 物理层 网桥 数据链路层 互联 路由器 网络层 桥路器 网桥+ 路由器 网关 网络层以上 虚拟互联网络又称逻辑互联网络，当互联网上的主机进行通信时，好像在一个网络上通信一样，虽然不同物理网络的异构性客观存在，但是被屏蔽掉了，对于用户而言，只能看到像在同一个网络上通信而看不到异构细节。 IP地址 32位二进制，四个点分十进制数，每个数取值在0 - 255 定义为 网络号+主机号 8位一组 分类 A类 第一位一定是0，前8位（一个字节）表示网络号，后24位表示主机号（三个字节） 一个网络中主机数最多有$2^{24} - 2 = 16777214$ 最大网络数$2^7 - 2 = 126$ 全零作为保留地址，意为本网络，不能指派 全一作为环回测试地址，不能指派 前8位 1 - 127 B类 前两位一定是10，前16位（两个字节）表示网络号，后16位表示主机号（两个字节） 一个网络中主机数最多有$2^{16} - 2 = 65534$ 最大网络数$2 ^ {14} = 16384$ 最小网络号为 128.0 二进制为 1000 0000 . 0000 0000 前8位 128 - 191 C类 前三位一定是110，前24位（三个字节）表示网络号，后8位表示主机号（一个字节) 一个网络中主机数最多有$2^{8} - 2= 254$ 最大网络数$2 ^ {21} = 2097152$ 最小网络号为 192.0.0 二进制为 1100 0000 . 0000 0000 . 0000 0000 前8位 192 - 223 D类 前四位一定是1110，用于多播地址 前8位 224 - 239 E类 前四位为1111，留作以后使用 前8位 240 - 255 保留 网络号 主机号 用作源地址 用作目的地址 含义 0 0 可 不n可 本网络的本主机，相当于临时牌照，申请IP地址时使用 0 host-id 可 不可 本网络的某台主机 全1 全1 不可 可 只在本网络进行广播，所有路由器不进行转发 net-id 全1 不可 可 网络外成员对net-id中的的所有成员进行广播 127（0111 1111） 非全零全一 可 可 本地软件环回测试 私有地址10.0.0.0 ———— 10.255.255.255 (0000 1010 . 0000 0000 . 0000 0000 . 0000 0000 —— 0000 1010 . 1111 1111 . 1111 1111 . 1111 1111) 172.16.0.0 ———— 172.131.255.255 (1010 1100 . 0001 0000 . 0000 0000 . 0000 0000 —— 1010 1100 . 1000 0011 . 1111 1111 . 1111 1111) 192.168.0.0 ———— 192.168.255.255 (1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 —— 1100 0000 . 1010 1000 . 1111 1111 . 1111 1111) 重要特点 分等级 IP地址管理机构分配IP只分配网络号，主机号由网络号管理单位自行分配 路由器仅仅根据目的主机所连接的网络号来转发分组 这样就可以大大减少路由表的大小 找到了网络，再找主机就很容易了 IP地址标志一个主机 / 路由器 / 链路的接口 路由器属于不同网络的接口有不同的IP地址 至少有两个不同的IP地址 网桥连接的若干局域网仍拥有相同的网络号，仍属于同一个网络 网桥 / 转发器仅仅是扩展网络 只包含一段线路的网络不指明IP地址 IP地址与硬件地址这里说硬件地址而不是MAC地址，因为链路层及以下使用的的硬件地址有很多种，其中以太网使用MAC地址 MAC地址 $\in$ 硬件地址 路由器转发不改变IP源和目的，但是改变MAC源和目的 网桥转发不改变MAC源和目的 路由器转发改变了链路 数据包中间经过的路由器的IP不会出现在IP数据报的首部中 虽然首部有源站，但是路由器仅根据目的站的IP的网络号进行转发 只找到网络就行 地址解析协议 ARP Address Resolution Protocal 从网络层使用的IP地址解析出链路层使用的硬件地址 每个主机都有一个ARP Cache，里面有所在局域网上的各个主机和路由器的IP地址到硬件地址的映射表 IP Address；MAC Address；TTL (Time to live) 使用老化策略，过久不使用的地址会被删除 能够减少ARP广播的数量 发送过程 向本局域网中的主机发送 有就把目的MAC地址写入MAC帧 没有就本地广播发送一个ARP请求分组，目的主机响应，把目的主机的MAC地址加入ARP Cache 本地广播：路由器不转发；链路层广播，MAC地址全1 ARP请求分组：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 未知时填零/ 目标方IP地址；所有主机都会记录下发送方的硬件地址 ARP响应分组：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 / 目标方IP地址；是广播实现的一对一通信 如果目的主机和源主机不在同一个局域网，发送主机获得的就不是真正目的主机的MAC地址，而是能通往目的主机的路由器的IP地址。此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。 为什么不使用硬件地址进行通信 异构网络很多，互相通信需要进行复杂的地址转换 IP使得所有网络像连接在同一个网络一样，把脏活累活交给ARP去做 IP数据报的格式 首部、数据 首部包括固定部分20字节，可选部分长度不定，总共不超过60字节 版本 4位 0100 IPv4 0110 IPv6 首部长度 4位 最大表示15个单位，一个单位4字节，所以首部最长60字节 区分服务 8位 总长度 16位 首部长度 + 数据长度 单位为字节，因此数据报最大长度为$2^{16} - 1 = 65535$字节 总长度不能超过MTU 标识 16位 长度超过MTU则需要分片 分片后标识来自同一个数据报 标志 3位 目前只有前两位有意义 最低位是MF（More Fragment），中间一位是DF（Don’t Fragment） MF=0 没有分片了 DF=0 允许分片 片偏移 13位 表示某片在原分组中的相对位置 以8字节为偏移单位，需要乘八，也就是左移三位，正好补上标志部分三位的空缺 生存事件TTL 8位 每经过一次路由转发，减少一，变成零了还没到目的就丢弃 协议 指出为谁服务，上层协议是什么 首部检验和 16位 验证首部在传输中有没有出现差错 二进制反码求和 IP不检验数据部分，扔给链路层做 源地址、目的地址 各32位 可变部分 最大40字节，需要使长度为4的整数倍，不足则用零填充 其实很少用 IP数据报分片IP分片不是一件好事情，应该能不分就不分 分片之后有哪些字段会变 总长度 报头检验和 MF位 片偏移 分片的坏处 效率低 需要缓存 防火墙可能会拦截 二进制反码求和 此反码非计组之反码 （ones’ complement） 计组中的反码 正数的反码是本身 负数的反码是符号位不变，其余位取反 逐位取反之后再相加（再取反） 最高位的进位加在最后一位上 (回卷) 这样可以使得先加后取反和先取反后加的结果一样 不依赖大端表示 / 小端表示 交换十六位数的字节顺序，得到的结果相同，只是字节顺序也相应发生变化 转发分组的流程特定主机路由将IP数据报发送到特定的某个主机上，而不是发送到网络上就结束了 默认路由路由表中的Default项，不在匹配其他任何项时按照默认路由进行转发 可以减少路由表中的条目数 划分子网与构造超网划分子网 网络号、主机号的两级IP 变为网络号、子网号、主机号的三级IP 网络号侵占主机号 因为全零全一不允许使用，每划分一个子网就会废掉两个IP 子网号的位数不能为0、1、15、16 为0则没有划分子网 为16则没有主机 为1则网络号要么0要么1，不允许使用 为15则主机号要么0要么1，不允许使用 定长子网划分、变长子网划分 一个问题一个C类IP，划分为四个子网，分别在全零全一可用 / 不可用的时候损失了多少IP？ 四个子网需要两个位的子网号，剩余六个位的主机号 网络号为00， 01， 10， 11，全零全一不可用，只剩下01， 10两个网络 子网掩码 用于找出IP地址中的子网部分 前面为1， 主机号部分为0，与IP做按位与运算，可以去掉主机号 最小IP网络的子网掩码是多少 255.255.255.252 留出两位作为主机号，00， 01， 10， 11个主机，全零全一不让用，只有两台主机，其中一台是路由器 构造超网 无分类编址CIDR 路由聚合无分类域间路由选择 Classless Inter-Domain Routing 取消了传统ABC类网络，改用网络前缀来代替网络号与子网号 主机号侵占网络号 又变成两级编址 可以把多个C类网络合并，相当于侵占网络号 使用斜线记法，斜线后面表示网络前缀所占的位数 数值上对应三级编址中子网掩码的1的位数 仍然使用掩码 路由表中的一个项目可以表示很多传统分类的路由 构造超网的规则 构成超网的地址块数必须是$2^n$ 构成超网的地址快必须连续 第一个地址的第三字节必须能被块数整除 一些问题 超网的网络地址能不能是X.Y.33.0？ X.Y.00100001.0，发现主机号只有最后一个字节，相当于C类网络，没有聚合，也就不能叫超网 X.Y.32.0 能不能确定网络 X.Y.00100000.0，不能确定主机号的零从哪里开始 必须加上掩码/斜线才能确定网络号 查找路由表最长前缀匹配匹配路由表中最长的那个，因为越长越具体，有特定主机路由就不用网络前缀路由，有网络前缀路由就不用默认路由 路由器取出IP分组中的目的地址，与前缀对应的掩码进行按位与运算提取到网络号，进行匹配 二叉线索是一棵Trie Trie上的前缀是唯一的，进行唯一前缀匹配 唯一前缀匹配不等价于网络前缀匹配 ICMPICMP在IP之上，ICMP报文作为IP报文的数据部分，也要被封装成IP数据报 格式1字节类型，1字节代码，2字节检验和 4字节ICMP数据部分，长度可变 ICMP差错报文长度为36字节 在收到错误的IP数据报后发送，也要封装为IP数据报 （封装后的IP数据报）数据部分是ICMP的前8字节 + 收到的IP数据报的首部 + 8字节，为TCP / UDP的端口号 因为要判定端口不可达 不需要发送ICMP差错报文的几种情况 不再为ICMP差错报文发送ICMP差错报文 / 禁止套娃 只对分片中的第一片发送 / 一个错各个错 多播地址的数据报不发送 特殊地址（127.0.0.0 / 0.0.0.0）不发送 分类 终点不可达 某一环无法继续传递，向发送方发送终点不可达 报文中的数据表示失败的原因 不可达有五种情况 网络不可达 主机不可达 协议不可达 //无法向上提交 端口不可达 需要分片但DF位为1 源路由失败 时间超过 TTL减到0 某些分片迟迟不来，组装出问题 参数问题 头部参数出错，Pointer部分会指出错误的字节位置 源点抑制 流量过大，缓存队列溢出，只能丢弃报文，此时发送一个ICMP源点抑制，告知发送方晚点再来 改变路由 / 重定向 找不到目的地址 ICMP询问报文长度为40字节 分类 回送请求和回答 ping 时间戳请求和回答 查询当前时间，提供毫秒级的分辨率 包含三个时间戳 ：Origin时间、Receive时间、transmit时间 （接收方发送回应的时间） 即使不同步也能计算正确的往返时间 源路由从源路由网桥中提到过，指从源点就确定的路由 应用ping ping非常特殊，应用层直接使用网络层，不经过运输层 trace route 发很多次，第一次发TTL是1，第二次发TTL是2，以此类推，每一次路由器都会给出一个超时 当到达目的主机时没法发送超时了，此时设置的一个不可达的UDP端口使得目的主机发送终点不可达 因此trace route 用到了运输层 路由选择协议理想的路由算法 正确、完整 计算上简单 能适应通信量和网络拓扑的变化 稳定性，路由不应该不停变化 公平，除了少数优先级高的用户 / 区分服务 算法应该是最佳的 / 相对概念，特定约束下的较为合理的选择 分类静态路由 简单开销小，但是不能及时适应网络状态变化 动态路由 复杂开销大，但是能较好适应网络状态的变化 内部网关协议 IGP AS内部使用 外部网关协议 EGP AS之间使用 分层次的路由选择协议Autonomous System 自治系统 把AS内的网络看作一个整体，屏蔽内部细节和采用的路由协议 一个AS对其他AS表现出一个单一的一致的路由选择策略 RIP Route information protocol是一种内部网关协议 分布式的基于距离向量的路由选择协议 每经过一个路由器距离加一，距离向量的距离指的是最短距离 / 经过路由器的数目最少 RIP简单粗暴的把距离短的路由认为是好的路由，允许一条路径最多包含15个路由器，距离超过15就标记为不可达 不存在负载均衡，有两条长度一样的路径也只会走其中一条 工作方式为每隔固定的一段时间和相邻路由器交换自己的路由表 三分钟没收到消息就认为不可达，距离设置为16 收到之后总总是要更新，距离可能增大也可能减小，应该以最新的更新 能很快收敛 / 所有路由器达到一致 路由表一致性不等于路由表表项相同 路由表包括目的网络（大方向） 距离 下一跳路由器（小方向） RIP2报文格式 RIP2要封装到UDP中再封装到IP中，RIP是应用层协议 四字节首部，路由信息20字节，最多25个，总长度最大4 + 20 * 25 = 504字节，超过则启用新的RIP2报文 RIP2和RIP1（最大的）的区别是RIP2支持子网 路由标记表示是否再同一个自治系统中，填写的是自治系统的编码 问题与解决方案 水平分割 从某个接口学到的路由不会再发回去，防止了路由环路 毒性逆转 当路由信息变成无效后不是直接删除而是设置为不可达并广播出去，可以清楚路由表中无用的路由 触发更新 路由信息改变后立即更新并发送给相邻路由器 抑制计时 如果一条路由更新的跳数大于路由表已记录的该路由的跳数，那么将会引起该路由进入长达180秒（即6个路由更新周期）的抑制状态阶段。在抑制计时器超时前，路由器不再接收关于这条路由的更新信息。可以用来防止路由环路。 OSPF Open Shortest Path First是一种内部网关协议 分布式的，基于链路状态的路由选择协议 工作在网络层，在IP之上，直接使用IP数据报进行传送 使用Djijkstra算法 需要一张完整的网络图，来跑Dijkstra算法 所有的路由器都维护一个完整的链路状态数据库 / 全网的拓扑结构图 所有路由器的数据库都是完全一致的，和RIP中的一致不同 OSPF收敛很快 三个要点 使用泛洪法向自治系统内的所有路由器发送信息 发送与本路由器相邻的所有路由器的链路状态 与谁相邻，代价是多少 只有链路状态发生变化时，路由器才使用泛洪法向所有路由器发送信息 划分区域自治系统通常贼大，需要维护的数据库也就会变大，因此在自治系统的基础上进一步划分区域（Area），这样就只需要在区域内泛洪、维护区域的拓扑结构图 每个区域用一个32位的区域标识符来表示，和IP一样使用点分十进制 使用层次结构的区域划分，上层的区域叫做主干区域，标识符为 0.0.0.0，主干区域联通下层区域 位于主干区域中的路由器称为主干路由器（BR） 位于区域边缘，与其他区域通信的路由器称为区域边界路由器（Area Border Router) 特点 数据报很短 减少路由信息的通信量，网络最主要的功能还是处理端系统的消息 不必将长的数据报分片传送，有效减少重传 具有多路径负载均衡 具有鉴别功能 保证了仅在可信的路由器之间交换链路状态信息 支持变长子网划分和CIDR 每一个链路状态都有一个32位的序号，序号增长不超过五秒钟一次 每隔一段时间刷新数据库中的链路状态 互联网规模很大时，OSPF要比RIP好很多，对网络变化的响应很快不存在坏消息传得慢的情况 指定路由器在一个广播性、多路访问的网络中，如果每个路由器都独立进行链路状态更新包的交换，就会产生巨大流量，不好，因此选举出一个村长来进行链路状态信息的交换。 有DR（Designated Router)）和BDR（Backup Designated Router） 分组格式 版本 当前版本为2，版本一版本二不兼容 类型 Hello 每隔十秒交换一次问候分组，从而得知有哪些路由器是可达的 Database Description Link State Request Link State Update 收到更新报文后需要恢复ACK Link State Acknowledgment 分组长度 包括OFSF头部的分组长度 路由器ID 在AS中可以唯一表示路由器 区域ID 指定分组所属的区域号 校验和 用于分组所有内容的校验和 鉴别1 0或1，表示不鉴别和使用口令鉴别 鉴别2 鉴别1为0时为0，鉴别1为1时为口令 BGP Border Gateway Protocol外部网关协议 目前版本为4 难以寻找最佳路由，只在AS之间交换可达性信息，找到一条不兜圈子的比较好的路由 基于路径向量的路由选择协议 每个AS至少要有一个BGP发言人，每个发言人都要属于一个AS 作用于不同AS，但同一个AS中的不同边界路由器也需要建立BGP连接 BGP支持CIDR 是应用层协议，使用TCP进行传输 对于远距离的传输，需要使用TCP保证可靠性 BGP热土豆路由选择协议热马铃薯路由选择（Hot-potato routing）是在当前AS接收到一个数据包后，使其停留在该AS中的时间尽可能短。它尝试减少当前AS的开销，而忽略了网络中其他组成成分的开销。 将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS。 AS的分类单口AS，只有一个连接可以到达另一个AS，只能是信源或信宿 多归路过渡AS，有多个连接到达多个AS，但是拒绝传送流量，只能是信源或信宿 / 拒绝通信量穿越的多归属AS 过渡AS，不允许通信量穿越的多归属AS BGP报文OPEN 与相邻的另一个BGP发言人建立关系 / 打招呼 UPDATE 发送某一路由的信息，列出要撤销的多条路由 / 有新闻 KEEPALIVE 确认打开报文与周期性证实临站关系 / 表明自己还活着 / 只有报文头 NOTIFICATION 发送检测到的差错 / 不跟你玩了 标记部分用于鉴别，但是现在没有鉴别方案，全部置为1 长度为包括首部在内的总长度 类型为1-4，上述的四种类型 一个问题 KeepAlive报文在链路层是否需要进行填充？ KeepAlive只有报文头，16 + 2 + 1 = 19 字节 作为TCP的数据部分，需要加上TCP的首部 19 + 20 = 39 字节 作为IP的数据部分，需要加上IP的首部 39 + 20 = 59 字节 MAC帧在长度小于46字节时才进行填充，因此不需要进行填充 以太网最短帧长为64字节，减去16字节头部，4字节FCS，数据部分最短46字节 IP多播路由器多输入端口，多输出端口 作用是转发分组 路由选择协议生成路由表，路由表生成转发表 多播特点使用组地址，D类地址 永久组地址 动态组成员 使用硬件进行多播 IP多播地址与以太网多播地址的转换01 + 00 + 5e + 0 + 组播IP低23位 一个例子 226.150.47.33 首先确定D类IP，D类IP从224到239 写出后三个字节的二进制 150 = 128 + 16 + 4 + 2 = 1001 0110 47 = 32 + 16 - 1 = 0011 0000 - 1 = 0010 1111 33 = 32 + 1 = 0010 0001 把正数第二字节第一位换成0，因为只要后23位 0001 0110 = 16 0010 1111 = 2F 0010 0001 = 21 最终结果为 01 00 5e 16 2F 21 IGMP Internet Group Management Protocal使路由器知道多播组成员的信息 看作IP的一个组成部分 IGMP的本地使用范围并非 在因特网范围内对所有多播组成员进行管理的协议 IGMP 不知道IP多播组包含的成员数，也不知道这些成员分布在哪些网络上 IGMP是让连接在本地局域网的多播路由器知道本剧于网上是否有主机参加或退出了多播组 为什么多播路由选择协议比单播路由选择协议复杂得多多播转发必须动态适应多播组成员的变化，而单播通常是在网络拓扑发生变化时才需要更新路由 多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从哪里来到哪里去 多播数据报可以从没有加入多播组的主机发出，也可以通过没有组成员接入的网络 IGMP两个阶段及具体措施第一阶段新主机加入多播组，先向该组的多播地址发送IGMP报文，表明自己要加入，多播路由器收到之后将组成员关系转发到因特网上其他多播路由器，以完善多播路径 第二阶段周期性探询本地局域网的主机，确认是否是该组的成员，只要有一个响应认为是活跃的，多次没有响应就不再将组成员关系转发给其他路由器 具体措施使用IP多播 探寻组成员关系时对所有组发送一个请求信息的询问报文（而不是每个组一个） 主机收到询问后随机选择一个时延进行发送 如果组内有其他主机发送了，自己就可以不发送了 多播路由选择的三种方法多播路由选择实际上是要构建以源主机为根节点的多播转发树 洪泛与剪除RBP Reverse Path Broadcasting 洪泛适用于较小的多播组，为了避免兜圈子，使用了反向路径广播Reverse Path Broadcasting的策略 剪除指发现下游树枝上没有多播组成员时，把它和下游树枝一起在转发树上剪除 隧道 &lt;第一个隧道&gt; 把多播报文封装为单播，使用单播通过不支持多播的网络，出来之后再恢复成多播 基于核心的发现技术对每一个多播组指定一个核心，核心路由器构建转发树 RPB特点路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的： 若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外 ） 否 则 ， 就 丢 弃 而 不 转 发。 如果 存 在 几 条 同 样 长 度 的 最 短 路 径 ， 那 么 只 能 选 择 一 条 最 短 路 径 ， 选 择 的 准 则 就 是 看 这 几 条 最 短 路 径中的相邻路由器谁的 IP 地址最小。 最终得出多播转发树，以后就按其转发多播数据报 VPN Virtaul Private Network利用公用的互联网作为本机构各专用网之间的通信载体 所有通过互联网传送的数据都必须加密 使用 隧道技术 来实现 &lt;第二个隧道&gt; 机构内部的VPN为内联网（intranet），不同机构共同建立的VPN为外联网（exrtanet） NAT Network Address Translation专用网中的主机需要与外部进行通信，需要通过NAT路由器将私有地址转换为全球地址 转换结果需要记录在NAT地址转换表中 每次通信需要进行两次转换，离开时一次，进入时一次 对于有$n$个全球IP地址的NAT路由器，最多可以同时有$n$台主机接入到互联网 专用网内部的主机不能作为服务器 NAPT Network Address and Port Translation多个主机公用一个NAT路由器上的全球IP地址 把专用网内部的不同IP地址转换为相同的全球IP地址，源主机采用的TCP端口号不管相不相同都转换为不同的新的端口号 MPLS Multi Protocol Label Switching属于2.5层协议，是IP的一种增强 多协议 表示MPLS的上层可以采用多种网络协议、下层可以采用多种链路层协议 标记 表示每类分组被打上一个标记，根据标记对分组进行转发 **面向连接** 传统的路由决策，路由器需要对网络数据包进行解包，再根据目的IP地址计算归属的FEC。 而MPLS提出，当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。 当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。 每类分组会有一个特定的编号 MPLS特点 分类意味着面向连接，标记一旦确定，连接的路径就确定了 支持流量工程，平衡网络负载 有效支持VPN 在转发是不上升到第三层查找转发表，而是直接在第二能用硬件进行转发 过程 使用LDP label distribution protocol交换报文，找到标记交换路径LSP 分组进入MPLS域时，在入口打上标记，按照转发表将分组发给下一个LSR 标记具有强烈的本地意义，仅在两个LSR之间才有意义 分组经过LSR要做两件事情，一是转发，二是标记对换 离开MPLS域时，MPLS出口节点把标记去除 这样的转发方式被称为显式路由选择 MPLS域这个区域中所有路由器都支持MPLS技术，都是LSR Label Switching router LSR既可以标记交换也可以路由选择，转发表被用来构造标记交换表 转发等价类FEC如何划分转发等价类是MPLS的核心 转发等价类是LSR按照同样的方式对待的分组的集合 划分方式很灵活，通常由网络管理员来控制 通过设置不同的FEC可以实现负载均衡，也称为流量工程 例子特定前缀进行匹配 源地址目的地址都相同 某种服务质量需求的（区分服务） MPLS格式在IP数据报被封装成以太网帧之前，先插入一个MPLS首部 生存时间用于防止兜圈子 LSP隧道 &lt;第三个隧道&gt; IPv6主要变化允许协议继续扩充 支持即插即用自动配置 支持资源预分配 首部由四字节对齐改为八字节对齐 一般形式 版本 4位，目前版本6 通信量类 8位，相当于区分服务 流标号 有效载荷长度 下一个首部 8位，指向扩展首部，串出一个列表 跳数限制 8位 地址128位 除Unicast、Multicast外支持Anycast 对于一组主机，只要找到最近的一个即可 发向一组，其中只要有一个接收到即可 使用冒号十六进制记法 允许把数字前面的0省略 一串零可以使用零压缩压缩成一对冒号，地址中只能压缩一次 CIDR斜线表示法仍然适用 特殊地址::/128 未指明 ::1/128 环回 FF00::/8 多播 FE80::/10 本地链路单播 v4 to v6 双协议栈 隧道技术 &lt;第四种隧道&gt; 把v6数据报封装进v4数据报]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统学习笔记-进程同步]]></title>
    <url>%2F2020%2F10%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[The Critical-Section ProblemAbout Critical Section An atomic action is required in a critical section. When one process is executing in its critical section, no other process is to be allowed to execute in its critical section. The critical section is not a public section. Each process has its own critical section. Each process must request permission to enter its critical section. The section of code implementing this request is the entry section, the critical section may be followed by an exit section Solution of the critical-section problem Mutual exclusion 互斥 If process $p_i$ is executing its critical section, then no other process can be executing in their critical sections progress 进步？ If no process is executing in its critical section and some processes with to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which will enter its critical section next, and this selection cannot be postponed indefinitely. 如果没有进程在执行临界区并且某些进程想要执行他们的临界区，那么只有那些不在他们剩余区的进程可以参与决定谁来执行临界区的筛选，这个选择过程不会无限期推迟。 Bounded waiting 有界等待 There exists a bound on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted. gantt section Figure1 请求进入临界区 :des1, 1d 等待 :des2, after des1, 3d 被授权进入临界区 :des3, after des2, 5d 如上图，在等待的过程中其他进程被允许进入临界区的次数是有限的 Algorithms两个进程的同步算法，软件实现 12345678// initicall turn = 0// turn is a shared variabledo &#123; while (turn != i); // only turn == i can this process execute it's critical section //critical section turn = j; //reminder section&#125; while (1); Satisfies mutual exclusion, but not progress 机械的规定零号进程一号进程交替进行。 进程是否有进入临界区的 意愿 ？ 12345678910//initial flag[0] = flag[1] = false;//flag[i] == true -&gt; process i ready to enter critical sectiondo &#123; flag[i] = true; while (flag[j]); // mutual exclusion //critical section flag[i] = false; //remainder section&#125; while (1); 不满足 progress ，在flag[i] = true之后，切换到另一个进程flag[j] = true，此时两个进程都想进临界区，但是都在看对方，都不能进入临界区 Peterson‘s Solution12345678910//share turn flag[2]do &#123; flag[i] = true; turn = j; while (flag[j] &amp;&amp; turn == j); //critical section flag[i] = false; //remainder section&#125; while (1) 最后执行turn等于谁，谁就进入临界区 Synchronization HardwareBased on locking Uniprocessors 同一时刻指运行一个进程 disable interrupts 把中断屏蔽即可 special atomic hardware instructions 硬件提供特殊的原子指令 原子指令执行期间不允许切换 test memory 查看某内存单元的值 set value 对某内存单元设置为1 swap 交换两个内存单元的值 123456do &#123; acquire lock //criticla section release lock //remainder section&#125; while (1); test_and_set Instruction做成一条机器指令 12345678//tar 看作一个锁，一堆人去抢这把锁boolean test_and_set(boolean *tar) &#123; bool rv = *tar; *tar = true; return rv; //got the lock or not; //flase -&gt; 锁没被锁，自己锁了 //true -&gt; 已经被锁了&#125; 使用这条指令加锁1234567891011//mutux lock//锁只是一个普通变量do &#123; while(test_and_set(&amp;lock)); //do something //critical section lock = false; //释放锁 //remainder section&#125; while (1);//比较倒霉的情况可能不满足有界等待//几率小，当倒霉处理 compare_and_swap Instruction和test_and_set Instruction做一样的事情，但是实际功能更强。 用牛刀杀鸡 12345678int compare_and_swap(int *value, int expected, int new_value) &#123; int temp = *value; if (*value == expected) *value = new_value; return temp;&#125;//旧值和新值比较 1234567do &#123; while (compare_and_swap(&amp;lock, 0, 1) != 0); //是0就设置为1 //do something //critical section lock = 0; //remainder section&#125; while (1); Mutex LockSoftware Tool 使用原子的acquire()和release()来申请、释放锁，不需要在意底层具体实现方式。 CPU busy waiting 问题 循环查看锁开没开 Spinlock 自旋锁 会浪费CPU的时间 更好的办法 锁可用获得锁 锁不可用进程挂起 释放锁时有进程挂起则挑一个唤醒 没有进程挂起直接释放 Semaphore信号量 Synchronization Tool that does not require busy waiting is an integer wait() P 减信号量 请求执行 12345wait(S) &#123; while (S &lt;= 0); //busy wait S--;&#125; signal() V 加信号量 123signal(S) &#123; S++;&#125; Usage某个资源的只能被有限的人使用，例如为了保证网络通畅，只允许五个人连接。 不局限于加锁解锁，可以有一定范围。 当信号量被限制到二元，则退化（？）为互斥锁。 生产者 / 消费者问题？ 有界缓冲区问题？ 哲学家就餐问题？如何把这些搞哲学的饿死。 一个使用信号量解决问题的例子 Implementation]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习笔记-数据链路层]]></title>
    <url>%2F2020%2F10%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[数据链路层的信道种类 点对点信道 一对一通信 广播信道 一对多 需要专门的协议 链路与数据链路 链路指一条无源的点到点的线路 物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路 数据链路层的传输单位是帧 Frame 数据链路层解决的三个基本问题 封装成帧 透明传输 差错控制 链路层的基本功能封装成帧 添加首部尾部进行帧定界 SOH Start_of_header EOT End_of_transmission 帧定界符是特殊的控制字符 透明传输 透明就是不透明 透明传输使得不用关心下层的传输，所采用的设备只是一个通道的作用 当传输二进制文件中出现定界符序列时，在这个序列之前添加ESC进行转义 称为 字节填充 / 字符填充 在前面的非归零反相编码 NRZI 中有提到比特位填充 bit_stuffing 先转义还是先封装? 差错控制 / 差错检测 误码率 BER $P_e = \frac{N_e}{N}$ 传错的除以总的 噪声的类型 热噪声 时刻存在、强度低 高斯白噪声 引起随机差错 冲击噪声 外界电磁干扰引起、强度高 闪电 引起突发错 纠错码与检错码 纠错码适用于错误出现多的情况，可以由接收方发现错误并纠正 检错码适用于错误出现较少的地方，例如有线网络，发现出错后不进行纠正，直接抛弃 常用检错码 奇偶校验 最后添加一个校验位 统计数据码中1的个数 循环冗余编码CRC 有纠错能力，但是数据链路层只用它来检错 CRC 生成多项式 除数，长度为生成多项式最高项的次数，翻译为二进制为多项式每一项的系数 FCS 帧检验序列 CRC是生成FCS的一种方法但不是唯一方法 无差错接受 凡是接受的帧，都可以以非常接近于1的概率认为它正确的 也有可能因为噪声，所有的位变成了0，但是概率非常小 点对点协议 PPP PPP 既能面向Bit也能面向字节 / 字符 点对点通信 只支持全双工 使用广域网进行串行通信 需要满足的要求 简单 链路层功能 封装成帧 透明性 差错检测 对上与对下 多种网络层协议 多种类型链路 检测连接状态 最大传送单元 MTU 不包含帧头帧尾 发送过程中逐步进行调整 高层协议根据链路层的MTU进行分片 网络层地址协商 数据压缩协商 不需要的功能 纠错 链路层不要求可靠性 流量控制 流量来自于端系统的进程，进程间通信由TCP协议负责 序号 PPP不保证可靠性 实际上链路层的传输本就很可靠 多点链路 PPP只支持点对点 半双工 / 单工链路 PPP只支持全双工链路 组成部分 一个将IP数据报封装到串行链路的方法 面向字符的异步链路 面向比特的同步链路 链路控制协议 LCP Link Control Protocol 与物理层交互 一套网络控制协议 NCP Network Control Protocol 与网络层交互 每个协议支持一种不同的网络层协议 帧格式 首部 定界符 / 定界字节序列 0x7E AC 固定的两个部分，但是说不准以后会有用 协议 0x0021 信息部分为IP数据报 0xC021 信息部分位PPP链路控制数据 0x8021 信息部分位网络控制数据 信息部分 IP数据报 尾部 CRC检验序列 从AC开始到信息部分结束 万一以后AC部分有用呢 定界符 / 定界字节序列 0x7E 字节填充 出现控制字符时，前面添加转义字符0x7D，同时第六个bit取反 零比特填充 SONET / SDH使用同步传输，同步传输中没有 字符 的概念 0x7E = 0111 1110 5个连续1之后插一个0，保证不出现连续6个1，就不会出现定界符 同步传输 使用时钟信号线或前同步序列保证发送端与接收端的时钟保持同步 以数据帧位单位传输 异步传输 以字符为单位传输 每个字符前添加起始位0，后面加停止位1，表示数据的开始和结束 工作流程连接从下往上建立，从上往下释放 调制解调器建立物理连接 PC向路由器发送一系列的LCP分组 （0xC021）建立LCP连接 NCP给新接入的PC分配一个临时的IP地址 通信 NCP释放网络层链接，收回临时IP LCP释放数据链路层连接 释放物理层链接 挑战握手认证协议 CHAP在初始链路建立时完成，也可以在链路建立后的任何时刻进行 使用广播信道的数据链路层 IEEE 局域网标准 IEEE 802.3 CSMA/CD IEEE 802.4 令牌总线 IEEE 802.5 令牌环 局域网的特点 网络为一个单位所拥有，地理范围和站点数目均有限 局域网的拓扑结构 环形 环形令牌网 总线 两端带有匹配电阻吸收电磁波信号的能量 CSMA/CD 星形 树形 共享信道 静态划分 不能适用于网络的突发性 动态接入 随机接入 需要解决冲突 受控接入 以太网 使用曼彻斯特编码进行数据传输 不需要尾部的定界符 可以在$1 \over 2$处不跳变 数据链路层的子层 LLC Logical Link Control 面向上层，与传输媒体无关 MAC Medium Access Control 面向下层 数据帧真正完成封装的位置 MAC 子层的功能 数据真的封装/卸装 帧的寻址和识别 帧的接受和发送 链路的管理 帧的差错控制 仲裁介质的使用权 LLC 子层的功能 识别网络层协议，进行封装，加上一个LLC报头 接收方可识别使用了何种局域网 以太网一统天下，LLC实际作用不大 为什么说以太网很简便 无连接 不编号，不要求对方发回确认 提供不可靠的最大努力交付，高层发现丢失了一些数据帧并进行重传，但是以太网并不知道这是一个重传的帧，而是完全当作一个新的数据帧来发送 适配器适配器既有链路层的功能，也有物理层的功能 适配器的主要功能 串行/并行转换 数据缓存 安装设备驱动程序（设备与CPU通信的媒介） 实现以太网协议 CSMA/CD协议 CSMA/CD 是随机征用型的介质访问控制方法 载波监听 多点接入 with 冲突检测 载波监听 每个站在发送数据前都要检测总线上是否有其他站在发信息 多点接入 多个站点连接在一根总线上 冲突检测 边发送数据边检测信道上的信号电压大小，当发现冲突时做出相应处理 Carrier Sense Multiple Access with Collision Detection 以帧为单位传输 存在 IFG Interframe Gap 帧间距 网络设备和组件在接受一个帧后，需要一段时间恢复为接受下一帧做准备 IFG 最小为96比特时间 站模型各个站点相互独立，以固定速率产生数据帧。某个站点一旦产生新帧，即使被阻塞，也不会有新的帧产生，直到发送完毕 单信道假设所有通信都是通过单信道进行，任何时刻仅允许一个站点发送，需要争用发送权 冲突假设若两帧同时发送，则产生冲突，所有站点都能检测冲突，冲突的帧必须重发 时间假设帧可以在任意时刻发送 侦听假设所有站点都可以侦听到当前信道的状态，若忙则等待 但是当某个站监听到总线是空闲时，可能总线并不是真正空闲，因为信号的传播需要时间，也就是之前提到过的传播时延 策略： 非坚持 忙则不等，过会再来看 １坚持 一直等待，直到空闲 Ｐ坚持 以概率为P进行等待 传播时延对载波侦听的影响A在 $t=0$ 时刻发送信号，B在$t = \tau - \delta$ 发送信号，两者信号在 $t = \tau - \frac{\delta}{2}$ 时刻碰撞，B在$t = \tau$时刻检测到碰撞，A在$t=2\tau-\delta$ 时刻检测到碰撞，$\tau$指传播时间。 先发送的一方较后检测到冲突。 CSMA/CD的重要特性 CSMA/CD不能进行全双工通信，只能进行半双工通信 （而PPP只支持全双工通信） 每个站在发送数据之后的一段时间内，存在着遭遇碰撞的可能性 时间的从长短取决于发送方到接收方的距离 发送的不确定性使得整个以太网的平均通信两远小于以太网的最高数据率 以太网不能保证某一时间内一定能把自己的数据帧成功发出去 因此以太网必须轻负载，百分之三十左右 关于碰撞争用期在发送数据后至多 $2\tau$ 时间可以知道是否发生冲突，这段时间称为争用期或碰撞窗口，经过这段时间后还没有检测到碰撞，则说明本次传输不会发生碰撞 所有以太网取 $51.2 \mu s$ 作为争用期长度 以太网的设计决定了最长的2RTT不会超过 $51.2 \mu s$ 对于 10Mb/s 的以太网，争用期内可以发送 512bit 即 64 字节 发生冲突一定是在前64字节以内 最短的有效帧长为64字节 或者说争用期的长度是512比特时间 截断二进制指数类型退避算法 碰撞之后退避一段时间再发送 基本退避时间是$ 2\tau $ （512比特时间），在此基础上乘以$[0, 1, \dots, (2^k - 1)]$中随机一个数，$k$是重传次数，最大为$10$ 争用期的若干倍数 重传$16$次还是失败，直接丢弃 会出现捕获效应，越退越倒霉 碰撞发生后 检测到碰撞立即停止发送数据，并发送干扰信号，让其他主机知道发生了碰撞 时间的浪费 整个发送过程准备发送 ​ 适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中，准备发送 检测信道 ​ 在96比特时间内（IFG 帧间距）没有检测到信道上有信号，就发送 发送 ​ 发送过程中持续检测信道，若检测到碰撞，就终止发送，并发送干扰信号 终止发送后 ​ 执行指数退避算法，等待$r$ 倍的512比特时间，继续检测信道 总结先听后说，边听边说 一旦冲突，立即停说 等待时机，然后再说 使用广播信道的以太网以太网物理设备的演进 粗同轴电缆 10BASE5 10Mbit/s，基带信号，最大段长度500m 站与站之间大于等于2.5m，网络最大跨度2.5km 中继器：信号的整形与放大 收发器：发送、接收、冲突检测、电气隔离 粗缆以太网的冲突检测不靠网卡进行 细同轴电缆 10BASE2 10Mbit/s，基带信号，最大段长度约等于200m 没有外置收发器 冲突检测由网卡完成 双绞线 10BASE-T 使用RJ45连接器 所有站点与集线器相连接 集线器：信号放大与整形，是物理层设备 两个集线器连接时要使用交叉链接法 帧长度可变，最大1518个字节，其中18个字节的MAC头尾，1500个字节的IP数据报 光纤 10BASE-F RJ45连接头锁扣朝上，从左到右编号1-8 为什么要两发两收 传送的是差分信号，用两个信号的差值作为传输的信号，相当于放大，更容易识别 集线器的特点 逻辑总线 多借口转发器 转发比特，不进行碰撞检测 工作在物理层 以太网的信道利用率 一些时间 争用期长度为$2 \tau$，是RTT的两倍 帧长为$L$ 数据发送率为$C$ 帧的发送时间 / 发送时延 / 传输时延 为$\frac{L}{C} = T_0$ 发送一帧需要经过若干个争用期，然后经过发送时延和传输时延 $a = \frac{\tau}{T_0}$，$a$小则说明信道利用率高，$a$大则说明每碰撞一次都会浪费许多信道资源 减小连线长度 / 增加帧长 理想情况下，极限信道利用率为，此时不发生碰撞 S_{\text{max}} = \frac{T_0}{T_0 + \tau} = \frac{1}{1 + a} 以太网的MAC层 硬件地址 / 物理地址 / MAC地址 一个主机多个网卡的话就有多个MAC地址 MAC地址应当理解为某个接口的标识符 网卡使用MAC地址检查某个帧是不是发给自己 MAC帧的格式最常用的是以太网V2标准的格式，IEEE802.3的格式和V2相差无几，我们研究的重点是以太网的V2协议。 类型字段用来表示上一层使用的是什么协议 不一定是网络层，比如PPP协议，PPPoE 为什么先是目的地址再是源地址 方便解析，能快速判断是不是发给自己的 在使用VLAN虚拟局域网的时候MAC帧的长度可能会超过1518 1500字节的数据部分 目的地址6，源地址6，类型2，FCS 4 0x0800表示IP，0x0806表示ARP 最后的FCS校验全部的内容 不包含帧定界符，因为使用曼彻斯特编码，时钟周期中间不跳变即标明发送结束，不需要帧定界符 不需要帧定界符也就不需要使用字节插入来实现透明传输 当数据字段的长度小于46字节时，再数据字段后面加入整数字节的填充字段 MAC层因为没有长度计数，所以MAC层并不知道有填充，填充也不发生在MAC层 填充发生在网络层或者有长度指征的层 例如IP协议有一个总长度字段，表示MAC层的真实数据字段 如何计算传输效率 $ \frac{X}{X + 18 + 8 + 12}$ 18字节的控制信息，8字节的前同步码，12字节的帧间隔IFG 前同步码是一串规律的01序列，用于告知接收方发送方的时钟序列，最后两个11表示准备发送 同步传输，所以需要前同步码 无效的MAC帧 数据字段长度不在46 ~ 1500字节之间 46 + 18 = 64，恰好是可以接受的最短帧长 参看 CSMA/CD / 关于碰撞 / 争用期 以太网对于无效的MAC帧直接丢弃，不负责重传，由更高层负责 无效帧的出现不一定因为发生了碰撞。例如断电。 IEEE 802.3的MAC协议 区别仅在于，第三个字段是长度或类型。长度和类型只能有一个，大于0x6000时表示类型， 小于0x6000时表示长度 因为长度最大不会超过0x6000 当实际长度与长度字段不同时被视为无效帧 强行让LLC发挥作用 无效的MAC帧 802.3协议中数据字段的长度与长度字段不一致 帧的长度不是整数个字节 FCS检测出错 数据字段的长度不在46 ~ 1500字节之间 扩展以太网在物理层扩展以太网 使用多个集线器级联 把多个碰撞域合并成一个碰撞域 Collision Domain 所有可能发生冲突的站点的集合 冲突域被看作物理层的感念 缺点 通信效率会下降，但是使得不同局域网可以通信，扩大了以太网覆盖的地理范围 总的吞吐量没有提高 数据率不同的碰撞域连接起来会使得较快的无法发挥出自己的吞吐量 在数据链路层扩展以太网 使用网桥 / 转发器 根据MAC地址进行转发和过滤 过滤通信量、增大吞吐量、划分冲突域 / 碰撞域 缺点 需要存储转发，增加了时延 转发前执行CSMA/CD算法 没有流量控制，帧多的时候会导致缓存空间不够，发生帧丢失 不同MAC子层的网段桥接在一起时延更大 只适合用户数不太多，通信量不太大的局域网 广播风暴 广播域 数据能广播到的范围，能收到同样广播的设备的集合 是链路层的概念（冲突域是物理层的概念） 产生于网络拓扑的设计和连接问题 使用交换机扩展以太网网桥目前所有的标准网桥都必须支持透明网桥，源路由网桥为可选配置 透明网桥透明网桥的特点 使用最多 “透明”，网桥对于站点来说是看不见的 即插即用，不需要人工配置转发表 需要配置转发表的为静态网桥 网桥的转发表不宜过大，有些旧的地址应该淘汰 网络拓扑可能变化 可能由于更换网卡导致MAC地址变化 不是所有的站点总是接通电源 有的站点从不发送数据或者长时间不发送数据 透明网桥的缺点 不能充分利用网络资源，尤其不能保证最佳路由（由于生成树算法导致相距很近的节点可能需要绕圈子） 为了防止广播风暴的产生，透明网桥只能使用生成树，不能保证每条路由最佳，也不能进行负载均衡 网桥自学习算法分为自学习和转发两个过程 每一次转发都可以得知发送站相对于自己的方向（源地址、进入的接口、时间） 如果之前没有与源地址匹配的项目就插入转发表，若有则更新转发表 但是帧从接口X进入网桥不代表帧发送站在X的网段上 当转发表中无目的地址时无条件进行转发到所有其他接口，记录下发送站相对于自己的方向 当目的地址和源地址在网桥的同一方向时不需要转发，直接丢弃，转发表不变 一个网桥丢弃帧不代表所有的网桥都会丢弃帧 网桥的转发需要拆帧成帧，集线器转发只是整型、放大 透明网桥的生成树算法 为了解决广播风暴的问题 当拓扑结构中存在环的时候求其中的生成树,消除图中的环路，从而保证两个站点之间只有一条路径。 最小序号网桥作为生成树的根 网桥为边，网段为节点 源路由网桥 发送帧时，详细路由信息放在帧的首部 发送数据帧之前，先发送发现帧，发现帧记录经过的路由，到达目的之后按照记住的路由返回 源站根据这些路由得到一个最佳路由进行发送 不再透明 发现帧还能够帮助源点确定整个网络可以通过的帧的最大长度 可以实现负载均衡 可以使用最佳路由 多接口网桥 / 以太网交换机 以太网交换机实质上是一个多接口的网桥，交换机出现之后网桥很快被淘汰了 Multiport Repeater = Hub Multiport Bridge = Switch 通常工作在链路层，常被称为第二层交换机 交换机本质上和网桥一样 网桥传统上基于软件，交换机基于硬件 由数据转发的逻辑部分和输入输出端口组成（input / output port） 两者等效而非等价 交换机的和网桥一样缩小了网络的冲突域，一个端口就是一个冲突域 一个端口连接一个计算机时，仍采用CSMA/CD的控制方法 只要网络上的用户不同时访问一个接口，而且是全双工通信，就不会发生冲突 有的交换机还具有差错控制的功能 能够提高带宽 工作原理 收到一个包时可以知道源MAC的机器连在哪个端口的方向上 之前有过这一项就更新，没有就添加 转发包时在转发表中查找目的MAC地址 如果有则直接复制到目的端口上 没有则泛洪到所有端口 特点 以太网交换机的每个接口都直接与主机或者另一个集线器相连 一般使用全双工的工作方式 此时CSMA/CD的单信道假设不再成立 能同时联通多对接口，每一对相互通信的主机都可以无碰撞的传输数据 和透明网桥一样，即插即用，使用自学习法逐步建立转发表 因为用硬件实现，转发速度较快 交换技术的种类 直通方式 只检查包头，把数据包转发到输出端口 转发速率高，但是会转发错误帧 存储转发方式 缓存数据包，进行CRC检验，过滤掉不正确的包 可以让错误包提前过滤掉，但是牺牲效率 无碎片直通方式 只检查数据包的长度够不够64字节，只去除无效帧 介于以上两者之间，比较平衡的方式 虚拟局域网 VLAN由IEEE 802.1Q定义 一些局域网网段构成的与物理位置无关的逻辑组，这些网段有某些共同的需求 每个VLAN的帧都有明确的标识符，标明这个帧属于哪个VLAN 所以帧长会超过1518 虚拟局域网是局域网的一种服务，而非另一种新型的局域网 优点 安全性 降低负载的相互影响 防止广播风暴 特点 VLAN中的每一个站点都可以听到同一个VLAN上的其他站点发出的广播 不会产生广播风暴 需要路由器或者第三层交换机 VLAN的工作站可以在不同的局域网（网段）中，也可以不在同一楼中（地理位置） 划分根据端口来划分 物理层 一个或多个交换机上的几个端口划分为一个逻辑组 一个集线器上的站点只能属于同一个VLAN 根据MAC地址来划分 数据链路层 可以实现同一广播域内站点的自由移动 但是需要对大量毫无规律的MAC地址进行操作 根据网路层来划分 网络层 按照站点的IP地址来定义广播域，形成虚拟IP子网]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL学习笔记]]></title>
    <url>%2F2020%2F02%2F22%2Flearn_SQL%2F</url>
    <content type="text"><![CDATA[非常粗浅的SQL学习笔记，关于如何使用SQL。 笔记中使用开源的MySQL作为数据管理软件。 MySQL Client安装好MySQL之后，除了服务器以外，还装上了一个客户端，对于数据库的操作都是由这个客户端提供的。客户端通过TCP连接服务器。 1mysql -u root -p 输入密码之后连接本地服务器。 1mysql -h &lt;IP&gt; -p 输入密码之后连接远程SQL服务器。 常用命令12345678SHOW DATABASES;-- 显示全部数据库CREATE DATABASES test;-- 创建数据库DROP DATABASES test;-- 删除数据库USE test;-- 切换到某个数据库 12345678910111213SHOW TABLES;-- 显示表CREATE TABLE students-- 创建表DROP TABLE students-- 删除表ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;-- 添加列ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;-- 修改列ALTER TABLE students DROP COLUMN birthday;-- 删除列 ALTER似乎是Alternate的意思，和键盘上的Alt键一样。 12EXIT-- 退出 这些都是MySQL的操作，对于不同的数据库系统可能有不同的指令。 SQL增删改查12345678910111213141516171819202122232425SELECT * FROM &lt;name_of_table&gt;;-- 列出某个表的所有行SELECT * FROM &lt;name_of_table&gt; WHERE &lt;condition&gt;;-- 列出符合条件的所有行-- 条件运算包括 &gt;= / &lt;= / = / &lt;&gt; / AND / OR / NOT 等SELECT &lt;name_of_columns&gt; FROM &lt;name_of_table&gt; WHERE &lt;condition&gt;;-- 列出想要的列-- 可以对列起一个别名方便表示SELECT &lt;name_of_colmns&gt; FROM &lt;name_of_table&gt; WHERE &lt;confition&gt; ORDER BY &lt;name_of_colmns&gt; &lt;DESC&gt;;-- DESC可以降序排序，默认是升序排序SELECT &lt;name_of_colmns&gt; FROM &lt;name_of_table&gt;WHERE &lt;conition&gt;ORDER BY &lt;name_of_colmns&gt;LIMIT &lt;limit_size_of_page&gt;OFFSET &lt;number_of_offset&gt;;-- 从&lt;number_of_offset&gt;开始分页显示，每页最多显示&lt;limit_size_of_page&gt;个-- 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 1234567891011121314-- SQL内置聚合函数COUNT()-- 计算某一列的合计值，该列必须为数值类型SUM()-- 计算某一列的合计值，该列必须为数值类型MAX()-- 计算某一列的最大值MIN()-- 计算某一列的最小值AVG()-- 计算某一列的平均值，该列必须为数值类型SELECT &lt;function&gt; FROM &lt;name_of_table&gt; GROUP BY &lt;num_of_colmns&gt;;-- 按照列中的值自动分别计算&lt;function&gt; 1-- 连接查询]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现减法]]></title>
    <url>%2F2020%2F01%2F22%2Fhow_to_diff%2F</url>
    <content type="text"><![CDATA[对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。 将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。 至此就实现了二进制加法。 每一个全加器只能计算一位二进制数，要进行多位二进制数的加法就需要串联多个全加器。 大数减小数对于减法而言，不存在进位，但是有借位。 为了避免借位，提出补数的概念 对于一个 $k$ 进制数 $a$ ，从一串 $k$ 中（个数等于 $k$ 进制下 $a$ 的位数）减去 $a$ 得到的数，称为 $a$ 对 $k$ 的补数 提出补数的好处是计算补数的过程不需要借位 当计算出补数之后，将补数与被减数相加，把结果加一，再减去$10^n$，$n$为$a$的位数。 为什么这样可行？举个例子 \begin{align} 253 - 176 &= 253 - 176 + 1000 - 1000 \\ &= 253 - 176 + 999 + 1 - 1000 \\ &= 253 + (999 - 176) + 1 - 1000\\ \end{align}二进制的减法与之类似。 注意到现在式子中唯一的减法其实就是求这个数的补数。 对于一个二进制数，计算它的补数只需要对其按位取反，也就是它的反码(inverse)。 并且，对于最后一步减法，也是不必真的做的，最高位会自然溢出，作为进位被丢掉。 至此，大数减小数的减法就实现了。 表示负数首先明确一点，计算机处理的位数是有限的，超过最高位的数将会溢出。 小数减大数]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>《编码》笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络-自顶向下方法》 编程作业三 邮件服务器]]></title>
    <url>%2F2019%2F11%2F27%2FComputer-Networking-Lab-3%2F</url>
    <content type="text"><![CDATA[《计算机网络-自顶向下方法》 Socket编程作业三 本作业完整代码可在我的这个Github仓库中找到。 要求通过完成本实验，您将更加了解SMTP协议。您还将学到使用Python实现标准协议的经验。 您的任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。您的客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。 为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。 附加说明在某些情况下，接收邮件服务器可能会将您的电子邮件分类为垃圾邮件。当您查找从客户端发送的电子邮件时，请检查垃圾邮件文件夹。 思路由于某些众所周知的原因，本实验不使用Google邮箱，而是使用QQ邮箱。 基本流程如下 与QQ邮箱服务器（smtp.qq.com）建立TCP连接，这里为了简单起见，使用非SSL协议的25端口。其他邮件服务器见这篇文章：常用的邮件服务器名称、地址及SSL/非SSL协议端口号。成功建立连接之后，服务器会返回状态码220表示已就绪。 发送 HELO 命令，输入自己的账户，开始试图与服务器交互。 发送 AUTH LOGIN 命令，输入密码。这里的密码指的是邮件服务器提供的授权码，而不是平时在web端登录的密码。 上面提到的用户名和密码都是经过Base64加密后的结果。我在这一步卡了很久，最后发现原因是在网上找的Base64加密工具给出的结果是错的，换一个工具就好了。 登录成功后，服务器会返回状态码235表示成功。 发送 MAIL FROM 命令，表明发信人，应当与 HELO-AUTH 命令中验证的邮箱保持一致。成功后会收到 250 OK的回复。 发送 RCPT TO 命令，表明收信人。成功后会收到 250 OK 的回复。 发送 DATA 命令，表明自己要开始发送信息了。 服务器将返回状态码354 。 发送邮件内容，最开头要有\r\n，每条信息结尾也要有\r\n，最后要发送一个\r\n.\r\n表明邮件内容的结束。 发送 QUIT 命令，结束与邮件服务器的连接。 日志]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络-自顶向下方法》 编程作业二 UDP ping 程序]]></title>
    <url>%2F2019%2F11%2F16%2FComputer-Networking-Lab-2%2F</url>
    <content type="text"><![CDATA[《计算机网络-自顶向下方法》 Socket编程作业二 本作业完整代码可在我的这个Github仓库中找到。 要求在这个编程作业中，你将用Python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序，然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第4章中学习ICMP）。此时我们将创建一个非标准（但简单）的基于UDP的ping程序。 你的ping程序经UDP向目标服务器发送10个ping报文，对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为1秒；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。 在此作业中，我们给出服务器的完整代码（在配套网站中可以找到。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以不受限制地从服务器代码中剪贴代码行。 思路 在服务端与客户端建立UDP连接 循环发送十条信息，在发出和接收的位置分别计时 每接收到一条回复，把两个时间相减得到RTT 注意 在判断超时的时候，socket自带了一个时长限定，当超出这个时间之后会抛出timeout异常。 time.perf_counter()是以秒为单位的计时。 服务端模拟丢包率为 $30 \%$ ，实际结果与其格外吻合。 效果【客户端】 【服务端】]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机网络-自顶向下方法》 编程作业一 Web服务器]]></title>
    <url>%2F2019%2F11%2F14%2FComputer-Networking-Lab-1%2F</url>
    <content type="text"><![CDATA[《计算机网络-自顶向下方法》 Socket编程作业一 本作业完整代码可在我的这个Github仓库中找到。 要求实现一个最简单的Web服务器，它能够处理一个请求： 当客户（浏览器）联系时创建一个连接Socket 从这个连接接收HTTP请求 解释该请求以确定所请求的特定文件 从服务器的文件系统获取该文件 创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行 经TCP连接向请求的浏览器发送响应。若服务器中不存在请求的文件是，返回一个404 Not Found的差错报文 思路 HTTP建立在TCP之上，所以在服务端建立TCP Socket HTTP响应报文的首部行需要手写，感觉有点奇怪 如果不用浏览器，也可以写一个客户端的程序来进行HTTP请求 对于浏览器，用&lt;ip_address&gt;:&lt;port&gt;/&lt;file&gt;来请求某个文件 图示]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配学习笔记]]></title>
    <url>%2F2019%2F11%2F06%2FBipartiteGraphLearn%2F</url>
    <content type="text"><![CDATA[学了好几次才学会 二分图 二分图一定是一个无向图 若一个无向图中不存在长度为奇数的环，则这个图为二分图 二分图可以分成两个部分，每部分中的点之间没有边 二分图匹配 对于一个二分图，从它的所有边中选出一些，使得任意两条边没有公共端点，这样的边的集合被称为二分图的匹配 二分图的匹配并不是唯一的 在所有的匹配中含边数最多的那一个称为这个二分图的 最大匹配 增广路定理网络流问题中也存在（类似的）增广路的概念。 对于一个二分图，如果存在一条连接两个非匹配点的路径，使得匹配边与非匹配边交替出现，则这个路径是已知匹配的 增广路。 对于一条增广路而言，如果将其中的匹配边与非匹配边身份互换，可得到一个更大的匹配。 由上述两条可知，找到最大匹配等价于此时二分图中不存在增广路。 匈牙利算法把二分图画成左边右边两个区域（黑点白点），两个区域中间有一些边，现在要在这些边里选择出一些，使形成一个最大匹配。 不妨以左边的点从上到下的顺序考虑 对于左边的第i个点，遍历与之相邻的点neighbor[i][j]（一定在右侧） 如果neighbor[i][j]还没有被匹配，那就把这两个点（暂时）匹配上，看左边的第i+1号点。 如果neighbor[i][j]已经被匹配过了，那就看看之前和neighbor[i][j]匹配的点还能不能匹配其他点（此时视角转换成neighbor[i][j]之前确定的那个匹配点（左边的点），递归进去）。 如果neighbor[i][j]之前的匹配点可以换一个匹配对象，就换，把neighbor[i][j]留给现在考虑的i号点，不能换就算了，看j+1号点 如果能找到一个合适的匹配点，就返回true，反之返回false 这是一个类似于dfs的过程，被访问的点不应到再被访问一次，所以用一个vis 数组记录dfs过程中的访问情况，注意这里的访问情况和匹配情况的区别，代码中的vis是访问情况，con_x con_y是匹配情况。所以vis每看一个左边的点就要全部设置为未访问一次。 理解这个过程之后，发现真的很像相亲…… 有点贪心的意思 模板题HDU-2063 过山车1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 500 + 10;bool p[MAXN * 2][MAXN * 2], vis[MAXN * 2];int con_x[MAXN * 2], con_y[MAXN * 2];int n, m;bool match(int x) &#123; for (int i = n + 1; i &lt;= n + m; i++) &#123; if (p[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (con_y[i] == -1 || match(con_y[i])) &#123; con_x[x] = i; con_y[i] = x; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; int k; while (scanf("%d%d%d", &amp;k, &amp;n, &amp;m) != EOF &amp;&amp; k != 0) &#123; memset(con_x, -1, sizeof(con_x)); memset(con_y, -1, sizeof(con_y)); memset(p, false, sizeof(p)); for (int i = 0; i &lt; k; i++) &#123; int girl, boy; scanf("%d%d", &amp;girl, &amp;boy); p[girl][boy + n] = p[boy + n][girl] = true; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; memset(vis, false, sizeof(vis)); if (match(i)) ans++; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manacher学习笔记]]></title>
    <url>%2F2019%2F11%2F04%2Fmanacher_learn%2F</url>
    <content type="text"><![CDATA[学了好几次才学会 Manacher简介Manacher算法用于高效解决这样的问题：给定一个长度为 $n$ 的字符串，求其中以每个字符为中心的回文子串的长度。 什么是回文串？正着读和反着读都一样的字符串，例如()()不是一个回文串，而())(是一个回文串。 暴力算法最蠢的那种$O(n^2)$ 枚举子串，$O(n)$ 判断是否为回文，总复杂度$O(n^3)$ 稍微好一点$O(n)$枚举中心，向两边尽量扩展，复杂度$O(n^2)$ Manacher算法Manacher 利用了回文串具有的对称性来通过之前计算过的子串的信息优化对当前位置的计算。这一点和KMP算法可以说异曲同工。 首先明确最后要通过这个算法得到什么东西。一个数组p，其中p[i]表示以i为中心的最大回文半径。 例如，对于字符串 s = &quot;cabadabae&quot; 最后求出的p数组应当为 p = [1, 1, 2, 1, 4, 1 , 2, 1, 1] 这样知道了最大回文半径，也就能求出以每个字符为中心的最长回文子串长度。 但是这样的做法不够完善，例如对于baaaab这个字符串，本身是一个回文串，那么最长回文子串自然是它本身，但是按照p数组的定义，这个字符串对应的p应该是[1, 1, 2, 2, 1, 1]，而仅仅通过这个数组是求不出最长回文子串的。 问题就出在这个串的长度是偶数，在这个串中不存在一个中心作为这个子串的中心。 所以需要进行预处理来使得这个算法支持偶数长的子串。 预处理个人感觉这一步相当巧妙。 对于原串，我们在开头插入一个$，在每个字符前后都插入一个#。 例如，对于字符串 s = &quot;cabadabae&quot; 预处理之后结果为 s1 = &quot;$#c#a#b#a#d#a#b#a#e#&quot; 这里的$和#并不是一定用这两个字符，只要是不在原串中出现的字符都可以。 经过这样的预处理我们发现之前不存在对称中心的问题解决了，偶数长度的子串在新字符串中以#为对称中心，奇数长度的子串在新字符串中还是以原来的对称中心为对称中心，且原字符串的回文子串长度等于新字符串回文半径长度减一。 添加开头的$是为了更好判断边界，不添加也可以，但是在边界处理上会麻烦一些。 算法思路在第二个暴力算法中，还是以s = &quot;cabadabae&quot;为例，假如我们已经知道了以第三位为中心的最大回文半径（相当于知道了以第三位为中心的最长回文子串）和以第五位为中心的最大回文半径，那么在求以第七位为中心的最大回文半径的时候，由于回文串具有对称的特性，并且三和七恰好关于五对称，所以可以直接得到（部分）结果。 以第三位为中心的最长回文子串 c[aba]dabae 以第五位为中心的最长回文子串 c[abadaba]e 以第七位为中心的最长回文子串 cabad[aba]e 所以可以直接从长度为3开始拓展（因为目前为止更后面的信息还不知道）。 如果换成计算第六位的时候又是怎样的情况呢？六关于五的对称点为四。 以第二位为中心的最长回文子串 cab[a]dabae 以第五位为中心的最长回文子串 c[abadaba]e 以第七位为中心的最长回文子串 cabad[a]bae 长度只能为1。 不难发现，在已知当前最长的回文串是以五位中心之后，再往后的位置都可以直接由对称性来得到至少一部分信息。我们利用这些信息，就能很快求出所有的回文子串。 算法流程设置两个状态 maxR 和 id，分别表示当前已知的回文子串的最右边界和这个边界所对应的中心。 设p[i]表示第i个字符为中心时最大回文子串的长度，按照i从大到小的顺序从左向右计算。 对于每一个即将计算到的i，先计算出关于id的对称点j = id * 2 - i，然后分以下三种情况进行。 若 $i &gt; maxR$，即这个点不在之前计算过的回文串中，此时我们并不能从之前的计算中获取有用的信息，只能令p[i] = 1，然后从这个位置开始向两边扩展，顺便更新 maxR 和 id 若 $i \leq maxR$ 且 $i + p[j] &lt; maxR$ ​，此时有 p[i] = p[j]，如同上面的第二个例子。 若 $i \leq maxR$ 且 $i + p[j] \geq maxR$，此时已知的最长回文串覆盖了i这个位置但是没有覆盖j为中心的回文串，此时有p[i] = maxR - i。 这样确定p[i]最小可能的值然后再尝试向两边扩展即可，其中第二种情况应该是无法继续扩展的。 1、先对字符串进行预处理，两个字符之间加上特殊符号# 2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整） 3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度 4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界 5、最后得到最长回文之后，去掉其中的特殊符号即可 模板题链接P3805 【模板】manacher算法 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int MAXN = 11000000 + 10;int p[MAXN * 2 + 10], maxR = 0, id = 0;string preProcess(string s) &#123; string ret = "$"; for (auto &amp;c : s) &#123; ret += "#"; ret += c; &#125; ret += '#'; return ret;&#125;int main() &#123; string s; cin &gt;&gt; s; string sp = preProcess(s); for (int i = 1; i &lt; sp.length(); i++) &#123; if (i &lt; maxR) &#123; int j = id * 2 - i; p[i] = min(p[j], maxR - i); &#125; else &#123; p[i] = 1; &#125; int l = i - p[i]; int r = i + p[i]; while (sp[l] == sp[r]) &#123; l--; r++; if (r &gt; maxR) &#123; maxR = r; id = i; &#125; &#125; p[i] = r - i; &#125; int maxx = -1; for (int i = 1; i &lt; sp.length(); i++) &#123; maxx = max(maxx, p[i]); &#125; cout &lt;&lt; maxx - 1 &lt;&lt; endl; return 0;&#125; 参考资料【面试现场】如何找到字符串中的最长回文子串？ Manacher 学习笔记 - Menci]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 - 文件操作]]></title>
    <url>%2F2019%2F10%2F30%2Ffilepython%2F</url>
    <content type="text"><![CDATA[真是令人迷惑 何为文件文件可以看作数据的抽象和集合。是数据存储的一种形式，由二进制存储。 Linux认为一切都是文件， 在UNIX系统中，一切资源都被看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，称之为设备文件。 文件的类型 / 展示方式 文本文件 单一而特定的编码组成的文件， 例如UTF-8编码。 可以看作一个长的字符串。 二进制文件 直接由0和1构成的文件，没有统一的编码格式。一般这样的文件中的0和1是由某种预定的格式组合成的，因此形成了一些特定的文件类型，例如图片的 .png，视频的.avi。 这类文件的0和1之上没有统一的编码。 文件的打开和关闭文件的操作通常遵循 “打开，操作，关闭” 的步骤，关系如下图所示 文件的打开 f = open(&lt;file_name&gt;, &lt;open_mode&gt;) 文件名可以使用相对路径也可以使用绝对路径 Python提供七种文件打开模式，与C类似 打开模式 描述 r 默认打开模式，只读，若文件不存在则抛出异常 w 覆盖写，若不存在则创建，若存在则完全覆盖 x 创建写，若不存在则创建，若存在则抛出异常 a 追加写，若不存在则创建，若存在则在文件后追加 b 二进制打开 t 文本打开，默认方式 + 与前四种模式一同使用，在原本的基础上增加读写功能 默认的文件编码格式为UTF-8，要打开其他编码格式的文件要在打开文件时为read添加参数encoding表示要使用的编码方式。 如果编码方式不规范，open会抛出异常，遇到这种情况可以添加errors参数表示如何处理，最简单的方式就是直接忽略error = &#39;ignore&#39;。 文件的关闭 f.close()用来关闭文件，使文件回到存储状态。 处理异常 由于在每次打开文件的时候都可能会产生异常，所以应该对异常采取适当的处理方式。 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 因为每次都要try-finally，过于繁琐，Python提供了with语句来简单处理（不局限但普遍应用于文件操作） 123# using with statement with open('file_path', 'w') as file: file.write('hello world !') 这样的写法不需要自己手动关闭文件，也不需要手动捕获异常。 文件的读取 python提供三种文件读取的方法 方法 描述 &lt;file_object&gt;.read() 直接读入整个文件，存到字符串当中，对于大文件慎用 &lt;file_object&gt;.read(size) 读前size个字符的内容 &lt;file_object&gt;.readline() 读一行 &lt;file_object&gt;.readline(size) 读前size个字符的内容 &lt;file_object&gt;.readlines() 读入所有行，组织成一个列表 &lt;dile_object&gt;.readlines(hint) 读入前hint 行，组织成一个列表 逐行遍历文件 123with open('test.txt', 'r') as f: for lines in f.readlines(): print(lines) 123with open('test.txt', 'r') as f: for lines in f: print(lines) 数据的文件写入想要写入文件，在打开文件时应该用w / wb形式 python提供两种写文件的方法 方法 说明 &lt;file_object&gt;.write(str) 写字符串或文件流到文件中 &lt;file_object&gt;.writelines(list) 把一个全为字符串的列表写到文件里，实际上是把列表中的字符串续到一起 文件指针 不是C语言里的那种文件指针。 就像文本编辑器里的光标一样，表示当前写入的位置。 使用&lt;file_project&gt;.seek()来调整文件指针 seek()接受两个参数，第一个参数表示偏移量，第二个参数表示起点（0-从开头开始，1-从当前位置开始，2-从末尾开始） 123456789101112l = ['hihi ', 'haha ', 'hoho ']with open('test.txt', 'w+') as f: f.writelines(l) # f.seek(0, 0) #hihi haha hoho # f.seek(1, 0) #ihi haha hoho # f.seek(2, 0) #hi haha hoho # f.seek(0, 1) #None # f.seek(0, 2) #None for lines in f: print(lines) 如果写入之后接着读取是什么都读不到的，因为文件指针默认从当前位置开始读，而刚写入之后文件指针的后面什么都没有，需要移动之后再输出 participant 存储状态 as ff participant 占用状态 as kk ff-->kk: a = open(, ) kk-->ff: a.close(){"theme":"simple"} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KMP学习笔记]]></title>
    <url>%2F2019%2F09%2F26%2FKMP_learn%2F</url>
    <content type="text"><![CDATA[学了好几次才学会 KMP简介KMP算法用于高效解决这样的问题：给定一个有 $n$ 个字符的字符串 txt 和一个有 $m$ 个字符的字符串 pat （$n &gt; m$），找出 txt 中 pat 每次出现的位置 。 举个例子1234Input : txt[] = &quot;THIS IS A TEST TEXT&quot; pat[] = &quot;TEST&quot;Output: Pattern found at index 10 另一个例子123456Input: txt[] = &quot;AABAACAADAABAABA&quot; pat[] = &quot;AABA&quot; Output: Pattern found at index 0 Pattern found at index 9 Pattern found at index 12 暴力匹配法对于这个问题，最容易想到的方法就是一个位置一个位置尝试匹配，每次将模式串 pat 向后移动一位，就像一个滑动的窗口一样，每次比较 $m$ 个位置。 但是这个方法在很多匹配的字符后面跟着一个不匹配的字符的情况下表现不够好，最坏的情况复杂度会达到 $O(m(n-m+1))$ 。 比如说：12txt[] = &quot;AAAAAAAAAAAAAAAAAB&quot;pat[] = &quot;AAAAB&quot; 或者：12txt[] = &quot;ABABABCABABABCABABABC&quot;pat[] = &quot;ABABAC&quot; KMP算法KMP算法最基本的想法就是：不论我们在哪里失配了（在某些字符匹配成功之后），我们都知道了接下来要尝试匹配的 txt 的子串的一部分信息，因为每次 pat 都只向右移动一个字符，所以我们可以利用这一点来减少不必要的匹配。 举个例子12txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot; 第一次匹配是成功的，接下来 pat 串会向右移动一个字符 12txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot; 在暴力匹配算法中，我们会从 txt 的第二个位置，pat 的第一个位置开始尝试匹配，但是实际上我们只需要看txt 的第五个位置和 pat 的第四个位置是不是相同的就可以了，因为我们知道前三个字符一定会匹配。 为了做到这一点，我们需要进行一些预处理。 我们定义一个列表lps[]（lps 是 longest proper prefix which is also suffix 的缩写），lps[i]表示pat 中[0, i]这个子串中即是前缀又是后缀的最长的子串（不包括[0, i]这个子串本身） 例如： 1234567891011121314For the pattern “AAAA”, lps[] is [0, 1, 2, 3]For the pattern “ABCDE”, lps[] is [0, 0, 0, 0, 0]For the pattern “AABAACAABAA”, lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]For the pattern “AAACAAAAAC”, lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] For the pattern “AAABAAA”, lps[] is [0, 1, 2, 0, 1, 2, 3] 在有了lps数组之后，就可以进行我们的KMP算法了： 我们用 i 来指示 txt 中当前考虑的元素的下标，j来指示 pat 中当前考虑元素的下标 匹配从i = 0，j = 0 开始，当 txt[i] == pat[j] 时，i++; j++，此时这个位置是匹配的 当txt[i] != pat[j]即这个位置不匹配的时候 既然能进行到这一步，说明pat的[0, j - 1]中的每个位置和txt的[i - j, i - 1]中的每个位置都是匹配的 我们还知道lps[j - 1]表示pat 中[0, j - 1]这个子串中即是前缀又是后缀的最长的子串 基于以上两点，我们发现在pat向右移动一位准备开始下一次匹配的时候，pat的前lps[j - 1]个字符是不需要匹配的（一定可以匹配成功），j重置为lps[j - 1] 简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。 ， 举个例子1234i = 0, j = 0txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 匹配，i++; j++ 1234i = 1, j = 1txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 匹配，i++; j++ 直到i = 4, j = 4为止都是匹配的，此时一轮匹配结束，j被重置为lps[j - 1] = lps[4 - 1] = lps[3] = 3，也就是说，在下一次匹配中，pat 的前三个字符都不必进行匹配（一定可以匹配成功） 1234i = 4, j = 3txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 匹配，i++; j++ 此时i = 5, j = 4，又一轮匹配结束，j被重置为lps[j - 1] = lps[4 - 1] = lps[3] = 3 1234i = 5, j = 3txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 不匹配，这轮匹配终止，j被重置为lps[j - 1] = lps[3 - 1] = lps[2] = 2 1234i = 5, j = 2txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 不匹配，这轮匹配终止，j被重置为lps[j - 1] = lps[2 - 1] = lps[1] = 1 1234i = 5, j = 1txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 不匹配，这轮匹配终止，j被重置为lps[j - 1] = lps[1 - 1] = lps[0] = 0 1234i = 5, j = 0txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 不匹配，这轮匹配终止，但是此时j = 0，故i++ 1234i = 6, j = 0txt[] = &quot;AAAAABAAABA&quot; pat[] = &quot;AAAA&quot;lps[] = &#123;0, 1, 2, 3&#125; 匹配，i++; j++ $\dots$ 重复上述过程，直到i = n，算法结束。 lps的计算现在，问题只剩下如何求得lps这个列表了。 求解lps的过程可以看作模式串自己与自己匹配的过程，对于每个位置（除了0位置，0位置永远为0）都与自己从头开始匹配，能匹配的最大长度就是lps。 实现中用len记录当前匹配到的最大长度。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000000 + 10;char txt[MAXN], pat[MAXN];int lps[MAXN];void KMP(char txt[], char pat[]) &#123; int lenA = strlen(txt); int lenB = strlen(pat); int i = 0, j = 0; while (i &lt; lenA) &#123; if (txt[i] == pat[j]) i++, j++; else &#123; if (j == 0) i++; else j = lps[j - 1]; &#125; if (j == lenB) &#123; printf("%d\n", i - j + 1); j = lps[j - 1]; &#125; &#125;&#125;void calcLps(int lps[], char pat[]) &#123; int len = 0; int i = 0; int lenPat = strlen(pat); while (i &lt; lenPat) &#123; if (i == 0) &#123; lps[len] = 0; i++; &#125; else &#123; if (pat[len] == pat[i]) &#123; len++; lps[i] = len; i++; &#125; else &#123; if (len == 0) &#123; lps[i] = 0; i++; &#125; else len = lps[len - 1]; &#125; &#125; &#125;&#125;int main() &#123; scanf("%s%s", txt, pat); calcLps(lps, pat); KMP(txt, pat); int len1 = strlen(pat); for (int i = 0; i &lt; len1; i++) &#123; printf("%d ", lps[i]); &#125; return 0;&#125; 参考资料KMP Algorithm for Pattern Searching 如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 3 - 3]]></title>
    <url>%2F2019%2F08%2F08%2Facmsummer_33%2F</url>
    <content type="text"><![CDATA[线段树与树状数组专题限时训练一 【链接】QDUACM集训队_18级暑假训练第3周_线段树、树状数组限时训练1 HDU 4217 Data Structure? - 树状数组区间第k小 + 二分【题目大意】在一个含有$1 \cdots n$的序列中，每次找到第 $k_i$ 小的数，并把它删除，每组数据，输出一个整数，表示删除元素的总和。 【题解】发现一个数的排名只受它的位置之前被删除的数的个数影响，删除比它大的数不影响它的排名，这样问题就转化为了前缀和，可以用树状数组维护，对于要求排名 $k_i$ 的数，只会位于 $[k_i, n]$ 这个区间中，在这个区间二分找到将要被删除的那个数，计入答案即可。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 262144 + 10;struct Bit &#123; long long a[MAXN]; int size; void init(int n) &#123; memset(a, 0, sizeof(a)); size = n; &#125; int lowBit(int x) &#123;return x &amp; -x;&#125; void modify(int index) &#123; while (index &lt;= size) &#123; a[index]++; index += lowBit(index); &#125; &#125; long long query(int index) &#123; long long ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowBit(index); &#125; return ans; &#125;&#125; bit;int find(int l, int r, int x) &#123; // printf("[%d %d]", l, r); int tmp = 0; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; tmp = mid - bit.query(mid); if (tmp &gt;= x) r = mid; else l = mid + 1; &#125; return r;&#125;int main() &#123; int t; scanf("%d", &amp;t); int cnt = 0; while (t--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); bit.init(n); long long ans = 0; for (int i = 0; i &lt; m; i++) &#123; int x; scanf("%d", &amp;x); int del = find(x, n, x); ans += del; bit.modify(del); &#125; printf("Case %d: ", ++cnt); printf("%lld\n", ans); &#125; return 0;&#125; ZOJ 1610 Count the Colors - 区间染色【题目大意】对线段染色，后染上去的会覆盖前染上的，问完成染色后每种颜色各有多少段 【题解】线段树维护区间当前的颜色，对于每次修改，下放标记然后修改子树。 每组数据只有一次查询，在所有修改都结束之后记录下每个叶节点的颜色，把连续的相同颜色 都算成一段，统计即可 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;const int MAXN = 8000 + 10;int cnt[MAXN];struct SegmentTree &#123; int l, r, mid; int color; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; color = -1; lc = rc = NULL; &#125; void build() &#123; if (this-&gt;r - this-&gt;l == 1) color = -1; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); &#125; &#125; void pushDown() &#123; if (color != -1) &#123; lc-&gt;color = this-&gt;color; rc-&gt;color = this-&gt;color; this-&gt;color = -1; &#125; &#125; void modify(int l, int r, int color) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) this-&gt;color = color; else &#123; pushDown(); if (l &lt; mid) lc-&gt;modify(l, std::min(mid, r), color); if (r &gt; mid) rc-&gt;modify(std::max(l, mid), r, color); &#125; &#125; void query(int l, int r, std::vector&lt;int&gt; &amp;v) &#123; if (r - l == 1) v.push_back(this-&gt;color); else &#123; pushDown(); if (l &lt; mid) lc-&gt;query(l, std::min(r, mid), v); if (r &gt; mid) rc-&gt;query(std::max(l, mid), r, v); &#125; &#125;&#125;;void deleteSegtree(SegmentTree *node) &#123; if (node-&gt;lc) deleteSegtree(node-&gt;lc); if (node-&gt;rc) deleteSegtree(node-&gt;rc); node-&gt;~SegmentTree(); delete node; node = NULL;&#125;int main() &#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; SegmentTree *root = new SegmentTree(0, MAXN); root-&gt;build(); for (int i = 0; i &lt; n; i++) &#123; int l, r, c; scanf("%d%d%d", &amp;l, &amp;r, &amp;c); root-&gt;modify(l, r, c); &#125; std::vector&lt;int&gt; v; root-&gt;query(0, MAXN, v); memset(cnt, 0, sizeof(cnt)); for (int i = 0; i &lt; v.size(); ) &#123; if (v[i] == -1) &#123; i++; continue; &#125; for (int j = 1; i + j &lt; v.size(); j++) &#123; if (v[i + j] != v[i]) &#123; cnt[v[i]]++; i += j; break; &#125; &#125; &#125; for (int i = 0; i &lt; MAXN; i++) &#123; if (cnt[i] != 0) &#123; printf("%d %d\n", i, cnt[i]); &#125; &#125; printf("\n"); deleteSegtree(root); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 3 - 1+2]]></title>
    <url>%2F2019%2F08%2F06%2Facmsummer_312%2F</url>
    <content type="text"><![CDATA[线段树与树状数组专题 【链接】QDUACM集训队_18级暑假训练第3周_线段树、树状数组专题训练1 QDUACM集训队_18级暑假训练第3周_线段树、树状数组专题训练2 专题一C - Ultra-QuickSort - 树状数组求逆序对 + 离散化【题目大意】给定一个序列，求对于升序排序的逆序对个数 【题解】树状数组求逆序对的模板题。 树状数组可以处理的问题是前缀和，对于某个元素来说，升序排序的逆序对的个数就是位置在它后面数值比他小的数的个数，这个就是一个前缀和的问题了。 对于每个元素，记录他的值和他的位置，按照从数值小到大的顺序排序去重完成离散化之后，把原数组从后往前的每个元素在排序好的数组中找到位置，用树状数组维护这个位置数组，这个位置的前缀和就是这个数逆序数，在找到的位置处加一。 例如 a = [9, 1, 0, 5, 4] \\ a' = [0, 1, 5, 4, 9]\\从后往前遍历 a 数组， 首先找到 $4$ ，在 a&#39; 数组中查找发现 $4$ 在第 $4$ 个位置，在树状数组中查询 $4$ 这个位置，发现前缀为 $0$ ，也就是 $4$ 后面数值比他小的数的个数为 $0$ ，也就是 $4$ 对于逆序数的贡献为 $0$，接下来在树状数组中把 $4$ 这个位置加一， 接下来找到 $5$ , 在 a&#39; 数组中查找发现 $5$ 在第 $3$ 个位置，在树状数组中查询 $3$ 这个位置，发现前缀为 $1$ ，也就是之前插入的 $4$，这说明 $5$ 后面数值比他小的数的个数为 $1$，也就是 $5$ 对于逆序数的贡献为 $1$，接下来在树状数组中把 $3$ 这个位置加一， 以此类推，最后的结果就是逆序对的总数。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int MAXN = 500000 + 10;struct Bit &#123; int size; int a[MAXN]; Bit(int size) : size(size) &#123;&#125; int lowBit(int x) &#123;return x &amp; -x;&#125; int query(int index) &#123; int ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowBit(index); &#125; return ans; &#125; void modify(int index, int delta) &#123; while (index &lt;= size) &#123; a[index] += delta; index += lowBit(index); &#125; &#125; void init() &#123; memset(a, 0, sizeof(a)); size = 0; &#125;&#125;;int a[MAXN];int main() &#123; int n; std::vector&lt;int&gt; v; Bit bit(0); while (scanf("%d", &amp;n) != EOF) &#123; if (n == 0) break; bit.size = n; memset(bit.a, 0, sizeof(bit.a)); v.clear(); for (int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;a[i]); v.push_back(a[i]); &#125; std::sort(v.begin(), v.end()); std::vector&lt;int&gt;::iterator newEnd = std::unique(v.begin(), v.end()); long long ans = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; int index = std::lower_bound(v.begin(), newEnd, a[i]) - v.begin() + 1; ans += bit.query(index - 1); bit.modify(index, 1); &#125; printf("%lld\n", ans); &#125; return 0;&#125; E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理【题目大意】给定一个序列和若干询问，对于每个询问给出区间中不重复的元素的和 【题解】单独的一棵线段树/树状数组不能维护所有区间的不重复元素和，需要主席树等数据结构，这里的做法是离线处理每个查询。 把所有询问存下来，按照右端点从小到大排序，从小到大依次处理每个询问，对于一个新的询问，考察比上一个询问扩展出来的部分是否有之前出现过的元素，如果有就把之前的元素删除，把最近的加入，这样就保证了每个元素在每个询问中只出现一次，且是所有出现中最右边的那个。 更新完之后就可以用树状数组查询了。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;#include &lt;map&gt;const int MAXN = 30000 + 10;struct Bit &#123; long long a[MAXN]; int size; Bit() &#123; size = 0; &#125; void init() &#123; memset(a, 0, sizeof(a)); size = 0; &#125; int lowBit(int x) &#123;return x &amp; -x;&#125; void modify(int index, int delta) &#123; while (index &lt;= size) &#123; a[index] += delta; index += lowBit(index); &#125; &#125; long long query(int index) &#123; long long ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowBit(index); &#125; return ans; &#125;&#125; bit;struct Query &#123; int l, r; int id; Query(int l, int r, int id) : l(l), r(r), id(id) &#123;&#125; bool operator&lt;(const Query &amp;a) const &#123; return r &lt; a.r; &#125;&#125;;int a[MAXN];int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; memset(a, 0, sizeof(a)); bit.init(); int n; scanf("%d", &amp;n); bit.size = n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; int q; scanf("%d", &amp;q); std::vector&lt;Query&gt; v; for (int i = 1; i &lt;= q; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); v.push_back(Query(l, r, i)); &#125; std::sort(v.begin(), v.end()); std::map&lt;int, int&gt; mp; std::vector&lt; std::pair&lt;int, long long&gt; &gt; ans; int l = 1; for (std::vector&lt;Query&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; for (int i = l; i &lt;= it-&gt;r; i++) &#123; if (mp.count(a[i])) bit.modify(mp[a[i]], -a[i]); bit.modify(i, a[i]); mp[a[i]] = i; &#125; ans.push_back(std::make_pair(it-&gt;id, bit.query(it-&gt;r) - bit.query(it-&gt;l - 1))); l = it-&gt;r; &#125; std::sort(ans.begin(), ans.end()); for (std::vector&lt; std::pair&lt;int, long long&gt; &gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123; printf("%lld\n", it-&gt;second); &#125; &#125; return 0;&#125; F - HDU 4417 Super Mario - 树状数组求区间不大于某数的数个数 + 离线处理【题目大意】马里奥吃金币，马里奥有在每个区间里有一个跳跃高度，只能吃到小于等于这个高度的硬币，给出若干组询问，问某个区间中能吃到多少金币。 【题解】离线处理所有询问，把每个点和每个询问都按照高度从小到大排序，排序后从小到大考察每个询问。 利用树状数组前缀求和的特点，只需要设置一个变量表示现在到了哪个金币，如果这个金币的高度小于当前询问的高度，就加入到树状数组当中，因为询问高度是单调增的，所以在前面的询问中加入的点仍然满足后面询问的条件，这样就只需要用树状数组维护一下区间和了。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int MAXN = 100000 + 10;struct Query &#123; int l, r, h; int id; bool operator&lt;(const Query &amp;a) const &#123; return h &lt; a.h; &#125;&#125; qs[MAXN];struct Node &#123; int h, id; bool operator&lt;(const Node &amp;a) const &#123; return h &lt; a.h; &#125;&#125; num[MAXN];struct Bit &#123; int a[MAXN]; int size; Bit() &#123; size = 0; memset(a, 0, sizeof(a)); &#125; void init(int n) &#123; size = n; memset(a, 0, sizeof(a)); &#125; int lowBit(int x) &#123;return x &amp; -x;&#125; void modify(int index, int delta) &#123; while (index &lt;= size) &#123; a[index] += delta; index += lowBit(index); &#125; &#125; int query(int index) &#123; int ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowBit(index); &#125; return ans; &#125;&#125; bit;int ans[MAXN];int main() &#123; int t; scanf("%d", &amp;t); int cnt = 0; while (t--) &#123; printf("Case %d:\n", ++cnt); int n, m; scanf("%d%d", &amp;n, &amp;m); bit.init(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i].h); num[i].id = i; &#125; std::sort(num + 1, num + n + 1); for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;qs[i].l, &amp;qs[i].r, &amp;qs[i].h); qs[i].l++; qs[i].r++; qs[i].id = i; &#125; std::sort(qs, qs + m); int cnt = 1; for (int i = 0; i &lt; m; i++) &#123; while (cnt &lt;= n &amp;&amp; num[cnt].h &lt;= qs[i].h) &#123; bit.modify(num[cnt++].id, 1); &#125; ans[qs[i].id] = bit.query(qs[i].r) - bit.query(qs[i].l - 1); &#125; for (int i = 0; i &lt; m; i++) &#123; printf("%d\n", ans[i]); &#125; &#125; return 0;&#125; 专题二C - An easy problem - 线段树维护区间乘积【题目大意】令$x = 1$，给出两种操作 操作(1, a)表示令 $x = a \cdot x$ 操作(2, i)表示令 $x = \frac{x}{a[i]}$，其中 $a[i]$ 表示第 $i$ 个一号操作中的a。 问经过若干次操作之后 $x$ 的值是多少。 【题解】看上去维护一个数的更改，和线段树没有什么关系，其实把所有的一操作看作一个序列，问题就变成了维护区间乘积，二操作相当于把序列中的某个位置改成 $1$ ，这样就可以用线段树维护单点修改和区间乘积了。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;algorithm&gt;long long mod = 0;struct SegmentTree &#123; int l, r, mid; long long data; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; data = 1; lc = rc = NULL; &#125; void update() &#123; data = (lc-&gt;data % mod * rc-&gt;data % mod) % mod; &#125; void build() &#123; if (this-&gt;r - this-&gt;l == 1) data = 1; else &#123; (lc = new SegmentTree(l, mid))-&gt;build(); (rc = new SegmentTree(mid, r))-&gt;build(); update(); &#125; &#125; void modify(int index, int delta) &#123; if (this-&gt;r - this-&gt;l == 1) data = delta; else &#123; if (index &lt; mid) lc-&gt;modify(index, delta); else rc-&gt;modify(index, delta); update(); &#125; &#125; long long query(int l, int r) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) return data; else &#123; long long ans = 1; if (l &lt; this-&gt;mid) ans = (ans % mod * lc-&gt;query(l, std::min(this-&gt;mid, r)) % mod) % mod; if (r &gt; this-&gt;mid) ans = (ans % mod * rc-&gt;query(std::max(this-&gt;mid, l), r) % mod) % mod; return ans; &#125; &#125;&#125;;void deleteSegTree(SegmentTree *node) &#123; if (node-&gt;lc) deleteSegTree(node-&gt;lc); if (node-&gt;rc) deleteSegTree(node-&gt;rc); node-&gt;~SegmentTree(); delete node; node = NULL;&#125;int main() &#123; int t; scanf("%d", &amp;t); int cnt = 0; while (t--) &#123; int q; scanf("%d%lld", &amp;q, &amp;mod); SegmentTree *root = new SegmentTree(0, q); root-&gt;build(); printf("Case #%d:\n", ++cnt); for (int i = 0; i &lt; q; i++) &#123; int op, x; scanf("%d%d", &amp;op, &amp;x); if (op == 1) root-&gt;modify(i, x); else if (op == 2) root-&gt;modify(x - 1, 1); printf("%d\n", root-&gt;query(0, q)); &#125; deleteSegTree(root); &#125; return 0;&#125; G - HDU 2795 -Billboard - 线段树变形【题目大意】有一个广告牌，有很多人往上贴广告，每个广告占一个单位高度，若干单位长度，广告优先往上边贴，同样高度情况下优先往左边贴，如果没有空间贴，就不贴。 对于每一张广告，询问它被贴在哪一行。 【题解】这题的修改的基本单位是行，以行为单位划分区间，想象把广告牌逆时针旋转九十度，建立线段树。 线段树维护每个区间中剩余空间的最大值，如果我们想贴一张新的海报上去，先与线段树的根节点值比较，如果大于根节点的值，说明所有行都没有空间贴这张新的海报；如果小于，就再与左右节点比较，以此类推，直到找到能贴的位置，注意要先和左子树比较再和右子树比较，因为要求尽量贴得高，旋转之后就是尽量贴得左。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;int ans = -1;struct SegmentTree &#123; static int w; int l, r, mid; int data; int id; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; data = w; id = -1; lc = rc = NULL; &#125; void update() &#123; data = std::max(lc-&gt;data, rc-&gt;data); &#125; void build() &#123; // printf("[%d %d]\n", this-&gt;l, this-&gt;r); if (this-&gt;r - this-&gt;l == 1) &#123; this-&gt;data = SegmentTree::w; this-&gt;id = this-&gt;l + 1; &#125; else &#123; (lc = new SegmentTree(l, mid))-&gt;build(); (rc = new SegmentTree(mid, r))-&gt;build(); update(); &#125; &#125; // int query(int l, int r) &#123; // if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return this-&gt;data; // else &#123; // int ans = INT_MIN; // if (l &lt; mid) ans = std::max(ans, query(l, std::min(r, mid))); // if (r &gt; mid) ans = std::max(ans, query(std::max(l, mid), r)); // return ans; // &#125; // &#125; int modify(int delta) &#123; if (this-&gt;r - this-&gt;l == 1) &#123; this-&gt;data -= delta; // if (ans &lt; this-&gt;id) ans = this-&gt;id; ans = this-&gt;id; return 1; &#125; else &#123; if(lc-&gt;data &gt;= delta) lc-&gt;modify(delta); else if (rc-&gt;data &gt;= delta) rc-&gt;modify(delta); else return -1; update(); return 1; &#125; &#125; void print() &#123; printf("[%d %d], data = %d\n", this-&gt;l, this-&gt;r, this-&gt;data); if (lc) lc-&gt;print(); if (rc) rc-&gt;print(); &#125;&#125;;int SegmentTree::w = 0;void deleteSegTree(SegmentTree *node) &#123; if (node-&gt;lc) deleteSegTree(node-&gt;lc); if (node-&gt;rc) deleteSegTree(node-&gt;rc); node-&gt;~SegmentTree(); delete node; node = NULL;&#125;int main() &#123; int h, w, n; while (scanf("%d%d%d", &amp;h, &amp;w, &amp;n) != EOF) &#123; SegmentTree::w = w; // int m = h; // if (h &gt; n) m = n; if (h &gt; 200000) h = 200000; // printf("m = %d\n", m); SegmentTree *root = new SegmentTree(0, h); // printf("[%d %d]\n", root-&gt;l, root-&gt;r); root-&gt;build(); for (int i = 0; i &lt; n; i++) &#123; int x; scanf("%d", &amp;x); // printf("root-&gt;data = %d\n", root-&gt;data); // root-&gt;print(); if (root-&gt;modify(x) != -1) printf("%d\n", ans); else printf("-1\n"); // root-&gt;print(); &#125; deleteSegTree(root); ans = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 2 - 4]]></title>
    <url>%2F2019%2F08%2F04%2Facmsummer_24%2F</url>
    <content type="text"><![CDATA[第二周限时训练二，题目多为思维题，不全和图论有关 【链接】QDUACM集训队_18级暑假训练第2周_限时训练2]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 2 - 3]]></title>
    <url>%2F2019%2F08%2F01%2Facmsummer_23%2F</url>
    <content type="text"><![CDATA[第二周限时训练一，题目简单且友好，不全和图论有关 【链接】QDUACM集训队_18级暑假训练第2周_限时训练1 D - D1. Add on a Tree题目大意给出一棵树，在这棵树上有这样的操作：选择两个叶节点，将连接他们的路径上的边全部加上某个实数 。 问是否任意的边权都能通过这种方法构造出来。 这棵树不满足条件 这棵树满足条件 题解一开始以为是 LCA 结果是普通的思维题。 代码12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;const int MAXN = 100000 + 10;int degree[MAXN];int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); degree[u]++; degree[v]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (degree[i] == 2) &#123; printf("NO\n"); return 0; &#125; &#125; printf("YES\n"); return 0;&#125; G - B. Letters Shop - 二分查找题目大意给定一个字符串 $S$ ，从中取前缀组合成新的字符串，给出目标字符串，输出最小需要的前缀的长度，数据保证目标串一定可以由 $S$ 的前缀的字符重新组合而成。 题解不关心目标串中字符出现的顺序，只要前缀中相应字符的数目多于目标串中该字符数目即可，先预处理出每个前缀中的每个字母的个数，对于每个目标串，统计其中各个字母的个数，与每个前缀比较，满足条件即可。 朴素的线性比较会TLE，改成二分查找即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 200000 + 10;int a[MAXN][26];int b[26];int main() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; a[0][s[0] - 'a'] = 1; for (int i = 1; i &lt; s.size(); i++) &#123; for (int j = 0; j &lt; 26; j++) a[i][j] = a[i - 1][j]; a[i][s[i] - 'a']++; &#125; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; string s1; cin &gt;&gt; s1; fill(b, b + 26, 0); for (char c: s1) &#123; b[c - 'a']++; &#125; int l = 0, r = s.size(); while (l &lt; r) &#123; int mid = (l + r) / 2; int flag = false; for (int k = 0; k &lt; 26; k++) &#123; if (a[mid][k] &lt; b[k]) &#123; flag = true; l = mid + 1; break; &#125; &#125; if (!flag) r = mid; &#125; cout &lt;&lt; l + 1 &lt;&lt; endl; &#125; return 0;&#125; H - B. Yet Another Crosses Problem - 模拟题目大意给出一些方格图， 现在需要把一些白格子染成黑色，使得图里存在至少一个cross（如pic2）。 问最少染几个白格子。 题解之前在cf上遇到了这题，当时没做出来。 其实很简单，要构成cross必须至少有一整行和一整列都是黑色的，那就把每行每列有多少黑色统计出来，枚举每种行列的组合，找出一个黑色数目最多的，把剩下的染上就行了。 但是有一个问题是，行数和列数的最大值都很大，开二维数组是开不下的。注意到虽然 $n, m$ 都很大，但是 $n \cdot m$ 是不大的，所以用 std::string 数组比较好 深夜果然容易神志不清。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;const int MAXN = 50000 + 10;int row[MAXN], col[MAXN];std::string s[MAXN];int main() &#123; int q; scanf("%d", &amp;q); while (q--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; s[i]; for (char c : s[i]) &#123; if (c == '*') row[i]++; &#125; &#125; for (int j = 0; j &lt; m; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; if (s[i][j] == '*') col[j]++; &#125; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans = std::max(ans, row[i] + col[j] - (s[i][j] == '*')); &#125; &#125; printf("%d\n", n + m - 1 - ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 2 - 1+2]]></title>
    <url>%2F2019%2F07%2F31%2Facmsummer_212%2F</url>
    <content type="text"><![CDATA[基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。 【链接】QDUACM集训队_18级暑假训练第2周_专题训练1 QDUACM集训队_18级暑假训练第2周_专题训练2 新的邻接表写法1234567891011121314151617181920struct Node &#123; std::vector&lt;Edge&gt; edges; int dfn, degree; Node() : dfn(0), degree(0) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;&#125;&#125;;void addEdge(int u, int v) &#123; nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v])); nodes[v].edges.push_back(Edge(&amp;nodes[v], &amp;nodes[u])); nodes[u].degree++; nodes[v].degree++;&#125; 最大的好处是多组数据初始化的时候边的删除很方便，尤其相对于之前的版本来说。 专题一C - Skiing - 最短路F - Sorting It All Out - 拓扑排序专题二D - Caterpillar - DFSE - 昂贵的聘礼 F - 最短路径问题 - 最短路K - Highways L - Truck History]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束系统学习笔记]]></title>
    <url>%2F2019%2F07%2F30%2Fdifference_constraints%2F</url>
    <content type="text"><![CDATA[数学问题转化到图论上解决，有点巧妙。 差分约束系统是一种特殊的 $N$ 元一次不等式组。包含 $N$ 个变量，$M$ 个约束条件，每个约束条件都是以差分的形式给出，形如 $X_i - X_j \leq c_k$。 现在要求 $X_i$ 的一组解，使得所有不等式成立。 对于这样的问题，有一个统一的转化方法： 把不等式表示成 $X_i - X_j \leq c_k$ 的形式， 把每个变量 $X_i$ 看作 有向图 中的一个结点 $i$，把每个约束条件 $X_i - X_j \leq c_k$ 看作从 $i$ 到 $j$ 连一条长度为 $c_k$ 的有向边， 注意到此时建立的图不一定联通，需要添加一个超级源点，从 $0$ 号结点向每个点连一条边权为$0$ 的边。 用 spfa 求出 $0$ 号点到各个点的最短路，如果最短路存在，那么每个点的 dis 值就是原不等式组的一组解。 如果有负环，则解不存在，为了解决负环的问题，只能用 spfa 来求最短路。 为什么这样是对的？看上去毫不相干的不等式怎么和最短路怎么联系起来的呢？其实不知道也没关系 有空就学]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Poj 3169] Layout - 差分约束 + spfa]]></title>
    <url>%2F2019%2F07%2F30%2Fpoj_3169%2F</url>
    <content type="text"><![CDATA[【题目大意】有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。 【题解】遇到这题才去学的差分约束系统。 明显题目中给出了关于两元素差的不等式，是差分约束的模型，转化成标准的模式 $a - b \leq c$，建图之后SPFA求出最短路即可，答案为nodes[n].dis。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 1000 + 10;struct Node;struct Edge;struct Node &#123; std::vector&lt;Edge&gt; edges; int dis, times; bool inQue; Node() : dis(INT_MAX), times(0), inQue(false) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123;&#125;&#125;;void addEdge(int u, int v, int w) &#123; nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v], w));&#125;std::queue&lt;Node*&gt; q;bool spfa(Node *x, int n) &#123; x-&gt;dis = 0; x-&gt;inQue = true; x-&gt;times++; q.push(x); while (!q.empty()) &#123; Node *v = q.front(); v-&gt;inQue = false; q.pop(); for (std::vector&lt;Edge&gt;::iterator it = v-&gt;edges.begin(); it != v-&gt;edges.end(); it++) &#123; if (it-&gt;to-&gt;dis &gt; v-&gt;dis + it-&gt;w) &#123; it-&gt;to-&gt;dis = v-&gt;dis + it-&gt;w; if (!it-&gt;to-&gt;inQue) &#123; it-&gt;to-&gt;inQue = true; it-&gt;to-&gt;times++; if (it-&gt;to-&gt;times &gt; n) return false; q.push(it-&gt;to); &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int n, ml, md; scanf("%d%d%d", &amp;n, &amp;ml, &amp;md); for (int i = 0; i &lt; ml; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if (u &gt; v) std::swap(u, v); addEdge(u, v, w); &#125; for (int i = 0; i &lt; md; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); if (u &lt; v) std::swap(u, v); addEdge(u, v, -w); &#125; // for (int i = 1; i &lt; n; i++) addEdge(i, i + 1, 0); // for (int i = 1; i &lt;= n; i++) addEdge(0, i, 0); if (!spfa(nodes + 1, n)) printf("-1\n"); else &#123; if (nodes[n].dis == INT_MAX) printf("-2"); else printf("%d\n", nodes[n].dis); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 1-4]]></title>
    <url>%2F2019%2F07%2F27%2Facmsummer_14%2F</url>
    <content type="text"><![CDATA[第一周限时训练二 【链接】QDUACM集训队_18级暑假训练第一周复习专题限时训练2]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 1-3]]></title>
    <url>%2F2019%2F07%2F26%2Facmsummer_13%2F</url>
    <content type="text"><![CDATA[第一周限时训练一 【链接】QDUACM集训队_18级暑假训练第一周复习专题限时训练1]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM集训队暑假训练 1-2]]></title>
    <url>%2F2019%2F07%2F25%2Facmsummer_12%2F</url>
    <content type="text"><![CDATA[数学与DP专题二，比较难，不怎么会 【链接】QDUACM集训队_18级暑假训练第一周复习专题 专题训练2 A - Easy Game - 区间DP 题目大意给定一个数组，$A，B$ 两人轮流从数组的开头或结尾取走一个或若干个连续的数，取走的数的和记为得分。现在 $A$ 先开始这个游戏，问在最优情况下 $A$ 比 $B$ 多得多少分 题解看上去像博弈，其实是DP 设状态 $f(l, r)$ 表示在左闭右开区间（取决于具体实现） $[l, r)$ 中取数字，在最优情况下的得分。（不区分$A ,B$）设函数 $sum(l, r)$ 表示开区间 $[l, r)$ 的所有数字的和，用前缀和数组实现。 则转移为: f(l, r) = sum(l ,r) - \min\{minR, minL\} minR = \min_{l \leq i \leq r} \{f(i ,r)\} minL = \min_{l \leq i \leq r} \{f(l, i)\}由于 $A$ 先手，我们可以让 $B$ 的收益最小来使得 $A$ 的收益最大，$minL$ 和 $minR$ 分别表示从左边取和从右边取能留下来的最小 $f$ 值，区间和减去剩下的最小值，就是取走的最大值。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int MAXN = 100 + 10;int a[MAXN], sum[MAXN], f[MAXN][MAXN];inline int getSum(int l, int r) &#123; return sum[r - 1] - sum[l - 1];&#125;int main() &#123; int t; scanf("%d", &amp;t); int cnt = 0; while (t--) &#123; int n; scanf("%d", &amp;n); memset(a, 0, sizeof(a)); memset(sum, 0, sizeof(sum)); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); sum[i] = sum[i - 1] + a[i]; f[i][i + 1] = a[i]; &#125; //[l, r) //[1, n + 1) for (int len = 2; len &lt;= n; len++) &#123; for (int l = 1; l + len &lt;= n + 1; l++) &#123; int r = l + len; int minL = f[l + 1][r]; for (int i = l + 1; i &lt;= r; i++) minL = std::min(minL, f[i][r]); int minR = f[l][r - 1]; for (int i = r - 1; i &gt;= l; i--) minR = std::min(minR, f[l][i]); f[l][r] = getSum(l, r) - std::min(0, std::min(minL, minR)); &#125; &#125; printf("Case %d: %d\n", ++cnt, f[1][n + 1] - sum[n] + f[1][n + 1]); // printf("----------\n"); // for (int i = 1; i &lt;= n; i++) &#123; // for (int j = 2; j &lt;= n + 1; j++) &#123; // printf("%5d ", f[i][j]); // &#125; // printf("\n"); // &#125; &#125; return 0;&#125;// 2// 4// 4 -10 -20 7// 4// 1 2 3 4 B - The Fewest Coins - 混合背包C - String painter - 区间DPD - Max Sum Plus Plus - 区间DPE - Constructing Roads In JGShining’s Kingdom - 最长上升子序列题目大意一些穷国和一些富国分别排在两条直线上，每个穷国和一个富国之间可以建道路，但是路不能交叉，给出每个穷国和富国的联系，求最多能建多少条路 题解把富国编号从大到小排序，问题转化为求最长上升子序列。 朴素的$O(n^2)$的最长上升子序列求法会TLE，需要用优化后的$O(n\log n)$的算法。 简述如下： 舍弃之前的 f 数组，另设立一个数组 d[len] 记录长度为 len 的最长上升子序列的最小结尾。 每次读到一个新的数字，如果这个数字比 d 数组的最后一个元素还要大，说明这个数可以续在 d 数组最后一个元素的后面使最长上升子序变长，此时d[++len] = a[i]。 如果这个数字比d数组的最后一个元素要小，就在 d 数组中找到比这个数小的最大的数，用这个数去更新 d 数组，这一步可以用 std::lower_bound() 完成，这也是复杂度中log的来源。 为什么这这样是对的？ 由于d数组定义为长度为 len 的最长上升子序列的最小结尾，如果想让d数组长度增加，则新元素大小必定增加，所以d数组单调，可以二分。 关于d数组的更新，状态i + 1一定是从状态i转移过来的，此时我们选择一个更小的数作为状态i的值，一定不会比原先的选择更劣，所以这样的更新也是成立的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int MAXN = 500000 + 10;struct Node &#123; int a, b; bool operator&lt;(const Node &amp;a) const &#123; return this-&gt;a &lt; a.a; &#125;&#125; nodes[MAXN];int f[MAXN], ans[MAXN];int main() &#123; int n; int cnt = 0; while (scanf("%d", &amp;n) != EOF) &#123; memset(f, 0, sizeof(f)); memset(ans, 0, sizeof(ans)); for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;nodes[i].a, &amp;nodes[i].b); &#125; std::sort(nodes, nodes + n); int len = 1; ans[0] = nodes[0].b; for (int i = 1; i &lt; n; i++) &#123; if (nodes[i].b &gt; ans[len - 1]) ans[(++len) - 1] = nodes[i].b; else &#123; int pos = std::lower_bound(ans, ans + len, nodes[i].b) - ans; ans[pos] = nodes[i].b; &#125; &#125; // for (int i = 0; i &lt; len; i++) &#123; // printf("%d ", ans[i]); // &#125; // printf("\n"); if (len == 1) printf("Case %d:\nMy king, at most %d road can be built.\n\n", ++cnt, len); else printf("Case %d:\nMy king, at most %d roads can be built.\n\n", ++cnt, len); &#125; return 0;&#125;// 9// 1 2// 2 7// 3 1// 4 5// 5 6// 6 4// 7 3// 8 8// 10 9 F - Farey Sequence - 欧拉函数题目大意给出一个数字 $n$ ，求有多少个有序对 $$ 满足 $0 &lt; a &lt; b \leq n$ $ \gcd(a, b) = 1$ 题解 ans = \sum_{i = 2}^n \varphi(i)先处理出欧拉函数值的数组，直接求和即可 代码12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;const int MAXN = 1000000 + 10;int phi[MAXN];void phiTable(int n) &#123; for (int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!phi[i]) &#123; for (int j = i; j &lt;= n; j += i) &#123; if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main() &#123; int n; phiTable(1000000 + 10); while (scanf("%d", &amp;n) != EOF &amp;&amp; n != 0) &#123; long long sum = 0; for (int i = 2; i &lt;= n; i++) &#123; sum += phi[i]; &#125; //printf("%d\n", 2 * sum + 1); printf("%lld\n", sum); &#125; return 0;&#125; G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧题目大意给定一个数字 $L$ ，求一个最小的每一位都是 $8$ 的 $L$ 的倍数 题解对于一个 $n$ 位的全是 $8$ 的数字 \begin{aligned} 888 \dots 888 &= 8 \times 111 \dots 111 \\ &= 8 \sum_{i = 0}^n 10^i \\ &= 8 \times \frac{10^n - 1}{9} \end{aligned}这个数是 $L$ 的倍数， 有 8(10^n - 1) = k \cdot 9L两边同除 $\gcd(8, L)$，记 $p = \frac{8}{\gcd(8, L)}, q = \frac{k \cdot 9L}{\gcd(8, L)}$，有 p(10^n - 1) = q$p, q$ 互质，两边同时对 $q$ 取模，得 10^n \equiv 1 \pmod q问题转化为求上面这个非线性同余方程的最小正整数解。 由欧拉定理知，当 $10$ 和 $q$ 互质的时候，有 10^{\varphi(q)} \equiv 1 \pmod q当 $10$ 和 $q$ 不互质的时候方程无解 $\varphi(q)$虽然是方程的一个解，但是不一定是最小正整数解，接下来枚举 $\varphi(q)$ 的因数，代入原方程检验是否成立 为什么$\varphi(q)$ 的因数是原方程的解？涉及到阶的概念 设 $m &gt; 1$ ，$\gcd(a, m) = 1$，则使得 $a^r \equiv 1 \pmod m$ 成立的最小正整数 $r_0$ 称为$a$ 对模 $m$ 的阶，记作 $\delta_m(a)$ 若 $m &gt; 1$，$\gcd(a, m) = 1$，$a^n \equiv 1 \pmod m$，则 $\delta_m(a) | n$ 所以原方程就是求阶。 乘法会爆long long 所以使用所谓快速乘法 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;long long gcd(long long a, long long b) &#123; return !b ? a : gcd(b, a % b);&#125;long long phi(long long n) &#123; long long ans = n; long long tmp = n; for (long long i = 2; i * i &lt;= tmp; i++) &#123; if (tmp % i == 0) &#123; ans = ans / i * (i - 1); while (tmp % i == 0) tmp /= i; &#125; &#125; if (tmp &gt; 1) ans = ans / tmp * (tmp - 1); return ans;&#125;// long long fastPowMod(long long a, long long b, long long p) &#123;// long long ans = 1 % p;// for (; b; b &gt;&gt;= 1) &#123;// if (b &amp; 1) ans = (ans % p * a % p) % p;// a = (a % p * a % p) % p;// &#125;// return ans;// &#125;long long Mul(long long a,long long b,long long m)&#123; long long ans = 0; while (b) &#123; if(b &amp; 1)&#123; ans = (ans + a) % m; b--; &#125; b &gt;&gt;= 1; a = (a + a) % m; &#125; return ans;&#125;long long fastPowMod(long long a, long long b, long long m)&#123; long long ans = 1; a %= m; while(b)&#123; if(b &amp; 1) &#123; ans = Mul(ans, a, m); b--; &#125; b &gt;&gt;= 1; a = Mul(a, a, m); &#125; return ans;&#125;std::vector&lt;long long&gt; v;int main() &#123; long long x; int cnt = 0; while (scanf("%lld", &amp;x) != EOF &amp;&amp; x != 0) &#123; printf("Case %d: ", ++cnt); long long p = 9 * x / gcd(8, x); if (gcd(10, p) != 1) printf("0\n"); else &#123; long long m = phi(p); v.clear(); for (long long i = 1; i * i &lt;= m; i++) &#123; if (m % i == 0) &#123; v.push_back(i); if (i * i != m) v.push_back(m / i); &#125; &#125; std::sort(v.begin(), v.end()); for (int i = 0; i &lt; v.size(); i++) &#123; if (fastPowMod(10, v[i], p) == 1) &#123; printf("%lld\n", v[i]); break; &#125; &#125; &#125; &#125; return 0;&#125; H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂题目大意设 y = (5 + 2\sqrt6)^{1+2^x} , 0 \leq x \leq 2^{32}给定 $x$ 和 $M$，求 [y] \% m题解看到这个式子，明显不能直接计算，先不管指数过大的问题，考虑如何求 a_n = (5 + 2\sqrt6)^n先写出前几项看一看 a_1 = 5 + 2\sqrt6 \\ a_2 = (5+2\sqrt6)^2 = 25 + 24 + 20\sqrt6 = 49 + 20\sqrt6 \\ a_3 = (5+2\sqrt6)^2 = (49 + 20\sqrt6) \times (5 + 2\sqrt6) = 585 + 198\sqrt6发现只是系数变了，不妨设 a_n =x_n + y_n \sqrt 6则 \begin{align} a_{n+1} &= (x_n + y_n \sqrt 6) \cdot (5 + 2\sqrt6) \\ &= 5x_n + 12y_n + (2x_n + 5y_n)\sqrt6 \\ &= x_{n+1} + y_{n+1}\sqrt6 \end{align}所以 \begin{equation} \begin{cases} x_{n+1} = 5x_n + 12y_n \\[2ex] y_{n+1} = 2x_n + 5y_n \end{cases} \end{equation}写成矩阵的形式 \begin{bmatrix} 5 & 12 \\ 2 & 5 \end{bmatrix} \begin{bmatrix} x_n\\ y_n \end{bmatrix} = \begin{bmatrix} x_{n+1}\\ y_{n+1} \end{bmatrix}现在我们就可以用矩阵快速幂快速计算系数了。 解决了底数计算，再来看指数上的$1 + 2^x$，这个东西非常大，所以需要用一些手段来降幂，对于整数的大幂计算，可以利用指数循环节用欧拉函数降幂，即 A^B \mod C = A^{B \mod \varphi(C) + \varphi(C)} \mod C但是对于矩阵是不能这样搞的，需要找到矩阵的循环节(广义斐波那契数列循环节)，对于寻找的方法，暂时超出了我的能力范围，暂记结论 广义斐波那契数列的循环节为 $p + 1$ 或 $(p+1) \cdot (p-1)$ 这样就可以在用快速幂计算指数的时候把模数设为循环节达到降幂的目的。 这样底数和指数的问题就解决了，先降幂算出指数之后，矩阵快速幂算出底数两项的系数，带入公式计算然后取整即可。 注意降幂时的模数和矩阵快速幂的模数不是同一个。 这题比较难，但是也有套路的东西在里面。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;int MOD = 0;struct Matrix &#123; long long a[10][10]; int sizeX, sizeY; Matrix(int sizeX = 0, int sizeY = 0) : sizeX(sizeX), sizeY(sizeY) &#123; memset(a, 0, sizeof(a)); &#125; Matrix operator*(const Matrix &amp;a) const &#123; Matrix ans(sizeX, a.sizeY); for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; a.sizeY; j++) &#123; for (int k = 0; k &lt; sizeY; k++) &#123; ans.a[i][j] += (this-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD; ans.a[i][j] %= MOD; &#125; &#125; &#125; return ans; &#125; void operator=(const Matrix &amp;a) &#123; for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; sizeY; j++) &#123; this-&gt;a[i][j] = a.a[i][j]; &#125; &#125; &#125; void print() &#123; for (int i = 0; i &lt; sizeX; i++) &#123; printf("["); for (int j = 0; j &lt; sizeY; j++) &#123; printf("%lld ", a[i][j]); &#125; printf("]\n"); &#125; &#125;&#125;;Matrix fastPowMod(Matrix m, int n) &#123; if (n == 1) return m; else if (n &amp; 1) return fastPowMod(m, n - 1) * m; else return fastPowMod(m * m, n &gt;&gt; 1);&#125;long long fastPowMod(long long a, long long b, long long p) &#123; long long ans = 1 % p; for ( ; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = (ans % p * a % p) % p; a = (a % p * a % p) % p; &#125; return ans;&#125;long long phi(long long n) &#123; long long ans = n; long long tmp = n; for (long long i = 2; i * i &lt;= tmp; i++) &#123; if (tmp % i == 0) &#123; ans = ans / i * (i - 1); while (tmp % i == 0) tmp /= i; &#125; &#125; if (tmp &gt; 1) ans = ans / tmp * (tmp - 1); return ans;&#125;int main() &#123; int t; scanf("%d", &amp;t); int cnt = 0; while (t--) &#123; long long x; scanf("%lld", &amp;x); scanf("%d", &amp;MOD); Matrix shift(2, 2); shift.a[0][0] = 5; shift.a[0][1] = 12; shift.a[1][0] = 2; shift.a[1][1] = 5; Matrix ans(2, 1); ans.a[0][0] = 5; ans.a[1][0] = 2; // int p = phi(MOD); // long long b = (fastPowMod(2, x, p) + 1 + p) % p; long long b = fastPowMod(2, x, MOD * MOD - 1) + 1; // printf("p = %d, b = %lld\n", p, b); // Matrix tmp = fastPowMod(shift, b - 1); // ans = tmp * ans; ans = fastPowMod(shift, b - 1) * ans; // printf("Case #%d: %d\n", ++cnt, (int)(ans.a[0][0] + ans.a[1][0] * sqrt(6)) % MOD); printf("Case #%d: %lld\n", ++cnt, (long long)(2 * ans.a[0][0] % MOD - 1) % MOD); &#125; return 0;&#125; K - Queries for Number of Palindromes - 区间DP题目大意给定一个字符串，求其回文子串的个数。 题解比较典型的区间DP题目 设状态 $f(l, r)$ 表示左闭右开区间 $[l, r)$ 中的回文子串个数，isP[l, r]数组表示在区间$[l ,r)$中的字符串是否为回文串。 则转移为 f(l, r) = f(l + 1, r) + f(l, r - 1) - f(l + 1, r - 1) + \text{isP}[l, r]区间的计数问题常常这样解决。好像有点容斥的感觉？记得预处理isP数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 5000 + 10;char s[MAXN];int f[MAXN][MAXN];bool isP[MAXN][MAXN];int main() &#123; scanf("%s", s + 1); int len = strlen(s + 1); for (int i = 1; i &lt;= len + 1; i++) &#123; f[i][i + 1] = 1; isP[i][i + 1] = isP[i][i] = true; &#125; for (int l = 2; l &lt;= len; l++) &#123; for (int i = 1; i + l &lt;= len + 1; i++) &#123; int j = i + l; isP[i][j] = (isP[i + 1][j - 1] &amp;&amp; s[i] == s[j - 1]); &#125; &#125; for (int l = 2; l &lt;= len; l++) &#123; for (int i = 1; i + l &lt;= len + 1; i++) &#123; int j = i + l; f[i][j] = f[i][j - 1] + f[i + 1][j] - f[i + 1][j - 1] + isP[i][j]; &#125; &#125; int q; scanf("%d", &amp;q); while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", f[l][r + 1]); &#125; return 0;&#125; L - Diophantus of Alexandria题目大意题解]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leading and Trailing - 对数 + 快速幂]]></title>
    <url>%2F2019%2F07%2F21%2FLat%2F</url>
    <content type="text"><![CDATA[QDU2019暑期集训第一周数学部分 【链接】 Leading and Trailing 【题目描述】You are given two integers: $n$ and $k$, your task is to find the most significant three digits, and least significant three digits of $n^k$. 给定$n$和$k$，求$n^k$的前三位数字和后三位数字。 【题解】后三位数字直接用快速幂对$1000$取模即可。 前三位数字的做法比较巧妙。 设 $10^p = n^k$ ，两边同取对数 $p = k\lg n$ ，$p$ 是一个浮点数，整数部分为$[p]$, 记为 $x$ ; 小数部分为 $p - [p]$， 记为$y$ 。有$10^p = 10^{x + y} = 10^x \cdot 10^y = n^k$ 这样就把 $n^k$ 转化为了科学记数法表示，$10^y &lt; 1$ ，所以要求的前三位就是 $10^y \cdot 10^3 = 10^{y+3}$。 最后三位前面不足的位置补$0$。 【代码】1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MOD = 1000;int fastPowMod(int a, int b) &#123; int ans = 1 % MOD; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = (long long)ans * a % MOD; a = (long long)a * a % MOD; &#125; return ans;&#125;int main() &#123; int t; scanf("%d", &amp;t); for (int cnt = 1; cnt &lt;= t; cnt++) &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); double p = k * log10(n); int x = (int)p; double y = p - x; printf("Case %d: %d %03d\n", cnt, (int)pow(10.0, y + 2), fastPowMod(n, k)); //if (cnt &lt; t) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得算法学习笔记]]></title>
    <url>%2F2019%2F07%2F21%2Fexgcd_learn%2F</url>
    <content type="text"><![CDATA[扩展欧几里得算法能在计算$\gcd(a,b)$ 的同时求解方程$ax + by = \gcd(a, b)$的一组特解。 是为欧几里得算法之扩展。 Bézout’s identity（裴蜀定理） 对于任意整数$a, b$，存在一对整数 $x, y$ 满足$ax + by = \gcd(a, b)$ 使用（类似）数学归纳法证明： 当 $b = 0$ 时，有$x = 1, y = 0$ 使得等式成立，即有 $a \times 1 + b \times 0 = \gcd(a, 0) = a$ 当 $b&gt;0$ 时，假设存在 $x, y$ 使得等式成立，即 ax + by = \gcd(a, b) = \gcd(b, a \% b) = bx + (a \% b)y 又由取模运算的定义 a \% b = a - b \lfloor \frac{a}{b} \rfloor可知 \begin{equation} \begin{aligned} \gcd(a, b) &= bx + ay - b \lfloor \frac{a}{b} \rfloor y \\ &= ay + b(x - b \lfloor \frac{a}{b} \rfloor y) \end{aligned} \end{equation}令 $x’ = y, y’ = x - b \lfloor \frac{a}{b} \rfloor y$ 可得 $ax’ + by’ = gcd(a, b)$ 即 $bx + (a \% b)y = \gcd(a, b)$ 有解 这里的 $a, b$ 在交换一次之后变小了，这样一直递归下去就会到达 $b = 0$ 的边界，所以解一定存在 扩展欧几里德算法1234567int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123;x = 1, y = 0; return a;&#125; int d = exgcd(b, a % b, x, y); int z = x; x = y; y = z - y * (a / b); return d;&#125; 上面的代码求出了$ax + by = \gcd(a, b)$，返回了$\gcd(a, b)$。 对于一般的线性方程$ax + by = c$，当且仅当$\gcd(a, b) | c$ 时存在非负整数解，此时先用扩展欧几里得算法求出$ax + by = \gcd(a, b)$ 的一组特解 $x_0, y_0$ 再等式两边同时乘以$\frac{c}{\gcd(a,b)}$ 即可求得原方程的一组特解 $x_0 \frac{c}{\gcd(a, b)}, y_0 \frac{c}{\gcd(a, b)}$ 而原方程的通解表示为 \begin{aligned} x &= x_0 \frac{c}{\gcd(a, b)} + k \frac{b}{\gcd(a, b)} \\ y &= y_0 \frac{c}{\gcd(a, b)} + k \frac{a}{\gcd(a, b)} \end{aligned}其中 $k$ 可以取遍全体整数 线性同余方程线性同余方程是指形如 $ax \equiv b \pmod m$ 的方程，因为未知数为的次数为一，故称之为线性同余方程。 扩展欧几里得算法的应用之一就是求解线性同余方程。 同余可以理解为模等于，也就是 $ax$ 模 $m$ 等于 $b$ ，所以原方程表示 $ax-b$ 是 $m$ 的倍数，不妨设为 $-y$ 倍，则原方程转化为 $ax - b = -ym$ 即 $ax + my = b$ 。 这样的方程我们可以用扩展欧几里得算法进行求解，当且仅当 $\gcd(a, m) | b$ 时，方程有解，易得原线性同余方程方程的特解为 $x = x_0 \frac{b}{\gcd(a, m)}$ 逆元特殊地，当 $ax \equiv 1 \pmod m$ 时， $x$ 被称为 $a$ 在模 $m$ 意义下的逆元，可以套用上面的方法求出，要求$\gcd(x, m) = 1$]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU 1576] A/B - 乘法逆元+费马小定理/扩展欧几里得]]></title>
    <url>%2F2019%2F07%2F21%2Fhdu_1576%2F</url>
    <content type="text"><![CDATA[QDU2019暑期集训第一周数学部分 【链接】HDU 1576 A/B 【题目描述】要求$(A / B)\%9973$，但由于$A$很大，我们只给出$n(n = A \% 9973)$(我们给定的$A$必能被$B$整除，且$\gcd(B, 9973) = 1)$。 【题解】$(A / B)\%9973 = (AB^{-1}) \% 9973 = (A \% 9973 \cdot B^{-1} \%9973) \%9973 = (n \cdot B^{-1} \%9973) \%9973$ 问题转化为求$B^{-1}$ 可用费马小定理或者扩展欧几里得算法求解。 ​ 【代码】1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MOD = 9973;int fastPowMod(int a, int b) &#123; int ans = 1 % MOD; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = (long long)ans * a % MOD; a = (long long)a * a % MOD; &#125; return ans;&#125;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, b; scanf("%d%d", &amp;n, &amp;b); b = fastPowMod(b, MOD - 2); printf("%d\n", (n % MOD * b % MOD) % MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 1477] 青蛙的约会 - 扩展欧几里得]]></title>
    <url>%2F2019%2F07%2F21%2Fbzoj_1477%2F</url>
    <content type="text"><![CDATA[QDU2019暑期集训第一周数学部分 【链接】bzoj 1477 青蛙的约会 【题目描述】两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 $A$ 的出发点坐标是 $x$，青蛙 $B$ 的出发点坐标是 $y$。青蛙 $A$ 一次能跳 $m$ 米，青蛙 $B$ 一次能跳$n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。 【题解】青蛙$A$: $(x + km) \% L$ 青蛙$B$: $(y + kn)\%L$ 问题转化为$(x + km) \% L = (y + kn)\%L$ 展开得线性同余方程$k(m-n) \equiv y-x \pmod L$ 其中 $m-n$ 和 $ y-x $ 都是已知的常数，利用扩展欧几里得算法求出 $k$ 即可。 需要注意的是$(m-n)$一定要是正的，如果算出来是负的，等号两边同乘以负一。 最后 $k$ 也应该也是正的，如果算出来是负的，加上$\frac{b}{d}$就好。 记得用long long 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;int gcd(int a, int b) &#123; return !b ? a : gcd(b, a % b);&#125;int exgcd(int a, int b, long long &amp;x, long long &amp;y) &#123; if (b == 0) &#123;x = 1; y = 0; return a;&#125; int d = exgcd(b, a % b, x, y); int z = x; x = y; y = z - y * (a / b); return d;&#125;int main() &#123; int x, y, m, n, l; scanf("%d%d%d%d%d", &amp;x, &amp;y, &amp;m, &amp;n, &amp;l); int a = m - n; int b = l; int c = y - x; if (a &lt; 0) &#123; a = -a; c = -c; &#125; //printf("a = %d, b = %d, c = %d\n", a, b, c); //solve ax + cy = b; int d = gcd(a, b); //printf("d = %d\n", d); if (c % d != 0) printf("Impossible\n"); else &#123; long long x0 = 0, y0 = 0; d = exgcd(a, b, x0, y0); long long x = x0 * c / d; long long t = b / d; if (x &gt;= 0) x %= t; else x = x % t + t; printf("%lld\n", x); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三分法学习笔记]]></title>
    <url>%2F2019%2F07%2F03%2Fdivide3%2F</url>
    <content type="text"><![CDATA[三分法是一种求解单峰函数极值的算法 【简介】所谓单峰函数，如图所示，三分法可以求出这样的函数的极值。 【算法】 确定极值点所在的区间 取区间的中点 mid 在中点左右各一个小距离中分别取midL midR，这两个点将整个区间三分 计算出midL midR的函数值 若f(midL) 比较大，则舍弃右边的部分，将区间右端点设置为mid 若f(midR)比较大，则舍弃左边的部分，将区间左端点设置为mid 重复上述过程直至区间大小小于某个设定好的EPS 【模板】洛谷P3382 【模板】三分法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MAXN = 15;const double EPS = 1e-7;double a[MAXN];// double func(double a[], int n, double x) &#123;// double ret = 0;// double b = 1;// for (int i = n; i &gt;= 0; i--) &#123;// ret += (b * a[i]);// b *= x;// &#125;// return ret;// &#125;double func(double a[], int n, double x) &#123; double sum = 0; for (int i = n; i &gt;= 0; i--) &#123; sum = sum * x + a[i]; &#125; return sum; &#125;int main() &#123; int n; scanf("%d", &amp;n); double l, r; scanf("%lf%lf", &amp;l, &amp;r); for (int i = n; i &gt;= 0; i--) &#123; scanf("%lf", &amp;a[i]); &#125; while (fabs(r - l) &gt;= EPS) &#123; double mid = (l + r) / 2; // double midL = (l + r) / 3; // double midR = midL * 2; double midL = mid - EPS; double midR = mid + EPS; if (func(a, n, midL) &lt; func(a, n, midR)) l = mid; else r = mid; &#125; printf("%.5lf\n", l); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[QDUoj 582] 嘉馨学姐吃包子 - 三分]]></title>
    <url>%2F2019%2F07%2F03%2Fqduoj582%2F</url>
    <content type="text"><![CDATA[【链接】嘉馨学姐吃包子 【题目描述】嘉馨学姐非常爱吃包子，但是嘉馨学姐这个人很懒，她总是希望包子可以自己飞到她的嘴里，现在有 $n(n \leq 100000)$ 个包子，告诉你每个包子的位置 $p_i(|p_i| \leq 10^6)$ 和重量$w_i(1 &lt; w_i \leq 10)$。 已知包子飞行时，包子的口感度会降低，如果一个包子飞行了$x$，那这个包子的口感度会降低$x^3 \times w$。嘉馨学姐的初始位置由你来决定，要求尽量使所有包子降低的口感度总和$F$最小。 【题解】设起点为$x$，则每个包子移动的距离为$|p_i - x|$，那么降低的口感总和为 f(x) = \sum_{i = 0}^n (|p_i - x|)^3 \times w_i三分这个函数求出最值即可。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MAXN = 100000 + 10;const double EPS = 1e-5;double p[MAXN], w[MAXN];double func(int n, double x) &#123; double ret = 0; for (int i = 0; i &lt; n; i++) &#123; ret += (pow(fabs(p[i] - x), 3) * w[i]); &#125; return ret;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;p[i], &amp;w[i]); &#125; double l = -1e6; double r = 1e6; while (fabs(r - l) &gt;= EPS) &#123; double mid = (l + r) / 2; double midL = mid - EPS; double midR = mid + EPS; if (func(n, midL) &gt; func(n, midR)) l = mid; else r = mid; &#125; printf("%.0lf\n", func(n, l) / 10); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[蓝桥杯 2013] 幸运数 - 构造]]></title>
    <url>%2F2019%2F05%2F21%2Flq2013_1%2F</url>
    <content type="text"><![CDATA[【链接】历届试题 幸运数 【题目描述】幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成 首先从1开始写出自然数 $1,2,3,4,5,6, \dots$ $1$ 就是第一个幸运数。 我们从2这个数开始。把所有序号能被2整除的项删除，变为： 1, 3, 5, 7, 9 \dots这时，$3$ 为第 $2$ 个幸运数，然后把所有能被 $3$ 整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被$3$ 整除!! 删除的应该是 $5, 11, 17,\dots$ 此时$7$为第$3$个幸运数，然后再删去序号位置能被$7$整除的$(19, 39, …)$ 最后剩下的序列类似： 1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, \dots 【题解】关键点在于如何构造出题目中要求的数列。 没有必要每次删除再移位再删除，发现前面没有被删除的数在后续的操作中也不会被删除 所以只需要找出当前这轮不会被删除的数填到数组中，下一轮参考的元素变成下一个，重复这样的过程。 只需要生成到$m$为止即可。 【代码】12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;const int MAXN = 1000000 + 10;int a[MAXN];int n, m;void dfs(int x) &#123; if (x &gt; m) return; else &#123; int cnt = x; for (int i = cnt; i &lt; m; i++) &#123; if (i % a[x] != 0) a[cnt++] = a[i]; &#125; dfs(x + 1); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; a[i] = (i * 2) - 1; &#125; dfs(2); int ans = 0; for (int i = 1; ; i++) &#123; if (a[i] &gt; m) break; if (a[i] &gt; n) ans++; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【5.13】2019一起开心蓝桥国赛训练]]></title>
    <url>%2F2019%2F05%2F14%2F5132109%2F</url>
    <content type="text"><![CDATA[【链接】【5.13】2019一起开心蓝桥国赛训练 树状数组 线段树 SPFA 桥 欧拉回路/函数 数学 SG博弈 密码：bullet A - hdu4738 - Caocao’s Bridges - Tajan求桥【题解】双联通分量的模板题。 求出所有桥中边权最小的那个。 Tarjan算法求桥和求割点/强连通分量的算法类似，都用到了low和dfn两个标记。 由于一个环中的点dfn值都是相同的，如果有一个点的dfn大于它的父亲节点，那连接这两个点的边一定是一个桥。 参看Tarjan强连通分量学习笔记 这题有几个坑: 图可能不连通 图里可能有重边 如果边权最小的为$0$，答案应该是$1$，因为总要派一个人去爆破（题意）。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 1000 + 10;int haveEdge[MAXN][MAXN];struct Node;struct Edge;struct Node &#123; int dfn, low; bool vis; Node *fa; Edge *edges; Node() : dfn(0), low(0), vis(false), fa(NULL), edges(NULL) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(u, v, w); v-&gt;edges = new Edge(v, u, w);&#125;void init(int n) &#123; memset(haveEdge, 0, sizeof(haveEdge)); for (int i = 1; i &lt;= n; i++) &#123; nodes[i].dfn = 0; nodes[i].low = 0; nodes[i].vis = false; delete nodes[i].edges; nodes[i].edges = NULL; nodes[i].fa = NULL; &#125;&#125;void tarjan(Node *x) &#123; static int cnt = 0; x-&gt;dfn = x-&gt;low = ++cnt; for (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123; if (e-&gt;to == x-&gt;fa) continue; if (!e-&gt;to-&gt;fa) &#123; e-&gt;to-&gt;fa = x; tarjan(e-&gt;to); x-&gt;low = std::min(x-&gt;low, e-&gt;to-&gt;low); &#125; else &#123; x-&gt;low = std::min(x-&gt;low, e-&gt;to-&gt;low); &#125; &#125;&#125;int min = INT_MAX;int num = 0;void dfs(Node *x) &#123; if (!x-&gt;vis) num++; x-&gt;vis = true; for (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123; if (x-&gt;fa &amp;&amp; e-&gt;to == x-&gt;fa || e-&gt;to-&gt;vis) continue; else &#123; if (haveEdge[e-&gt;fr - nodes][e-&gt;to - nodes] == 1 &amp;&amp; e-&gt;to-&gt;low &gt; x-&gt;low) min = std::min(min, e-&gt;w); dfs(e-&gt;to); &#125; &#125;&#125;int main() &#123; int n, m; while (scanf("%d%d", &amp;n, &amp;m) != EOF &amp;&amp; n != 0 &amp;&amp; m != 0) &#123; init(n); num = 0; min = INT_MAX; for (int i = 0; i &lt; m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(nodes + u, nodes + v, w); haveEdge[u][v]++; haveEdge[v][u]++; &#125; tarjan(nodes + 1); dfs(nodes + 1); if (min == 0) printf("1\n"); else if (num != n) printf("0\n"); else if (min == INT_MAX) printf("-1\n"); else printf("%d\n", min); &#125; return 0;&#125; B - POJ 3245 - Wormholes - SPFA判负环【题解】裸的SPFA判负环，条件是存在某一个节点入队次数大于$n$(节点总数)。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//SPFA判负环#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;climits&gt;const int MAXN = 500 + 10;struct Node;struct Edge;struct Node &#123; Edge *edges; int dis; bool inQue; int cnt; Node() : edges(NULL), dis(INT_MAX), inQue(false), cnt(0) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(u, v, w);&#125;bool spfa(Node *x, int n) &#123; std::queue&lt;Node*&gt; q; x-&gt;dis = 0; x-&gt;inQue = true; x-&gt;cnt++; q.push(x); while (!q.empty()) &#123; Node *v = q.front(); q.pop(); v-&gt;inQue = false; for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123; e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w; if (!e-&gt;to-&gt;inQue) &#123; e-&gt;to-&gt;inQue = true; e-&gt;to-&gt;cnt++; if (e-&gt;to-&gt;cnt &gt; n) return true; q.push(e-&gt;to); &#125; &#125; &#125; &#125; return false;&#125;void init(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; nodes[i].dis = INT_MAX; nodes[i].inQue = false; delete nodes[i].edges; nodes[i].edges = NULL; nodes[i].cnt = 0; &#125;&#125;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, m, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;w); init(n); for (int i = 0; i &lt; m + w; i++) &#123; int s, e, t; scanf("%d%d%d", &amp;s, &amp;e, &amp;t); s--; e--; if (i &lt; m) &#123; addEdge(nodes + s, nodes + e, t); addEdge(nodes + e, nodes + s, t); &#125; else &#123; addEdge(nodes + s, nodes + e, -t); &#125; &#125; if (spfa(nodes, n)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; C - POJ 3468 - A Simple Problem with Integers - 线段树【题解】用线段树维护区间和，支持区间修改和区间查询。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//线段树区间加 区间和#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int MAXN = 100000 + 10;long long a[MAXN];struct SegmentTree &#123; long long sum; int l, r, mid; SegmentTree *lc, *rc; long long lazy; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; sum = lazy = 0; lc = rc = NULL; &#125; void update() &#123;sum = lc-&gt;sum + rc-&gt;sum;&#125; void build() &#123; if (r - l == 1) sum = a[l]; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void addTag(long long tag) &#123; lazy += tag; sum += (r - l) * tag; &#125; void pushDown() &#123; if (lazy) &#123; lc-&gt;addTag(lazy); rc-&gt;addTag(lazy); lazy = 0; &#125; &#125; long long query(int l, int r) &#123; long long ans = 0; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) return sum; else &#123; pushDown(); if (l &lt; this-&gt;mid) ans += lc-&gt;query(l, std::min(this-&gt;mid, r)); if (r &gt; this-&gt;mid) ans += rc-&gt;query(std::max(this-&gt;mid, l), r); return ans; &#125; &#125; void modify(int l, int r, int delta) &#123; if (this-&gt;l == l &amp;&amp; this-&gt;r == r) addTag(delta); else &#123; pushDown(); if (l &lt; this-&gt;mid) lc-&gt;modify(l, std::min(this-&gt;mid, r), delta); if (r &gt; this-&gt;mid) rc-&gt;modify(std::max(l, this-&gt;mid), r, delta); update(); &#125; &#125;&#125;;int main() &#123; std::ios::sync_with_stdio(false); int n, q; std::cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; a[i]; &#125; SegmentTree *root = new SegmentTree(0, n); root-&gt;build(); for (int i = 0; i &lt; q; i++) &#123; char op; int l, r; std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; l--; r--; if (op == 'Q') std::cout &lt;&lt; root-&gt;query(l, r + 1) &lt;&lt; std::endl; else if (op == 'C') &#123; int del; std::cin &gt;&gt; del; root-&gt;modify(l, r + 1, del); &#125; &#125; return 0;&#125; D - HDU 1166 - 敌兵布阵 - 树状数组/线段树【题解】用线段树/树状数组维护区间和，支持单点修改区间查询，树状数组代码量相对较少。 注意用树状数组查询区间$[l, r]$的区间和要写成query(r) - query(l - 1) 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//线段树（树状数组）单点修改前缀求和#include &lt;iostream&gt;const int MAXN = 50000 + 10;struct Bit &#123; int a[MAXN]; int n; void init(int n) &#123; this-&gt;n = n; for (int i = 1; i &lt;= n; i++) a[i] = 0; &#125; int lowbit(int x) &#123;return x &amp; -x;&#125; void modify(int index, int delta) &#123; while (index &lt;= n) &#123; a[index] += delta; index += lowbit(index); &#125; &#125; long long query(int index) &#123; int ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowbit(index); &#125; return ans; &#125;&#125; bit;int main() &#123; std::ios::sync_with_stdio(false); int t; std::cin &gt;&gt; t; int cnt = 0; while (t--) &#123; int n; std::cin &gt;&gt; n; bit.init(n); for (int i = 1; i &lt;= n; i++) &#123; int x; std::cin &gt;&gt; x; bit.modify(i, x); &#125; std::cout &lt;&lt; "Case " &lt;&lt; ++cnt &lt;&lt; ":" &lt;&lt; std::endl; while (true) &#123; std::string s; std::cin &gt;&gt; s; if (s == "End") break; else &#123; int a, b; std::cin &gt;&gt; a &gt;&gt; b; if (s == "Add") &#123; bit.modify(a, b); &#125; else if (s == "Query") &#123; std::cout &lt;&lt; bit.query(b) - bit.query(a - 1) &lt;&lt; std::endl; &#125; else if (s == "Sub") &#123; bit.modify(a, -b); &#125; &#125; &#125; &#125; return 0;&#125; E - POJ 2230 - Watchcow - 欧拉回路【题解】欧拉回路模板题，用dfs求欧拉回路。其中不允许同向走两次的要求用对边打标记实现，由于加边时加的是两条方向相反的边，走的时候给其中一条标记上之后，相反方向的那条还是可以走的。 由于不确定的原因，TLE，大概是指针邻接表的锅。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;vector&gt;const int MAXN = 10000 + 10;struct Node;struct Edge;struct Node &#123; Edge *edges; Node() : edges(NULL) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; Edge *next; bool vis; Edge(Node *fr, Node *to) : fr(fr), to(to), vis(false) &#123; next = fr-&gt;edges; &#125;&#125;;void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v); v-&gt;edges = new Edge(v, u);&#125;int ans[10 * MAXN];int cnt = 0;void dfs(Node *x) &#123; for (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123; if (!(e-&gt;vis)) &#123; e-&gt;vis = true; dfs(e-&gt;to); ans[cnt++] = (e-&gt;to) - nodes; &#125; &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(nodes + u, nodes + v); &#125; dfs(nodes + 1); for (int i = 0; i &lt; cnt; i++) &#123; printf("%d\n", ans[i]); &#125; printf("1\n"); return 0;&#125; F - POJ 3090 - Visible Lattice Points - 欧拉函数【题解】知道欧拉函数的提示就好做了，画图找规律可以得到 ans = 2 \sum_{i = 2}^n \varphi(i) + 3$\varphi(x)$是欧拉函数，表示小于等于$x$的与$x$互质的数的个数。 关于欧拉函数可以看【数学】- 容斥原理学习笔记 可是为什么是欧拉函数？ 首先发现上三角和下三角是对称的，所以只需要考虑一半。 易知$(1, 0), (0, 1), (1, 1)$是一定可见的，所以只需要考虑剩下的点。 如果某个点被挡住了，那在它之前一定有一个点和它共线，这里有点相似三角形的感觉，相当于两个直角边同时放大若干倍，也就是说，如果这个点的横纵坐标有公共因子，那么一定可以同时除以这个因子使得沿着这条线向$(0, 0)$方向移动，移动到不能动之后横纵坐标就互质了，所以对于每一个$x$只要求出小于等于它的（只考虑下三角）与它互质的数的个数即可。也就是$\varphi(x)$。 【代码】123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;int phi(int n) &#123; int ans = n; int tmp = n; for (int i = 2; i * i &lt;= tmp; i++) &#123; if (tmp % i == 0) &#123; ans = ans / i * (i - 1); while (tmp % i == 0) tmp /= i; &#125; &#125; if (tmp &gt; 1) ans = ans / tmp * (tmp - 1); return ans;&#125;int main() &#123; int c; scanf("%d", &amp;c); int cnt = 0; while (c--) &#123; cnt++; int n; scanf("%d", &amp;n); int tmp = 0; for (int i = 2; i &lt;= n; i++) &#123; int a = phi(i); // printf("phi(%d) = %d\n", i, a); tmp += a; &#125; printf("%d %d %d\n", cnt, n, tmp * 2 + 3); &#125; return 0;&#125; G - POJ 1845 - Sumdiv - 数学H - POJ 2311 - Cutting Game - 博弈 + SG函数]]></content>
      <categories>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记（三）- 内联函数 / Lambda表达式]]></title>
    <url>%2F2019%2F04%2F15%2Fcpp3%2F</url>
    <content type="text"><![CDATA[上课时的随手笔记，供期末复习用。 内联函数普通的函数123int add(int x, int y) &#123; return x + y;&#125; 在调用这个函数的时候，不是简单的跳转，要先把main()函数里面的变量”保护起来”，再跳到add()函数的位置，重新分配变量，进行运算（此时main()里面的变量不能被修改），然后返回值。 这样的过程虽然不慢，但也要花时间，如果函数比较短小，同一个函数的多次调用在跳转上花费的时间可能会比执行花费的还要长。 所以我们有了内联函数 内联函数123inline int add(int a, int b) &#123; return a + b;&#125; 这样的函数会由编译器直接原地展开，例如上面的函数int x = add(a, b)就相当于int x = a + b，这样就有了更好的执行效率。 好处显而易见，不用手动复制代码，也提升了执行效率。 同样也存在缺点，代码被多次复制，增加了代码量，占用更多的内存空间。 有些函数即使声明为内联的也不一定会被编译器内联, 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数) Lambda 表达式(C++11)1auto f = [](int x, int y) &#123;return x + y;&#125; (3, 5); Lambda表达式可以看作是一个匿名函数（但是实际上是个表达式） 语法语法定义如下:1[capture](parameters) mutable -&gt;return_type &#123;statement&#125; [capture]是捕捉列表，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，如果不需要可以只写中括号(捕捉列表为空) (parameters)是参数列表，就像普通函数一样，如果不需要传参数，则可以省略 mutable是一个修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空） -&gt;return-type表明了Lambda表达式的返回类型 {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量 捕捉列表中可以指定捕捉何种类型的变量 [&amp;var_name] 以传引用的方式捕获var_name这个变量（需要修改外部变量时） [var_name] 以传值的方式捕获var_name这个变量 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main() &#123; int sum = 0; auto f = [sum](int x, int y) mutable &#123; cout &lt;&lt; "Before adding, sum = " &lt;&lt; sum &lt;&lt; endl; sum = x + y; cout &lt;&lt; "After adding, sum = " &lt;&lt; sum &lt;&lt; endl; return sum; &#125;; cout &lt;&lt; f(13, 15) &lt;&lt; endl; cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl; sum = 2333; f(1, 2); cout &lt;&lt; "Sum = " &lt;&lt; sum &lt;&lt; endl; return 0;&#125; [=]以传值方式捕获所有变量 [&amp;]以传引用方式捕获所有变量 也可以同时混合多种使用，比如 [=, &amp;sum] 以传引用方式捕获sum这个变量，以传值方式捕获其他变量 [&amp;, sum] 以传值方式捕获sum这个变量，以引用方式捕获其他变量 但是不要重复使用，比如不能 [=, sum] [&amp;, &amp;sum] 应用场景自定义排序顺序在排序的时候，通常需要传入一个自定义的比较函数，这时就可以用一个匿名函数作为比较函数，而不是额外定义一个函数。 12// a是一个存了int的vectorsort(a.begin(), a.end(), [](int a, int b)&#123;return a &gt; b;&#125;)) for_each检索数组（vector）里有多少个偶数 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; a(10); generate(a.begin(), a.end(), rand); for_each(a.begin(), a.end(), [](int x)&#123;cout &lt;&lt; x &lt;&lt; " ";&#125;); cout &lt;&lt; endl; int cnt = 0; for_each(a.begin(), a.end(), [&amp;cnt](int x)&#123;cnt += (x % 2 == 0);&#125;); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; count_ifalgorithm 里提供的函数12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; a(10); generate(a.begin(), a.end(), rand); for_each(a.begin(), a.end(), [](int x)&#123;cout &lt;&lt; x &lt;&lt; " ";&#125;); cout &lt;&lt; endl; int count = 0; count = count_if(a.begin(), a.end(), [](int x)&#123;return x % 2 == 0;&#125;); cout &lt;&lt; count; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【数学】- 微分方程学习笔记（二）]]></title>
    <url>%2F2019%2F04%2F11%2Fdiff_equation_2%2F</url>
    <content type="text"><![CDATA[我们称表示未知函数、未知函数的导数、自变量之间的关系的方程叫做微分方程，微分方程的解是一个函数。下面我们讨论各种不同的微分方程的解法。 一阶线性微分方程一阶线性齐次微分方程形如 \frac{dy}{dx} + P(x)y = 0的方程为一阶线性齐次微分方程。 通解公式为 y = Ce^{-\int P(x) {\rm d}x}一阶线性非齐次微分方程形如 \frac{dy}{dx} + P(x)y = Q(x)的方程为一阶线性非齐次微分方程。通解公式为 \begin{align} y &= Ce^{-\int P(x) {\rm d}x} \left( \int Q(x)e^{\int P(x) {\rm d}x} + C\right) \\ &= Ce^{-\int P(x){\rm d}x} + e^{-\int P(x) {\rm d}x} \int Q(x)e^{\int P(x) {\rm d}x} {\rm d}x \end{align}可以发现非齐次方程的通解是对应齐次方程的通解加上一个特解。 可降阶的高阶微分方程$y^{(n)} = f(x)$ 型两边连续进行$n$次积分即可 $y’’ = f(x, y’)$ 型令$p = y’$，则原式转换为$p’ = f(x, p)$ $y’’ = f(y, y’)$ 型线性微分方程解的结构对于二阶齐次线性方程]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记（二） - C++11/STL]]></title>
    <url>%2F2019%2F04%2F09%2Fcpp2%2F</url>
    <content type="text"><![CDATA[上课时的随手笔记，供期末复习用。 C++11的部分新特性使用auto进行自动的类型推断旧的用法12auto int a = 0; //写和不写auto效果相同static int b = 0; 新的用法1auto a = 6; //自动进行类型推断 注意 auto类型的变量声明时必须初始化。 并不会牺牲运行效率和编译效率。 auto并不能用于函数的参数，如果不想进行函数重载请使用函数模板。 基于范围的for循环旧的用法1234int arr[] = &#123;11, 22, 33, 44, 55&#125;;for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " ";&#125; 新的用法12345678int arr[] = &#123;11, 22, 33, 44 ,55&#125;;for (int k : arr) &#123; // 冒号后面应当是一个容器 cout &lt;&lt; k &lt;&lt; " ";&#125;/*for (auto k : arr) cout &lt;&lt; k &lt;&lt; " "; // 可以应用于各种类型的数组*/ 不止普通数组，其他的容器也可以进行类似的遍历操作。1234567//字符串string s = "Hello World";for (auto c : s) cout &lt;&lt; c;//向量（动态数组）vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;; // only for c++11for (auto x : v) cout &lt;&lt; x &lt;&lt; " "; STL迭代器（iterator）为了形式的通用与统一，可以看作是一种广义的指针。 声明12vector&lt;int&gt; v;vector&lt;int&gt;::iterator it; //指向存储int的vector的迭代器 用法1234567for (vector&lt;int&gt;::iterator it = v.begin(), it != v.end(); it++) &#123; //do something cout &lt;&lt; *it &lt;&lt; endl;&#125;//v.begin()返回指向v的第一个元素的迭代器//v.end()返回指向v的最后一个元素后面的位置的迭代器//vector的随机存取迭代器的行为类似指针，允许++操作（前置后置均可） 在C++11中，有更方便的写法1234// only for c++11for (auto it = v.begin(); it != v.end(); it++) &#123; //do something&#125; 还有更更方便的写法1234//only for c++11for (auto x : v) &#123; //do something&#125; 注意 迭代器并不等同于指针，迭代器表示逻辑上的前后关系，而指针表示的是物理上的前后关系。 容器vector（动态数组）靠谱的参考 可以通过重载 &lt;&lt; 来实现直接用 cout 来输出vector，可以写成模板函数的形式。 123456template &lt;class T&gt;std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, const std::vector&lt;T&gt; &amp;v) &#123; for (auto x : v) out &lt;&lt; x &lt;&lt; " "; out &lt;&lt; endl; return out;&#125; 算法（Algorithm）sort（排序）12//需要#include &lt;algorithm&gt;sort(v.begin(), v.end(), cmp); //默认升序排序 sort()可以排序任何支持比较大小的对象，比如整数，字符串，甚至是自己定义的类（需要重载小于号，相当于给sort()一个比较的规则） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;template &lt;class T&gt;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::vector&lt;T&gt; &amp;v) &#123; for (auto x : v) out &lt;&lt; x &lt;&lt; " "; out &lt;&lt; std::endl; return out;&#125;class Stu &#123;public: int score; std::string name; Stu() &#123; score = -1; name = "Anonymous"; &#125; Stu(int sc, std::string nm) &#123; score = sc; name = nm; &#125;&#125;;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Stu &amp;a) &#123; out &lt;&lt; a.score &lt;&lt; " " &lt;&lt; a.name; return out;&#125;bool operator&lt;(const Stu &amp;a, const Stu &amp;b) &#123; if (a.score &lt; b.score) return true; else return false;&#125;int main() &#123; std::vector&lt;std::string&gt; aa = &#123;"ZhangSans", "LiSi", "WangWu"&#125;; std::vector&lt;int&gt; bb = &#123;11, 222, 333, 4444&#125;; std::vector&lt;Stu&gt; cc = &#123;&#123;99, "ZhangSan"&#125;, &#123;90, "LiSi"&#125;&#125;; cc.push_back(&#123;91, "WangWu"&#125;); cc.push_back(Stu(95, "ZhaoLiu")); std::cout &lt;&lt; cc; std::sort(cc.begin(), cc.end()); std::cout &lt;&lt; cc; return 0;&#125; 想倒序排序怎么办？ 不怎么靠谱的方法 把小于号重载成大于号 【不推荐】 靠谱的方法： 写一个比较规则函数放在cmp的位置上，调用的时候用sort(v.begin(), v.end(), cmp); 1234bool cmp(const Stu&amp; a, const Stu&amp; b) &#123; if (a.score &gt; b.score) return true; else return false;&#125; random_shuffle（打乱）12//需要#include &lt;algorithm&gt;random_shuffle(v.begin(), v.end()); //随机打乱 for_each用于遍历某容器的指定区间并执行某个操作。123456for_each(v.begin(), v.end(), print);//print 是一个函数指针//这句话的意思是对从v.begin()到v.end()这个左闭右开区间中的每一个元素应用print这个函数//print如果是一个函数模板，请指明其类型for_each(v.begin(), v.end(), print&lt;int&gt;);]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记（一）- 异常]]></title>
    <url>%2F2019%2F04%2F08%2Fcpp1%2F</url>
    <content type="text"><![CDATA[上课时的随手笔记，供期末复习用。 异常C语言的做法C语言中，通常使用函数的返回值来表示错误。 考虑下面的代码：123456789101112131415#include &lt;stdio.h&gt;double divide(int a, int b) &#123; return (double)a / b;&#125;int main() &#123; int a, b; double c; a = 5; b = 2; c = divide(a, b); //b can't be 0 printf("%lf", c); return 0;&#125; 为了捕获 $b$ 为 $0$ 的错误，原始且暴力的方法是在divide函数中进行判断。但这样会导致程序终止。1234double divide(int a, int b) &#123; if (b == 0) exit(1) abort() //example return (double)a / b;&#125; 更进一步，函数通过某种方式告知调用者出现了某些问题。函数除了提供结果，还需要提供是否成功执行的标志。1234567int divide(int a, int b， double *c) &#123; if (b == 0) return 0; //failed else &#123; *c = (double)a / b; return 1; //succeed &#125;&#125; 更丑陋的写法：12345678double divide(int a, int b， int *pFlag) &#123; if (b == 0) &#123; *pFlag = 0; //failed return 0; &#125; *pFlag = 1; return (double)a / b; //succeed&#125; C语言中函数判断是否正常运行的机制并不独立，在面向对象的思想里面，把运行出错这件事情作为一个异常进行处理，程序永远只负责返回（正常情况下的）结果。 如果运行出错，则抛出(throw)一个异常。 c++的做法123456789#include &lt;iostream&gt;using namespace std;double divide(int a, int b) &#123; if (b == 0) &#123; throw 1； &#125; return (double)a / b;&#125; 抛出异常之后需要进行处理，否则被操作系统所捕获之后会终止程序。 123456789101112131415int main() &#123; int a, b; double c; a = 5; b = 2; try &#123; c = divide(a, b); //b can't be 0 &#125; catch (int e) &#123; // 'e' means exception cout &lt;&lt; "exception occured!" &lt;&lt; e &lt;&lt; endl; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 注意： try和catch应当配对使用。必须紧挨着出现。 抛出异常之后函数的剩余部分不再执行，直接跳到catch块里。 如果throw多个东西，谁先被触发先扔谁。 一个try后面可以跟着多个catch。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;double divide(int a, int b) &#123; if (b == 0) throw 1； if (a &lt; 0) throw "Negative!"; return (double)a / b;&#125;int main() &#123; int a, b; double c; a = 5; b = 2; try &#123; c = divide(a, b); //b can't be 0 &#125; catch (int e) &#123; // 'e' means exception cout &lt;&lt; "exception occured!" &lt;&lt; e &lt;&lt; endl; &#125; catch (const char* e) &#123; cout &lt;&lt; e &lt;&lt; endl; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 异常类我们（通常）可以定义一个类来表示异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class E &#123;public: string msg; E() &#123; cout &lt;&lt; "E()" &lt;&lt; endl; &#125; E(string msg) &#123; this-&gt;msg = msg; &#125; E(const E &amp;e) &#123;//拷贝构造记得用const this-&gt;msg = e.msg; &#125;&#125;;//betterdouble divide(int a, int b) &#123; if (b == 0) throw E("Divided by zero");//带参构造一次 return (double)a / b;&#125;//worse/*double divide(int a, int b) &#123; E e("hoho"); //带参构造一次 if (b == 0) throw e; //拷贝构造一次 return (double)a / b;&#125;*/int main() &#123; int a, b; double c; a = 5; b = 2; try &#123; c = divide(a, b); //b can't be 0 &#125; catch (E &amp;e) &#123; // 使用引用来避免多余的拷贝构造 cout &lt;&lt; e.msg &lt;&lt; endl; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; C++ 贴心地 提供了标准的异常类。包含在exception头文件中。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;double divide(int a, int b) &#123; if (b == 0) throw exception(); return (double)a / b;&#125;int main() &#123; int a, b; double c; a = 5; b = 2; try &#123; c = divide(a, b); &#125; catch (exception &amp;e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 我们可以从标准的exception类中派生出自己的异常类。 12345678910111213141516class E : public exception &#123;public: string msg; E() &#123; cout &lt;&lt; "E()" &lt;&lt; endl; &#125; E(string msg) &#123; this-&gt;msg = msg; &#125; E(const E &amp;e) &#123;//拷贝构造记得用const this-&gt;msg = e.msg; &#125; ~E() throw() &#123;//规范的写法要求重写基类的析构函数，记得加throw()表明这个函数不会抛出任何异常 cout &lt;&lt; "~E()" &lt;&lt; endl; &#125;&#125;; 123456class EE : public exception &#123;public: int code; EE() &#123;code = -1;&#125; EE(int c) &#123;code = c;&#125;&#125;; 对于这样的两个类，都从exception派生而来，都有what()成员函数（来自exception），只需要重写what()这个函数，就可以只写一个catch块，来应对不同种类的异常（捕获的异常是抛出异常的基类），这也是多态性的一种体现。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;class E : public exception &#123;public: string msg; E() &#123; msg = "error"; &#125; E(string msg) &#123; this-&gt;msg = msg; &#125; ~E() throw() &#123; cout &lt;&lt; "Die" &lt;&lt; endl; &#125; const char* what() const throw() &#123;//表示这个函数函数实现时不会抛出任何异常，c++11中通常写作 void func() noexcept&#123;&#125; return msg.c_str(); //std::string转换成C风格字符串 &#125;&#125;;double divide(int a, int b) &#123; if (b == 0) throw E("Divided by zero"); else return (double)a / b;&#125;int main() &#123; int a = 10; int b = 0; double c = 0; try &#123; c = divide(a, b); &#125; catch (E &amp;e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125; cout &lt;&lt; c &lt;&lt; endl; return 0;&#125; 更好的阅读体验？C++学习笔记（一） - 异常]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[GPLT2017]-古风排版]]></title>
    <url>%2F2019%2F03%2F29%2Fgplt2017-gf%2F</url>
    <content type="text"><![CDATA[【链接】GPLT 2017 古风排版 【题目描述】中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。 【输入样例】124This is a test case 【输出样例】1234asa Tst ihe tsi ce s 【题解】模拟，先把句子用空格补成能被$n$整除的长度。 【代码】1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;int main() &#123; int n; std::cin &gt;&gt; n; getchar(); std::string s; getline(std::cin, s); int m = n - s.size() % n; if (s.size() % n != 0) &#123; for (int i = 1; i &lt;= m; i++) s += " "; &#125; for (int i = s.size() - n; i &lt; s.size(); i++) &#123; for (int j = i; j &gt;= 0; j -= n) &#123; std::cout &lt;&lt; s[j]; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>GPLT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数学】- 容斥原理学习笔记]]></title>
    <url>%2F2019%2F03%2F02%2Frcyl%2F</url>
    <content type="text"><![CDATA[容斥原理是组合数学基本的计数定理之一。 概述设 $S$ 为有穷集 $P_1, P_2, \dots, P_n$ 是 $n$ 个性质。$S$ 中任意元素 $x$ 或者具有性质 $P_i$ 或者没有。令 $A_i$ 表示 $S$ 中具有性质 $P_i$ 的元素构成的子集，则$S$中不具有任何一种性质的元素个数表示为： |\overline A_1 \cap \overline A_2 \cap \dots \cap \overline A_n| = |S| - \sum_{i = 1}^n |A_i| + \sum_{1 \le i < j \le n} |A_i \cap A_j | - \sum_{1 \le i < j < k \le n} |A_i \cap A_j \cap A_k| + \dots +(-1)^n|A_1 \cap A_2 \cap \dots \cap A_n|容斥原理被用来解决不具有任何性质的元素个数问题。 而由于不具有任何性质和至少具备一条性质是对立的，容斥原理也可以解决至少具备一条性质的元素个数问题。 应用举例欧拉函数的求法 欧拉函数$\varphi(n)$表示不大于$n$的与$n$互质的数的个数。 对于两个正整数 $a$ 和 $b$ ，如果有 $\gcd(a, b) = 1$ 那么我们称这两个数互质。 对于一个正整数$n$，根据唯一分解定理我们可以把它分解成若干质因数的幂次之积，即： n = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k} 我们发现如果 $a$ 不能被 $n$ 的任何质因子以及其乘积整除(没有公共的质因子)，那么 $n$ 和 $a$ 一定互质。现在问题就转化为了求不大于$n$的数中不具有性质$A$的元素个数，其中性质$A$ 就是能被 $n$ 的某个质因子或者其几个质因子的乘积整除。 而这种不具有任何性质的元素个数问题正是容斥原理所能解决的。 令 A_i = \{ x \mid 0 \le x \le n - 1 \text{且} p_i | x \}则 \varphi(n) = |\overline A_1 \cap \overline A_2 \cap \dots \cap \overline A_k|我们考虑等式右边的计算方法，在$[1, n - 1]$的范围中，一定是每 $p_i$ 个数出现一个数能被 $p_i$ 整除，所以 |A_i| = \frac{n}{p_i}, i = 1, 2, 3, \dots ,k又因为$p_i$都是质数所以任意两两互质，所以有 |A_i \cap A_j| = \frac{n}{\operatorname{lcm}(p_i, p_j)} = \frac{n}{p_ip_j}， 1 \le i < j \le k所以 \begin{align} \varphi(n) &= |\overline A_1 \cap \overline A_2 \cap \dots \cap \overline A_k| \\\ &= n - \sum_{i = 1}^k \frac{n}{p_i} + \sum_{1 \le i < j \le k} \frac{n}{p_ip_j} - \dots + (-1)^k \frac{n}{\prod_{i =1}^k p_i} \\\ &= n(1- \frac{1}{p_1})(1- \frac{1}{p_2}) \dots (1- \frac{1}{p_k}) \\\ &= n \prod_{i = 1}^k(1-p_k) \end{align}错位排列问题 一个人写了 $n$ 封不同的信及相应的 $n$ 个不同的信封，他把这 $n$ 封信都装错了信封，问都装错信封的装法有多少种？ 全错位排列求的是没有任何一个元素在自己的位置上的集合个数，不难发现我们所设的性质就是有某些元素在自己的位置上，设$A_i$表示第$i$个元素在自己位置上的集合。 不难看出全集为$[1, n]$的全排列构成的集合: |S| = n!而 |A_i| = (n - 1)! , i = 1, 2, \dots , n |A_i \cap A_j| = (n - 2)! , 1 \le i < j \le n \dots |A_1 \cap A_2 \cap \dots \cap A_n| = 0! = 1所以错位排列$D_n$就是不具备以上任何一条性质的集合大小， \begin{align} D_n &= |A_1 \cap A_2 \cap \dots \cap A_n| \\ &= n! - C_n^1(n - 1)! + C_n^2(n-2)!-\dots+(-1)^nC_n^n0! \\ &= n![1 - \frac{1}{1!} + \frac{1}{2!} - \dots + (-1)^n\frac{1}{n!}] \end{align}从表达式可以看出，当$n$充分大时，错位排列占全排列的比例大约等于$e^{-1}$.]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数学】- 微分方程学习笔记（一）]]></title>
    <url>%2F2019%2F02%2F24%2Fdiff_equation_1%2F</url>
    <content type="text"><![CDATA[我们称表示未知函数、未知函数的导数、自变量之间的关系的方程叫做微分方程，微分方程的解是一个函数。下面我们讨论各种不同的微分方程的解法。 可分离变量的微分方程对于 $\frac{dy}{dx} = \frac{Q(x, y)}{P(x, y)}$ 这种形式的微分方程，我们将变量 $x$ 和 $y$ 分离到等号的两端，再对两边分别积分，得到答案。 例题xy' - y \ln y = 0把导数写成$\frac{dy}{dx}$的形式 x \frac{dy}{dx} - y \ln y =0分离变量 \frac{dy}{y \ln y} = \frac{dx}{x}两边分别积分 \int \frac{dy}{y \ln y} = \int \frac{dx}{x}\ln |\ln y| = \ln |x|y = e^x齐次方程如果一阶微分方程可化成 \frac{dy}{dx} = \varphi(\frac{y}{x})的形式，我们称其为齐次方程，对于这样的微分方程，我们先将其化为上面的标准形式，再令$u = \frac{y}{x}$，换元之后转化成可分离变量的微分方程求解。 例题(xy-y^2)dy-(x^2-2xy)dx=0化简为标准的形式 \frac{dy}{dx}=\frac{xy-y^2}{x^2-2xy}\frac{dy}{dx}=\frac{\frac{y}{x}-(\frac{y}{x})^2}{1-2 \times \frac{y}{x}}变量代换$u = \frac{y}{x}$，则$\frac{dy}{dx} = u + x \frac{du}{dx}$原式转化为 u + x\frac{du}{dx} = \varphi(u)下面便可以分离变量进行求解。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起开心寒假训练 - 2]]></title>
    <url>%2F2019%2F02%2F03%2FhappyWinter2%2F</url>
    <content type="text"><![CDATA[【链接】一起开心寒假训练 - 2 这周好像都是带字符串的贪心/模拟/脑洞题 A - Did you mean… - 模拟 + 贪心【题目描述】给定一个由小写字母组成的单词，规定如果单词中连续出现三个或以上的辅音字母，则这是一个错误的单词。存在特例：如果这些连续的辅音字母都相同的话，则不算一个错误的单词。 现在要在个单词中间插入若干个空格，使得产生的这些由空格分隔的新单词都是合法的。 【题解】贪心，如果发现连续的三个不同辅音字母出现，就在第二个辅音字母后面加上一个空格。 具体实现上可以不用真的修改原先的字符串，而是先记录一下在哪个字母后面加空格，最后再输出。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int MAXN = 3000 + 10;char s[MAXN];char vowels[] = &#123;'a', 'e', 'i', 'o', 'u'&#125;;bool isConsonants(char c) &#123; for (int i = 0; i &lt; 5; i++) &#123; if (vowels[i] == c) return false; &#125; return true;&#125;bool isSame(int i) &#123; if (s[i] == s[i - 1] &amp;&amp; s[i - 1] == s[i - 2]) return true; else return false;&#125;std::queue&lt;int&gt; q;int main() &#123; scanf("%s", s); int len = strlen(s); int cnt = 0; for (int i = 0; i &lt; len; i++) &#123; if (isConsonants(s[i])) cnt++; else cnt = 0; if (cnt &gt;= 3 &amp;&amp; !isSame(i)) &#123; q.push(i - 1); cnt = 1; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; if (i == q.front()) &#123; printf("%c ", s[i]); q.pop(); &#125; else printf("%c", s[i]); &#125; return 0;&#125; B - Alphabetic Removals - 模拟【题目描述】给定一个由26个小写字母组成的字符串，进行如下操作$k$次： 检查字母a的数目，如果大于一，则删除最左边的哪一个，结束操作。 否则继续按上述规则检查字母表中每一个字母。 问最后的字符串是什么样子的，保证有解。 【题解】直接按题意模拟，在寻找最左边的某个字母的操作中，使用了26个队列。 先从左至右扫一遍原串，预处理出每个字母的位置，这样最左边的那个字母的位置就在队头，每次删除只需要直接出队就可以了。 【代码】12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;queue&gt;const int MAXL = 26;const int MAXN = 400000 + 10;std::queue&lt;int&gt; q[MAXL];char s[MAXN];int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); scanf("%s", s); for (int i = 0; i &lt; n; i++) &#123; q[s[i] - 'a'].push(i); &#125; while (k--) &#123; for (int i = 0; i &lt; 26; i++) &#123; if (q[i].size() &gt;= 1) &#123; int index = q[i].front(); q[i].pop(); s[index] = ' '; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (s[i] == ' ') continue; else putchar(s[i]); &#125; return 0;&#125; C - Crusaders Quest - 脑洞 + 贪心【题目描述】给了一个类似消消乐的游戏，一个或以上一样元素的碰在一起可以消除，三个一样的碰在一起就会是一个powerful skill，现在给定一个长度为 $9$ 的字符串，问最多能有几个三消。 【题解】这个题目并不会做，但是长度为 $9$ 好像怎么做都可以。 我用的方法是用一个栈来维护，如果栈顶三个元素相同，那就弹出来，答案加一。 发现答案只可能是 $1$，$2$ 或 $3$，如果第一遍发现最后栈空了那就是$3$，如果不空，就删掉某种元素再重复压栈的操作，三种删法中取一个最好的结果，如果三种删法都不能使栈变空，那答案就是$1$。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int MAXN = 10;char s[MAXN];char stack[MAXN];int top = -1;int solve(char c, int len) &#123; int ans = 0; for (int i = 0; i &lt; len; i++) &#123; if (s[i] == c) continue; if (top &gt;= 1 &amp;&amp; stack[top] == s[i] &amp;&amp; stack[top - 1] == s[i]) &#123; top -= 2; ans++; &#125; else stack[++top] = s[i]; &#125; return ans;&#125;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; top = -1; scanf("%s", s); int len = strlen(s); for (int i = 0; i &lt; len; i++) &#123; if (top &gt;= 1 &amp;&amp; stack[top] == s[i] &amp;&amp; stack[top - 1] == s[i]) top -= 2; else stack[++top] = s[i]; &#125; if (top == -1) printf("3\n"); else &#123; top = -1; int a = solve('a', len); top = -1; int b = solve('g', len); top = -1; int c = solve('o', len); if (a == b &amp;&amp; b == c &amp;&amp; a == 0) printf("1\n"); else printf("2\n"); &#125; &#125; return 0;&#125; D - Polycarp and Div 3 - 规律 + 贪心【题目描述】给定一个数字，可以切割这个数字，问最多切割出多少三的倍数。 比如 $3121$ 这个数字,可以切割成$3$，$1$ 和 $21$最多有两个数是三的倍数。 【题解】我们知道如果一个数的各个位上的数的和是三的倍数，那么这个数就是三的倍数，也就是比如对于一个三位数 $abc$ 来说，如果$(a + b + c) \% 3 = 0$，那么$abc \% 3 = 0$。 而一个数模三的结果只有 $0$，$1$，$2$ 三种，如果某位模 $3$ 为 $0$ ，就直接把这位分割出去，如果为 $1$ 或者 $2$ 就先留着看下一位，如果是 $[1, 2]$ 或 $[2, 1]$ 就把这两位分出去，也就是说每三位数都至少会分割出一个数。 【代码】12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 200000 + 10;char s[MAXN];int main() &#123; scanf("%s", s); int len = strlen(s); int ans = 0, cnt = 0, tmpp = 0; for (int i = 0; i &lt; len; i++) &#123; int tmp = (s[i] - 0) % 3; if (tmp == 0) &#123; ans++; cnt = 0; tmpp = 0; &#125; else &#123; cnt += tmp; tmpp++; if (cnt % 3 == 0) &#123; ans++; cnt = 0; tmpp = 0; &#125; else if (tmpp % 3 == 0) &#123; ans++; cnt = 0; tmpp = 0; &#125; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记(四)]]></title>
    <url>%2F2019%2F01%2F30%2Fgit_learn_4%2F</url>
    <content type="text"><![CDATA[虽然这个博客是托管在github上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习git。 教程是《廖雪峰的Git教程》和《官方教程》 分支管理分支管理在多人协作开发的场景下有着重要的意义，试想你正在开发一个新功能，只开发了一半，如果直接提交的话，不完整的代码库会导致其他人都用不了了，如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。而有了分支，就可以自己单独开一个分支，等自己完全完成工作之后，再一次性合并到原来分支上，这样既安全又不影响别人工作。 创建与合并分支 使用git check -b &lt;branch&gt;来创建一个分支并切换到新的分支，其中-b参数表示创建并切换，等价于下面两条命令。12$ git branch dev$ git checkout dev git branch是创建，git checkout是切换。 使用git branch查看当前分支，这个命令会列出所有分支，并在当前分支前打一个星号。 使用git merge &lt;branch&gt;来将&lt;branch&gt;这个分支合并到当前分支。 使用git branch -d &lt;baranch&gt;来删除分支。 解决冲突有时候两个分支各自有不同的修改，就不能很顺利地完成合并。 这个时候直接git merge &lt;branch&gt;来合并的话会出现冲突，master后面会出现MERGING的标志。 这个时候查看修改过文件的内容会给出不同分支中不同的部分，改成一样之后再提交就可以了。 现在，master分支和feature1分支变成了下图所示： 最后删除feature1分支就行了。 这个图示可以用git log --graph来查看。 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记(三)]]></title>
    <url>%2F2019%2F01%2F29%2Fgit_learn_3%2F</url>
    <content type="text"><![CDATA[虽然这个博客是托管在github上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习git。 教程是《廖雪峰的Git教程》和《官方教程》 远程仓库我们使用Github作为我们学习Git使用的远程仓库。 本地仓库和远程仓库之间的数据传输是通过SSH进行加密的，所以需要先生成SSH key。 使用ssh-keygen -t rsa -C &quot;youremail@example.com&quot;命令创建SSH key，一路回车之后发现主目录下多了一个.ssh目录，里面有里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 关于非对称加密中公钥和私钥的理解可以看这里。 获得自己的SSH key之后，可以在Github的Setting里找到添加SSH key。 这样一来Github就知道是你在向库里提交东西了。 添加远程库（先有本地库，再有远程库）在Github上新建一个仓库，使用git remote add origin &lt;SSH key&gt;添加一个远程库，其中SSH key可以在如图所示的地方找到。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 接下来用git push -u origin master命令就可以把本地内容推送到远程库上了，第一次提交需要写-u，以后就不需要了，可以直接git push origin master。 这样就可以在没有网络的时候在本地工作，有网络之后直接git push就好了。 从远程库克隆（先有远程库，再有本地库）先找到想要克隆的仓库，还是在如图位置找到地址，使用git clone &lt;SSH key&gt;来将这个库克隆到本地。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记(二)]]></title>
    <url>%2F2019%2F01%2F28%2Fgit_learn_2%2F</url>
    <content type="text"><![CDATA[虽然这个博客是托管在github上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习git。 教程是《廖雪峰的Git教程》和《官方教程》 版本回退 使用 git log 查看自己的历史纪录，嫌输出信息太多可以用 git log --pretty=oneline 命令，其中最前面显示的叫commit id。 想要回退到上个版本可以使用git reset --hard HEAD^。Git里面HEAD是一个指针，表示的就是当前版本。 如果想回退很多版本的话可以打很多^，也可以指定数字~&lt;num&gt;。 想回退到指定版本可以使用git reset --hard &lt;commit id&gt;，其中版本号可以只写前几位。这样可以在回退之后再返回最新的版本。 Git提供git reflog命令来查看过去的每一条命令，可以找到每一次的commit id 注意git log是提交的历史，是和当前版本相关的，是到当前版本为止的历史提交，git reflog是命令的历史，会一直保存。 工作区与暂存区 如图所示，工作区即为本地的那个目录（仓库），版本库就是那个隐藏的.git文件夹。 在这个版本库里有一个暂存区（stage）和 Git 自动创建的第一个分支master（后面会学到关于分支的内容）。 前面说的我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）git diff --cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别。 Git管理的是“修改”，也就是说只要不git add，git commit就不会把修改提交上去。 撤销修改 情况一：只在工作区修改，既没有add也没有commit git checkout -- &lt;file name&gt; 可以撤销当前工作区的全部修改，注意--之后要加空格 情况二：已经add到暂存区了 git reset HEAD &lt;file&gt; 可以把暂存区的修改撤销掉，重新放回工作区。 之前见过reset命令，它既可以用作回退版本，也可以用作把暂存区的修改回退到工作区 这样一来就转换成了情况一 情况三：已经commit过了 直接回退到上个版本 删除文件 直接在工作区删除 如果真的要删除，就用git rm &lt;file name&gt;告诉Git要在版本库里删除，然后git commit 如果是自己手滑删错了，就用git checkout -- &lt;file name&gt;恢复过来 还有一点git checkout -- &lt;file name&gt;这个命令，做的事情实际上是用版本库里的版本去替换工作区的版本，具体来说是分支里的版本，不是暂存区里的版本。 所以在撤销修改一节中，由于既没有add也没有commit，版本库里的是老版本，用过命令后工作区的版本就被替换成了版本库里的老版本。 在误删这个情境下，如果没有既没有add也没有commit，版本库里仍然存着被删掉的文件，自然就可以恢复过来了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记(一)]]></title>
    <url>%2F2019%2F01%2F27%2Fgit_learn_1%2F</url>
    <content type="text"><![CDATA[虽然这个博客是托管在github上的，但是之前使用的时候都是知其然而不知其所以然，所以今天开始正式学习git。 教程是《廖雪峰的Git教程》和《官方教程》 安装Git对于 Windows 系统，直接到官网下载并安装。 安装完之后打开 GitBash 用这两个命令进行设置，因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库（仓库） 随便新建一个文件夹 在这个文件夹下使用git init命令将这个文件夹变成一个仓库(repository) Git 实际上做的事情是在这个文件夹下建立了一个隐藏的文件夹.git用于管理这个库 添加文件到版本库 在仓库里新建一个文本文件 使用命令git add &lt;filename&gt;来添加文件到版本库 使用命令git commit -m &lt;message&gt;来将刚才添加的文件提交到版本库，这个命令可以一次提交多个文件，感觉就像把很多东西塞到一辆货车上，再一块拉去仓库 查看仓库状态 用git status查看当前仓库的状态 用git diff查看进行了哪些修改]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起开心寒假训练 - 1]]></title>
    <url>%2F2019%2F01%2F27%2FhappyWinter1%2F</url>
    <content type="text"><![CDATA[【链接】一起开心寒假训练 - 1 A - 矩形判断 - 几何【题目描述】给出平面上$4$条线段，判断这$4$条线段是否恰好围成一个面积大于$0$的矩形。 【题解】先判断这四条线能否首尾相连形成一个封闭的四边形，再通过斜率或者向量相乘的方法判断是否垂直。 【代码】1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; std::vector&lt; std::pair&lt;int, int&gt; &gt; v; std::vector&lt;double&gt; v1; for (int i = 1; i &lt;= 4; i++) &#123; int x1, y1, x2, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); v.push_back(std::make_pair(x1, y1)); v.push_back(std::make_pair(x2, y2)); v1.push_back((double)(y1 - y2) / (double)(x1 - x2)); &#125; std::sort(v.begin(), v.end()); if (std::unique(v.begin(), v.end()) - v.begin() != 4) printf("NO\n"); else &#123; std::sort(v1.begin(), v1.end()); if (std::unique(v1.begin(), v1.end()) - v1.begin() != 2) printf("NO\n"); else if (v1[0] * v1[1] == -1) printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125; B - 水陆距离 - BFS【题目描述】给定一个$N \times M$ 的 $01$ 矩阵，其中 $1$ 表示陆地，$0$ 表示水域。对于每一个位置，求出它距离最近的水域的距离是多少。 矩阵中每个位置与它上下左右相邻的格子距离为$1$。 【题解】一开始以所有水域为起点开始BFS，每块陆地一旦被扩展到就说明找到了离它最近的水域。可以一开始将所有陆地设置初值为$-1$来实现判重。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;climits&gt;const int MAXN = 800 + 10;char s[MAXN][MAXN];int ans[MAXN][MAXN];typedef std::pair&lt;int, int&gt; info;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf("%s", s[i]); &#125; std::queue&lt;info&gt; q; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; ans[i][j] = -1; if (s[i][j] == '0') &#123; ans[i][j] = 0; q.push(std::make_pair(i, j)); &#125; &#125; &#125; while (!q.empty()) &#123; info v = q.front(); q.pop(); int x = v.first, y = v.second; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dx[i]; int yy = y + dy[i]; if (xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; ans[xx][yy] == -1) &#123; ans[xx][yy] = ans[x][y] + 1; q.push(std::make_pair(xx, yy)); &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (j &lt; m - 1) printf("%d ", ans[i][j]); else printf("%d\n", ans[i][j]); &#125; &#125; return 0;&#125; C - 满减优惠 - 背包DP【题目描述】【题解】【代码】D - 出勤记录I - 模拟【题目描述】小Hi的算法课老师每次上课都会统计小Hi的出勤记录。迟到会被记录一个L，缺席会被记录一个A，按时上课会被记录一个O。 一学期结束，小Hi的出勤记录可以看成是一个只包含L A O的字符串，例如OOOOLOOOLALLO……。 如果小Hi整学期缺席不超过1次，并且没有连续3次迟到，小Hi的出勤记录就算合格。 现在给出小Hi的出勤记录，你能判断他是否合格么？ 【题解】按照题目说的模拟即可。 【代码】123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt; #include &lt;vector&gt;int main() &#123; int t; std::cin &gt;&gt; t; while(t--) &#123; int l = 0, a = 0, o = 0; std::string s; std::cin &gt;&gt; s; for(int i = 0; i &lt; s.size(); i++) &#123; if(s[i] == 'A') a++; if(i + 3 &lt; s.size() &amp;&amp; s[i] == 'L' &amp;&amp; s[i + 1] == 'L' &amp;&amp; s[i + 2] == 'L' ) &#123; l += 3; break; &#125; &#125; if(a &gt; 1 || l &gt;= 3) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125; E - 跳石头 - 线性DP【题目描述】有 $n$ 个石头从左到右拍成一排，第 $i$ 个石头的颜色为 $c_i$ 。现在小 Ho 在第一个石头，他想跳到第 $n$ 个石头，每一步有两种跳跃方式： 从第 $i$ 个石头跳到第 $i + 1$ 个石头 跳到右边第一个和当前石头颜色相同的石头（如果存在的话） 现在他想知道，从第一个石头跳到第 $n$ 个石头至少需要几步跳跃 【题解】设 $f(i)$ 表示跳到第 $i$ 个石头需要的最少步数，容易写出状态转移方程为： f(i) = \min \{ f(i - 1), f(\text{same color})\} + 1使用记忆化搜索来实现这个DP，代码中使用了std::map来预处理出每个石头之前最近的颜色相同的石头的编号。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;typedef std::pair&lt;int, int&gt; info;std::map&lt;int, int&gt; mp;std::vector&lt;info&gt; v;const int MAXN = 1000000 + 10;int dp[MAXN];int solve(int x) &#123; if (x == 0) return dp[x] = 0; else if (dp[x] != -1) return dp[x]; else &#123; if (v[x].second != -1) return dp[x] = std::min(solve(x - 1), solve(v[x].second)) + 1; else return dp[x] = solve(x - 1) + 1; &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int x; scanf("%d", &amp;x); if (mp.count(x)) v.push_back(std::make_pair(x, mp[x])); else v.push_back(std::make_pair(x, -1)); mp[x] = i; dp[i] = -1; &#125; printf("%d\n", solve(n - 1)); return 0;&#125; F - 机会渺茫 - 数学【题目描述】给定两个正整数 $n$ 和 $m$，随机选出 $n$ 的一个因数 $n_1$ 和 $m$ 的一个因数 $m_1$，问 $n_1 = m_1$ 的概率为多少。 【题解】记 $x’$ 为 $x$ 的因数个数，对于两个数 $a$ 和 $b$ ，他们共有的因数个数为$\gcd(a, b)’$，故： P(n_1 = m_1) = \frac{\gcd(n, m)'}{n' \times m'}题目要求分子分母互质，因此最后要同除分子分母的 $\gcd$ 【代码】1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;long long getCntX(long long x) &#123; long long cntX = 0; for (long long i = 1; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; cntX++; if (x / i != i) cntX++; &#125; &#125; return cntX;&#125;int main() &#123; long long n, m; scanf("%lld%lld", &amp;n, &amp;m); long long cntN = getCntX(n); long long cntM = getCntX(m); long long p = gcd(n, m); long long cntP = getCntX(p); int tmp = cntN * cntM; long long x = gcd(tmp, cntP); printf("%d %d\n", tmp / x, cntP / x); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于异或]]></title>
    <url>%2F2018%2F09%2F06%2FXor%2F</url>
    <content type="text"><![CDATA[异或的一些应用 定义异或是一种二元逻辑运算符，作用是 「取异」，即两值相异返回$1$，相同返回 $0$ 。 另外一种理解是异或是二进制下忽略进位的加法： 0 \oplus 0 = 0 \rightarrow 0 + 0 = 01 \oplus 1 = 0 \rightarrow 1 + 1 = (1)01 \oplus 0 = 1 \rightarrow 1 + 0 = 1性质异或运算满足交换律与结合律。 异或具有自反性即 $a \oplus b \oplus b = a$。 应用两数交换123void swap(int &amp;a, int &amp;b) &#123; a ^= b ^= a ^= b;&#125; 并不易懂，不推荐使用，三变量交换法足够了。 寻找只出现一次的数给定一个非空数组，其中一个元素出现过奇数次，其余均出现偶数次，找出这个只出现奇数次的元素。1234567int find(int a[], int len) &#123; int ans = a[0]; for (int i = 1; i &lt; len; i++) &#123; ans ^= a[i]; &#125; return ans;&#125; 利用异或的定义，相同两数异或结果为$0$，又有异或满足结合律。 寻找重复数$1$ 到 $n$放在含有$n + 1$个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。找出这个重复的元素。 与上面的做法相同，把所有数异或起来再与$1$到$n$异或一遍就是最终的答案。 相当于强行构造出奇数次与偶数次的异或。 12345678int find(int a[], int len) &#123; int ans = 0; for (int i = 1; i &lt;= len; i++) &#123; ans ^= a[i]; ans ^= i; &#125; return ans;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Educational Codeforces 49 C] Minimum Value Rectangle - 贪心]]></title>
    <url>%2F2018%2F08%2F22%2FCodeforces_E49_C%2F</url>
    <content type="text"><![CDATA[【链接】Educational Codeforces 49 C Minimum Value Rectangle 【题目描述】给出一些木棍拼成矩形，求一种方案使得 $\frac{P^2}{S}$ 最小，其中$P$代表矩形的周长，$S$代表矩形的面积。 【题解】设拼成的矩形的长和宽分别为$x$和$y$ $(x &gt; y)$，则 \frac{P^2}{S} = \frac{(x+y)^2}{xy} = \frac{x^2+y^2+2xy}{xy} = \frac{x}{y} + \frac{y}{x} + 2记$a = \frac{x}{y}$，则$a&gt;1$ 原式化为$a + \frac{1}{a} + 2$，由对号函数的性质可知，上式在$(1, +\infty)$单调增，故我们的贪心策略为使$a$尽量小。 我的做法是利用std::map有序的特点把出现超过两次的木棍存在map里，顺序遍历，每次只考虑相邻的两个元素，最终比较得到最小值，并将方案输出。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;int main() &#123; int t; scanf("%d", &amp;t); std::map&lt;int, int&gt; mp; while (t--) &#123; mp.clear(); int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); mp[x]++; &#125; bool flag = false; for (auto it = mp.begin(); it != mp.end(); ) &#123; if (it-&gt;second &gt;= 4) &#123; printf("%d %d %d %d\n", it-&gt;first, it-&gt;first, it-&gt;first, it-&gt;first); flag = true; break; &#125; it-&gt;second == 1 ? mp.erase(it++) : it++; &#125;#ifdef DBG printf("--------\n"); for (auto it = mp.begin(); it != mp.end(); it++) &#123; printf("%d ", it-&gt;first); &#125; printf("\n--------\n");#endif if (flag) continue; else &#123; double minDiff = DBL_MAX; int a, b; auto it1 = mp.end(); it1--; for (auto it = mp.begin(); it != it1; it++) &#123; auto it2 = it; it2++; double tmp = double(std::max(it2-&gt;first, it-&gt;first)) / double(std::min(it2-&gt;first, it-&gt;first)); if (tmp &lt;= minDiff) &#123; minDiff = tmp; a = it-&gt;first; b = it2-&gt;first; &#125; &#125; printf("%d %d %d %d\n", a, a, b, b); &#125; &#125; return 0;&#125; 【我还有要说的话】 map中调用erase方法之后iterator失效，故不能在循环中直接用erase删除循环变量指向的元素，一种参考做法是这样1234for (auto it = mp.begin(); it != mp.end(); ) &#123; //do something it-&gt;second == 1 ? mp.erase(it++) : it++;&#125; 浮点数的最大最小值不在&lt;climits&gt;里面而在&lt;cfloat&gt;里面 map的迭代器不能+1，但可以++，上面代码中迫不得已YY出来的用法并不优美]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #505(div2) B] Weakened Common Divisor - 枚举 + 质因数分解]]></title>
    <url>%2F2018%2F08%2F21%2FCodeforces_505_B%2F</url>
    <content type="text"><![CDATA[【链接】Codeforces #505(div2) Weakened Common Divisor 【题目描述】定义 $\text{WCD(Weakened Common Divisor)}$ 如下： 对于 $n$ 个二元组 $(a_i, b_i)$ 若存在某个数 $p$ 能被每个二元组的其中至少一个数整除，则称 $p$ 为这些二元组的 $\text{WCD}$。 现给定若干二元组，求他们的 $\text{WCD}$。 【题解】对第一个二元组质因数分解，之后枚举每个质因数看看能不能满足定义。 复杂度$O(n \times \sqrt{a_{max}})$ 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;typedef std::pair&lt;int, int&gt; info;std::vector&lt;int&gt; v;std::vector&lt;info&gt; inv;void calc(int x) &#123; for (int i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) v.push_back(i); while (x % i == 0) x /= i; &#125; if (x &gt; 1) v.push_back(x);&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); if (i == 1) &#123; calc(a); calc(b); &#125; inv.push_back(std::make_pair(a, b)); &#125;#ifdef DBG printf("-------\n"); for (auto &amp;p : v) &#123; printf("%d ", p); &#125; printf("\n-------\n");#endif for (auto &amp;p : v) &#123; bool flag = false; for (auto it = inv.begin(); it != inv.end(); it++) &#123; if (it-&gt;first % p != 0 &amp;&amp; it-&gt;second % p != 0) &#123; flag = true; break; &#125; &#125; if (!flag) &#123; printf("%d\n", p); return 0; &#125; &#125; printf("-1\n"); return 0;&#125; 【TLE代码】123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 150000 + 10;int a[MAXN][2];int main() &#123; int n; scanf("%d", &amp;n); int max = -1; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;a[i][0], &amp;a[i][1]); max = std::max(max, std::max(a[i][0], a[i][1])); &#125; for (int i = 2; i &lt;= max; i++) &#123; bool flag = false; for (int j = 0; j &lt; n; j++) &#123; if (a[j][0] % i == 0 || a[j][1] % i == 0) continue; else &#123; flag = true; break; &#125; &#125; if (!flag) &#123; printf("%d\n", i); return 0; &#125; &#125; printf("-1\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
        <tag>质因数分解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[QDU 门槛题 1010] easy problem - 枚举]]></title>
    <url>%2F2018%2F08%2F08%2FQDU_Entrance_1010%2F</url>
    <content type="text"><![CDATA[【链接】[QDU 59] Easy Problem 【题目描述】给你一个数字$n$，$n$的范围是$1 \dots 1000000$，求一个最小的正整数$m$，这个数字的各个位的数字加上它本身之和恰好为$n$。当然，如果没有解，输出$0$。 【题解】经过观察不难发现 $m$ 各位数之和最大不会超过 $54$，因为这个数字最大不过$999999$ 那么只需要枚举和，以 $n$ 减之，并判断差的各位数之和是否等于枚举得到的和 【代码】1234567891011121314151617181920212223242526#include &lt;cstdio&gt;int main() &#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; bool flag = false; for (int sum = 54; sum &gt;= 1; sum--) &#123; int rest = n - sum; if (rest &lt;= 0) continue; else &#123; int tmp = 0, tmp2 = rest; while (tmp2 != 0) &#123; tmp += (tmp2 % 10); tmp2 /= 10; &#125; if (tmp == sum) &#123; printf("%d\n", rest); flag = true; break; &#125; &#125; &#125; if (!flag) printf("0"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #500(div2) D] Chemical table - 并查集]]></title>
    <url>%2F2018%2F07%2F31%2FCodeforces_500_D%2F</url>
    <content type="text"><![CDATA[【链接】Codeforces #500(div2) Chemical table 【题目描述】给定一个网格图，其中一些格子里放有一些「元素」，对于这样的三个元素$e_1(r_1, c_1), e_2(r_1, c_2), e_3(r_2, c_1)$，可以生成第四个元素$e_4(r_2, c_2)$ 问给定初始的一些元素，最少需要额外添加多少元素能使得整个表格被填满。 【题解】这里用到一个没见过的很巧妙的转化。 把一个格子看做一行和一列的「连接」，当 $r_1$ 和 $c_1$，$r_1$ 和 $c_2$，$r_2$ 和 $c_1$ 都相应地联系起来时，$r_2$ 和 $c_2$ 也自然联系起来了。 维护这种集合间的连接关系，就要用到并查集。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;const int MAXN = 200000 * 2 + 10;struct UnionFindSet &#123; int fa[MAXN]; UnionFindSet() &#123; for (int i = 0; i &lt; MAXN; i++) &#123; fa[i] = i; &#125; &#125; int find(int x) &#123; //return fa[x] == x ? x : find(fa[x]); if (fa[x] != x) fa[x] = find(fa[x]); return fa[x]; &#125; void merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); fa[r1] = r2; &#125;&#125; ufs;int main() &#123; int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 0; i &lt; q; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; y += n; ufs.merge(x, y); &#125; int ans = -1; for (int i = 1; i &lt;= n + m; i++) &#123; if (ufs.fa[i] == i) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷 P2341 / HAOI2006] 受欢迎的牛 - 强连通分量]]></title>
    <url>%2F2018%2F07%2F02%2Fluogup3241%2F</url>
    <content type="text"><![CDATA[【链接】P2341 [HAOI2006]受欢迎的牛 【题目描述】每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果$A$喜欢$B$，$B$喜欢$C$，那么$A$也喜欢$C$。牛栏里共有$n$头奶牛，给定一些奶牛之间的爱慕关系，请你算出有多少头奶牛可以当明星。 【题解】Tarjan求出所有强连通分量，把每个强连通分量看做一个 超级点 ，缩点后输出出度为 $0$ 的点所对应的强连通分量的大小，若有不止一个点出度为 $0$ ，则无解，输出 $0$ 。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAXN = 10000 + 10;struct Node;struct Edge;struct SCC;struct Node &#123; Edge *edges; bool vis, inStack; int dfn, low, sccNum, outEdge;&#125; nodes[MAXN], newMap[MAXN];struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;;void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v); u-&gt;outEdge++;&#125;struct SCC &#123; std::vector&lt;Node *&gt; nodes; &#125;;std::vector&lt;SCC *&gt; scc;int index = 0;std::stack&lt;Node *&gt; s;void tarjan(Node *x) &#123; x-&gt;low = x-&gt;dfn = ++index; x-&gt;vis = true; x-&gt;inStack = true; s.push(x); for (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123; if (!e-&gt;to-&gt;vis) &#123; tarjan(e-&gt;to); x-&gt;low = std::min(x-&gt;low, e-&gt;to-&gt;low); &#125; else if (e-&gt;to-&gt;inStack) &#123; x-&gt;low = std::min(x-&gt;low, e-&gt;to-&gt;dfn); &#125; &#125; if (x-&gt;low == x-&gt;dfn) &#123; SCC *newOne = new SCC(); Node *v; do &#123; v = s.top(); v-&gt;sccNum = scc.size(); v-&gt;inStack = false; s.pop(); newOne-&gt;nodes.push_back(v); &#125; while (x != v); scc.push_back(newOne); &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); u--, v--; addEdge(nodes + u, nodes + v); &#125; for (int i = 0; i &lt; n; i++) &#123; if (!nodes[i].vis) tarjan(nodes + i); &#125; for (auto it = scc.begin(); it != scc.end(); it++) &#123; for (auto it1 = (*it)-&gt;nodes.begin(); it1 != (*it)-&gt;nodes.end(); it1++) &#123; for (Edge *e = (*it1)-&gt;edges; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;sccNum != (*it1)-&gt;sccNum) addEdge(newMap + (*it1)-&gt;sccNum, newMap + e-&gt;to-&gt;sccNum); &#125; &#125; &#125; std::vector&lt;int&gt; popular; for (int i = 0; i &lt; scc.size(); i++) &#123; if (newMap[i].outEdge == 0) popular.push_back(i); &#125; if (popular.size() != 1) printf("0\n"); else printf("%d\n", scc[popular[0]]-&gt;nodes.size()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan强连通分量学习笔记]]></title>
    <url>%2F2018%2F06%2F28%2Ftarjan_note%2F</url>
    <content type="text"><![CDATA[看了这篇文章(《全网最!详!细!tarjan算法讲解》)终于学会了 Tarjan 求强连通分量的算法 一些概念弱连通图将 有向图 的所有的有向边替换为无向边，所得到的图称为原图的基图。如果一个有向图的基图是连通图，则有向图是 弱连通图。 强连通在一个 有向图 $G$ 中，如果两个点之间能够从一个点到达另一个点，则这两个点 连通，相对的，如果两个点之间能够 相互 到达，则这两个点 强连通。 强连通图在一个 有向图 $G$ 中，如果 任意 两点都是强连通的，那么这个图为 强连通图。 强连通分量对于一个有向 非 强连通图，其 极大强连通子图 为其 强连通分量。注意是指 极大 而非 最大。 Tarjan算法复杂度可以在 $O(N + M)$ 的时间内求出图中所有的强连通分量。 一些定义 $\text{dfn[ ]}$ : 时间戳，表示这个点是第几个被搜索到的，每个点的 $\text{dfn}$ 都不同。 $\text{low[ ]}$ : 这个点所能到达的点中在搜索树中为这个点的祖先且 $\text{dfn}$ 最小的点的 $\text{dfn}$ (有点拗口)。 算法概述 这个算法的核心是一次DFS，它基于这样一个事实：强连通分量中的点一定存在于搜索树上的同一棵子树当中。 我们使用栈来存储强连通分量中的点。 算法流程如下 从点 $x$ 开始DFS。令x-&gt;low = x-&gt;dfn = ++index，其中 index 为计数器。将 $x$ 标记为已访问。将 $x$ 扔入栈中，记录其 已入栈 的状态。 枚举起点连出去的每一条边。 若该边的终点未被访问过，则DFS进入该点，并更新x-&gt;low = min(x-&gt;low, e-&gt;to-&gt;low) 若该边的终点已在栈中，即找到了一条指向自己在搜索树中的祖先的边，则更新x-&gt;low = min(x-&gt;low, e-&gt;to-&gt;dfn) 所有邻接点回溯完成后，若当前点仍满足low == dfn，即在搜索的过程中该点为该子树的根，则让该点之后进栈的点全部出栈，并将其标记为一个强连通分量。 对于一个强连通分量中的所有点，其 $\text{low}$ 都是相同的，该命题的逆命题同样成立。 代码在实际应用的过程中，整个图不一定是弱联通的，所以要对每一个未访问过的点都进行一遍该算法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;const int MAXN = 10000 + 10;struct Node;struct Edge;struct Connection;struct Node &#123; int dfn, low; Edge *edges; bool inStack, visited;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;;struct Connection &#123; int size;&#125;;std::vector&lt;Connection *&gt; connections;void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v);&#125;int sum, index;std::stack&lt;Node *&gt; s;void tarjan(Node *x) &#123; x-&gt;dfn = x-&gt;low = ++index; x-&gt;visited = true; x-&gt;inStack = true; s.push(x); for (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123; if (!e-&gt;to-&gt;visited) &#123; tarjan(e-&gt;to); x-&gt;low = std::min(x-&gt;low, e-&gt;to-&gt;low); &#125; else if (e-&gt;to-&gt;inStack) &#123; x-&gt;low = std::min(x-&gt;low, e-&gt;to-&gt;dfn); &#125; &#125; if (x-&gt;low == x-&gt;dfn) &#123; Connection *connection = new Connection(); Node *v; do &#123; v = s.top(); v-&gt;inStack = false; s.pop(); connection-&gt;size++; &#125; while (x != v); connections.push_back(connection); &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(nodes + u, nodes + v); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!nodes[i].visited) tarjan(nodes + i); &#125; for (std::vector&lt;Connection *&gt;::iterator it = connections.begin(); it != connections.end(); it++) &#123; if ((*it)-&gt;size &gt; 1) sum++; &#125; printf("%d\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数学】- 交替和]]></title>
    <url>%2F2018%2F03%2F02%2FMath_Set%2F</url>
    <content type="text"><![CDATA[【题目】 对于集合$ N = {1, 2, 3, \dots, n } $的每一个非空子集，定义一个「交替和」如下： 按照递减的顺序重新排列该子集，然后从最大数开始交替地减、加其后继数。 例如：当集合$N = {1, 2}$ 时，其所有非空子集为 ${1}, {2}, {1, 2}$，则它的所有交替和的总和为 S_2 = 1 + 2 + (2 - 1) = 4现有一 $n$ 元集合$N = {1, 2, 3, \dots, n}$，求其交替和的总和。 【解】考虑集合$M = {1, 2, \dots, {n-1}}$，记其交替和的总和为$S_{n - 1}$，则在其中添加一个元素$n$之后，构成集合$N$，此时所有的非空子集包括三种： $M$ 所有的非空子集。交替和的总和为$S_{n-1}$ $M$ 所有的非空子集中都添加一个$n$。这时由交替和的定义可得对于某个集合，增加一个$n$会使其交替和 $Si$ 变为 $n - S_i$，因此在这种情况下交替和的总和为 $2^{n-2} \times n - S{n-1}$ ${n}$。交替和的总和为$n$ 故最终答案为$S{n - 1} + 2^{n - 2} \times n - S{n - 1} + n$，即$n \times 2^{n - 1}$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST 表模板]]></title>
    <url>%2F2017%2F11%2F08%2FS_Table%2F</url>
    <content type="text"><![CDATA[ST 表的模板题，有一些加一减一的地方要注意 【链接】Poj 3264 Balanced Lineup 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;cmath&gt;const int MAXN = 200000 + 10;const int MAXLOG = 18; // ln(MAXN) = 17.609int a[MAXN];int f[MAXN][MAXLOG + 1];int g[MAXN][MAXLOG + 1];void prepare(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][0] = a[i]; g[i][0] = a[i]; &#125; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) &lt;= n + 1; i++) &#123; f[i][j] = std::max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); g[i][j] = std::min(g[i][j - 1], g[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int query(int l, int r) &#123; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; //int k = log2(r - l + 1); int max = std::max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]); int min = std::min(g[l][k], g[r - (1 &lt;&lt; k) + 1][k]); return max - min;&#125;int main() &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; prepare(n); for (int i = 1; i &lt;= q; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", query(l, r)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>整理</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组拓展]]></title>
    <url>%2F2017%2F11%2F07%2Fexbit%2F</url>
    <content type="text"><![CDATA[被 WangLL 拐去学习了树状数组的一些拓展用法，当然可以用线段树做，但是树状数组似乎更好写一点 区间修改 单点查询考虑正常的树状数组可以做些什么。 「单点修改」 「前缀查询」 回忆我们学习的差分，可以把 区间修改 转移到差分数组的 单点修改，可以把 单点查询 转移到差分数组的 前缀查询，发现这正好是树状数组可以做的事情，所以我们维护一个差分数组 $C$ ，对这个数组建立树状数组. 对于原数组的区间$[l, r]$进行的修改，不去对原数组进行操作，而是对差分数组进行单点修改modify(l, delta)，modify(r + 1, delta)。 对于原数组的 $index$ 位置的单点查询，对差分数组进行前缀查询query(index)，求出原数组的变化量，再加上原数组的值即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN=500000+10;int n,m,a[MAXN],c[MAXN];int lowbit(int k)&#123; return k&amp;-k;&#125;void add(int x, int p)&#123; while(x&lt;=n)&#123; c[x]+=p; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int ans=0; while(x&gt;0)&#123; ans+=c[x]; x-=lowbit(x); &#125; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for (int i=1; i&lt;=n; i++)&#123; scanf("%d",&amp;a[i]); &#125; for (int x,y,z,i=1; i&lt;=m; i++)&#123; scanf("%d",&amp;x); if(x==1)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; add(x,z); add(y+1,-z); continue; &#125; if (x==2)&#123; cin&gt;&gt;x; printf("%d\n",a[x]+sum(x)); &#125; &#125; return 0;&#125; 区间修改 区间查询延续刚才的思路，区间修改仍然是刚才的方法，对于区间查询，依然可以表示为原值 + 变化量的形式。 \begin{equation} \begin{split} sum[x] &= \sum_{i = 1}^x a[i] + \sum_{i = 1}^x delta[i] \times (x - i + 1) \\ &= \sum_{i = 1}^x a[i] + \sum_{i = 1}^x delta[i] \times [(x + 1) - i] \\ &= \sum_{i = 1}^x a[i] + \sum_{i = 1}^x delta[i] \times (x - 1) - \sum_{i = 1}^x i \times delta[i] \\ &= \sum_{i = 1}^x a[i] + (x - 1)\sum_{i = 1}^xdelta[i] - \sum_{i = 1}^x i \times delta[i] \end{split} \end{equation}上式中的$sum[x]$表示变化的前缀和，$delta[x]$表示差分数组。 上式中的 \sum_{i = 1}^x a[i]可以预处理得到， (x - 1)\sum_{i = 1}^x delta[i]和 \sum_{i = 1}^x i \times delta[i]两个值我们使用两个树状数组进行维护 这样我们在查询区间和的时候，直接sum[r] - sum[l - 1]即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN=500000+10;int n,m;long long suml,sumr,a[MAXN],c[MAXN],deltac[MAXN],sum[MAXN];int lowbit(int k)&#123; return k&amp;-k;&#125;void deltaAdd(int x, int p)&#123; while(x&lt;=n)&#123; deltac[x]+=p; x+=lowbit(x); &#125;&#125;void Add(int x, int p)&#123; while(x&lt;=n)&#123; c[x]+=p; x+=lowbit(x); &#125;&#125;long long deltaSum(int x)&#123; long long ans=0; while(x&gt;0)&#123; ans+=deltac[x]; x-=lowbit(x); &#125; return ans;&#125;long long Sum(int x)&#123; long long ans=0; while(x&gt;0)&#123; ans+=c[x]; x-=lowbit(x); &#125; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for (int i=1; i&lt;=n; i++)&#123; scanf("%lld",&amp;a[i]); sum[i]+=a[i]+sum[i-1]; &#125; for (int x,y,z,i=1; i&lt;=m; i++)&#123; scanf("%d",&amp;x); if(x==1)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; Add(x,z); Add(y+1,-z); deltaAdd(x,x*z); deltaAdd(y+1,(y+1)*-z); continue; &#125; if (x==2)&#123; cin&gt;&gt;x&gt;&gt;y; suml=sum[x-1]+x*Sum(x-1)-deltaSum(x-1); sumr=sum[y]+(y+1)*Sum(y)-deltaSum(y); printf("%lld\n",sumr-suml); &#125; &#125; return 0;&#125; 其他感谢 WangLL 同学提供的代码]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组模板]]></title>
    <url>%2F2017%2F11%2F06%2Fbit%2F</url>
    <content type="text"><![CDATA[树状数组是一种支持单点修改前缀查询的数据结构。 可以在 部分场合，一定程度 代替线段树。 灵魂操作1int lowbit(int x) &#123;return x &amp; -x;&#125; 其他操作123456789101112131415void modify(int index, int delta) &#123; while (index &lt;= n) &#123; a[index] += delta; index += lowbit(index); &#125;&#125;int query(int index) &#123; int ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowbit(index); &#125; return ans;&#125; 完整代码123456789101112131415161718192021struct Bit &#123; int a[MAXN]; int lowbit(int x) &#123;return x &amp; -x;&#125; void modify(int index, int delta) &#123; while (index &lt;= n) &#123; a[index] += delta; index += lowbit(index); &#125; &#125; int query(int index) &#123; int ans = 0; while (index &gt; 0) &#123; ans += a[index]; index -= lowbit(index); &#125; return ans; &#125;&#125; bit; 注意事项 初始化a数组的时候要用bit.modify()函数 区间和查询相当于两个前缀和相减，是bit.query(r) - bit.query(l - 1) 不用理解背过就行]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「lyx_tst 系列」lyx 的小迷妹 - 最短路]]></title>
    <url>%2F2017%2F11%2F05%2Flyx_tst_4%2F</url>
    <content type="text"><![CDATA[【链接】「lyx_tst 系列」lyx 的小迷妹 【题目描述】lyx 一脚踢倒了关押 tst 小黑屋的门，说时迟那时快，杨教授扛起 tst 就是一个百米冲刺。杨教授跑到四院门口，迎面来了一辆公交车，他不假思索的冲了上去。 市内有 $n$ 个路口和 $m$ 条双向道路，每条道路都有过路费，第 $i$ 条道路的过路费为 $w_i$ 元。市内还有 $k$ 条公交线路，公交车只在路口停靠，而且一路公交车只会沿着固定的线路往返行驶。上第 $i$ 路公交车需要 $b_i$ 元的费用，但费用是一次性的，即你可以在公交线路上的任意停靠路口下车。但是一旦下车了，如果要再次上车，则还需要再次付费。 路痴 lyx 有点迷茫，杨教授在全市乱跑，她要从路口 $s$ 怎么行动，才能到每个路口的费用最小？ （我跟你们嗦，lyx 呀，怎么这么可爱啊！ 【输入描述】第一行四个整数 $n$、$m$、$k$ 和 $s$，分别代表路口数、道路数、公交线路数和 lyx 所处的路口编号。 接下来的 $m$ 行，每行三个整数 $u_i$、$v_i$ 和 $w_i$ ，代表第 i $i$ i 条道路连接 $u_i$ 路口和 $v_i$路口，并且通过这条道路需要缴纳 $w_i$ 元的过路费。 接下来的 $k$ 行，每行首先是两个整数 $b_i$ 和 $t_i$ ，代表第 $i$ 路公交车的上车费用为 $b_i$ 元，而且公交线路共有 $t_i$ 个停靠路口。接下来同一行内有 $t_i$ 个整数，按顺序给出了这路公交车的各个停靠路口。 【输出描述】一行 $n$ 个整数，表示从路口 $s$ 到每个路口的最小费用。 【题解】明显是最短路，重点是车站怎么处理，只要给车站建一个虚拟点，从可以坐车的地方到车站连一条边权为上车费用的边，车站虚拟点到每个可以停车的点连一条边权为$0$的边，跑最短路即可 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;climits&gt;const int MAXN = 200000 + 10;const int MAXK = 5000 + 10;struct Node;struct Edge;struct Node &#123; Edge *edges; long long dis; Node() : edges(NULL), dis(LLONG_MAX) &#123;&#125;&#125; nodes[MAXN + MAXK];struct Edge &#123; Node *fr, *to; long long w; Edge *next; Edge(Node *fr, Node *to, long long w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;void addEdge(Node *u, Node *v, long long w) &#123; u-&gt;edges = new Edge(u, v, w);&#125;void dijkstra(Node *x) &#123; typedef std::pair&lt;long long, Node*&gt; info; std::priority_queue&lt;info, std::vector&lt;info&gt;, std::greater&lt;info&gt; &gt; pq; x-&gt;dis = 0; pq.push(std::make_pair(0, x)); while (!pq.empty()) &#123; info x = pq.top(); pq.pop(); if (x.second-&gt;dis != x.first) continue; for (Edge *e = x.second-&gt;edges; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;dis &gt; e-&gt;w + x.second-&gt;dis) &#123; e-&gt;to-&gt;dis = e-&gt;w + x.second-&gt;dis; pq.push(std::make_pair(e-&gt;to-&gt;dis, e-&gt;to)); &#125; &#125; &#125;&#125;int main() &#123;#ifndef tst freopen("lyx_tst.in", "r", stdin); freopen("lyx_tst.out", "w", stdout);#endif int n, m, k, s; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;s); for (int i = 1; i &lt;= m; i++) &#123; int u, v; long long w; scanf("%d%d%lld", &amp;u, &amp;v, &amp;w); addEdge(nodes + u, nodes + v, w); addEdge(nodes + v, nodes + u, w); &#125; for (int i = n + 1; i &lt;= n + k; i++) &#123; long long b; int t; scanf("%lld%d", &amp;b, &amp;t); while (t--) &#123; int tmp; scanf("%d", &amp;tmp); addEdge(nodes + tmp, nodes + i, b); addEdge(nodes + i, nodes + tmp, 0); &#125; &#125; dijkstra(nodes + s); for (int i = 1; i &lt;= n; i++) &#123; printf("%lld ", nodes[i].dis); &#125; printf("\n");#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>这是一个系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ 2777] Count Color - 线段树 + 状态压缩]]></title>
    <url>%2F2017%2F11%2F05%2FPOJ_2777%2F</url>
    <content type="text"><![CDATA[【链接】POJ 2777 Count Color 【题目描述】给出一个区间，每次选择一个子区间染色，每次询问某个区间内颜色种类数 【题解】线段树，发现颜色 种类 数在合并的时候不能简单相加，而是 并集 操作，想到愤怒的小鸟一题中取并集的方法，考虑状态压缩，因为颜色种类数并不多，所以可以把状态压入一个int里面，建立线段树即可 调了很久发现是自己手算算错 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100000 + 10;int a[MAXN];int count(int n) &#123; //0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位 n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); //0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位 n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); //0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位 n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); //0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位 n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); //0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位 n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n; &#125;void printBinary(int x) &#123; while (x &gt; 0) &#123; printf("%d", x % 2); x /= 2; &#125; printf("\n");&#125;struct SegmentTree &#123; int l, r, mid; SegmentTree *lc, *rc; int tag; int color; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; lc = rc = NULL; color = 0; tag = 0; &#125; void update() &#123; color = 0; if (lc) color |= lc-&gt;color; if (rc) color |= rc-&gt;color; &#125; void build() &#123; if (r - l == 1) color = a[l]; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void addTag(int tag) &#123; this-&gt;tag = tag; color = 0; color |= (1 &lt;&lt; (tag - 1)); &#125; void pushDown() &#123; if (tag) &#123; if (lc) lc-&gt;addTag(tag); if (rc) rc-&gt;addTag(tag); tag = 0; &#125; &#125; int query(int l, int r) &#123; // int ans = 0; // if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return count(color); // else &#123; // pushDown(); // if (l &lt; mid) ans += lc-&gt;query(l, std::min(mid, r)); // if (r &gt; mid) ans += rc-&gt;query(std::max(l, mid), r); // return ans; // &#125; int ans = 0; if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return color; else &#123; pushDown(); if (l &lt; mid) ans |= lc-&gt;query(l, std::min(mid, r)); if (r &gt; mid) ans |= rc-&gt;query(std::max(l, mid), r); return ans; &#125; &#125; void modify(int l, int r, int delta) &#123; if (this-&gt;l == l &amp;&amp; this-&gt;r == r) &#123; addTag(delta); &#125; else &#123; pushDown(); if (l &lt; mid) lc-&gt;modify(l, std::min(mid, r), delta); if (r &gt; mid) rc-&gt;modify(std::max(l, mid), r, delta); update(); &#125; &#125;&#125;;void printColor(SegmentTree *x) &#123; printf("[%d, %d]:\n", x-&gt;l, x-&gt;r - 1); printf(" tag = %d\n", x-&gt;tag); printf(" color = %d =&gt;", x-&gt;color); printBinary(x-&gt;color); if (x-&gt;lc) printColor(x-&gt;lc); if (x-&gt;rc) printColor(x-&gt;rc);&#125;int main() &#123; int l, t, o; while (scanf("%d%d%d", &amp;l, &amp;t, &amp;o) == 3) &#123; std::fill(a + 1, a + l + 1, 1); SegmentTree root(1, l + 1); root.build(); getchar(); for (int i = 1; i &lt;= o; i++) &#123; char op; op = getchar(); if (op == 'C') &#123; int l, r, delta; if (r &lt; l) std::swap(l ,r); scanf("%d%d%d", &amp;l, &amp;r, &amp;delta); root.modify(l, r + 1, delta);#ifdef DBG printf("---------\n"); printColor(&amp;root); printf("---------\n");#endif &#125; else &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); if (r &lt; l) std::swap(l, r); printf("%d\n", count(root.query(l, r + 1))); &#125; getchar(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「lyx_tst 系列」lyx 超强超满足 - BFS]]></title>
    <url>%2F2017%2F11%2F04%2Flyx_tst_3%2F</url>
    <content type="text"><![CDATA[【链接】 「lyx_tst 系列」lyx 超强超满足 【题目描述】 神犇 lyx 得到了足够的线索，来到了临沂第四人民医院，去拯救即将被教育的 tst 。她发现整个医院可以看做一个矩阵，tst 肯定在某个房间里。房间类型如下： -，普通房间，无任何特殊性质； *，墙，不可进入或经过； L、Y、X，普通传送门，可以传送到相同字符的任意房间； (、)，配对传送门，只能传送到相反的括号，即 ( 可以传送到任意一个 )，) 可以传送到任意一个 (。lyx 不愧是 lyx，她早就根据线索推导出 tst 的位置 $T$ ，已知 lyx 所在的位置为 $S$ ，现在她想在最短的时间内救出 tst。 走到传送门时可以选择使用传送门，使用传送门不会消耗时间，如果不使用传送门，则相当于经过一个普通房间。在四连通的房间之间可以花费 $k$ 时间移动。 （我跟你们嗦，lyx 啊，超强！ 【输入描述】第一行两个正整数 $n$ 和 $m$ ，表示矩阵大小为 $n$ 行 $m$ 列。 第二行四个正整数 $a_S, b_S, a_T, b_T$，表示起点为第 $a_S$ 行 $b_S$ 列，终点为第 $a_T$ 行第 $b_T$ 列。 第三行一个正整数 $k$，表示每走一步需要消耗的时间。 之后的 $n$ 行，每行 $m$ 个字符，表示矩阵中格子的类型。 【输出描述】一行一个整数，表示所用的最短时间。由于某些特♂殊的原因，你需要输出答案对第 $520$ 个质数取模后的结果。 如果 tst 一生都等不到 lyx 去救他，请输出 please go home to sleep。 【题解】普通的BFS. 遇到传送门的时候就把它对面那个传送门一并扔到队列里，但是步数不加，注意可以不走传送门，所以先处理正常走路的情况，然后再处理传送门的情况 代码里很多重复的地方，感觉写个函数能一下短不少，不过复制粘贴几次也不是什么很难的事情 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 800 + 10;const int MOD = 3727;int dx[] = &#123;0, 0, -1, 1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;char g[MAXN][MAXN];bool vis[MAXN][MAXN];struct Node &#123; int x, y; bool isL, isY, isX, isLeft, isRight; int dis; Node(int x = 0, int y = 0) : x(x), y(y) &#123; isL = isY = isX = isLeft = isRight = false; dis = -1; &#125;&#125; nodes[MAXN * MAXN];std::vector&lt;Node&gt; l;std::vector&lt;Node&gt; y;std::vector&lt;Node&gt; x;std::vector&lt;Node&gt; left;std::vector&lt;Node&gt; right;int main() &#123;#ifndef tst freopen("lyx_tst.in", "r", stdin); freopen("lyx_tst.out", "w", stdout);#endif int n, m; scanf("%d%d", &amp;n, &amp;m); int x1, y1, x2, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); int k; scanf("%d", &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", g[i] + 1); for (int j = 1; j &lt;= m; j++) &#123; if (g[i][j] == 'L') l.push_back(Node(i, j)); else if (g[i][j] == 'Y') y.push_back(Node(i, j)); else if (g[i][j] == 'X') x.push_back(Node(i, j)); else if (g[i][j] == '(') left.push_back(Node(i, j)); else if (g[i][j] == ')') right.push_back(Node(i, j)); &#125; &#125; Node s(x1, y1); if (g[x1][y1] == 'L') s.isL = true; else if (g[x1][y1] == 'Y') s.isY = true; else if (g[x1][y1] == 'X') s.isX = true; else if (g[x1][y1] == '(') s.isLeft = true; else if (g[x1][y1] == ')') s.isRight = true; std::queue&lt;Node&gt; q; s.dis = 0; q.push(s); vis[x1][y1] = true; while (!q.empty()) &#123; Node v = q.front(); q.pop(); if (v.x == x2 &amp;&amp; v.y == y2) &#123; printf("%d\n", v.dis); return 0; &#125; int xx = v.x, yy = v.y; for (int i = 0; i &lt; 4; i++) &#123; if (xx + dx[i] &lt;= 0 || yy + dy[i] &lt;= 0) continue; if (!vis[xx + dx[i]][yy + dy[i]] &amp;&amp; g[xx + dx[i]][yy + dy[i]] != '*') &#123; Node tmp(xx + dx[i], yy + dy[i]); if (g[xx + dx[i]][yy + dy[i]] == 'L') tmp.isL = true; else if (g[xx + dx[i]][yy + dy[i]] == 'Y') tmp.isY = true; else if (g[xx + dx[i]][yy + dy[i]] == 'X') tmp.isX = true; else if (g[xx + dx[i]][yy + dy[i]] == '(') tmp.isLeft = true; else if (g[xx + dx[i]][yy + dy[i]] == ')') tmp.isRight = true; vis[xx + dx[i]][yy + dy[i]] = true; tmp.dis = v.dis + k; tmp.dis %= MOD; q.push(tmp); &#125; &#125; if (v.isL) &#123; for (std::vector&lt;Node&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; if (!vis[it-&gt;x][it-&gt;y]) &#123; Node tmp(it-&gt;x, it-&gt;y); tmp.dis = v.dis; q.push(tmp); vis[it-&gt;x][it-&gt;y] = true; &#125; &#125; &#125; else if (v.isY) &#123; for (std::vector&lt;Node&gt;::iterator it = y.begin(); it != y.end(); it++) &#123; if (!vis[it-&gt;x][it-&gt;y]) &#123; Node tmp(it-&gt;x, it-&gt;y); tmp.dis = v.dis; q.push(tmp); vis[it-&gt;x][it-&gt;y] = true; &#125; &#125; &#125; else if (v.isX) &#123; for (std::vector&lt;Node&gt;::iterator it = x.begin(); it != x.end(); it++) &#123; if (!vis[it-&gt;x][it-&gt;y]) &#123; Node tmp(it-&gt;x, it-&gt;y); tmp.dis = v.dis; q.push(tmp); vis[it-&gt;x][it-&gt;y] = true; &#125; &#125; &#125; else if (v.isLeft) &#123; for (std::vector&lt;Node&gt;::iterator it = right.begin(); it != right.end(); it++) &#123; if (!vis[it-&gt;x][it-&gt;y]) &#123; Node tmp(it-&gt;x, it-&gt;y); tmp.dis = v.dis; q.push(tmp); vis[it-&gt;x][it-&gt;y] = true; &#125; &#125; &#125; else if (v.isRight) &#123; for (std::vector&lt;Node&gt;::iterator it = left.begin(); it != left.end(); it++) &#123; if (!vis[it-&gt;x][it-&gt;y]) &#123; Node tmp(it-&gt;x, it-&gt;y); tmp.dis = v.dis; q.push(tmp); vis[it-&gt;x][it-&gt;y] = true; &#125; &#125; &#125; &#125; printf("please go home to sleep\n");#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>这是一个系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「lyx_tst 系列」沉迷于 tst 女装的 lyx - 递推 + 矩乘]]></title>
    <url>%2F2017%2F11%2F04%2Flyx_tst_1%2F</url>
    <content type="text"><![CDATA[【链接】「lyx_tst 系列」沉迷于 tst 女装的 lyx 【题目描述】很久很久以前，有个 OI 界的 dalao，是个风流倜傥、玉树临风、目若朗星、仪表堂堂的，妹子。她叫做 lyx，这么一个迷倒万千少女的人自从在某晚目睹了 tst 穿女装后，沉迷于此无法自拔，日渐消瘦。 不久后，tst 被邪恶的团长困在了一座台阶为 $N$ 的高塔里【tst：QVQ】，团长向世界上的各单位提供了丰富的悬赏，如果有人能数出自己走上高塔的走法，那么就让 tst 穿小旗袍给那个人看。 听说了这个消息，lyx 跑的比香港记者还快╭(`З’)╯，马上来到了高塔下。她比量了一下自己脖子以下全是腿的长度，大致计算了一下。 已知 lyx 每次只能走一级、两级、三级或四级 【lyx 腿长有两米八！(๑´ㅂ`๑)】。 （我跟你们嗦，tst 的女装，棒！(๑•̀ㅂ•́)و✧）（说完 tst 提着 $\mathrm{40m}$ 长的大刀赶来了我也不知道为什么） 【输入描述】一行一个整数 $N$，表示团长囚禁 tst 的塔所拥有的台阶数。 【输出描述】一行一个整数，表示 lyx 登上塔顶可能的方案数。由于某些特殊的原因，答案对第 $201314$ 个质数取模。 【题解】易得递推式为： f(i) = f(i - 1) + f(i - 2) + f(i - 3) + f(i - 4) f(1) = f(0) = 1, f(2) = 2, f(3) = 4, f(4) = 8构造初始矩阵为 \begin{bmatrix} 1 & 2 & 4 & 8 \end{bmatrix}转移矩阵为 \begin{bmatrix} 0 & 0 & 0 & 1 \\ 1 & 0 & 0 & 1 \\ 0 & 1 & 0 & 1 \\ 0 & 0 & 1 & 1 \end{bmatrix}直接计算快速幂即可。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MOD = 2769433;struct Matrix &#123; int sizeX, sizeY; long long a[4][4]; Matrix(int sizeX = 0, int sizeY = 0) : sizeX(sizeX), sizeY(sizeY) &#123; memset(a, 0, sizeof(a)); &#125; Matrix operator*(const Matrix &amp;a) const &#123; Matrix ans(sizeX, a.sizeY); for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; a.sizeY; j++) &#123; for (int k = 0; k &lt; sizeY; k++) &#123; ans.a[i][j] += (this-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD; ans.a[i][j] %= MOD; &#125; &#125; &#125; return ans; &#125; void operator=(const Matrix &amp;a) &#123; for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; sizeY; j++) &#123; this-&gt;a[i][j] = a.a[i][j]; &#125; &#125; &#125; void print() &#123; for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; sizeY; j++) &#123; printf("%lld ", a[i][j]); &#125; printf("\n"); &#125; &#125;&#125;;Matrix fastPowMod(Matrix m, unsigned long long n) &#123; if (n == 0) &#123; Matrix ans(4, 4); ans.a[0][0] = 1; ans.a[1][1] = 1; ans.a[2][2] = 1; ans.a[3][3] = 1; return ans; &#125; else if (n == 1) return m; else if (n &amp; 1) return fastPowMod(m, n - 1) * m; else return fastPowMod(m * m, n &gt;&gt; 1);&#125;int main() &#123;#ifndef tst freopen("lyx_tst.in", "r", stdin); freopen("lyx_tst.out", "w", stdout);#endif unsigned long long n; scanf("%llu", &amp;n); Matrix begin(1, 4); Matrix change(4, 4); begin.a[0][0] = 1; begin.a[0][1] = 2; begin.a[0][2] = 4; begin.a[0][3] = 8; change.a[0][0] = 0; change.a[0][1] = 0; change.a[0][2] = 0; change.a[0][3] = 1; change.a[1][0] = 1; change.a[1][1] = 0; change.a[1][2] = 0; change.a[1][3] = 1; change.a[2][0] = 0; change.a[2][1] = 1; change.a[2][2] = 0; change.a[2][3] = 1; change.a[3][0] = 0; change.a[3][1] = 0; change.a[3][2] = 1; change.a[3][3] = 1; // begin.print(); // change.print(); // begin = begin * change; // begin.print(); if (n == 0) &#123; printf("1\n"); &#125; else if (n == 1) &#123; printf("1\n"); &#125; else if (n == 2) &#123; printf("2\n"); &#125; else if (n == 3) &#123; printf("4\n"); &#125; else if (n == 4) &#123; printf("8\n"); &#125; else &#123; change = fastPowMod(change, n - 4); begin = begin * change; printf("%lld\n", begin.a[0][3]); &#125;#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125; 【写的时候犯的错误】 没用long long 初始矩阵计算错误 构造函数里没有对数组清零]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>这是一个系列</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「lyx_tst 系列」lyx 最神啦 - 序列DP]]></title>
    <url>%2F2017%2F11%2F04%2Flyx_tst_2%2F</url>
    <content type="text"><![CDATA[【链接】「lyx_tst 系列」lyx 最神啦 【题目描述】由于磁暴步兵杨教授的罪恶统治，LYOI 的很多同学都被抓去临沂第四院（简称 lydsy）进行爱♂的♂教♂育。某天，神犇 lyx 发现 tst 不见了，为了找到 tst，她决定走出机房，到校园去找线索。路线可看做数轴，数轴上有连续的 $n$ 个点，第 $i$ 个点有 $a_i$ 名同学，lyx 可以在每个同学那里得知一条线索。 lyx 一开始停留在第 $i$ 个点上， 她每次可以选择左边第一个未停留过的点或右边第一个未停留过的点，在那个点上停留并询问一条线索；也可以在当前点停下来不继续询问。最终 lyx 获得的总线索为她访问过的点的数量加上最终停下来时所在点的线索量。 为了让 lyx 有把握地解救 tst，你需要求出对于每一个 $i$ ，lyx 可以获得的最大线索量。由于某些特♂殊的原因，你需要输出答案对第$5201314$个质数取模后的结果。 （我跟你们嗦，lyx 呀，太神辣！ 【输入描述】第一行一个正整数 $n$。 之后的 $n$ 行，每行一个正整数 $a_i$ 【输出描述】共 $n$ 行，每行一个正整数，第 $i$ 行表示 lyx 的起点为 $i$ 时的答案对第 $5201314$ 个质数取模后的结果。 【题解】序列DP 在起点的一侧停下来的最优方案肯定是走完另一侧的所有点，最后在这个点停下来 设状态$f(i)$表示到第$i$个位置停下来，且这个位置在起点右边时能获得的最大价值，转移为 f(i) = \max\{ f(i + 1), a(i) + i\}设状态$g(i)$表示到第$j$个位置停下来，且这个位置在起点左边时能获得的最大价值，转移为 g(i) = \max \{ f(i - 1), a(i) + n - i + 1\}注意递推方向 【代码】123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100000 + 10;const int MOD = 89712239;int a[MAXN], f[MAXN], g[MAXN];int main() &#123;#ifndef tst freopen("lyx_tst.in", "r", stdin); freopen("lyx_tst.out", "w", stdout);#endif int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; long long x; scanf("%lld", &amp;x); a[i] = x % MOD; &#125; for (int i = n; i &gt;= 1; i--) f[i] = std::max(f[i + 1], (a[i] + i) % MOD); for (int i = 1; i &lt;= n; i++) g[i] = std::max(g[i - 1], (a[i] + n - i + 1) % MOD); for (int i = 1; i &lt;= n; i++) &#123; int ans = a[i]; ans = std::max(ans, f[i + 1]); ans = std::max(ans, g[i - 1]); printf("%d\n", ans); &#125;#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>序列DP</tag>
        <tag>这是一个系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷 P3939] 数颜色 - 二分查找]]></title>
    <url>%2F2017%2F11%2F03%2Fluogu_P3939%2F</url>
    <content type="text"><![CDATA[【链接】洛谷 P3939 数颜色 【题目描述】小 $C$ 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有相同的颜色。小 $C$ 把她标号从 1 到 $n$ 的 $n$ 只兔子排成长长的一排，来给他们喂胡萝卜吃。 排列完成后，第 $i$ 只兔子的颜色是 $a_i$ 。 俗话说得好，“萝卜青菜，各有所爱”。小 $C$ 发现，不同颜色的兔子可能有对胡萝卜的不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而 绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 $C$ 十分苦恼。所以，为 了使得胡萝卜喂得更加准确，小 C 想知道在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$的兔子。 不过，因为小 $C$ 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同 时，小 $C$ 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 $xj$ 和 $x{j+1}$的两只兔子会交换位置。 小 $C$ 被这一系列麻烦事给难住了。你能帮帮她吗？ 【输入描述】从标准输入中读入数据。 输入第 $1$ 行两个正整数 $n$,$m$。 输入第 $2$ 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$ 输入接下来 mm 行，每行为以下两种中的一种： $1 \ l_j \ r_j \ c_j$ 询问在区间$[l_j, r_j]$中有多少颜色为$c_j$的兔子 $2 \ xj$ 表示$x_j$和$x{j + 1}$交换了位置 【输出描述】输出到标准输出中。 对于每个 1 操作，输出一行一个正整数，表示你对于这个询问的答案。 【题解】乍一看区间操作然后乱搞一发线段树强行维护，然后就MLE了，只有$25$分 通过观察可以发现查询操作可以直接二分查找，具体来说就是记录下每个颜色的兔子的位置，二分找到左边界的那一只和右边界的那一只，两个位置中间的兔子就是在区间中的。 至于修改操作，因为每次都只会修改相邻两只兔子，所以如果两只兔子颜色相同，那是不会影响查询的，那我们就continue掉，如果两个兔子颜色不同，还是二分找到与他相邻的兔子，两者交换一下即可 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAXN = 300000 + 10;std::vector&lt; std::vector&lt;int&gt; &gt; v(MAXN);int a[MAXN];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); v[a[i]].push_back(i); &#125; for (int i = 1; i &lt;= m; i++) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; int l, r, q; scanf("%d%d%d", &amp;l, &amp;r, &amp;q); std::vector&lt;int&gt;::iterator lPos, rPos; lPos = std::lower_bound(v[q].begin(), v[q].end(), l); rPos = std::upper_bound(v[q].begin(), v[q].end(), r); printf("%ld\n", rPos - lPos); &#125; else &#123; int index; scanf("%d", &amp;index); if (a[index] == a[index + 1]) continue; else &#123; int col1 = a[index], col2 = a[index + 1]; std::vector&lt;int&gt;::iterator lPos, rPos; lPos = std::lower_bound(v[col1].begin(), v[col1].end(), index); rPos = std::lower_bound(v[col2].begin(), v[col2].end(), index + 1); std::swap(v[col1][lPos - v[col1].begin()], v[col2][rPos - v[col2].begin()]); //std::swap(col1, col2); a[index] = col2; a[index + 1] = col1; &#125; &#125; &#125; return 0;&#125; MLE代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAXN = 3 * 100000 + 10;struct Node &#123; int color, id; Node(int color = 0, int id = 0) : color(color), id(id) &#123;&#125; bool operator&lt;(const Node &amp;a) const &#123; if (color &lt; a.color) return true; else return id &lt; a.id; &#125; bool operator&gt;(const Node &amp;a) const &#123;return a &lt; *this;&#125; bool operator==(const Node &amp;a) const &#123; if (color == a.color) return true; else if (id == a.id) return true; &#125;&#125;;std::vector&lt;Node&gt; v;int a[MAXN];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); v.push_back(Node(x, i)); a[i] = x; &#125; std::stable_sort(v.begin(), v.end()); // printf("Done\n"); for (int i = 1; i &lt;= m; i++) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; int l, r, q; scanf("%d%d%d", &amp;l, &amp;r, &amp;q); int sum = 0; std::vector&lt;Node&gt;::iterator it = std::lower_bound(v.begin(), v.end(), Node(q, -1));// #ifdef DBG// printf("--------\n");// printf("*it : color = %d, id = %d\n", it-&gt;color, it-&gt;id);// printf("--------\n");// #endif while (it-&gt;color == q) &#123; if (it-&gt;id &gt;= l &amp;&amp; it-&gt;id &lt;= r) &#123; sum++; &#125; it++; &#125; printf("%d\n", sum); &#125; else &#123; int index; scanf("%d", &amp;index); int color1 = a[index];// #ifdef DBG// printf("color1 : %d\n", color1);// #endif std::vector&lt;Node&gt;::iterator s = std::lower_bound(v.begin(), v.end(), Node(color1, -1)); std::vector&lt;Node&gt;::iterator t = s; while (t-&gt;color == color1) t++; t--;// #ifdef DBG// printf("--------\n");// printf("*s : color = %d, id = %d\n", s-&gt;color, s-&gt;id);// printf("*t : color = %d, id = %d\n", t-&gt;color, t-&gt;id);// printf("--------\n");// #endif std::vector&lt;Node&gt;::iterator aim = std::lower_bound(s, t, Node(-1, index)); aim-&gt;id = index + 1;// #ifdef DBG// printf("----------\n");// printf("aim : %d, %d\n", aim-&gt;color, aim-&gt;id);// printf("----------\n");// #endif int color2 = a[index + 1]; s = std::lower_bound(v.begin(), v.end(), Node(color2, -1)); t = s; while (t-&gt;color == color2) t++; t--; aim = std::lower_bound(s, t, Node(-1, index + 1)); aim-&gt;id = index; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 11582] Colossal Fibonacci Numbers! - 数学相关]]></title>
    <url>%2F2017%2F11%2F01%2FUVa_11582%2F</url>
    <content type="text"><![CDATA[【链接】UVa 11582 Colossal Fibonacci Numbers 【题目描述】给定两个非负整数$a$, $b$和正整数$n (0 \le a, b &lt; 2 ^ {64}, 1 \le n \le 1000)$，计算$f(a ^ b) \% n$，其中$f(i)$表示斐波那契数列的第$i$项 【输入描述】Input begins with an integer $t \le 10, 000$, the number of test cases. Each test case consists of three integers $a, b, n$ where $0 \le a, b &lt; 2^{64} $，$1 \le n \le 1000$. 【输出描述】For each test case, output a single line containing the remainder of $f(a^b)$ upon division by $n$. 【题解】斐波那契数列取模后是有周期性的，所以求出循环节后算一个快速幂取模就可以了。 数据很大要用unsigned long long，因为这个原因调了很久还出了很多奇奇怪怪的错误 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;const int MAXN = (1000 + 10) * (1000 + 10);int f[MAXN];int mulMod(unsigned long long a, unsigned long long b, int mod) &#123; return ((a % mod) * (b % mod)) % mod;&#125;int fastPowMod(unsigned long long m, unsigned long long n, int mod) &#123; if (n == 0) return 1; if (n == 1) return m; if (n &amp; 1) return mulMod(fastPowMod(m, n - 1, mod), m, mod); else return fastPowMod(mulMod(m, m, mod), n &gt;&gt; 1, mod);&#125;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; unsigned long long a, b; int n; scanf("%llu%llu%d", &amp;a, &amp;b, &amp;n); if (n == 1 || a == 0) &#123; printf("0\n"); continue; &#125; f[1] = 1; f[2] = 1; int loop = 0; for (int i = 3; i &lt;= n * n + 10; i++) &#123; f[i] = (f[i - 1] % n + f[i - 2] % n) % n; if (f[i] == f[2] &amp;&amp; f[i - 1] == f[1]) &#123; loop = i - 2; break; &#125; &#125; printf("%d\n", f[fastPowMod(a % loop, b, loop)]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LYOJ 103] 蚯蚓 - 单调队列]]></title>
    <url>%2F2017%2F10%2F31%2Flyoj_103%2F</url>
    <content type="text"><![CDATA[【链接】LYOJ 103 蚯蚓 #NOIp2016 【题目描述】本题中，我们将用符号 $\lfloor c \rfloor$ 表示对 $c$ 向下取整，例如：$\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 $n$ 只蚯蚓（ $n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i$（$i = 1, 2, \ldots , n$ ），并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 &lt; p &lt; 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$ ，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来 ……（ $m$ 为非负整数） 蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道： $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）； $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你 …… 【输入描述】第一行包含六个整数 $n, m, q, u, v, t$ 其中：$n, m, q$ 的意义见「问题描述」，$u, v, t$ 均为正整数，你需要自己计算 $p = \frac{u}{v}$ (保证 $0 &lt; u &lt; v$) $t$是输出参数，其含义将会在「输出格式」中解释。 第二行包含 n n n 个非负整数，为 $a_1, a_2, \ldots, a_n$ 即初始时 $n$ 只蚯蚓的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。 保证 $1 \leq n \leq 10 ^ 5, 0 &lt; m &lt; 7 \times 10 ^ 6 , 0 &lt; u &lt; v &lt; 10 ^ 9, 0 \leq q \leq 200, 1 &lt; t &lt; 71, 0 &lt; a_i &lt; 10 ^ 8$ 。 【输出描述】第一行输出 $\lfloor \frac{m}{t} \rfloor$ 个整数，按时间顺序，依次输出第 $t$秒，第$2t$秒，第 $3t$秒 …… 被切断蚯蚓（在被切断前）的长度。 第二行输出 $\lfloor \frac{(n+m)}{t} \rfloor$ 个整数，输出$m$秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 $t$，第 $2t$，第 $3t$…… 的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。 请阅读样例来更好地理解这个格式。 【题解】题面中提到 最长的 那只蚯蚓，自然考虑优先队列，要求每次对 所有的 蚯蚓增加长度，可以打一个全局标记而不是真正修改，等到输出的时候在假装修改，但是这样会TLE只有$80$分的样子（在考场上打暴力还是很划算的） 经过观察我们发现每次切的蚯蚓长度是单调递减的，所以构造三个队列，一个用来存放从小到大排序好的初始序列，另外两个一个存每次切完后较大的那一段另一个存较小的那一段，可以证明这三个队列都是单调递减的，只需要每次取这三个队列队头元素中最大的那一个切一切，全局标记增加，这两段的长度减小就可以了。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 100010;long long n, m, q, u, v, t;long long a[MAXN];std::queue&lt;long long&gt; qa;std::queue&lt;long long&gt; qb;std::queue&lt;long long&gt; qc;bool cmp(long long a, long long b) &#123; return a &gt; b; &#125;inline long long getMax(int time) &#123; std::queue&lt;long long&gt; *curq = NULL; long long cur = LLONG_MIN; if (!qa.empty() &amp;&amp; qa.front() &gt; cur) &#123; cur = qa.front();curq = &amp;qa; &#125; if (!qb.empty() &amp;&amp; qb.front() &gt; cur) &#123; cur = qb.front();curq = &amp;qb; &#125; if (!qc.empty() &amp;&amp; qc.front() &gt; cur) &#123; cur = qc.front();curq = &amp;qc; &#125; if(curq!=NULL)curq-&gt;pop(); return cur + (time - 1)*q;&#125;int main() &#123;#ifndef tst freopen("earthworm.in", "r", stdin); freopen("earthworm.out", "w", stdout);#endif scanf("%lld%lld%lld%lld%lld%lld", &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); &#125; std::sort(a + 1, a + n + 1, cmp); for (int i = 1; i &lt;= n; i++) &#123; qa.push(a[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; long long realcur = getMax(i); if (i%t == 0) printf("%lld ", realcur); long long cut1 = realcur * u / v; long long cut2 = realcur - cut1; cut1 -= i * q; cut2 -= i * q; if (cut1 &gt; cut2) std::swap(cut1, cut2); qb.push(cut1); qc.push(cut2); &#125; printf("\n"); for (int i = 1; i &lt;= n + m; i++) &#123; long long temp = getMax(m + 1); if (i % t == 0) printf("%lld ", temp); &#125; printf("\n");#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LYOJ 104] 愤怒的小鸟 - 状压DP]]></title>
    <url>%2F2017%2F10%2F31%2Flyoj_104%2F</url>
    <content type="text"><![CDATA[【链接】LYOJ 104 愤怒的南小鸟 #NOIp2016 【题目描述】钟皓曦最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于$(0, 0)$处，每次钟皓曦可以用它向第一象限发射一只南小鸟，南小鸟们的飞行轨迹均为形如 $y = ax ^ 2 + bx$ 的曲线，其中 $a，b$ 是钟皓曦指定的参数，且必须满足 $a &lt; 0$。 当南小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小葱，其中第 $i$ 只小葱所在的坐标为 $(x_i, y_i)$ 如果某只南小鸟的飞行轨迹经过了 $(x_i, y_i) $，那么第 $i$ 只小葱就会被消灭掉，同时南小鸟将会沿着原先的轨迹继续飞行； 如果一只南小鸟的飞行轨迹没有经过$(x_i, y_i)$，那么这只南小鸟飞行的全过程就不会对第 $i$ 只小葱产生任何影响。 例如，若两只小葱分别位于 $(1, 3)$ 和 $(3, 3)$ ，钟皓曦可以选择发射一只飞行轨迹为 $y = -x ^ 2 + 4x$ 的南小鸟，这样两只小葱就会被这只南小鸟一起消灭。 而这个游戏的目的，就是通过发射南小鸟消灭所有的小葱。 这款神奇游戏的每个关卡对来说都很难，所以钟皓曦还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。 假设这款游戏一共有 $T$ 个关卡，现在钟皓曦想知道，对于每一个关卡，至少需要发射多少只南小鸟才能消灭所有的小葱。由于她不会算，所以希望由你告诉她。 【输入描述】第一行包含一个正整数 $T$，表示游戏的关卡总数。 下面依次输入这 $T$ 个关卡的信息。每个关卡第一行包含两个非负整数 $n$，$m$ ，分别表示该关卡中的小葱数量和钟皓曦输入的神秘指令类型。接下来的 $n$ 行中，第 $i$ 行包含两个正实数 $(x_i, y_i)$ ，表示第 $i$ 只小葱坐标为 $(x_i, y_i)$。数据保证同一个关卡中不存在两只坐标完全相同的小葱。 如果 $m = 0$，表示钟皓曦输入了一个没有任何作用的指令。 如果 $m = 1$，则这个关卡将会满足：至多用$\lceil \frac{n}{3} + 1 \rceil$只南小鸟即可消灭所有小葱。 如果$m = 2$，则这个关卡将会满足：一定存在一种最优解，其中有一只南小鸟消灭了至少$\lfloor \frac{n}{3} \rfloor$ 只小葱。 保证 $1 \leq n \leq 18$，$0 \leq m \leq 2$，$0 &lt; x_i, y_i &lt; 10$，输入中的实数均保留到小数点后两位。 上文中，符号 $\lceil x \rceil$ 和$\lfloor x \rfloor$ 分别表示对 $x$ 向上取整和向下取整。 【输出描述】对每个关卡依次输出一行答案。 输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小葱最少需要的南小鸟数量。 【题解】状压DP 设状态为当前没有被击中的猪的集合，压缩到一个二进制数中，转成十进制后作为数组下标，$f(i)$ 表示到达$i$这个状态最少需要发射的鸟的数目。 由于每条抛物线都是过原点的，枚举每两只猪便可以解出抛物线解析式里的 $a$ 和 $b$ ，可以由此确定出 $C_n^2$ 条抛物线，再枚举每一只猪，看能否被这条抛物线击中。 我们发现状态的转移是以抛物线为媒介的，所以说我们记录每一条抛物线能对状态造成的更改，同样用一个二进制数表示，这样就可以以没有被击中的猪的集合为点，抛物线为边建立状态图了，这个图是一个DAG，所以只需要刷表法跑一遍就可以了，使用类似BFS的做法，BFS保证最先找到的解一定是最小的。 题目中给出的 $m$ 没有什么用，是给的部分分 但是并不觉得有多简单 状态在修改的时候实际上就是当前的状态与抛物线的转移取并集，用位运算中的|就可以实现 关于位运算可以看这里 希望NOIp早日支持c++11 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 18 + 2;const int MAXSTATUS = 1048576 + 100; //2 ** MAXNconst double EPS = 1e-10;struct Pig &#123; double x, y; bool hit; Pig(double x = 0, double y = 0) : x(x), y(y), hit(false) &#123;&#125;&#125;;struct Parabola &#123; double a, b; int cnt, status; Parabola(double a = 0, double b = 0, int cnt = 0) : a(a), b(b), cnt(cnt), status(0) &#123;&#125;&#125;;std::vector&lt;Pig&gt; pigs;std::vector&lt;Parabola&gt; parabola;bool cmp(double a, double b) &#123; return fabs(a - b) &lt;= EPS;&#125;devoid calc(Pig pig1, Pig pig2, double &amp;a, double &amp;b) &#123; a = (pig2.x * pig1.y - pig1.x * pig2.y) / (pig1.x * pig1.x * pig2.x - pig2.x * pig2.x * pig1.x); b = (pig2.x * pig2.x * pig1. y - pig1.x * pig1.x * pig2.y) / (pig2.x * pig2.x * pig1.x - pig1.x * pig1.x * pig2.x);&#125;bool check(Parabola a, Pig b) &#123; if (cmp(b.x * b.x * a.a + b.x * a.b, b.y)) return true; else return false;&#125;void printBinary(int a) &#123; while (a &gt; 0) &#123; printf("%d", a % 2); a /= 2; &#125;&#125;int f[MAXSTATUS];int main() &#123;#ifndef tst freopen("angrykotori.in", "r", stdin); freopen("angrykotori.out", "w", stdout);#endif int t; scanf("%d", &amp;t); while (t--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); pigs.clear(); parabola.clear(); for (int i = 1; i &lt;= n; i++) &#123; double x, y; scanf("%lf%lf", &amp;x, &amp;y); pigs.push_back(Pig(x, y)); &#125; for (std::vector&lt;Pig&gt;::iterator it1 = pigs.begin(); it1 != pigs.end(); it1++) &#123; for (std::vector&lt;Pig&gt;::iterator it2 = it1 + 1; it2 != pigs.end(); it2++) &#123; double a = 0, b = 0; // if (!it1-&gt;hit &amp;&amp; !it2-&gt;hit) calc(*it1, *it2, a, b); calc(*it1, *it2, a, b); if (a &lt; 0) &#123; it1-&gt;hit = true; it2-&gt;hit = true; parabola.push_back(Parabola(a, b, 1)); &#125; else continue; &#125; &#125;#ifdef DBG printf("----------\n"); for (auto &amp;x : parabola) &#123; printf("%.2lf \n", (-x.b) / 2 * x.a); &#125; printf("----------\n");#endif Parabola unHit(0, 0, 0); for (std::vector&lt;Pig&gt;::iterator it1 = pigs.begin(); it1 != pigs.end(); it1++) &#123; if (!it1-&gt;hit) &#123; unHit.status |= (1 &lt;&lt; (it1 - pigs.begin())); unHit.cnt++; &#125; &#125; parabola.push_back(unHit); for (std::vector&lt;Parabola&gt;::iterator it1 = parabola.begin(); it1 != parabola.end(); it1++) &#123; for (std::vector&lt;Pig&gt;::iterator it2 = pigs.begin(); it2 != pigs.end(); it2++) &#123; if (check(*it1, *it2)) &#123; // it1-&gt;cnt++; it1-&gt;status |= (1 &lt;&lt; (it2 - pigs.begin())); &#125; &#125; &#125;#ifdef DBG printf("----------------\n"); for (auto &amp;x : parabola) &#123; printBinary(x.status); // printf("%d\n", x.cnt); printf("\n"); &#125; printf("----------------\n");#endif std::fill(f, f + MAXSTATUS, 0x7f7f7f7f); f[0] = 0; std::queue&lt;int&gt; q; q.push(0); while (!q.empty()) &#123; int now = q.front(); q.pop(); if (now &gt;= (1 &lt;&lt; n) - 1) continue; for (std::vector&lt;Parabola&gt;::iterator it = parabola.begin(); it != parabola.end(); it++) &#123; if (f[now | it-&gt;status] &gt; f[now] + it-&gt;cnt) &#123; f[now | it-&gt;status] = f[now] + it-&gt;cnt; q.push(now | it-&gt;status); &#125; &#125; &#125; printf("%d\n", f[(1 &lt;&lt; n) - 1]); &#125;#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125;// 1// 5 2// 1.00 5.00// 2.00 8.00// 3.00 9.00// 4.00 8.00// 5.00 5.00]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LYOJ 101] 换教室 - 期望DP]]></title>
    <url>%2F2017%2F10%2F30%2Flyoj_101%2F</url>
    <content type="text"><![CDATA[【链接】LYOJ 101 换教室 #NOIp 2016 【题目描述】对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 $2n$ 节课程安排在 $n$ 个时间段上。在第 $i$ $(1 \leq i \leq n)$个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $c_i$ 上课，而另一节课程在教室 $d_i$ 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的$n$节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $i$个时间段去教室 $d_i$上课，否则仍然在教室 $c_i$ 上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $i$ 节课程的教室时，申请被通过的概率是一个已知的实数 $k_i$，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $m$ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 $m$ 门课程，也可以不用完这 $m$ 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课问时间从一间教室赶到另一间教室。 牛牛所在的大学有 $v$ 个教室，有 $e$ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $i$ $(1 \leq i \leq n - 1)$节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 【输入描述】第一行四个整数 $n$ ，$m$，$v$，$e$。$n$ 表示这个学期内的时间段的数量；$m$ 表示牛牛最多可以申请更换多少节课程的教室；$v$ 表示牛牛学校里教室的数量；$e$表示牛牛的学校里道路的数量。 第二行 $n$ 个正整数，第 $i$ $(1 \leq i \leq n)$个正整数表示 $c_i$ ，即第 $i$ 个时间段牛牛被安排上课的教室；保证 $1 \leq c_i \leq v$。 第三行$n$个正整数，第 $i (1 \leq i \leq n)$个正整数表示 $d_i$，即第 $i$ 个时间段另一间上同样课程的教室；保证 $1 \leq d_i \leq v$ 第四行 $n$个实数，第$i(1 \leq i \leq n)$个实数表示 $k_i$，即牛牛申请在第 $i$ 个时间段更换教室获得通过的概率。保证 $0 \leq k_i \leq 1$ 接下来 $e$ 行，每行三个正整数 $a_j, b_j, w_j$ ，表示有一条双向道路连接教室 $a_j, b_j$ ，通过这条道路需要耗费的体力值是 $w_j$ ；保证 $1 \leq a_j, b_j \leq v, 1 \leq w_j \leq 100 $。 保证 $1 \leq n \leq 2000 ，0 \leq m \leq 2000， 1 \leq v \leq 300 ， 0 \leq e \leq 90000$ 。 保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。 保证输入的实数最多包含 $3$ 位小数。 【输出描述】输出一行，包含一个实数，四舎五入精确到小数点后恰好 $2$ 位，表示答案。你的输出必须和标准输出完全一样才算正确。 测试数据保证四舎五入后的答案和准确答案的差的绝对值不大于 $4 \times 10 ^ {-3}$​​ 。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理） 【题解】期望DP 设状态$f(i, j, 0 / 1)$表示在第$i$个时间段以前，换了$j$个教室，第$i$个换$(1)$, 不换$(0)$，所能达到的最小距离，则转移为 f(i, j, 0) = \min \begin{cases} f(i - 1, j, 0) + dis(c_{i - 1}, c_i)\\\[2ex] f(i - 1, j, 1) + dis(d_{i - 1}, c_i) \times k_{i - 1} + dis(c_{i - 1}, c_i) \times (1 - k_i) \end{cases} f(i, j, 1) = \min \begin{cases} f(i - 1, j - 1, 0) + dis(c_{i - 1}, d_i) \times k_i + dis(c_{i - 1}, c_i) \times (1 - k_i) \\\[2ex] f(i - 1, j - 1, 1)+dis(d_{i - 1}, d_i) \times k_{i - 1} \times k_i+dis(c_{i - 1}, d_i) \times (1 - k_{i - 1}) \times k_i+dis(d_{i - 1}, c_i) \times k_{i - 1} \times (1 - k_i)+dis(c_{i - 1}, c_i) \times (1 - k_{i - 1}) \times (1 - k_i) \end{cases}其中$dis(u, v)$表示的是从教室$u$到教室$v$的最短路，用Floyd算法预处理出即可 感觉说是期望DP实际上只要知道期望是个什么东西就和普通的DP没什么区别了，不过这个状态转移虽然不难想但是是真的长 原题给了很多部分分，比如说一个Floyd交上去就能有$20$分了，但是考场上没能仔细分析没拿到暴力分 拿到了说不定我现在就不会在这里了 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;const int MAXN = 2000 + 10;const int MAXV = 300 + 10;int g[MAXN][MAXN];int c[MAXN], d[MAXN];double k[MAXN];double f[MAXN][MAXN][2];int main() &#123;#ifndef tst freopen("classroom.in", "r", stdin); freopen("classroom.out", "w", stdout);#endif int n, m, v, e; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;v, &amp;e); // n-&gt;sizeOfTime, m-&gt;sizeOfChance, v-&gt;sizeOfNode, e-&gt;sizeOfEdge for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;d[i]); for (int i = 1; i &lt;= n; i++) scanf("%lf", &amp;k[i]); for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++) &#123; g[i][j] = INT_MAX; &#125; &#125; for (int i = 1; i &lt;= e; i++) &#123; int x, y, w; scanf("%d%d%d", &amp;x, &amp;y, &amp;w); g[x][y] = g[y][x] = std::min(g[x][y], w); &#125; for (int k = 1; k &lt;= v; k++) &#123; for (int i = 1; i &lt;= v; i++) &#123; for (int j = 1; j &lt;= v; j++) &#123; if (g[i][k] != INT_MAX &amp;&amp; g[k][j] != INT_MAX) &#123; g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= v; i++) &#123; g[i][i] = 0; &#125; f[1][0][1] = DBL_MAX; f[1][0][0] = 0; for (int i = 2; i &lt;= n; i++) &#123; f[i][0][1] = DBL_MAX; f[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]]; for (int j = 1; j &lt;= m; j++) &#123; f[i][j][0] = std::min(f[i - 1][j][0] + g[c[i - 1]][c[i]], f[i - 1][j][1] + g[d[i - 1]][c[i]] * k[i - 1] + g[c[i - 1]][c[i]] * (1 - k[i - 1])); f[i][j][1] = std::min(f[i - 1][j - 1][1] + g[d[i - 1]][d[i]] * k[i - 1] * k[i] + g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i] + g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]) + g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]), f[i - 1][j - 1][0] + g[c[i - 1]][d[i]] * k[i] + g[c[i - 1]][c[i]] * (1 - k[i])); &#125; &#125; double ans = DBL_MAX; for (int i = 0; i &lt;= m; i++) &#123; ans = std::min(ans, f[n][i][1]); ans = std::min(ans, f[n][i][0]); &#125; printf("%.2lf\n", ans);#ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125; 【写的时候犯的错误】 变量名起重复了…… 这大概是我写的最 宽 的代码]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 12186] Another Crisis - 树形DP]]></title>
    <url>%2F2017%2F10%2F28%2FUVa_12186%2F</url>
    <content type="text"><![CDATA[【链接】UVa 12186 Another Crisis 【题目描述】一个老板和$n$个员工组成树状结构，每个员工都有自己的唯一上司，老板的编号为$0$，员工$1 \dots n$，工人们打算签署一个志愿书给老板，但无法跨级，当一个中级员工（非是工人的员工）的直属下属中不小于$T\%$的人签字时，他也会签字并且递给他的直属上司，问：要让老板收到请愿书至少需要多少个工人签字 【输入描述】There are several test cases. The input for each test case is given in exactly two lines. The first line contains two integers $N$ and $T (1 \le N \le 10^5 , 1 \le T \le 100)$, separated by a single space. $N$ indicates the number of employees of the company (not counting the owner) and $T$ is the parameter described above. Each of the employees is identified by an integer between $1$ and $N$. The owner is identified by the number $0$. The second line contains a list of integers separated by single spaces. The integer $B_i$, at position $i$ on this list (starting from $1$), indicates the identification of the direct boss of employee $i (0 \le B_i \le i − 1)$. The last test case is followed by a line containing two zeros separated by a single space. 【输出描述】For each test case output a single line containing a single integer with the minimum number of workers that need to file a petition in order to get the owner of the company to receive a petition. 【题解】设状态$f(i)$表示员工$i$向上传递信息最少要有多少（底层的）工人同意。 则转移为 f(i) = \min \{ \sum_{cnt=1}^{num} f(j) \mid j \in s(i) \}其中 $num = \frac{k \times T - 1}{100} + 1$, $s(i)$表示节点$i$的儿子节点集合 边界为工人的答案为$1$，最后把每个节点的子节点汇总上来的答案排序后取前$num$个作为这个节点的答案即可 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;const int MAXN = 100000 + 10;int n, t;struct Node &#123; Node *fa; std::vector&lt;Node*&gt; ch; int d; Node() : fa(NULL), d(0) &#123; ch.clear(); &#125;&#125; nodes[MAXN];void addEdge(Node *fa, Node *son) &#123; fa-&gt;ch.push_back(son); son-&gt;fa = fa;&#125;int dp(Node *x) &#123; if (x-&gt;ch.empty()) return 1; int numOfSon = x-&gt;ch.size(); std::vector&lt;int&gt; d; for (int i = 0; i &lt; numOfSon; i++) &#123; d.push_back(dp(x-&gt;ch[i])); &#125; std::sort(d.begin(), d.end()); int cnt = (numOfSon * t - 1) / 100 + 1; int ans = 0; for (int i = 0; i &lt; cnt; i++) &#123; ans += d[i]; &#125; x-&gt;d = ans; return ans;&#125;int main() &#123; while (scanf("%d%d", &amp;n, &amp;t) == 2 &amp;&amp; n &amp;&amp; t) &#123; for (int i = 0; i &lt;= n; i++) &#123; nodes[i].ch.clear(); nodes[i].d = 0; nodes[i].fa = NULL; &#125; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); addEdge(nodes + x, nodes + i); &#125;#ifdef DBG for (int i = 0; i &lt;= n; i++) &#123; printf("I'm node[%d]\n", i); printf("My father is %ld\n", nodes[i].fa - nodes); printf("I have %d sons\n", nodes[i].ch.size()); printf("They are:\n"); for (int j = 0; j &lt; nodes[i].ch.size(); j++) &#123; printf("%d ", nodes[i].ch[j] - nodes); &#125; printf("\n"); &#125;#endif dp(nodes); printf("%d\n", nodes[0].d); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态压缩中常见的位运算技巧]]></title>
    <url>%2F2017%2F10%2F28%2FbitCalc%2F</url>
    <content type="text"><![CDATA[在学习状态压缩DP之前先来看看这些位运算的处理方法 【基本运算】 &amp; 「按位与」运算，返回两个数在二进制下进行按位与运算后的结果的十进制表示形式，对应到集合运算中为交运算 | 「按位或」运算，返回两个数在二进制下进行按位或运算后的结果的十进制表示形式，对应到集合运算中为并运算 ^ 「按位异或」运算，返回两个数在二进制下进行按位异或运算后的结果的十进制表示形式，对应到集合运算中为对称差运算 ~ 「按位取反」运算，返回一个数在二进制下进行按位取反运算后的结果的十进制表示形式 &lt;&lt; 「左移」运算，返回一个数在二进制下丢掉最高位并在最低位补零之后的结果的十进制表示(看上去就是向左错开了一位)，在十进制下表现为扩大为原数的两倍 &gt;&gt; 「右移」运算，返回一个数在二进制下丢掉最低位并在最高位补零之后的结果的十进制表示(看上去就是向右错开了一位)，在十进制下表现为缩小到原数的二分之一 【应用】 判断一个数字x二进制下第i位是否等于1 if (((1 &lt;&lt; (i - 1)) &amp; x ) &gt; 0) 将一个数字x二进制下第i位更改成1 x = x | (1 &lt;&lt; (i - 1)) 将一个数字x二进制下第i位更改成0 n &amp; ~(1 &lt;&lt; (m - 1)) 把一个数字二进制下最靠右的第一个1去掉 x = x &amp; (x - 1) 判断一个数的是否为偶数 if(x &amp; 1) 判断一个数是否为$2$的整数次幂 if(!(n &amp; (n - 1) &amp;&amp; n) = 1 || n == 1) 获得一个$n$位的全$1$二进制数 (1 &lt;&lt; n) - 1 统计一个数在二进制下$1$的个数 123456789101112131415 int CountOne(unsigned int n) &#123; //0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位 n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); //0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位 n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); //0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位 n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); //0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位 n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); //0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位 n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n; &#125; 【注意事项】 多用括号 【参考资料】 动态规划之状态压缩dp入门 编程技巧—位运算的巧妙运用 优秀程序员不得不知道的20个位运算技巧]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1378]选课 - 树形DP]]></title>
    <url>%2F2017%2F10%2F28%2FCodevs_1378%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 1378 选课 【题目描述】给出$n$个课程之间的关系(是否有先修课，有的话是谁)以及每一个课程的学分，和$m$个选课名额，问如何选课使得最后能获得的学分最多 【输入描述】输入文件的第一行包括两个整数$n$、$m$（中间用一个空格隔开）其中$1 \le n \le 300,1 \le m \le n$。 以下N行每行代表一门课。课号依次为$1，2, \cdots n$。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为$0$），第二个数为这门课的学分。学分是不超过$10$的正整数。 【输出描述】输出文件只有一个数,实际所选课程的学分总数。 【题解】树形DP 设状态$f(i, m)$表示在$i$及$i$的兄弟 或 儿子节点分配$m$个名额能得到的最大学分，则转移为： f(i, m) = \max \{f(ch(i), k) + f(bra(i), m - k - 1), f(bra(i), m) \mid k \in [0, m - 1]\}其中$ch(i)$表示$i$号点的 最后一个加入的 孩子，$bra(i)$表示$i$号点最后一个加入的兄弟 （感觉怪怪的） 上述方程直观表示出转移的两种情况： 如果选这门课， 那么有一个名额留给自己，剩下的分$i$个名额给孩子，分$m - i - 1$个名额给兄弟 如果不选这门课，那么就把所有的$m$个名额让给兄弟 在建树的时候用的是一种类似邻接表的表示方法，每个点里存的是 最后一个加入的 孩子，和 最后一个加入的兄弟 ，通过next指针链接成链表。 值得注意的是对于每一个点的状态是有很多种的（取决与兄弟和孩子的不同分配方案），所以在记录的时候不能只简单记录一个ans，而是应该用一个数组保存所有的状态值 另外数据中可能会有一些课程是没有先修课的，也就是说题目中给出的是一个森林，这个时候我们增加一个虚拟节点$0$号点，把所有的点都连到以这个虚拟节点为根的树上，但是这样的话总的可选课程数就要加一，因为$0$号点显然是必须要选的。 代码使用了记忆化搜索，因为树形结构本身具有的层次关系，记忆化搜索往往要比递推要容易实现 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 300 + 10;struct Node &#123; Node *fa, *ch, *next; int value; bool solved[MAXN]; int ans[MAXN]; Node() : fa(NULL), ch(NULL), next(NULL), value(0) &#123; std::fill(ans, ans + MAXN, 0); std::fill(solved, solved + MAXN, 0); &#125;&#125; nodes[MAXN];void addEdge(Node *a, Node *b) &#123; if (!a-&gt;ch) a-&gt;ch = b; else &#123; b-&gt;next = a-&gt;ch; a-&gt;ch = b; &#125;&#125;int dp(Node *x, int m) &#123; if (!x || m &lt;= 0) return 0; if (x-&gt;solved[m]) return x-&gt;ans[m]; else x-&gt;solved[m] = true; x-&gt;ans[m] = 0; for (int i = 0; i &lt; m; i++) &#123; x-&gt;ans[m] = std::max(dp(x-&gt;ch, i) + dp(x-&gt;next, m - i - 1) + x-&gt;value, x-&gt;ans[m]); &#125; if (x != nodes) &#123; x-&gt;ans[m] = std::max(dp(x-&gt;next, m), x-&gt;ans[m]); &#125; return x-&gt;ans[m];&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); addEdge(nodes + x, nodes + i); nodes[i].value = y; &#125;#ifdef DBG for (int i = 0; i &lt;= n; i++) &#123; printf("Node %d :\n", i); printf(" value = %d\n", nodes[i].ans); if (nodes[i].ch) &#123; printf(" ch = %d\n", nodes[i].ch - nodes); &#125; else &#123; printf(" ch = NULL\n"); &#125; printf("brothers : "); Node *v = nodes[i].ch; while (v != NULL) &#123; printf("%d ", v - nodes); v = v-&gt;next; &#125; printf("\n"); &#125;#endif printf("%d\n", dp(nodes, m + 1)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用矩阵快速幂优化递推时转移矩阵的构造]]></title>
    <url>%2F2017%2F10%2F27%2Fcons%2F</url>
    <content type="text"><![CDATA[在使用矩阵快速幂优化递推时最重要最核心的一步就是构造出关键的转移矩阵，这篇文章介绍了一种构造方法 我们以LyOJ #77小澳的坐标系一题为例，说明如何构造转移矩阵 已知递推式为 f(n) = f(n - 2) + 2f(n - 1)也就是说我们要构造一个矩阵使得 \begin{bmatrix} f(n - 2) & f(n - 1) \end{bmatrix} \times \begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} f(n - 1) & f(n) \end{bmatrix}根据矩阵乘法的定义可以得到 \begin{bmatrix} f(n - 2) & f(n - 1) \end{bmatrix} \times \begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} af(n - 2) + cf(n - 1) & bf(n - 2) + df(n - 1) \end{bmatrix}然后与我们的目标结果做一下对应，便可以得到转移矩阵为 \begin{bmatrix} 0 & 1 \\ 1 & 2 \end{bmatrix}]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LyOJ #77]小澳的坐标系 - 矩阵乘法]]></title>
    <url>%2F2017%2F10%2F27%2FLYOJ_77%2F</url>
    <content type="text"><![CDATA[【链接】LyOJ #77 小澳的坐标系 【题目描述】小澳的梦境中出现了一个平面直角坐标系，自原点，向四方无限延伸。 小澳在坐标系的原点，他可以向上、向左或者向右走。他可以走 $n$ 步，但不能经过相同的点。 小澳想知道他有多少种走法。 【输入描述】输入文件仅第一行一个正整数 $n$，表示小澳可以走的步数。 【输出描述】输出文件共一行，输出一个正整数，表示答案（对 $10^9 + 7$ 取模）。 【题解】容易想到用$f(i, 0)$，$f(i, 1)$，$f(i, 2)$分别表示第 $i$ 步向上，向左，向右走的方案数，则可由下面的式子递推求解： \begin{cases} f(i, 0) = f(i - 1, 0) + f(i - 1, 1) + f(i - 1, 2) \\\[2ex] f(i, 1) = f(i - 1, 0) + f(i - 1, 1)\\\[2ex] f(i, 2) = f(i - 1, 0) + f(i - 1, 2) \end{cases}最终答案为$f(n, 0) + f(n, 1) + f(n, 2)$ 使用滚动数组优化空间 但是问题是这样递推是会超时的，所以把上面的式子化简一下可以得到 f(n) = f(n - 2) + 2f(n - 1)对于这样的线性齐次递推式，考虑使用矩阵快速幂优化时间 我们可以构造出转移矩阵 \left[ \begin{matrix} 0 & 1 \\ 1 & 2 \end{matrix} \right]然后答案直接计算即可 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;const int MOD = 1000000000 + 7;struct Matrix &#123; long long a[100][100]; int sizeX, sizeY; Matrix(int sizeX = 0, int sizeY = 0) : sizeX(sizeX), sizeY(sizeY) &#123;&#125; Matrix operator*(const Matrix &amp;a) const &#123; Matrix ans(sizeX, a.sizeY); for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; a.sizeY; j++) &#123; for (int k = 0; k &lt; sizeY; k++) &#123; ans.a[i][j] += (this-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD; ans.a[i][j] %= MOD; &#125; &#125; &#125; return ans; &#125; void operator=(const Matrix &amp;a) &#123; for (int i = 0; i &lt; sizeX; i++) &#123; for (int j = 0; j &lt; sizeY; j++) &#123; this-&gt;a[i][j] = a.a[i][j]; &#125; &#125; &#125; void print() &#123; printf("[%lld %lld]\n", a[0][0], a[0][1]); printf("[%lld %lld]\n", a[1][0], a[1][1]); &#125;&#125;;Matrix fastPowMod(Matrix m, int n) &#123; if (n == 1) return m; else if (n &amp; 1) return fastPowMod(m, n - 1) * m; else return fastPowMod(m * m, n &gt;&gt; 1);&#125;int main() &#123;#ifndef tst freopen("coordinate.in", "r", stdin); freopen("coordinate.out", "w", stdout);#endif int n; scanf("%d", &amp;n); Matrix begin(1, 2); begin.a[0][0] = 1; begin.a[0][1] = 3; // printf("this is Matrix Begin\n"); // begin.print(); Matrix move(2, 2); move.a[0][0] = 0; move.a[0][1] = 1; move.a[1][0] = 1; move.a[1][1] = 2; // printf("this is Matrix Move\n"); // move.print(); Matrix ans(1, 2); ans = begin * fastPowMod(move, n - 1); // printf("this is Matrix Ans\n"); // ans.print(); printf("%lld\n", ans.a[0][1]); fclose(stdin); fclose(stdout); return 0;&#125; 【递推式化简的过程】 \begin{equation} \begin{split} F(n) &= f(n, 0) + f(n, 1) + f(n, 2) \\ &= f(n - 1, 1) + f(n - 1, 2) + f(n - 1, 0) + f(n - 1, 0) + f(n - 1, 1) + f(n - 1, 0) + f(n - 1, 2) \\ &= 2f(n - 1, 1) + 2f(n - 1 ,2) + 3f(n - 1, 0) \\ &= 2F(n - 1) + f(n - 1, 0) \\ &= 2F(n - 1) + F(n - 2) \end{split} \end{equation}]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 10003] Cutting Sticks - 区间DP]]></title>
    <url>%2F2017%2F10%2F27%2FUVa_10003%2F</url>
    <content type="text"><![CDATA[【链接】UVa 10003 Cutting Sticks 【题目描述】给定一根木棍，木棍上有若干切割点，切割木棍的花费数值上等于被切割木棍的长度，问最小花费 【输入描述】The input will consist of several input cases. The first line of each test case will contain a positive number $l$ that represents the length of the stick to be cut. You can assume $l &lt; 1000$. The next line willcontain the number $n (n &lt; 50)$ of cuts to be made. The next line consists of $n$ positive numbers $c_i (0 &lt; c_i &lt; l)$ representing the places where the cuts have to be done, given in strictly increasing order. An input case with $l = 0$ will represent the end of the input. 【输出描述】You have to print the cost of the optimal solution of the cutting problem, that is the minimum cost of cutting the given stick. Format the output as shown below. 【题解】区间DP 设状态$f(l, r)$表示切割$[l, r]$这个闭区间所能实现的最小花费。 则转移为： f(l, r) = \min\{f(l, k) + f(k, j) | i < k < j\} + a[j] - a[i]最终答案为$f(0, n + 1)$ 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cstring&gt;const int MAXN = 50;int a[MAXN];int f[MAXN][MAXN];int vis[MAXN][MAXN];int dp(int l, int r) &#123; if (l &gt;= r - 1) return 0; if (vis [l][r]) return f[l][r]; else vis[l][r] = true; int &amp;ans = f[l][r]; ans = -1; for (int i = l + 1; i &lt;= r - 1; i++) &#123; int tmp = dp(l, i) + dp(i, r) + a[r] - a[l]; if (ans &lt; 0 || tmp &lt; ans) &#123; ans = tmp; &#125; &#125; return ans;&#125;int main() &#123; int l; while (scanf("%d", &amp;l) == 1 &amp;&amp; l) &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; a[0] = 0; a[n + 1] = l; memset(vis, 0, sizeof(vis)); printf("The minimum cutting is %d.\n", dp(0, n + 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 12563]Jin Ge Jin Qu hao - 背包DP]]></title>
    <url>%2F2017%2F10%2F25%2Fuva_12563%2F</url>
    <content type="text"><![CDATA[【链接】UVa 12563 Jin Ge Jin Qu hao 【题目描述】(If you smiled when you see the title, this problem is for you ^_^)For those who don’t know KTV, see:http://en.wikipedia.org/wiki/Karaoke_boxThere is one very popular song called Jin Ge Jin Qu(). It is a mix of 37 songs, and is extremely long (11 minutes and 18 seconds) — I know that there are Jin Ge Jin Qu II and III, and some other unofficial versions. But in this problem please forget about them. Why is it popular? Suppose you have only 15 seconds left (until your time is up), then you should select another song as soon as possible, because the KTV will not crudely stop a song before it ends (people will get frustrated if it does so!). If you select a 2-minute song, you actually get 105 extra seconds! ….and if you select Jin Ge Jin Qu, you’ll get 663 extra seconds!!! Now that you still have some time, but you’d like to make a plan now. You should stick to thefollowing rules: • Don’t sing a song more than once (including Jin Ge Jin Qu). • For each song of length t, either sing it for exactly t seconds, or don’t sing it at all. • When a song is finished, always immediately start a new song.Your goal is simple: sing as many songs as possible, and leave KTV as late as possible (since we have rule 3, this also maximizes the total lengths of all songs we sing) when there are ties. 给定一个容量为 $t$ 的背包和体积分别为 $v_i$ 的 $n$ 个物品，使得在选择最多物品的情况下使得最后背包中剩余体积最小 【输入描述】The first line contains the number of test cases $T (T \le 100)$. Each test case begins with two positive integers $n, t (1 \le n \le 50, 1 \le t \le 10^9)$, the number of candidate songs (BESIDES Jin Ge Jin Qu) and the time left (in seconds). The next line contains n positive integers, the lengths of each song, in seconds. Each length will be less than $3$ minutes — I know that most songs are longer than $3$ minutes. But don’t forget that we could manually “cut” the song after we feel satisfied, before the song ends. So here “length” actually means “length of the part that we want to sing”. It is guaranteed that the sum of lengths of all songs (including Jin Ge Jin Qu) will be strictly larger than $t$. 【输出描述】For each test case, print the maximum number of songs (including Jin Ge Jin Qu), and the total lengths of songs that you’ll sing. 【题解】【代码】123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;const int MAXV = 9678 + 1000;const int MAXN = 50 + 50;int f[MAXV], a[MAXN];int main() &#123; int T; scanf("%d", &amp;T); for (int cas = 1; cas &lt;= T; cas++) &#123; int n, t; scanf("%d%d", &amp;n, &amp;t); t--; memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; int ans = 0; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = t; j &gt;= a[i]; j--) &#123; if (f[j - a[i]] &gt;= 1 || j == a[i]) &#123; f[j] = std::max(f[j], f[j - a[i]] + 1); ans = std::max(ans, f[j]); &#125; &#125; &#125; int cnt = 0; for (cnt = t; f[cnt] != ans; cnt--) &#123;&#125; if (ans == 0) printf("Case %d: 1 678\n", cas); else printf("Case %d: %d %d\n", cas, 1 + ans, cnt + 678); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 11584] Partitioning by Palindromes - 划分DP]]></title>
    <url>%2F2017%2F10%2F25%2FUVa_11584%2F</url>
    <content type="text"><![CDATA[【题目链接】 UVa 11584 Partitioning by Palindromes 【题目描述】 给定一个字符串，求最多能少能被划分成多少个回文串。 【输入描述】Input begins with the number $n$ of test cases. Each test case consists of a single line of between $1$ and $1000$ lowercase letters, with no whitespace within. 【输出描述】For each test case, output a line containing the minimum number of groups required to partition the input into groups of palindromes. 【题解】划分DP 设 $f(i)$ 表示前 $i$ 个字符中能划分出的最少回文串的个数，则转移为 f(i) = \min \{f(j) + 1\ | j \leq i , \text{$s[j \dots i]$ is Memo string} \}含义为从$j$这个位置分割，$s[j, i]$作为一个回文串，前边的部分用前边的最优做法。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 1000;int f[MAXN];char s[MAXN];bool check(int l, int r) &#123; while (l &lt; r) &#123; if (s[l] == s[r]) &#123; l++; r--; &#125; else return false; &#125; return true;&#125;int main() &#123; int n; scanf("%d", &amp;n); while (n--) &#123; scanf("%s", s + 1); int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) &#123; f[i] = i; for (int j = 1; j &lt;= i; j++) &#123; if (check(j, i)) f[i] = std::min(f[i], f[j - 1] + 1); &#125; &#125;#ifdef DBG for (int i = 1; i &lt;= len; i++) &#123; printf("f[%d] = %d \n", i, f[i]); &#125;#endif printf("%d\n", f[len]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>划分DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1004] 四子连棋 - BFS + Hash]]></title>
    <url>%2F2017%2F10%2F24%2FCodevs_1004%2F</url>
    <content type="text"><![CDATA[【题目描述】在一个$4 \times 4$的棋盘上摆放了$14$颗棋子，其中有$7$颗白色棋子，$7$颗黑色棋子，有两个空白地带，任何一颗黑白棋子都可以向上下左右四个方向移动到相邻的空格，这叫行棋一步，黑白双方交替走棋，任意一方可以先走，如果某个时刻使得任意一种颜色的棋子形成四个一线（包括斜线），这样的状态为目标棋局。 【输入描述】从文件中读入一个$4 \times 4$的初始棋局，黑棋子用$B$表示，白棋子用$W$表示，空格地带用$O$表示。 【输出描述】用最少的步数移动到目标棋局的步数。 【题解】BFS，队列里存储的是整个棋盘，每个棋盘记录第一个空格的坐标和第二个空格的坐标，以及变换到当前棋盘所用的步数，判重可以把一个棋盘看做一个十六位三进制数，转换成十进制后判重即可。 听说用迭代加深搜索可以秒杀，但是我不是很会 代码出现了在GDB里跑得过，直接运行跑不过的尴尬情况，仍有待解决。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;climits&gt;int a[4][4];int dx[] = &#123;1, 0, -1, 0&#125;;int dy[] = &#123;0, 1, 0, -1&#125;;struct Node &#123; int x1, y1, x2, y2; int step; int color; //0-&gt;w, 1-&gt;b; int a[4][4]; Node(int x1 = -1, int y1 = -1, int x2 = -1, int y2 = -1, int step = 0) : x1(x1), y1(y1), x2(x2), y2(y2), step(step) &#123; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; a[i][j] = 0; &#125; &#125; color = 0; &#125; void operator=(const Node &amp;x) &#123; x1 = x.x1; y1 = x.y1; x2 = x.x2; y2 = x.y2; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; a[i][j] = x.a[i][j]; &#125; &#125; &#125; void print() &#123; printf("Check\n"); printf("[x1, x1] = [%d, %d]\n", x1, y1); printf("[x2, y2] = [%d, %d]\n", x2, y2); for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; printf("a[%d][%d] = %d ", i, j, a[i][j]); &#125; printf("\n"); &#125; printf("color : %d\n", color); &#125;&#125;;void move(Node *x, int i, int num) &#123; if (num == 1) &#123; std::swap(x-&gt;a[x-&gt;x1 + dx[i]][x-&gt;y1 + dy[i]], x-&gt;a[x-&gt;x1][x-&gt;y1]); x-&gt;x1 += dx[i]; x-&gt;y1 += dy[i]; &#125; else &#123; std::swap(x-&gt;a[x-&gt;x2 + dx[i]][x-&gt;y2 + dy[i]], x-&gt;a[x-&gt;x2][x-&gt;y2]); x-&gt;x2 += dx[i]; x-&gt;y2 += dy[i]; &#125; x-&gt;step++; x-&gt;color ^= 1;&#125;int getHash(Node x) &#123; int ans = 0, bit = 15; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; ans += x.a[i][j] * pow(3, bit--); &#125; &#125; return ans;&#125;bool check(int a, int b, int c, int d) &#123; if (a == b &amp;&amp; b == c &amp;&amp; c == d) return true; else return false;&#125;bool judge(Node x) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (check(x.a[i][0], x.a[i][1], x.a[i][2], x.a[i][3])) return true; if (check(x.a[0][i], x.a[1][i], x.a[2][i], x.a[3][i])) return true; &#125; if (check(x.a[0][0], x.a[1][1], x.a[2][2], x.a[3][3])) return true; if (check(x.a[0][3], x.a[1][2], x.a[2][1], x.a[3][0])) return true; return false;&#125;std::set&lt;int&gt; set;bool vis(Node x) &#123; if (set.count(getHash(x))) return true; else return false;&#125;int bfs(Node &amp;x, int color) &#123; std::queue&lt;Node&gt; q; x.step = 0; x.color = color; q.push(x); while (!q.empty()) &#123; Node tmp = q.front(); q.pop(); if (vis(tmp)) continue; set.insert(getHash(tmp)); if (judge(tmp)) return tmp.step; for (int i = 0; i &lt; 4; i++) &#123; int xx1 = tmp.x1 + dx[i]; //printf("xx1 = %d ", xx1); int yy1 = tmp.y1 + dy[i]; //printf("yy1 = %d\n", yy1); if (xx1 &gt;= 0 &amp;&amp; xx1 &lt;= 3 &amp;&amp; yy1 &gt;= 0 &amp;&amp; yy1 &lt;= 3 &amp;&amp; tmp.a[xx1][yy1] == tmp.color) &#123; Node tmpp = tmp; move(&amp;tmpp, i, 1); q.push(tmpp); &#125; int xx2 = tmp.x2 + dx[i]; //printf("xx2 = %d ", xx2); int yy2 = tmp.y2 + dy[i]; //printf("yy2 = %d\n", yy2); if (xx2 &gt;= 0 &amp;&amp; xx2 &lt;= 3 &amp;&amp; yy2 &gt;= 0 &amp;&amp; yy2 &lt;= 3 &amp;&amp; tmp.a[xx2][yy2] == tmp.color) &#123; Node tmpp = tmp; move(&amp;tmpp, i, 2); q.push(tmpp); &#125; &#125; &#125; return INT_MAX;&#125;int main() &#123; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; char c = getchar(); if (c == 'B') a[i][j] = 1; else if (c == 'W') a[i][j] = 0; else a[i][j] = 2; &#125; getchar(); &#125; Node start; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; if(a[i][j] == 2 &amp;&amp; start.x1 == -1 &amp;&amp; start.y1 == -1) &#123; start.x1 = i; start.y1 = j; &#125; else if (a[i][j] == 2 &amp;&amp; start.x2 == -1 &amp;&amp; start.y2 == -1) &#123; start.x2 = i; start.y2 = j; &#125; start.a[i][j] = a[i][j]; &#125; &#125; printf("%d\n", std::min(bfs(start, 1), bfs(start, 0))); //1-&gt;b, 0-&gt;w return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1099] 字串变换 - BFS]]></title>
    <url>%2F2017%2F10%2F23%2FCodevs_1099%2F</url>
    <content type="text"><![CDATA[【题目描述】已知有两个字串 $A$, $B$ 及一组字串变换的规则（至多6个规则） 规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$、$A_2$ 可以变换为 $B_2$ 问将起始串按照上述规则变为目标串所需的最少步数。 【输入描述】输入格式如下： $A$ $B$ $A_1$ $B_1$ $A_2$ $B_2$ $\dots$ $\dots$ 所有字符串长度的上限为 20。 【输出描述】若在 $10$ 步（包含 $10$ 步）以内能将 $A$ 变换为 $B$ ，则输出最少的变换步数；否则输出NO ANSWER! 【题解】普通的BFS，对原串的每一位考虑每一个变换规则能否成立，成立就扔到队列里，记得用std::set判一下重。 注意字母可能重复，所以不能直接str.find()，而是应该对每一位往后的子串看是不是和某个变换规则吻合。 记得要写NO ANSWER!，别忘了感叹号和大写 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;const int MAXN = 10;struct String &#123; std::string str; int step; String(std::string s, int n) : str(s), step(n) &#123;&#125;&#125;;struct Pair &#123; std::string a, b; &#125; pairs[MAXN];std::set&lt;std::string&gt; st;int main() &#123; std::string before, after; std::cin &gt;&gt; before &gt;&gt; after; int cnt = 0; while (std::cin &gt;&gt; pairs[cnt].a &gt;&gt; pairs[cnt].b) cnt++; std::queue&lt;String&gt; q; q.push(String(before, 0)); while (!q.empty()) &#123; String tmp = q.front(); q.pop(); if (st.count(tmp.str)) continue; if (tmp.step &gt; 10) &#123; std::cout &lt;&lt; "NO ANSWER!" &lt;&lt; std::endl; return 0; &#125; else if (tmp.str == after) &#123; std::cout &lt;&lt; tmp.step &lt;&lt; std::endl; return 0; &#125; for (int i = 0; i &lt; (int)tmp.str.size(); i++) &#123; for (int j = 0; j &lt; cnt; j++) &#123; if (tmp.str.substr(i, pairs[j].a.size()) == pairs[j].a) &#123; std::string tmpp = tmp.str; tmpp.replace(i, pairs[j].a.size(), pairs[j].b); q.push(String(tmpp, tmp.step + 1)); st.insert(tmp.str); &#125; &#125; &#125; &#125; std::cout &lt;&lt; "NO ANSWER!" &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通的读入/输出优化]]></title>
    <url>%2F2017%2F10%2F22%2FIO%2F</url>
    <content type="text"><![CDATA[普通的读入/输出优化1234567891011121314void get(int &amp;x)&#123; char c = getchar(); x = 0; while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &lt;= '9' &amp;&amp; c &gt;= '0') x = x * 10 + c - 48, c = getchar();&#125;void put(int x) &#123; int num = 0; char c[15]; while(x) c[++num] = (x % 10) + 48, x /= 10; while(num) putchar(c[num--]); putchar('\n'); &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>输出/输出优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1166] 矩阵取数游戏 - 区间DP]]></title>
    <url>%2F2017%2F10%2F19%2FCodevs_1166%2F</url>
    <content type="text"><![CDATA[【链接】 Codevs 1166 矩阵取数游戏 【题目描述】 帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素$a_{ij}$均为非负整数。游戏规则如下： 每次取数时须从每行各取走一个元素，共$n$个。$m$次后取完矩阵所有元素； 每次取走的各个元素只能是该元素所在行的行首或行尾； 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 $=$ 被取走的元素值$\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）； 游戏结束总得分为$m$次取数得分之和。 帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。 【输入描述】第$1$行为两个用空格隔开的整数n和m。 第$2 \to n+1$ 行为$n \times m$矩阵，其中每行有$m$个用单个空格隔开的非负整数。 【输出描述】 输出 仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。 【数据范围及提示】$60\%$的数据满足：$1 \le n, m \le 30$, 答案不超过$10^{16}$ $100\%$的数据满足：$1 \le n, m \le 80, 0 \le a_{ij} \le 1000$ 【题解】 区间DP 考虑到行与行之间互不影响，所以把每一行单独考虑，问题转化到序列上。 设状态 $f(i, j)$ 表示在闭区间 $[i, j]$ 中进行取数能得到的最大收益，则转移为 f(i, j) = \max ( f[i + 1][j] + a[i] \times 2^{m - i + j}, f[i][j - 1] + a[j] \times 2^{m - i + j})$m$很小，所以随便按区间长度从小到大枚举一下区间端点就可以了 需要高精度 【代码】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;struct BigInt &#123; std::vector&lt;int&gt; v; static const int BASE = 10; BigInt(long long x) &#123; do &#123; v.push_back(x % 10); &#125;while (x /= 10); &#125; BigInt(const std::string &amp;str) &#123; v.reserve(str.length()); for(int i = str.length() - 1; i &gt;= 0; i--)&#123; v.push_back(str[i] - '0'); &#125; &#125; BigInt() &#123; ; &#125; void removePreZero() &#123; while(v.size() &gt; 1 &amp;&amp; v.back() == 0) v.pop_back(); &#125; bool operator&lt;(const BigInt &amp;a) const &#123; if (v.size() != a.v.size()) &#123; return v.size() &lt; a.v.size(); &#125; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; if (v[i] != a.v[i]) &#123; return v[i] &lt; a.v[i]; &#125; &#125; return false; &#125; bool operator&gt;(const BigInt &amp;a) const &#123;return a &lt; *this;&#125; bool operator&lt;=(const BigInt &amp;a) const &#123;return !(a &lt; *this);&#125; bool operator&gt;=(const BigInt &amp;a) const &#123;return !(*this &lt; a);&#125; bool operator!=(const BigInt &amp;a) const &#123;return a &lt; *this || a &gt; *this;&#125; bool operator==(const BigInt &amp;a) const &#123;return !(a &lt; *this) &amp;&amp; !(a &gt; *this);&#125; BigInt operator+(const BigInt &amp;a) const &#123; BigInt ans; int sum = 0; for (int i = 0; i &lt; std::max(a.v.size(), v.size()); i++) &#123; if (i &lt; a.v.size()) sum += a.v[i]; if (i &lt; v.size()) sum += v[i]; ans.v.push_back(sum % BASE); sum /= BASE; &#125; if (sum) ans.v.push_back(sum); ans.removePreZero(); return ans; &#125;/* BigInt operator+=(const BigInt &amp;a) const &#123; return *this = *this + a; &#125;*/ BigInt operator-(const BigInt &amp;a) const &#123; BigInt ans; int dif = 0; for (int i = 0; i &lt; std::max(a.v.size(), v.size()); i++) &#123; if (i &lt; v.size()) dif += v[i]; if (i &lt; a.v.size()) dif -= a.v[i]; if (dif &gt;= 0) &#123; ans.v.push_back(dif); dif = 0; &#125; else &#123; ans.v.push_back((dif + BASE) % BASE); dif = -1; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator-=(const BigInt &amp;a) const &#123; return *this = *this - a; &#125;*/ BigInt operator*(const BigInt &amp;a) const &#123; BigInt ans; ans.v.resize(v.size() + a.v.size(), 0); for (int i = 0; i &lt; v.size(); i++) &#123; for (int j = 0; j &lt; a.v.size(); j++) &#123; ans.v[i + j] += v[i] * a.v[j]; ans.v[i + j + 1] += ans.v[i + j] / BASE; ans.v[i + j] %= BASE; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator*=(const BigInt &amp;a) const &#123; return *this = *this * a; &#125;*/ BigInt operator/(const BigInt &amp;a) const &#123; BigInt ans, ret(0); ans.v.resize(v.size(), 0); ret = 0; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; ret = ret * 10 + v[i]; while (ret &gt;= a) &#123; ret = ret - a; ans.v[i]++; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator/=(const BigInt &amp;a) const &#123; return *this = *this / a; &#125;*/&#125;;std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const BigInt &amp;x) &#123; for (int i = x.v.size() - 1; i &gt;= 0; i--) &#123; out &lt;&lt; x.v[i]; &#125; return out;&#125;std::istream&amp; operator&gt;&gt; (std::istream &amp;in, BigInt &amp;x) &#123; std::string str; in &gt;&gt; str; x = BigInt(str); return in;&#125;const int MAXN = 80 + 5;BigInt a[MAXN];BigInt x[MAXN];BigInt f[MAXN][MAXN];int n, m;int main() &#123; std::cin &gt;&gt; n &gt;&gt; m; BigInt sum(0); x[0] = 1; for (int i = 1; i &lt;= m; i++) &#123; x[i] = x[i - 1] * 2; &#125; while (n--) &#123; memset(a, 0, sizeof(a)); memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= m; i++) &#123; std::cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; //BigInt tmp(1 &lt;&lt; m); f[i][i] = a[i] * x[m]; &#125; for (int i = m; i &gt;= 1; i--) &#123; for (int j = i + 1; j &lt;= m; j++) &#123; int len = j - i; int cnt = m - len; //BigInt tmp(1 &lt;&lt; cnt); f[i][j] = std::max(f[i + 1][j] + a[i] * x[cnt], f[i][j - 1] + a[j] * x[cnt]); &#125; &#125; sum = sum + f[1][m]; &#125; std::cout &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 【出现的问题】 刚开始自己随便yy了一个记忆化搜索，调了很久发现好像就是暴力，看了题解之后写了递推…… 记忆化搜索代码（80分）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int MAXN = 80 + 5;bool vis[MAXN][2][MAXN][MAXN];BigInt a[MAXN];BigInt f[MAXN][2][MAXN][MAXN];BigInt x[MAXN];int n, m;BigInt dp(int cnt, int d, int l, int r) &#123; BigInt &amp;ans = f[cnt][d][l][r]; if (vis[cnt][d][l][r]) return ans; else vis[cnt][d][l][r] = true; //BigInt tmp(1 &lt;&lt; cnt); // BigInt tmp = x[cnt]; if (r == l) ans = tmp * a[l]; else &#123; BigInt x, y; if (d == 0) &#123; x = dp(cnt + 1, 0, l + 1, r); y = dp(cnt + 1, 1, l + 1, r); &#125; else &#123; x = dp(cnt + 1, 0, l, r - 1); y = dp(cnt + 1, 1, l, r - 1); &#125; // BigInt tmp = (x &gt; y ? a[l] : a[r]); BigInt take = (d == 0 ? a[l] : a[r]); ans = take * tmp; ans = ans + std::max(x, y); &#125;#ifdef DBG std::cout &lt;&lt; "f[" &lt;&lt; cnt &lt;&lt; "]" &lt;&lt; "[" &lt;&lt; d &lt;&lt; "]" &lt;&lt; "[" &lt;&lt; l &lt;&lt; "]" &lt;&lt; "[" &lt;&lt; r &lt;&lt; "]" "=" &lt;&lt; ans &lt;&lt; std::endl;#endif return ans;&#125;int main() &#123; std::cin &gt;&gt; n &gt;&gt; m; BigInt sum(0); x[0] = 1; for (int i = 1; i &lt;= m; i++) &#123; x[i] = x[i - 1] * 2; &#125; for (int i = 0; i &lt; n; i++) &#123; memset(f, 0, sizeof(f)); memset(vis, false, sizeof(vis)); for (int j = 0; j &lt; m; j++) &#123; std::cin &gt;&gt; a[j]; &#125; //sum = sum + std::max(dp(m, 0, 0, m - 1), dp(m, 1, 0, m - 1)); //0-&gt;front-&gt;l, 1-&gt;back-&gt;r [] sum = sum + std::max(dp(1, 0, 0, m - 1), dp(1, 1, 0, m - 1)); &#125; std::cout &lt;&lt; sum &lt;&lt; std::endl; return 0;&#125; 还有要注意的就是要乘上去的$2$的次幂会爆long long，所以不能简单的用2 &lt;&lt; cnt来构造一个大整数，应该先预处理出这些幂，存在一个数组里]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 11400] Lighting System Design - 序列DP]]></title>
    <url>%2F2017%2F10%2F19%2FUVa_11400%2F</url>
    <content type="text"><![CDATA[【链接】 UVa 11400 Lighting System Design 【题目描述】 You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of $n$ different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating. Now, you know thenumber of lamps and cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) and complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources and replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system. 给出$n$种灯的相关信息：额定电压($V$)，电源价格($K$)，灯的价格($C$)，灯的个数($L$)，其中一个电源可以给任意多的灯供电，所以为了省钱，我们可以把一些额定电压比较高的灯换成额定电压比较低的灯，从而让他们共用一个电源。任务是计算最优方案的花费。 【输入描述】Each case in the input begins with $n (1 \le n \le 1000)$, denoting the number of categories. Each of the following $n$ lines describes a category. A category is described by $4$ integers - $V (1 \le V \le 132000)$, the voltage rating, $K (1 \le K \le 1000)$, the cost of a voltage source of this rating, $C (1 \le C \le 10)$, the cost of a lamp of this rating and $L (1 \le L \le 100)$, the number of lamps required in this category. The input terminates with a test case where $n = 0$. This case should not be processed. 【输出描述】For each test case, print the minimum possible cost to design the system. 【题解】序列DP 设状态 $f(i)$ 为只考虑前 $i$ 盏灯时的最少花费，则转移为 f(i) = \min \{f(j) + (s[i] - s[j]) \times c[i] + k[i]\}其中 $s$ 表示灯的数目的前缀和，$c[i]$表示第$i$种灯的价格，$k[i]$表示第$i$种电源的价格。表示前$j$种灯使用最佳的策略，其他的灯全部换成第$i$种灯之后所能实现的最小花费。 所以把灯按照价格从小到大排序后，按照上式进行转移，最后答案为$f(n - 1)$（从$0$开始编号） 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;struct Light &#123; int v, k, c, l; Light(int v, int k, int c, int l) : v(v), k(k), c(c), l(l) &#123;&#125; bool operator&lt;(const Light &amp;a) const &#123; return v &lt; a.v; &#125;&#125;;std::vector&lt;Light&gt; vector;std::vector&lt;int&gt; f;std::vector&lt;int&gt; s;int main() &#123; int n; while (scanf("%d", &amp;n) == 1 &amp;&amp; n) &#123; vector.clear(); f.clear(); f.resize(n + 10); std::fill(f.begin(), f.end(), INT_MAX); s.clear(); for (int i = 0; i &lt; n; i++) &#123; int v, k, c, l; scanf("%d%d%d%d", &amp;v, &amp;k, &amp;c, &amp;l); vector.push_back(Light(v, k, c, l)); &#125; std::sort(vector.begin(), vector.end()); s.push_back(vector[0].l); for (int i = 1; i &lt; n; i++) &#123; s.push_back(s[i - 1] + vector[i].l); &#125; for (int i = 0; i &lt; n; i++) &#123; f[i] = vector[i].c * vector[i].l + vector[i].k; if (i &gt; 0) f[i] += f[i - 1]; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = -1; j &lt; i; j++) &#123; int tmp = 0; if (j == -1) tmp = s[i] * vector[i].c + vector[i].k; else tmp = f[j] + (s[i] - s[j]) * vector[i].c + vector[i].k; f[i] = std::min(f[i], tmp); &#125; &#125; printf("%d\n", f[n - 1]); &#125; return 0;&#125; 【写的时候犯的错误】 没有考虑所有的都换成第$i$种灯的情况，如果从$1$开始编号$j$应该从$0$开始枚举，如果从$0$开始编号，就应该从$-1$开始枚举，并特判$ j = -1$的情况]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 437] The Tower of Babylon - DP]]></title>
    <url>%2F2017%2F10%2F18%2FUVa_437%2F</url>
    <content type="text"><![CDATA[【链接】UVa 437 The Tower of Babylon 【题目描述】Perhaps you have heard of the legend of the Tower of Babylon. Nowadays many details of this tale have been forgotten. So now, in line with the educational nature of this contest, we will tell you the whole story: The babylonians had n types of blocks, and an unlimited supply of blocks of each type.Each type-$i$ block was a rectangular solid with linear dimensions $(x_i, y_i, z_i)$. A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height. They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to haveequal-sized bases couldn’t be stacked. Your job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks. 给出 $n$ 种长方体的长宽高，每种长方体都可以使用无限次，要求选一些长方体把他们摞成一根尽可能高的柱子，但是每个立方体的底面长宽都必须严格小于他下面的那个立方体的长宽。 【输入描述】The input file will contain one or more test cases. The first line of each test case contains an integer n,representing the number of different blocks in the following data set. The maximum value for $n$ is $30$. Each of the next n lines contains three integers representing the values $x_i, y_i$ and $z_i$.Input is terminated by a value of zero $(0)$ for $n$. 【输出描述】For each test case, print one line containing the case number (they are numbered sequentially starting from $1$) and the height of the tallest possible tower in the format Case case: maximum height = height 【数据范围及提示】对于$\%100$的数据 $n \le 30$ 【题解】DAG上的DP 因为每向上摞一块，长宽都是严格减小的，所以状态图可以表示为一个DAG 设状态$f(a, b)$表示从底边长宽分别为$a, b$的立方体开始向上摞能得到的最大高度，则按照一般的DAG上DP的套路，转移为 f(a, b) = \max \{f(x, y)\} + h其中 $h$ 表示这块立方体的高，$x, y$应当满足题目中给出的长宽都是严格减小的条件。 但是现在的问题是$a, b$可能很大，不能直接这样存状态，考虑到如果知道了高，那么长宽就都知道了，所以把状态修改为$f(id, h)$，表示编号为$id$的立方体把$h$作为高，把，从这个立方体向上摞能达到的最大高度，转移是一样的。 看了别人的代码才发现可以显式的把图建出来，这样判断会方便很多。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;const int MAXN = 300 + 5;struct Block &#123; int a, b, c; Block() : a(0), b(0), c(0) &#123;&#125; void sort() &#123; if (a &gt; b) std::swap(a, b); if (a &gt; c) std::swap(a, c); if (b &gt; c) std::swap(b, c); &#125;&#125; blocks[MAXN];int f[MAXN][3];bool vis[MAXN][3];void calc(int id, int h, int &amp;x, int &amp;y) &#123; if (h == 0) &#123; x = blocks[id].b; y = blocks[id].c; &#125; else if (h == 1) &#123; x = blocks[id].a; y = blocks[id].c; &#125; else if (h == 2) &#123; x = blocks[id].a; y = blocks[id].b; &#125;&#125;bool check(int id1, int h1, int id2, int h2) &#123; int x1, y1; //x1 &lt; y1 calc(id1, h1, x1, y1); int x2, y2; //x2 &lt; y2 calc(id2, h2, x2, y2); if ((x1 &gt; x2 &amp;&amp; y1 &gt; y2) || (x1 &gt; y1 &amp;&amp; x2 &gt; y2)) return true; return false;&#125;int n;int dp(int x, int y) &#123; int &amp;ans = f[x][y]; if (vis[x][y]) return ans; else vis[x][y] = true; int delta = 0; if (y == 0) delta = blocks[x].a; if (y == 1) delta = blocks[x].b; if (y == 2) delta = blocks[x].c; ans = delta; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (check(x, y, i, j)) &#123; ans = std::max(ans, dp(i, j) + delta); &#125; &#125; &#125; return ans;&#125;void init() &#123; memset(f, 0, sizeof(f)); memset(vis, false, sizeof(vis));&#125;int main() &#123; int cnt = 0; while (scanf("%d", &amp;n) == 1) &#123; init(); if (n == 0) break; cnt++; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;blocks[i].a, &amp;blocks[i].b, &amp;blocks[i].c); blocks[i].sort(); &#125;#ifdef DBG for (int i = 0; i &lt; n; i++) &#123; printf("blocks[%d] : a = %d, b = %d, c = %d\n", i, blocks[i].a, blocks[i].b, blocks[i].c); &#125;#endif int max = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; max = std::max(max, dp(i, j)); &#125; &#125; printf("Case %d: maximum height = %d\n", cnt, max); &#125; return 0;&#125; 【写的时候的错误】 数组开小了， $f$的第二维存三个元素但是只开到了$2$ 三个数字排序写错……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1154] 能量项链 - 区间DP]]></title>
    <url>%2F2017%2F10%2F17%2FCodevs_1154%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 1154 能量项链 【题目描述】在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $n$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$ ，尾标记为$r$，后一颗能量珠的头标记为 $r$ ，尾标记为 $n$ ，则聚合后释放的能量为 $ m \times r \times n $（Mars单位），新产生的珠子的头标记为$m$，尾标记为$n$。 需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 【输入描述】第一行是一个正整数$n(4 \le n \le 100)$，表示项链上珠子的个数。第二行是$n$个用空格隔开的正整数，所有的数均不超过$1000$。第$i$个数为第$i$颗珠子的头标记$(1 \le i \le N)$，当$i&lt;n$时，第$i$颗珠子的尾标记应该等于第$i+1$颗珠子的头标记。第$n$颗珠子的尾标记应该等于第$1$颗珠子的头标记。 至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。 【输出描述】只有一行，是一个正整数$E(E \le 2.1 \times 10^9)$，为一个最优聚合顺序所释放的总能量。 【题解】区间DP 题目中给的是一个环，可以考虑把这条链拆开，即枚举断点把问题转化到区间上，但是枚举断点需要$O(n)$，这样一来再加上枚举区间起点和区间长度以及区间断点（转移中的$k$）就是$O(n^4)$的复杂度，所以我们试着将长度翻倍，这样一来就不需要再 枚举断点了，复杂度就成了$O(n^3)$ 设$f(l, r)$表示合并闭区间$[l, r]$所能得到的最大价值，则转移为 f(l, r) = \max \{f(l, k) + f(k + 1, r) + a[l] \times a[k + 1] \times a[r + 1]\}记忆化搜索即可 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 100 * 2 + 10;int a[MAXN];int f[MAXN][MAXN];bool vis[MAXN][MAXN];int search(int l, int r) &#123; int &amp;ans = f[l][r]; if (vis[l][r]) return ans; else vis[l][r] = true; if (l == r) ans = 0; else if (r - l == 1) ans = a[l] * a[r] * a[r + 1]; else &#123; ans = INT_MIN; for (int k = l; k &lt; r; k++) &#123; ans = std::max(ans, search(l, k) + search(k + 1, r) + a[l] * a[k + 1] * a[r + 1]); &#125; &#125; return ans;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); a[i + n] = a[i]; &#125; a[n * 2] = a[0]; search(0, 2 * n - 1); int ans = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; ans = std::max(ans, f[i][i + n - 1]); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3657] 括号序列 - 区间DP]]></title>
    <url>%2F2017%2F10%2F11%2FCodevs_3657%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 3657 括号序列 【题目描述】我们用以下规则定义一个合法的括号序列： （1）空序列是合法的 （2）假如 $S$ 是一个合法的序列，则 $(S)$ 和 $[S]$ 都是合法的 （3）假如 $A$ 和 $B$ 都是合法的，那么 $AB$ 和 $BA$ 也是合法的 现在给定一些由(, ), [, ]构成的序列 ，请添加尽量少的括号，得到一个合法的括号序列。 【输入描述】输入包括号序列$S$。含最多$100$个字符（四种字符： (, ), [, ]) ，都放在一行，中间没有其他多余字符。 【输出描述】使括号序列 $S$ 成为合法序列需要添加最少的括号数量。 【题解】区间DP 设$f(l, r)$表示使闭区间$[l, r]$合法所需添加的最少括号个数，转移不太好用一个式子描述，分两种情况看 如果这个区间的左右端点可以匹配，即(s[l] == &#39;(&#39; &amp;&amp; s[r] == &#39;)&#39;) || (s[l] == &#39;[&#39; &amp;&amp; s[r] == &#39;]&#39;)，那么转移到$f(l + 1, r - 1)$ 转移到$\min(f(l, k), f(k + 1, r)), k \in [l, r)$ 需要注意的是不管第一种转移满足不满足，都要考虑第二种转移，否则[][]会被转移到][，这样就需要添加两个括号了，但实际上显然这种情况是不需要添加括号的 边界为$f(i, r) = 1$，因为单独一个括号是不合法的，需要添加一个括号使之匹配 $f(l, r)$初始值都应该为$+\infty$ 代码中的$len$枚举的是区间长度，要从$2$开始枚举，如果枚举偏移量的话，要从$1$开始枚举 【代码】123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 100 + 10;char s[MAXN];int f[MAXN][MAXN];int main() &#123; scanf("%s", s); int length = strlen(s); for (int i = 0; i &lt; length; i++) &#123; f[i][i] = 1; &#125; for (int len = 2; len &lt;= length; len++) &#123; for (int l = 0; l &lt; length - len + 1; l++) &#123; int r = len + l - 1; int &amp;ans = f[l][r]; ans = INT_MAX; if ((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']')) &#123; ans = std::min(ans, f[l + 1][r - 1]); &#125; for(int k = l; k &lt; r; k++) &#123; ans = std::min(ans, f[l][k] + f[k + 1][r]); &#125; &#125; &#125; printf("%d\n", f[0][length - 1]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3155] 连续和 - 序列DP / 最大连续子段和]]></title>
    <url>%2F2017%2F10%2F10%2FCodevs_3155%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 3155 连续和 【题目描述】给定$n$个数 $a_1 , a_2 , \dots , a_n$ 定义 f_{i,j} = a_i + a_{i + 1} + a_{i + 2} + \dots + a_{j-1} + a_j (1 \le i \le j \le n)求 $f_{i,j}$ 的最大值 【输入描述】第一行有$1$个数，$n$ 第二行有$n$个数，$a_1 , a_2 , \dots , a_n$ 【输出描述】输出只有一行，$f_{i,j}$ 的最大值 【题解】设$f(i)$表示以$a[i]$为结尾的最大连续子段和,而不是到$a[i]$为止的最大连续子段和 则转移为 f(i) = \max(f(i - 1) + a[i], a[i])即要么自己作为一个子段，要么和前面的子段续起来 【代码】1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 1000000 + 10;int a[MAXN], f[MAXN];int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; f[0] = a[0]; for (int i = 1; i &lt; n; i++) &#123; f[i] = std::max(a[i], f[i - 1] + a[i]); &#125; int max = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; max = std::max(max, f[i]); &#125; printf("%d\n", max); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1220]数字三角形 - DP]]></title>
    <url>%2F2017%2F10%2F10%2FCodevs_1220%2F</url>
    <content type="text"><![CDATA[NOIp2017前的集训终于开始了，第一周决定跟着Hellc的脚步学习DP，先从简单开始 【链接】Codevs 1220 数字三角形 【题目描述】有一个数字三角形，从顶部出发，在每一结点可以选择向左走或得向右走，一直走到底层，要求找出一条路径，使路径上的值最大。 【输入描述】第一行是数塔层数$n(1 \le n \le 100)$。 第二行起，按数塔图形，有一个或多个的整数，表示该层节点的值，共有$n$行。 【输出描述】输出最大值。 【题解】设$f(i, j)$表示从$(i, j)$出发向下走的路径上的最大值，则转移为 f(i, j) = \max(f(i + 1, j), f(i + 1, j + 1)) + a[i][j]边界为$f(n, j) = a[n][j], j \in [1, n]$ 【代码】12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100 + 10;int a[MAXN][MAXN];int f[MAXN][MAXN];int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; f[n][j] = a[n][j]; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; f[i][j] = std::max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]; &#125; &#125; printf("%d\n", f[1][1]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 12412] A Typical Homework(a.k.a Shi Xiong Bang Bang Mang) - 模拟]]></title>
    <url>%2F2017%2F10%2F10%2FUVa_12412%2F</url>
    <content type="text"><![CDATA[【链接】A Typical Homework (a.k.a Shi Xiong Bang Bang Mang) 【题目描述】略Sh… Could you help me with it? Please keep secret!!I know that you won’t say NO to a poor little girl, boy. 【输入描述】略【输出描述】略【题解】模拟即可 【不AC代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using std::string;struct Student &#123; string SID, CID; string name; int rank, position, numberOfPassed; double sum, average; int score[4]; // 0-&gt;Chinese, 1-&gt;Math, 2-&gt;English, 3-&gt;Program Student(string SID, string CID, string name, int *score) : SID(SID), CID(CID), name(name), rank(0), sum(0), average(0) &#123; for (int i = 0; i &lt; 4; i++) this-&gt;score[i] = score[i]; for (int i = 0; i &lt; 4; i++) this-&gt;sum += this-&gt;score[i]; this-&gt;average = this-&gt;sum / 4.0; this-&gt;position = 0; numberOfPassed = 0; &#125; bool operator&lt;(const Student &amp;a) const &#123; return sum &gt; a.sum; &#125; void calc() &#123; for (int i = 0; i &lt; 4; i++) if (score[i] &gt;= 60) numberOfPassed++; &#125;&#125;;std::vector&lt;Student&gt; v;std::set&lt;string&gt; s;void printMenu() &#123; using namespace std; cout &lt;&lt; "Welcome to Student Performance Management System (SPMS)." &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "1 - Add" &lt;&lt; endl; cout &lt;&lt; "2 - Remove" &lt;&lt; endl; cout &lt;&lt; "3 - Query" &lt;&lt; endl; cout &lt;&lt; "4 - Show ranking" &lt;&lt; endl; cout &lt;&lt; "5 - Show Statistics" &lt;&lt; endl; cout &lt;&lt; "0 - Exit" &lt;&lt; endl &lt;&lt; endl;&#125;void add() &#123; using namespace std; while (true) &#123; cout &lt;&lt; "Please enter the SID, CID, name and four scores. Enter 0 to finish." &lt;&lt; endl; string SID, CID; string name; int score[4]; cin &gt;&gt; SID; if (SID == "0") break; cin &gt;&gt; CID &gt;&gt; name; for (int i = 0; i &lt; 4; i++) &#123; cin &gt;&gt; score[i]; &#125; if (s.count(SID)) cout &lt;&lt; "Duplicated SID." &lt;&lt; endl; else &#123; Student x(SID, CID, name, score); x.calc(); v.push_back(x); s.insert(SID); &#125; &#125;&#125;void remove() &#123; using namespace std; while (true) &#123; cout &lt;&lt; "Please enter SID or name. Enter 0 to finish." &lt;&lt; endl; string tmp; cin &gt;&gt; tmp; if (tmp == "0") break; int sum = 0; vector&lt;int&gt; deleted; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; if (it-&gt;SID == tmp || it-&gt;name == tmp) &#123; deleted.push_back(it - v.begin()); sum++; &#125; &#125; for (vector&lt;int&gt;::iterator it = deleted.begin(); it != deleted.end(); it++) &#123; v.erase(v.begin() + *it); s.erase((v.begin() + *it)-&gt;SID); &#125; cout &lt;&lt; sum &lt;&lt; " student(s) removed." &lt;&lt; endl; &#125;&#125;void query() &#123; using namespace std; while (true) &#123; cout &lt;&lt; "Please enter SID or name. Enter 0 to finish." &lt;&lt; endl; string tmp; cin &gt;&gt; tmp; if (tmp == "0") break; vector&lt;Student&gt; rank; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; if (it-&gt;SID == tmp || it-&gt;name == tmp) &#123; it-&gt;position = it - v.begin(); // rank.push_back(*it); &#125; rank.push_back(*it); &#125; stable_sort(rank.begin(), rank.end()); for (vector&lt;Student&gt;::iterator it = rank.begin(); it != rank.end(); it++) &#123; if (it == rank.begin()) v[it-&gt;position].rank = 1; else if (it-&gt;sum == (it - 1)-&gt;sum) v[it-&gt;position].rank = v[(it - 1)-&gt;position].rank; else v[it-&gt;position].rank = it - rank.begin() + 1; &#125; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; if (it-&gt;SID == tmp || it-&gt;name == tmp) &#123; cout &lt;&lt; it-&gt;rank &lt;&lt; " "; cout &lt;&lt; it-&gt;SID &lt;&lt; " " &lt;&lt; it-&gt;CID &lt;&lt; " " &lt;&lt; it-&gt;name &lt;&lt; " "; for (int i = 0; i &lt; 4; i++) cout &lt;&lt; it-&gt;score[i] &lt;&lt; " "; cout &lt;&lt; it-&gt;sum &lt;&lt; " " ; printf("%.2lf\n", it-&gt;average); &#125; &#125; &#125;&#125;void calcWhole(int lesson, double &amp;average, int &amp;passed, int &amp;notPassed) &#123; using namespace std; int sum = 0; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; sum += it-&gt;score[lesson]; if (it-&gt;score[lesson] &gt;= 60) passed++; else notPassed++; &#125; average = (double)(sum) / v.size();&#125;void printLesson(int i) &#123; using namespace std; if (i == 0) cout &lt;&lt; "Chinese" &lt;&lt; endl; if (i == 1) cout &lt;&lt; "Mathematics" &lt;&lt; endl; if (i == 2) cout &lt;&lt; "English" &lt;&lt; endl; if (i == 3) cout &lt;&lt; "Programming" &lt;&lt; endl;&#125;void statistics() &#123; using namespace std; cout &lt;&lt; "Please enter class ID, 0 for the whole statistics." &lt;&lt; endl; string tmp; cin &gt;&gt; tmp; if (tmp == "0") &#123; for (int i = 0; i &lt; 4; i++) &#123; int passed = 0, notPassed = 0; double average = 0; calcWhole(i, average, passed, notPassed); printLesson(i); printf("Average Score: %.2lf\n", average); cout &lt;&lt; "Number of passed students: " &lt;&lt; passed &lt;&lt; endl; cout &lt;&lt; "Number of failed students: " &lt;&lt; notPassed &lt;&lt; endl &lt;&lt; endl; &#125; int passedThree = 0, passedTwo = 0, passedOne = 0, failedALL = 0, passedAll = 0; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; if (it-&gt;numberOfPassed &gt;= 1) passedOne++; if (it-&gt;numberOfPassed &gt;= 2) passedTwo++; if (it-&gt;numberOfPassed &gt;= 3) passedThree++; if (it-&gt;numberOfPassed == 4) passedAll++; if (it-&gt;numberOfPassed == 0) failedALL++; &#125; cout &lt;&lt; "Overall:" &lt;&lt; endl; cout &lt;&lt; "Number of students who passed all subjects: " &lt;&lt; passedAll &lt;&lt; endl; cout &lt;&lt; "Number of students who passed 3 or more subjects: " &lt;&lt; passedOne &lt;&lt; endl; cout &lt;&lt; "Number of students who passed 2 or more subjects: " &lt;&lt; passedTwo &lt;&lt; endl; cout &lt;&lt; "Number of students who passed 1 or more subjects: " &lt;&lt; passedThree &lt;&lt; endl; cout &lt;&lt; "Number of students who failed all subjects: " &lt;&lt; failedALL &lt;&lt; endl &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 4; i++) &#123; int sum = 0, passed = 0, notPassed = 0; double average = 0; int numberOfStudents = 0; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; if (it-&gt;CID == tmp || it-&gt;SID == tmp) &#123; numberOfStudents++; sum += it-&gt;score[i]; if (it-&gt;score[i] &gt;= 60) passed++; else notPassed++; &#125; &#125; average = sum / (double)(numberOfStudents); printLesson(i); printf("Average Score: %.2lf\n", average); cout &lt;&lt; "Number of passed students: " &lt;&lt; passed &lt;&lt; endl; cout &lt;&lt; "Number of failed students: " &lt;&lt; notPassed &lt;&lt; endl &lt;&lt; endl; &#125; int passedThree = 0, passedTwo = 0, passedOne = 0, failedALL = 0, passedAll = 0; for (vector&lt;Student&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; if (it-&gt;CID == tmp || it-&gt;SID == tmp) &#123; if (it-&gt;numberOfPassed &gt;= 1) passedOne++; if (it-&gt;numberOfPassed &gt;= 2) passedTwo++; if (it-&gt;numberOfPassed &gt;= 3) passedThree++; if (it-&gt;numberOfPassed == 4) passedAll++; if (it-&gt;numberOfPassed == 0) failedALL++; &#125; &#125; cout &lt;&lt; "Overall:" &lt;&lt; endl; cout &lt;&lt; "Number of students who passed all subjects: " &lt;&lt; passedAll &lt;&lt; endl; cout &lt;&lt; "Number of students who passed 3 or more subjects: " &lt;&lt; passedOne &lt;&lt; endl; cout &lt;&lt; "Number of students who passed 2 or more subjects: " &lt;&lt; passedTwo &lt;&lt; endl; cout &lt;&lt; "Number of students who passed 1 or more subjects: " &lt;&lt; passedThree &lt;&lt; endl; cout &lt;&lt; "Number of students who failed all subjects: " &lt;&lt; failedALL &lt;&lt; endl &lt;&lt; endl; &#125;&#125;int main() &#123; while (true) &#123; printMenu(); int x; std::cin &gt;&gt; x; if (x == 1) add(); if (x == 2) remove(); if (x == 3) query(); if (x == 4) std::cout &lt;&lt; "Showing the ranklist hurts students' self-esteem. Don't do that." &lt;&lt; std::endl; if (x == 5) statistics(); if (x == 0) break; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[清北Day5 T1] Cut - 数学 + 找规律]]></title>
    <url>%2F2017%2F10%2F06%2FQB_DAY5_T1%2F</url>
    <content type="text"><![CDATA[【链接】没有链接 【题目描述】$A$ 和 $B$ 想要切蛋糕来吃,蛋糕可以看作一个 $m \times n$ 的矩形,由分割线划分。蛋糕由 $A$ 来切,他切蛋糕的方式分为两步: 沿着蛋糕的某条分割线将蛋糕分成两半。 如果两块蛋糕大小一样,$A$ 吃掉其中的一块蛋糕,把另一块给 $B$ 吃,结束切蛋糕。否则从大块中切去较小块蛋糕那么大的部分并吃掉切下的部分,重复第二步。 另外 $A$ 不希望连续两次都从同一块蛋糕中切。 求 $A$ 最多能吃多少单位蛋糕,每单位蛋糕就是一个 $1 \times 1$ 的单位矩形。 【输入描述】第一行包含两个整数 $m$ 和 $n$,$(1 \leq m, n \leq 10^9 )$ 【输出描述】输出一个数 $c$,表示 $A$ 最多能吃到的蛋糕数量。 【数据范围及提示】对于 $40\%$ 的数据,$m, n \leq 1000$。 对于 $100\%$ 的数据,$m, n \leq 10^9$。 【题解】本题中使用 $[a, b]$ 表示 两块蛋糕的大小分别为$a$和$b$ 从后往前考虑，假如说最后分给$B$的蛋糕大小为$a$，那么最后一次分割完结果一定是$[a, a]$，倒数第二次就是$[a, 2a]$，因为两次不应该分割同一块蛋糕，所以倒数第三次就应该是$[3a, 2a]$，以此类推，倒数第四次就是$[5a, 3a]$，倒数第五次就是$[5a, 8a]$，写到这里应该就能看出一些规律了，分割的倒数第$k$次分割出的两块蛋糕就应该是$[F{k-1}a, F{k}a]$，其中$F_{i}$表示的是斐波那契数列的第$i$项 那么我们想让自己留下的尽可能多，那就应该让$a$尽可能小，考虑第一次分割，应该分割成$[Fna, F{n+1}a]$，由于是第一次分割，所以应该有$Fna + F{n+1}a = n$，即$a \times (Fn + F{n+1}) = n$，由斐波那契数列的定义可以知道 F_n + F_{n+1} = F_{n+2}所以稍微移项可得 a = \frac{n}{F_{n+2}}现在问题就转化成了找一个尽可能大的斐波那契数$F_i$，使$F_i | n$ 在以上的分析中我们都只考虑了一条边，另一条边在最后的时候作为系数乘上去就可以了，两条边都算一遍最后取一个$\max$就可以了。 记得用long long 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;climits&gt;const int MAXN = 10000;int f[MAXN];bool flag = false;void fib(int x) &#123; if (x == 1 || x == 2) f[x] = 1; else f[x] = f[x - 2] + f[x - 1]; if (f[x] &gt;= 100000000) flag = true;&#125;int main() &#123; long long n, m; scanf("%lld%lld", &amp;n, &amp;m); int cnt = 1; while (true) &#123; if (!flag) fib(cnt++); else break; &#125; long long ans = INT_MAX; for (int i = cnt - 1; i &gt;= 1; i--) &#123; if (n % f[i] == 0) &#123; if (ans &gt; n / f[i]) &#123; ans = n / f[i]; flag = true; &#125; &#125; &#125; for (int i = cnt - 1; i &gt;= 1; i--) &#123; if (m % f[i] == 0) &#123; if (ans &gt; m / f[i]) &#123; ans = m / f[i]; flag = false; &#125; &#125; &#125; if (flag) printf("%lld\n", (n - ans) * m); else printf("%lld\n", (m - ans) * n); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1144] 守望者的逃离 - 贪心]]></title>
    <url>%2F2017%2F10%2F04%2FCodevs_1144%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 1144 守望者的逃离 【题目描述】恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。守望者的跑步速度为$17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在$1s$内移动$60m$，不过每次使用闪烁法术都会消耗魔法值$10$点。守望者的魔法值恢复的速度为$4/s$，只有处在原地休息状态时才能恢复。 现在已知守望者的魔法初值$M$，他所在的初始位置与岛的出口之间的距离$S$，岛沉没的时间$T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意：守望者跑步、闪烁或休息活动均以秒$(s)$为单位，且每次活动的持续时间为整数秒。距离的单位为米$(m)$。 【输入描述】仅一行，包括空格隔开的三个非负整数$M$, $S$, $T$。 【输出描述】包含两行： 第$1$行为字符串Yes或No（区分大小写），即守望者是否能逃离荒岛。 第$2$行包含一个整数。第一行为Yes（区分大小写）时表示守望者逃离荒岛的最短时间； 第一行为No（区分大小写）时表示守望者能走的最远距离。 【题解】先考虑只闪烁不跳跃的情况，处理出f数组，$f(i)$表示在第$i$秒的时候跑的距离，如果魔法值不够就停下来，再考虑只跑步，如果发现某时刻跑步比瞬移优，那就选择跑步，到最后还没跑出去就是No了。 【代码】123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;const int MAXN = 300000 + 10;int f[MAXN];int main() &#123; int m, s, t; scanf("%d%d%d", &amp;m, &amp;s, &amp;t); for (int i = 1; i &lt;= t; i++) &#123; if (m &gt;= 10) &#123; f[i] = f[i - 1] + 60; m -= 10; &#125; else &#123; f[i] = f[i - 1]; m += 4; &#125; &#125; for (int i = 1; i &lt;= t; i++) &#123; if (f[i] &lt; f[i - 1] + 17) f[i] = f[i - 1] + 17; if (f[i] &gt;= s) &#123; printf("Yes\n%d\n", i); return 0; &#125; &#125; printf("No\n%d\n", f[t]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[清北Day2 T1] video - 数学相关 + 组合数]]></title>
    <url>%2F2017%2F10%2F02%2FQBXT_DAY2_T1%2F</url>
    <content type="text"><![CDATA[【链接】没有链接 【题目描述】pluto 喜欢看片,现在他的硬盘里有 $n$ 部片,但是由于他还要把妹,所以看片时间有限,他只能挑出其中的 $k$ 部片来看,他想知道有多少种不同的选片方案。方案数可能很大,答案对$10^9 + 7$取模后输出。 【输入描述】一行两个整数,$n$ 和 $m$ 【输出描述】一行一个整数,即所求答案 【数据范围及提示】对于 $30\%$ 的数据,$n \leq 10$ 对于 $60\%$ 的数据,$n \leq 3000$ 对于 $100\%$ 的数据,$n \leq 2 \times 10^5$ 【题解】裸的组合数，化简一下直接求就好了，递推的话会T掉 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MOD = 1000000007;void exgcd(long long a, long long b, long long &amp;d, long long &amp;x, long long &amp;y) &#123; if (!b) d = a, x = 1, y = 0; else &#123; exgcd(b, a % b, d, y, x); y -= x * (a / b); &#125;&#125;long long d, x, y;void inv(long long a, long long mod) &#123; exgcd(a, mod, d, x, y);&#125;long long c(long long n, long long m) &#123; long long a = 1, b = 1; if ((long long)m * 2 &gt; n) m = n - m; for (long long i = n; i &gt; (n - m); i--) a = (a % MOD * i % MOD) % MOD; for (long long i = 1; i &lt;= m; i++) b = (b % MOD * i % MOD) % MOD;#ifdef DBG printf("a = %lld, b = %lld\n", a, b);#endif inv(b, MOD); return (a % MOD * (x + MOD) % MOD) % MOD;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); printf("%lld\n", c(n, m)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[清北Day1 T2] polyLine - 数学相关]]></title>
    <url>%2F2017%2F10%2F01%2FQB_DAY1_T2%2F</url>
    <content type="text"><![CDATA[【题目链接】没有链接 【题目描述】有若干个类似于下面的函数: y_i(x) = \begin{cases} k_i \cdot x + b_i, & \text{if $k_i \cdot x + b_i \ge 0$} \\ 0, & \text{if $k_i \cdot x + b_i < 0$} \end{cases}定义 $n$ 个函数 $y_1(x)\dots y_n(x)$ 的对于任意 $x$ 的总和 s(x) = \sum_{i = 1}^n y_i(x)很容易发现 $s(x)$ 的图象是多段线组成。给你 $n$ 个函数,你的任务是找出 $s(x)$ 图象不等于 $180$ 度的角的个数。 【输入描述】第一行一个整数 $n$,表示函数的个数。 接下来 $n$ 行, 每行包含两个空格隔开的整数 $k_i$ , $b_i$ , 表示第 $i$ 个函数的参数。 【输出描述】输出一行一个整数, 表示形成的多段线的图像中不等于 $180$ 度角的个数。 【数据范围及提示】对于 $30\%$ 的数据,$n \le 3000$。 对于 $100\%$ 的数据,$1 \le n \le 10^5 , −10^9 \le k_i , b_i \le 10^9$ 。 【题解】说是一道数学题实际上并没有用到很多和数学相关的知识，题目中要求多段线的图像中不等于 $180$ 度角的个数，也就是求斜率变化的点的个数，通过观察解析式可以发现只有当某个函数$y_i(x)$的函数值变为零时斜率才会发生变化，现在问题就转化成了求这些函数里不同的零点个数。 这题对精度有一点要求，用long double就可以过了，不过写一个分数类可以完全避免精度问题。 求不同的数的个数直接std::unique就好了 【代码】123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;std::vector&lt;long double&gt; a;int main() &#123;#ifndef tst freopen("polyline.in", "r", stdin); freopen("polyline.out", "w", stdout);#endif int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; long double k, b; scanf("%Lf%Lf", &amp;k, &amp;b); if (k != 0) a.push_back(-b / k); &#125; std::sort(a.begin(), a.end()); printf("%d\n", std::unique(a.begin(), a.end()) - a.begin()); #ifndef tst fclose(stdin); fclose(stdout);#endif return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美好的一天]]></title>
    <url>%2F2017%2F08%2F28%2FGoodDay%2F</url>
    <content type="text"><![CDATA[今天是丁酉鸡年(2017)农历七月七日，是一年一度的七夕拜魁星的日子，为了表示纪念，我决定从今天开始 尽量使用vim写代码 数组从0开始编号]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codeforces #428(div2) C] Journey - 数学期望]]></title>
    <url>%2F2017%2F08%2F13%2FCodeforces_428_C%2F</url>
    <content type="text"><![CDATA[【链接】Codeforces #428(div2) Journey 【题目描述】There are $n$ cities and $n - 1$ roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads. Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren’t before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities. Let the length of each road be $1$. The journey starts in the city $1$. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link https://en.wikipedia.org/wiki/Expected_value. 给定一棵树，每一条边的长度都是$1$，每一个点都可以到达与他直接相连的之前未访问过的点，访问每个点的概率相同，当周围没有满足条件的点的时候结束，求走过的总路径长度的数学期望。 【输入描述】The first line contains a single integer $n (1 \leq n \leq 100000)$ — number of cities. Then n - 1 lines follow. The i-th line of these lines contains two integers $u_i$ and $v_i (1 \leq u_i, v_i \leq n, u_i \neq v_i)$ — the cities connected by the $i$-th road. It is guaranteed that one can reach any city from any other by the roads. 【输出描述】Print a number — the expected length of their journey. The journey starts in the city $1$. Your answer will be considered correct if its absolute or relative error does not exceed $10 ^{-6}$. Namely: let’s assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\frac{|a - b|}{\max(1, b)} \leq 10^{-6}$. 【题解】理解数学期望的含义之后做法就很明显了，最后停止的时候一定是在某个叶节点上，这样预处理出每个节点的深度，和到达每个点的概率，最后检查每一个叶节点，把深度与概率相乘后求和即可。 出题人给的正解用的是DFS，比较玄妙看的不是很懂 比赛的时候写了两种算法都很接近正解然而…… 发现用std::vector&lt;&gt;存图好像很方便诶…… 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;queue&gt;const int MAXN = 100000 + 10;struct Node;struct Edge;struct Node &#123; int depth, size; bool vis; double probability; Edge *edges; Node() : depth(-1), size(0),vis(false), probability(1), edges(NULL) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr = NULL, Node *to = NULL) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v); v-&gt;edges = new Edge(v, u);&#125;void bfs(Node *x) &#123; std::queue&lt;Node*&gt; q; q.push(x); x-&gt;vis = true; x-&gt;depth = 0; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if (!e-&gt;to-&gt;vis) &#123; e-&gt;to-&gt;vis = true; e-&gt;to-&gt;depth = v-&gt;depth + 1; if (v - nodes == 1) e-&gt;to-&gt;probability = 1.0 / v-&gt;size; else e-&gt;to-&gt;probability = v-&gt;probability / (v-&gt;size - 1); q.push(e-&gt;to); &#125; &#125; &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(nodes + u, nodes + v); nodes[u].size++; nodes[v].size++; &#125; bfs(nodes + 1); double sum = 0; for (int i = 1; i &lt;= n; i++) &#123; if (nodes[i].size == 1 &amp;&amp; i != 1) &#123; sum += nodes[i].depth * nodes[i].probability; &#125; &#125; printf("%lf\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codefoces #428(div2) B] Game of the Rows - 贪心]]></title>
    <url>%2F2017%2F08%2F13%2FCodeforces_428_B%2F</url>
    <content type="text"><![CDATA[【链接】Codeforces #428(div2) Game of the Rows 【题目描述】Daenerys Targaryen has an army consisting of $k$ groups of soldiers, the $i$-th group contains $a_i$ soldiers. She wants to bring her army to the other side of the sea to get the Iron Throne. She has recently bought an airplane to carry her army through the sea. The airplane has n rows, each of them has $8$ seats. We call two seats neighbor, if they are in the same row and in seats ${1, 2}$, ${3, 4}$, ${4, 5}$, ${5, 6}$ or ${7, 8}$. A row in the airplane Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats. Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied. 飞机上有$n$排如图所示的座椅，现在有$k$个小队，每个小队有$a_i$个人，要给这些人排座位，要求不同小队的人不能相邻，问能否实现 【输入描述】The first line contains two integers $n$ and $k (1 \leq n \leq 10000, 1 \leq k \leq 100)$ — the number of rows and the number of groups of soldiers, respectively. The second line contains $k$ integers $a_1, a_2, a_3 \dots a_k (1 \leq a_i \leq 10000)$, where $a_i$ denotes the number of soldiers in the $i$-th group. It is guaranteed that $\sum_{i = 1}^k a_i \leq 8 \times n$. 【输出描述】If we can place the soldiers in the airplane print YES (without quotes). Otherwise print NO (without quotes). You can choose the case (lower or upper) for each letter arbitrary. 【题解】贪心，考虑这样几种小队人数情况：大于等于$4$人，$3$人，$2$人，$1$人。 依次处理下面这几种情况。 对于大于等于$4$人的小队，以$4$人为一组安排，他们优先坐中间的四个位置，如果中间的座位已经满了，那就坐边上的两个位置。 对于$3$人的小队，处理方法与大于等于$4$人的小队相同。 对于$2$人的小队，他们优先坐边上的两个位置，如果边上没有位置但中间还有位置，那就把中间的位置拿出两个分配给他们，然后中间还剩下一个可用的座位，如果中间也没有位置了，那就把两人拆开，最后处理。 对于$1$人的小队，只要看看剩下的座位够不够用就可以了。 如果以上任意一步不能满足，那么就是NO 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;const int MAXN = 100 + 10;int have[5], cnt[5];int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); have[4] = n; have[2] = n * 2; for (int i = 1; i &lt;= k; i++) &#123; int x; scanf("%d", &amp;x); while (x &gt;= 3) &#123; if (have[4] &gt; 0) have[4]--, x -= 4; else if (have[2] &gt; 0) have[2]--, x -= 2; else &#123; printf("NO\n"); return 0; &#125; &#125; if (x &gt; 0) cnt[x]++; &#125; while (cnt[2] &gt; 0) &#123; if (have[2] &gt; 0) have[2]--, cnt[2]--; else if (have[4] &gt; 0) have[4]--, cnt[2]--, have[1]++; else cnt[2]--, cnt[1] += 2; &#125; if (cnt[1] &gt; have[1] + have[2] + have[4] * 2) &#123; printf("NO\n"); return 0; &#125; printf("YES\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codefoces #271(div2) D] Flowers - 序列DP]]></title>
    <url>%2F2017%2F07%2F30%2FCodeforces_271_D%2F</url>
    <content type="text"><![CDATA[【链接】Codeforces #271(div2) Flowers 【题目描述】We saw the little game Marmot made for Mole’s lunch. Now it’s Marmot’s dinner time and, as we all know, Marmot eats flowers. At every dinner he eats some red and white flowers. Therefore a dinner can be represented as a sequence of several flowers, some of them white and some of them red. But, for a dinner to be tasty, there is a rule: Marmot wants to eat white flowers only in groups of size k. Now Marmot wonders in how many ways he can eat between a and b flowers. As the number of ways could be very large, print it modulo $1000000007 (10^9 + 7)$. 题目大意是说有一只土拨鼠爱吃花 边 ，花有红白两种，如果吃白花，那么就一次吃$k$朵，如果吃红花，那么就一次吃一朵，$n$次询问在区间$[a, b]$中，共有多少种吃花方法。 【输入描述】Input contains several test cases. The first line contains two integers $t$ and $k (1 \leq t, k \leq 105)$, where $t$ represents the number of test cases. The next $t$ lines contain two integers $a_i$ and $b_i$ $(1 \leq a_i ≤\leq b_i \leq 105)$, describing the $i$-th test. 【输出描述】Print t lines to the standard output. The i-th line should contain the number of ways in which Marmot can eat between ai and bi flowers at dinner modulo $1000000007 (10^9 + 7)$. 【题解】考虑序列DP,设 $f(i)$ 表示吃到第 $i$ 朵花时的方案数，则转移为 f(i) = f(i - 1) + f(i - k)边界为$f(0) = 1$，初始化的时候$f(i) = f(i - 1)$ 即考虑第$i$朵花是红花还是白花，处理完$f$数组之后求一下前缀和，就可以在$O(1)$的时间内回答每次询问了。 【代码】12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;const int MOD = 1e9 + 7;const int MAXN = 100000 + 10;int f[MAXN];int k;int main() &#123; int t; scanf("%d%d", &amp;t, &amp;k); f[0] = 1; for (int i = 1; i &lt; MAXN; i++) &#123; f[i] = f[i - 1]; if (i &gt;= k) f[i] = (f[i] % MOD + f[i - k] % MOD) % MOD; &#125; for (int i = 1; i &lt; MAXN; i++) &#123; f[i] = (f[i - 1] % MOD + f[i] % MOD) % MOD; &#125; while (t--) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", ((f[b] - f[a - 1]) + MOD) % MOD); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDSC Day5 T1] 小菜一碟的背包 - 背包DP]]></title>
    <url>%2F2017%2F07%2F30%2FSDSC_Day5_T1%2F</url>
    <content type="text"><![CDATA[【链接】没有链接 【题目描述】Blice和阿强巴是好朋友但萌萌哒Blice不擅长数学,所以阿强巴给了她一些奶牛做练习 阿强巴有 $n$ 头奶牛,每头奶牛每天可以产一定量的奶,同时也需要一定量的草作为饲料 对于第 $i$ 头奶牛来说,它每天可以产 $v_i$ 升的奶,同时需要 $w_i$ 千克的草作为饲料 现在来自蚯蚓国的九条可怜想借一些奶牛,使借走的这些奶牛每天的总产奶量最大,但九条可怜很穷,每天最多只能提供$W_i$千克的草作为饲料,而且她还需要对付跳蚤国的神刀手,所以她把这个问题交给了阿强巴,不不不……阿强巴觉得这个问题太简单了,所以把这个问题交给了你 【输入描述】第一行两个整数 $n$, $W$ ,表示奶牛的数量和每天最多能提供的草 接下来 $n$ 行,每行两个整数,第 $i$ 行表示第 $i$ 头奶牛的产奶量 $v_i$ 和食量 $w_i$ 【输出描述】仅一行,输出一个整数,表示每天最大的总产奶量 【数据范围及提示】对于 $20\%$ 的数据, $n \leq 10$ 另有 $30\%$ 的数据, $W \leq 10000$ 另有 $10\%$ 的数据, $w_i = w_1$ 对于 $100\%$ 的数据, $1 \leq n \leq 100 , 1 \leq w_i , W \leq 10 ^ 9 , 1 \leq v_i \leq 10^7$ 对于所有数据,均满足特殊限制:$w_1 \leq w_i \leq w_1 + 3$ 【题解】看上去就是裸的01背包，但是注意到 $ W \leq 10^9$，普通做法就算是用一维数组也是开不下的，所以试着对01背包稍微变形 注意到题目中给出了一条特殊限制$w_1 \leq w_i \leq w_1 + 3$，也就是说每一个牛的食量是不会比第一头牛的食量多三以上的，这样一来如果每一头奶牛的食量都减掉第一头牛的食量，并不会影响我们的决策，但是这时我们的需要提供的草就大大减少了，最多只需要$100\times 3$ 设状态 $f(i, j, k)$ 表示前 $i$ 头牛中选择 $j$ 头，消耗 $k$ 单位的草所获得的最大产奶量，则转移为： f(i, j, k) = \max(f(i + 1, j + 1, k + w_{i + 1}) + v_{i + 1}, f(i + 1, j, k))实现上使用了记忆化搜索 【代码】12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 100 + 10;int f[MAXN][MAXN][MAXN * 3];bool vis[MAXN][MAXN][MAXN * 3];int v[MAXN], c[MAXN];int n, W, delta;int dp(int i, int j, int k) &#123; if (j * delta + k &gt; W) return INT_MIN; if (vis[i][j][k]) return f[i][j][k]; if (i == n) return 0; else &#123; vis[i][j][k] = true; f[i][j][k] = std::max(dp(i + 1, j, k), dp(i + 1, j + 1, k + c[i + 1]) + v[i + 1]); &#125; return f[i][j][k];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;W); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;v[i], &amp;c[i]); &#125; delta = c[1]; for (int i = 1; i &lt;= n; i++) &#123; c[i] -= delta; &#125; printf("%d\n", dp(0, 0, 0)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 1008] 越狱 - 排列组合]]></title>
    <url>%2F2017%2F07%2F29%2Fbzoj_1008%2F</url>
    <content type="text"><![CDATA[【链接】bzoj 1008 越狱 【题目描述】监狱有连续编号为$[1, n]$的$n$个房间，每个房间关押一个犯人，有$m$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。 【输入描述】输入两个整数$m, n$。 $1 \leq m \leq 10^8,1 \leq N \leq 10^{12}$ 【输出描述】可能越狱的状态数，模$100003$取余 【题解】普通的组合问题，使用分步乘法计数原理，每一步考虑这个位置上有多少种选择，显然第一个位置有$m$种选择，剩下的位置因为不能与相邻位置相同，所以都只有$m - 1$种选择，答案就是 ans = m \times (m - 1) ^ {n - 1}注意在取模的时候，减法分步取模的时候要记得加上一个 $mod$ 防止出现负数。 开始写的时候把$n$和$m$读入反了…… 【代码】12345678910111213141516171819202122#include &lt;cstdio&gt;const int MOD = 100003;inline long long mulMod(long long a, long long b) &#123; return ((a % MOD) * (b % MOD)) % MOD;&#125;inline long long fastPowMod(long long a, long long b) &#123; if (b == 1) return a; else if (b == 0) return 1; else if (b % 2 == 0) return fastPowMod(mulMod(a, a), b &gt;&gt; 1); else if (b % 2 != 0) return mulMod(fastPowMod(a, b - 1), a);&#125;int main() &#123; long long n, m; scanf("%lld%lld", &amp;m, &amp;n); printf("%lld\n", (MOD + fastPowMod(m, n) % MOD - m * fastPowMod(m - 1, n - 1) % MOD) % MOD); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDSC Day2 T1] 债务 - 暴力]]></title>
    <url>%2F2017%2F07%2F28%2FSDSC_Day2_T1%2F</url>
    <content type="text"><![CDATA[【链接】没有链接 【题目描述】小 $G$ 有一群好朋友,他们经常互相借钱。假如说有三个好朋友 $A$, $B$, $C$。$A$ 欠 $B$ $20$ 元, $B$ 欠 $C$ $20 $元, 总债务规模为 $20 + 20 = 40$ 元。小 $G$ 是个追求简约的人,他觉得这样的债务太繁杂了。他认为,上面的债务可以完全等价为 $A$ 欠 $C$ $20$ 元,$B$ 既不欠别人,别人也不欠他。这样总债务规模就压缩到了 $20$ 元。现在给定 $n$ 个人和 $m$ 条债务关系。小 $G$ 想找到一种新的债务方案,使得每个人欠钱的总数不变,或被欠钱的总数不变(但是对象可以发生变化),并且使得总债务规模最小。 【输入描述】输入文件第一行两个数字 $n$, $m$,含义如题目所述。 接下来 $m$ 行,每行三个数字 $a_i$ , $b_i$ , $c_i$ ,表示 $a_i$ 欠 $b_i$ 的钱数为 $c_i$ 。 注意,数据中关于某两个人 $A$ 和 $B$ 的债务信息可能出现多次,将其累加即可。 【输出描述】输出文件共一行,输出最小的总债务规模。 【题解】根据债务关系建图，把边权转移到点上，起点点权减边权，终点点权加边权，最后bfs一遍把所有正点权相加即为答案。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;const int MAXN = 1000000 + 10;struct Node;struct Edge;struct Node &#123; bool vis; Edge *edges; int val; Node() : edges(NULL), vis(false), val(0) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) :fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(u, v, w);&#125;int main() &#123; freopen("debt.in", "r", stdin); freopen("debt.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(nodes + u, nodes + v, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123; e-&gt;fr-&gt;val -= e-&gt;w; e-&gt;to-&gt;val += e-&gt;w; &#125; &#125; int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; if (nodes[i].val &gt;= 0) sum += nodes[i].val; &#125; printf("%d\n", sum); fclose(stdin); fclose(stdout); return 0;&#125; 【另】感谢 Roller_dhw 同学提供的思路]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bzoj 1015] 星球大战 - 并查集]]></title>
    <url>%2F2017%2F07%2F27%2Fbzoj_1015%2F</url>
    <content type="text"><![CDATA[【链接】bzoj 1015 星球大战 【题目描述】很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 【输入描述】输入文件第一行包含两个整数，$n(1 \leq n \leq 2 \times m)$ 和 $m(1 \leq m \leq 200,000)$，分别表示星球的数目和以太隧道的数目。星球用 $[0, n-1]$的整数编号。接下来的$m$行，每行包括两个整数$x, y$，其中$(0 \leq x \neq y)$ 表示星球$x$和星球$y$之间有“以太”隧道，可以直接通讯。接下来的一行为一个整数$k$，表示将遭受攻击的星球的数目。接下来的$k$行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这$k$个数互不相同，且都在$0$到$n-1$的范围内。 【输出描述】第一行是开始时星球的连通块个数。接下来的$k$行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 【题解】离线处理的逆序并查集。对于末状态，先把一开始有的所有边存起来，图建好，记录下收到打击的星球，然后枚举每一条边，如果这条边的两端都没有受到打击，就在并查集里把他们合并。 之后逆序枚举操作，使用sum记录当前有多少个联通块，恢复一个点的时候首先增加一个联通块（这恢复出的点本身作为一个联通块），然后把这个点记做未被打击，枚举和它相关的边，每有一条边能与其他联通块联通，sum--。 每次操作后的sum存在num数组里，最后顺序输出，其中num[0]为最末状态，也就是我们算出的第一个sum值。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;const int MAXM = 200000 + 10;;std::vector&lt;int&gt; graph[MAXM * 4];int star[MAXM * 2];bool destroy[MAXM * 2];int num[MAXM * 2];struct Edge &#123; int fr, to;&#125; edges[MAXM];void addEdge(int fr, int to) &#123; graph[fr].push_back(to); graph[to].push_back(fr);&#125;struct Ufs &#123; int fa[MAXM * 2]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) &#123; fa[i] = i; &#125; &#125; int find(int x) &#123; if (fa[x] != x) fa[x] = find(fa[x]); return fa[x]; &#125; void merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); fa[r1] = r2; &#125;&#125; ufs;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;edges[i].fr, &amp;edges[i].to); &#125; int k; scanf("%d", &amp;k); // memset(destroy, false, sizeof(false)); for (int i = 1; i &lt;= k; i++) &#123; scanf("%d", &amp;star[i]); destroy[star[i]] = true; &#125; for (int i = 1; i &lt;= m; i++) &#123; addEdge(edges[i].fr, edges[i].to); &#125; ufs.init(n); for (int i = 0; i &lt; n; i++) &#123; if (destroy[i]) continue; else &#123; for (int j = 0; j &lt; graph[i].size(); j++) &#123; if (!destroy[graph[i][j]]) &#123; ufs.merge(i, graph[i][j]); // printf("yes\n"); // printf("u = %d, v = %d\n", i, graph[i][j]); &#125; &#125; &#125; &#125; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; if (!destroy[i] &amp;&amp; ufs.find(i) == i) sum++; &#125; for (int i = k; i &gt; 0; i--) &#123; num[i] = sum; int u = star[i]; destroy[u] = false; sum++; // bool flag = false; for (int j = 0; j &lt; graph[u].size(); j++) &#123; int v = graph[u][j]; if (!destroy[v]) &#123; if (ufs.find(v) != ufs.find(u)) &#123; ufs.merge(v, u); sum--; // flag = true; &#125; &#125; &#125; // if (!flag) sum++; &#125; num[0] = sum; for (int i = 0; i &lt;= k; i++) &#123; printf("%d\n", num[i]); &#125; return 0;&#125;// 8 13// 0 1// 1 6// 6 5// 5 0// 0 6// 1 2// 2 3// 3 4// 4 5// 7 1// 7 2// 7 6// 3 6// 5// 1// 6// 3// 5// 7// 1// 1// 1// 2// 3// 3]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 4650] 破损的键盘 - 链表]]></title>
    <url>%2F2017%2F07%2F25%2Fcodevs_4650%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 4650 破损的键盘 【题目描述】有一天，你需要打一份文件，但是你的键盘坏了，上面的home键和end键会时不时地按下，而你却毫不知情，甚至你都懒得打开显示器，当你打开显示器之后，出现在你的面前的是一段悲剧的文本。 【输入描述】输入只有一行，即这份文件，这份文件只包含小写字母和[以及]，用[代替home键，用]代替end键。 【输出描述】你的任务是在打开显示器之前，计算出这份悲剧的文档。 【题解】直接用一个链表模拟即可。 链表的入门题目，借此熟悉一下std::list&lt;&gt;的相关操作。 定义 下面的代码定义了一个名为ls的int类型的双向链表 1std::list&lt;int&gt; ls; 插入和删除 链表的特色就是能快速在链表中的某个位置插入和删除元素，下面的代码使用在迭代器it所在指向的位置插入5 1ls.insert(it, 5); 迭代器 下面的代码定义了一个list的迭代器 1list&lt;type&gt;::iterator iterator_name; 成员函数 下面的代码使用成员函数clear()清空链表 1ls.clear(); 【代码】1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;list&gt;#include &lt;cstring&gt;const int MAXN = 10000 + 10;char list[MAXN];std::list&lt;char&gt; ls;int main() &#123; while (scanf("%s", list) == 1) &#123; ls.clear(); int len = strlen(list); std::list&lt;char&gt;::iterator now = ls.begin(); for (int i = 0; i &lt; len; i++) &#123; if (list[i] == '[') &#123; now = ls.begin(); continue; &#125; if (list[i] == ']') &#123; now = ls.end(); continue; &#125; ls.insert(now, list[i]); &#125; now = ls.begin(); for (std::list&lt;char&gt;::iterator it = ls.begin(); it != ls.end(); it++) &#123; printf("%c", *it); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1043] 方格取数 - 棋盘DP]]></title>
    <url>%2F2017%2F07%2F17%2Fcodevs-1043%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 1043 方格取数 【题目描述】设有$n \times n$的方格图$(n \leq 10)$,我们将其中的某些方格中填入正整数,而其他的方格中则放入数字$0$。 某人从图的左上角的$A$点出发，可以向下行走，也可以向右走，直到到达右下角的$B$点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字$0$）。 此人从$A$点到$B$点共走两次，试找出$2$条这样的路径，使得取得的数之和为最大。 【输入描述】输入的第一行为一个整数 $n$（表示 $n \times n$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。 【输出描述】只需输出一个整数，表示 $2$ 条路径上取得的最大的和。 【题解】虽然说是DP，但个人感觉更像暴力…… 设状态 $f[i][j][k][l]$ 表示第一次走到 $(i, j)$ 第二次走到 $(k, l)$ 所得到的最大价值 状态转移方程为： f[i][j][k][l] = \max \begin{cases} f[i - 1][j][k - 1][l] \\[2ex] f[i - 1][j][k][l - 1] \\[2ex] f[i][j - 1][k - 1][l] \\[2ex] f[i][j - 1][k][l - 1] \end{cases} + \begin{cases} num[i][j] , &\text{$i = k \land j = l$}\\[2ex] num[i][j] + num[k][l] , &\text{$i \neq k \land j \neq l$} \end{cases}最后要保证如果两条路线经过同一个点的话只把格子中的数取一次。 复杂度$O(n^4)$，对于原题的$n \leq 10$来说足够了 输入格式有点奇怪需要注意一下。 【代码】12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 10 + 10;int a[MAXN][MAXN];int f[MAXN][MAXN][MAXN][MAXN];int main() &#123; int n; scanf("%d", &amp;n); int x, y, num; while (scanf("%d%d%d", &amp;x, &amp;y, &amp;num) == 3 &amp;&amp; x != 0 &amp;&amp; y != 0 &amp;&amp; num != 0) &#123; a[x][y] = num; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int l = 1; l &lt;= n; l++) &#123; int &amp;tmp = f[i][j][k][l]; tmp = std::max(std::max(f[i - 1][j][k - 1][l], f[i][j - 1][k][l - 1]), std::max(f[i][j - 1][k - 1][l], f[i - 1][j][k][l - 1])); if (i == k &amp;&amp; j == l) tmp += a[i][j]; else &#123; tmp += a[i][j]; tmp += a[k][l]; &#125; &#125; &#125; &#125; &#125; printf("%d\n", f[n][n][n][n]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>棋盘DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2017%2F07%2F16%2FSegmentTree-Learn%2F</url>
    <content type="text"><![CDATA[拖了很久的线段树学习笔记。 【一些练习】Codevs 1080 线段树练习一 Codevs 1081 线段树练习二 Codevs 1082 线段树练习三 【这是什么】线段树（SegmentTree）是一种用来维护区间信息的数据结构，可以快速的维护一些符合「区间加法」的信息，比如区间和，区间最值，而一些不符合「区间加法」的信息，比如区间众数，是不能用线段树维护的。 线段树是一棵二叉树，每一个节点看做一个区间，存储该区间的相关信息，左右子树递归的均分父节点的线段，就像这样： 【常见操作】对于一棵线段树，它支持的操作通常有下面几种 单点修改 区间修改 单点查询 区间查询 【原理】以下以维护区间和为例简述线段树的原理 对于一个静态的区间和查询问题，我们可以利用前缀和达到预处理$O(n)$，查询$O(1)$，但是我们考虑这个问题的动态版本，如果我们增加修改操作，前缀和就不那么靠谱了，因为我每进行一次修改，我的前缀和都要发生相应的改变，这样的复杂度显然没有变优。 这个时候，我们强大的线段树就要派上用场了。 【单点修改】之前说过，线段树每一个节点维护一个区间的信息（区间端点，区间中点，区间和等），而一个大区间中的信息又可以由若干小区间（子节点）合并得到（线段树只能维护符合「区间加法」信息），这样一来，我对于某个单点，或者说某个区间，中信息的修改，实际上只会影响到这棵树上的一部分节点，那么剩下的节点我们就不去管它。比如对于上图，如果我们要修改5这个位置上的值，那我就直接修改他，然后5的变化会引起那些节点的变化呢？只会影响他的父节点，影响父节点的父节点等等，那么这个时候我们就可以一路合并上去，因为线段树是一棵二叉树，所以最多有$\log n$层，找到需要修改的节点需要$O(\log n)$，把信息合并上去也需要$O(\log n)$，那么我们说线段树单点修改的复杂度就是$O(\log n)$的 实现起来就像这样123456789void modify(int index, int delta) &#123; if (r - l == 1) sum += delta; else &#123; if (index &lt; mid) lc-&gt;modify(index, delta); else rc-&gt;modify(index, delta); update(); &#125;&#125; 【单点查询】单点查询非常简单，只需要一路找到你需要的点就可以了，复杂度$O(\log n)$ 实现起来就像这样1234567int query(int index) &#123; if (r - l == 1) return sum; else &#123; if (index &gt; mid) return rc-&gt;query(index); if (index &lt; mid) return lc-&gt;query(index); &#125;&#125; 如果有懒标记(下面会讲到)，记得把标记下放 实现起来就像这样12345678int query(int index) &#123; if (r - l == 1) return sum; else &#123; pushDown(); if (index &gt; mid) return rc-&gt;query(index); if (index &lt; mid) return lc-&gt;query(index); &#125;&#125; 【区间修改】在区间修改这个操作当中，我们引入「懒标记」的概念，所谓「懒标记」，就是说我们在找到我们要修改的区间之后，我不真的去修改它，而是在它上面打上一个标记，表示这个区间中的信息应该被修改，而我们只在需要用到这个区间中的节点的信息的时候，才真正的修改它，也就是说，如果这个修改过的区间中的点从来没有被查询到，那么我为什么要真的去修改它呢？我只需要保证我查询能得到正确的结果就好了。 什么叫做需要用到这个区间中的节点的信息呢？简单来说就是本节点的统计信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。 比如说，我要对$[1, 5]$这个区间中的每一个数都$+1$，那么我从根向下找，在代表区间$[1, 5]$的节点上打上一个$+1$的懒标记，表示这个区间中的每一个数都加一，然后这个节点中所维护的sum加五，因为下面总共有$5$个数，假如挨着一个个修改完再合并上来，那整个区间相当于加了$5$，这个时候，我的这一次区间修改就完成了，尽管我并没有真正的修改这个区间中的任何数。那么如果接下来的操作和这个区间完全没有关系的话，这个标记我就完全可以放在那里不管他，因为他不会影响我查询的结果，但是，如果说下面出现了一个操作是$[4, 5]$这个区间中所有的数$-1$怎么办？现在，就是我们所说的需要用到这个区间中的子区间的信息的时候。 现在我们还是一路向下找到$[1, 5]$这个区间，发现上面有个标记，但是我们要操作的区间在有标记的区间的下面，怎么办呢？我们把标记下放，先在他的左右子节点上同样的打上$+1$的标记，同样的修改子节点所维护的值，然后把这个节点的标记清空。标记下放完之后，新的标记就可以打在$[4, 5]$这个区间上了，这里注意的是像区间加某个数的标记可以叠加，但是像直接把这个区间里的数全部修改为某个数的标记，是不能叠加的，或者说是会前后覆盖的。 实现起来就像这样12345678910111213141516171819202122232425void addTag(int delta) &#123; lazy += delta; sum += (r - l) * delta; &#125; void pushDown() &#123; if (lazy) &#123; lc-&gt;addTag(lazy); rc-&gt;addTag(lazy); lazy = 0; &#125; &#125; void modify(int l, int r, int delta) &#123; pushDown(); if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; addTag(delta); &#125; else &#123; if (l &lt; mid) &#123; lc-&gt;modify(l, std::min(mid, r), delta); &#125; if (r &gt; mid) &#123; rc-&gt;modify(std::max(mid, l), r, delta); &#125; update(); &#125; &#125; 上述代码上有个小技巧，就是解决「我修改的区间不是正好被线段树上的某个节点完全覆盖怎么办」这个问题。只需要把这个区间分割，直到能被某个节点完全覆盖为止就可以了，打完标记之后不要忘记向上合并信息。 【区间查询】对于没有懒标记的区间查询，只需要一路向下查找查询区间，如果没有恰好被某个节点覆盖那就分割，最后合并两个区间的信息就好了。 实现起来就像这样12345678910int query(int l, int r) &#123; if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return sum; else &#123; int ans = 0; if (l &lt; mid) ans += lc-&gt;query(l, std::min(r, mid)); if (r &gt; mid) ans += rc-&gt;query(std::max(mid, l), r); return ans; &#125;&#125; 如果有懒标记呢？我们说查询也是需要用到这个区间中的子区间的信息的情况，所以需要把标记下放，唯一的区别就是多了一步pushDown() 实现起来就像这样123456789101112long long query(long long l, long long r) &#123; long long ans = 0; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; return sum; &#125; else &#123; pushDown(); if (l &lt; mid) ans += lc-&gt;query(l, std::min(mid, r)); if (r &gt; mid) ans += rc-&gt;query(std::max(l, mid), r); return ans; &#125;&#125; 【实现】上面大概的讲了各个操作的实现，接下来说一下这个数据结构整体要怎么建立。 线段树就是一棵二叉树，所以我们使用经典的链表实现12345678910111213141516171819202122struct SegmentTree &#123; int l, r, mid, sum; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; sum = 0; lc = rc = NULL; &#125; void update() &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void build() &#123; if (r - l == 1) &#123; sum = a[l]; &#125; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125;&#125;; update函数就是前面提到的「区间信息的合并」，如果是区间和的话就相加，如果是区间最大值就std::max()，以此类推。 build函数是在递归建树，分割区间作为左右子树。 构造函数传两个参数，根据这两个参数构造一个区间，其中包含左右端点和区间中点。 对于需要支持区间修改的线段树，需要多保存一个lazy变量作为标记。 使用的时候需要建一个代表整个区间的根节点SegmentTree root(1, n + 1)， 然后root.build()建树。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct SegmentTree &#123; long long l, r, mid, lazy, sum; SegmentTree *lc, *rc; SegmentTree(long long l, long long r) : l(l), r(r) &#123; mid = (l + r) / 2; lazy = sum = 0; lc = rc = NULL; &#125; void update() &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void build() &#123; if (r - l == 1) &#123; sum = a[l]; &#125; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void addTag(long long delta) &#123; lazy += delta; sum += (r - l) * delta; &#125; void pushDown() &#123; if (lazy) &#123; lc-&gt;addTag(lazy); rc-&gt;addTag(lazy); lazy = 0; &#125; &#125; void rangeModify(long long l, long long r, long long delta) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; addTag(delta); &#125; else &#123; pushDown(); if (l &lt; mid) lc-&gt;modify(l, std::min(mid, r), delta); if (r &gt; mid) rc-&gt;modify(std::max(mid, l), r, delta); update(); &#125; &#125; long long rangeQuery(long long l, long long r) &#123; long long ans = 0; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; return sum; &#125; else &#123; pushDown(); if (l &lt; mid) ans += lc-&gt;query(l, std::min(mid, r)); if (r &gt; mid) ans += rc-&gt;query(std::max(l, mid), r); return ans; &#125; &#125; void modify(int index, int delta) &#123; if (r - l == 1) sum += delta; else &#123; if (index &lt; mid) lc-&gt;modify(index, delta); else rc-&gt;modify(index, delta); update(); &#125; &#125; int query(int index) &#123; if (r - 1 == 1) return sum; else &#123; pushDown(); if (index &gt; mid) return rc-&gt;query(index); if (index &lt; mid) return lc-&gt;query(index); &#125; &#125;&#125;; 【注意】 线段树在使用原始数据建完树之后，所有的操作都是在线段树上进行的，不会修改原始数据。 所有操作都可以写在结构里面作为成员函数 这里线段树表示的区间是左闭右开的，这样求区间中点直接 $\frac{l + r}{2}$ 就可以了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1093] 花生采摘 - 枚举]]></title>
    <url>%2F2017%2F07%2F16%2Fcodevs-1093%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1093 花生采摘 【题目描述】在告示牌背后，路边有一块花生田，花生植株整齐地排列成矩形网格。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。” 我们假定多多在每个单位时间内，可以做下列四件事情中的一件： 1) 从路边跳到最靠近路边（即第一行）的某棵花生植株； 2) 从一棵植株跳到前后左右与之相邻的另一棵植株； 3) 采摘一棵植株下的花生； 4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。 现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。 【输入描述】输入第一行包括三个整数，$m$，$n$ 和 $k$，用空格隔开；表示花生田的大小为 $m \times n(1 \leq m, n \leq 20)$，多多采花生的限定时间为$K(0 \leq K \leq 1000)$个单位时间。接下来的$m$行，每行包括$n$个非负整数，也用空格隔开；第$i + 1$行的第$j$个整数$P{ij}(0 \leq P{ij} \leq 500)$表示花生田里植株$(i, j)$下花生的数目，$0$表示该植株下没有花生。 【输出描述】输出包括一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。 【题解】题面中说了采摘花生的顺序是一定的，所以排序之后从大到小枚举，如果采了这个花生还能回去那就采，不能就不采，从上一棵花生直接往回走。 两棵花生之间的距离为曼哈顿距离。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int MAXN = 20 * 20 + 10;struct Node &#123; int x, y, num; Node(int x = 0, int y = 0, int num = 0) : x(x), y(y), num(num) &#123;&#125; bool operator&lt;(const Node &amp;a) const &#123; return num &gt; a.num; &#125;&#125; nodes[MAXN];int calc(Node a, Node b) &#123; return (abs(a.x - b.x) + abs(a.y - b.y));&#125;int main() &#123; int n, m, lim; scanf("%d%d%d", &amp;n, &amp;m, &amp;lim); int cnt = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int k; scanf("%d", &amp;k); if (k != 0) &#123; nodes[cnt].x = i; nodes[cnt].y = j; nodes[cnt].num = k; cnt++; &#125; &#125; &#125; std::sort(nodes + 1, nodes + cnt); int sum = 0; Node now(0, nodes[1].y, 0); for (int i = 1; i &lt;= cnt; i++) &#123; lim -= (calc(now, nodes[i]) + 1); if (lim &lt; nodes[i].x) break; sum += nodes[i].num; now = nodes[i]; &#125; printf("%d\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1017]乘积最大 - 划分DP]]></title>
    <url>%2F2017%2F07%2F02%2FCodevs_1017%2F</url>
    <content type="text"><![CDATA[【题目链接】 Codevs 1017 乘积最大 【题目描述】 给出由$n$个数字组成的数字串，要求在其中插入$k$个乘号将其分为$k + 1$个部分，使得这些部分的乘积最大 【输入描述】程序的输入共有两行： 第一行共有$2$个自然数$n，k(6 \le n \le 40，1 \le k \le 6)$ 第二行是一个长度为N的数字串。 【输出描述】输出所求得的最大乘积 【题解】划分DP 设状态$f(n, k)$表示在前$n$个数字中插入$k$个乘号能获得的最大乘积。 则转移为 f(i, j) = \max\{ f(i, j - 1) \times num[i + 1][n]\}含义为在如果在$i$这个位置插入一个乘号，则答案为在前$i$个位置插入$j - 1$个乘号的最优结果乘上在$i$这个位置插入乘号后划分出的数。 计算的时候先预处理出每一个区间构成的数字是多少 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100;char s[MAXN];int num[MAXN][MAXN];long long f[MAXN][MAXN];bool vis[MAXN][MAXN];long long search(int n, int k) &#123; long long &amp;ans = f[n][k]; if (k == 0) return num[0][n]; if (!vis[n][k]) &#123; vis[n][k] = true; for (int i = k - 1; i &lt; n; i++) &#123; ans = std::max(ans, search(i, k - 1) * num[i + 1][n]); &#125; &#125; return ans;&#125;int main() &#123; int n, k; scanf("%d%d%s", &amp;n, &amp;k, s); for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int bit = 1; for (int k = j; k &gt;= i; k--) &#123; num[i][j] += (s[k] - '0') * bit; bit *= 10; &#125; &#125; &#125; printf("%lld\n", search(n - 1, k)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>划分DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVa 1674]Lightning Energy Report - LCA]]></title>
    <url>%2F2017%2F06%2F17%2Flighting%2F</url>
    <content type="text"><![CDATA[【题目链接】UVa 1674 Lightning Energy Report 【题目描述】给你一棵树，实现一个操作 modify(a, b, c) 使得 a 到 b 的路径上所有点的 electrical energy 加上 c ，问最终每个点上的能量值为多少 【题解】 树剖 不会树剖怎么办 在节点上记录一个mark值， 对于每一个操作 modify(a, b, c) ，a-&gt;mark += c，b-&gt;mark += c，lca(a, b)-&gt;mark -= c，如果lca(a, b)不为根，那么lca(a, b)-&gt;father-&gt;mark -= c 这样一来每个点的的能量值就是以这个点为根的子树的mark值的和，最后DFS一遍就可以求出来了 NOIP2015 运输计划运用了相似的思想 然而我的倍增LCATLE了，效率瓶颈可能是倍增LCA，等学了TarjanLCA之后可能会重写一遍 以后必不可能做这种连题解都找不到的冷门题目 【代码】TLE代码，学了正解之后可能会有AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAXN = 50000 + 10;const int MAXLOG = 16;struct Node;struct Edge;struct Node &#123; int depth; Edge *edges; int lighting, mark; bool vis; Node() : depth(0), edges(NULL), lighting(0), mark(0), vis(false) &#123;&#125;&#125; nodes[MAXN], *f[MAXN][MAXLOG + 1];struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v); v-&gt;edges = new Edge(v, u);&#125;void bfs(Node *x) &#123; std::queue&lt;Node*&gt; q; q.push(x); x-&gt;depth = 1; f[x - nodes][0] = x; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;depth == 0) &#123; e-&gt;to-&gt;depth = v-&gt;depth + 1; f[(e-&gt;to) - nodes][0] = v; q.push(e-&gt;to); &#125; &#125; &#125;&#125;void prepare(int n) &#123; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][j] = f[f[i][j - 1] - nodes][j - 1]; &#125; &#125;&#125;Node *lca(Node *a, Node *b) &#123; if (a-&gt;depth &lt; b-&gt;depth) std::swap(a, b); if (a-&gt;depth &gt; b-&gt;depth) &#123; for (int i = MAXLOG; i &gt;= 0; i--) &#123; if (f[a - nodes][i] &amp;&amp; f[a - nodes][i]-&gt;depth &gt;= b-&gt;depth) &#123; a = f[a - nodes][i]; &#125; &#125; &#125; if (a != b) &#123; for (int i = MAXLOG; i &gt;= 0; i--) &#123; if (f[a - nodes][i] != f[b - nodes][i]) &#123; a = f[a - nodes][i]; b = f[b - nodes][i]; &#125; &#125; return f[a - nodes][0]; &#125; return a;&#125;int dfs(Node *x, int n) &#123; int sum = x-&gt;mark; for (int i = 1; i &lt;= n; i++) &#123; if (i != (x - nodes) &amp;&amp; f[i][0] == x/* &amp;&amp; !nodes[i].vis*/) &#123; if (nodes[i].vis) sum += nodes[i].lighting; else sum += dfs(nodes + i, n);// #ifdef DBG// printf("%d-&gt;sum = %d\n", (x - nodes), sum);// #endif &#125; &#125; x-&gt;vis = true; x-&gt;lighting = sum; return sum;&#125;void init(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; nodes[i].depth = 0; nodes[i].edges = NULL; nodes[i].lighting = 0; nodes[i].vis = false; nodes[i].mark = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= MAXLOG; j++) &#123; f[i][j] = NULL; &#125; &#125;&#125;namespace IO &#123; inline int read() &#123; int data=0,w=1; char ch=0; while(ch!='-' &amp;&amp; (ch&lt;'0' || ch&gt;'9')) ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(ch&gt;='0' &amp;&amp; ch&lt;='9') data=data*10+ch-'0',ch=getchar(); return data*w; &#125;&#125;int main() &#123; int t; // scanf("%d", &amp;t); t = IO::read(); for (int cases = 1; cases &lt;= t; cases++) &#123; int n; // scanf("%d", &amp;n); n = IO::read(); init(n); for (int i = 1; i &lt;= n - 1; i++) &#123; int x, y; // scanf("%d%d", &amp;x, &amp;y); x = IO::read(); y = IO::read(); x++, y++; addEdge(nodes + x, nodes + y); &#125; int q; // scanf("%d", &amp;q); q = IO::read(); for (int i = 1; i &lt;= q; i++) &#123; int a, b, c; // scanf("%d%d%d", &amp;a, &amp;b, &amp;c); a = IO::read(); b = IO::read(); c = IO::read(); a++, b++; bfs(nodes + 1); prepare(n); Node* ancestors = lca(nodes + a, nodes + b);// #ifdef DBG// printf("%d &amp; %d 's lca -&gt; %d\n", a, b, (ancestors - nodes));// #endif (nodes + a)-&gt;mark += c; (nodes + b)-&gt;mark += c; ancestors-&gt;mark -= c; if (ancestors-&gt;depth != 1) f[ancestors - nodes][0]-&gt;mark -= c; &#125;// #ifdef DBG// for (int i = 1; i &lt;= n; i++) &#123;// printf("%d-&gt;mark = %d\n", i, nodes[i].mark);// &#125;// #endif int rubbish = dfs(nodes + 1, n); printf("Case #%d:\n", cases); for (int i = 1; i &lt;= n; i++) &#123; printf("%d\n", nodes[i].lighting); &#125; &#125; return 0;&#125;// 1// 9// 1 3// 4 0// 8 4// 5 4// 3 0// 3 7// 1 2// 6 3// 6// 3 7 1// 7 1 5// 0 4 6// 1 2 9// 8 3 4// 6 5 4// 2// 1// 4// 0 0 5// 0 0 2// 0 0 7// 0 0 1// 3// 2 1// 0 2// 4// 1 0 2// 0 2 1// 0 2 5// 0 0 2 【其他】 不怎么可读的对拍用标程(侵删) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;vector&gt;using namespace std;#define MAXV 65536int visited[MAXV];vector&lt;int&gt; tree[MAXV];int parent[MAXV], weight[MAXV];int findp(int x) &#123; return parent[x] == x ? x : (parent[x] = findp(parent[x]));&#125;int joint(int x, int y) &#123; x = findp(x), y = findp(y); if(x == y) return 0; if(weight[x] &gt; weight[y]) weight[x] += weight[y], parent[y] = x; else weight[y] += weight[x], parent[x] = y; return 1;&#125;// LCAvector&lt; pair&lt;int, int&gt; &gt; Q[MAXV];// query pair, input index - nodeint LCA[131072]; // [query time] input query answer buffer.void tarjan(int u, int p) &#123;// rooted-tree. parent[u] = u; for(int i = 0; i &lt; tree[u].size(); i++) &#123;//son node. int v = tree[u][i]; if(v == p) continue; tarjan(v, u); parent[findp(v)] = u; &#125; visited[u] = 1; for(int i = 0; i &lt; Q[u].size(); i++) &#123; if(visited[Q[u][i].second]) &#123; LCA[Q[u][i].first] = findp(Q[u][i].second); &#125; &#125;&#125;int dfs(int u, int p, int weight[]) &#123; int sum = weight[u]; for(int i = 0; i &lt; tree[u].size(); i++) &#123;//son node. int v = tree[u][i]; if(v == p) continue; sum += dfs(v, u, weight); &#125; return weight[u] = sum;&#125;int main() &#123; int n, m, x, y; int testcase, cases = 0; int X[MAXV], Y[MAXV], K[MAXV]; scanf("%d", &amp;testcase); while (testcase--) &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) tree[i].clear(); for (int i = 1; i &lt; n; i++) &#123; scanf("%d %d", &amp;x, &amp;y); tree[x].push_back(y); tree[y].push_back(x); &#125; int weight[MAXV] = &#123;&#125;, extra[MAXV] = &#123;&#125;; for (int i = 0; i &lt; n; i++) visited[i] = 0, Q[i].clear(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;X[i], &amp;Y[i], &amp;K[i]); Q[X[i]].push_back(make_pair(i, Y[i])); Q[Y[i]].push_back(make_pair(i, X[i])); &#125; tarjan(0, -1); for (int i = 0; i &lt; m; i++) &#123; extra[LCA[i]] += K[i]; weight[X[i]] += K[i]; weight[Y[i]] += K[i]; weight[LCA[i]] -= 2 * K[i]; &#125; dfs(0, -1, weight); printf("Case #%d:\n", ++cases); for (int i = 0; i &lt; n; i++) printf("%d\n", weight[i] + extra[i]); &#125; return 0;&#125; 数据生成器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt;const int MAXN = 50000; // the number of nodesconst int MAXT = 10; // the number of groupsconst int MAXQ = 50000; // the number of modifiesconst int MAXC = 10; // the largest power of lightingstruct UnionFindSet &#123; static const int MAXF = 100000; int father[MAXF]; void init(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125; &#125; int find(int x) &#123; if (father[x] != x) father[x] = find(father[x]); return father[x]; &#125; void merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); father[r1] = r2; &#125;&#125; ufs;int main() &#123; freopen("tmp.in", "w", stdout); srand(time(NULL)); int t = (rand() % MAXT) + 1; printf("%d\n", t); while (t--) &#123; int n = (rand() % MAXN) + 1; printf("%d\n", n); ufs.init(n); for (int i = 1; i &lt;= n - 1; i++) &#123; int a = (rand() % n); int b = (rand() % n); while (ufs.find(a) == ufs.find(b)) &#123; a = (rand() % n); b = (rand() % n); &#125; ufs.merge(a, b); printf("%d %d\n", a, b); &#125; int q = (rand() % MAXQ); printf("%d\n", q); while (q--) &#123; int a = (rand() % n); int b = (rand() % n); int c = (rand() % MAXC); printf("%d %d %d\n", a, b, c); &#125; &#125; fclose(stdout); return 0;&#125; 对拍 123456789101112131415161718192021222324252627282930g++ 1674.cpp -o 1674 -gg++ std.cpp -o std -gg++ maker.cpp -o maker -gwhile true ; do ./maker&gt;tmp.in ./std&lt;tmp.in&gt;std.out echo std did it ./1674&lt;tmp.in&gt;my.out echo i did it if diff my.out std.out ; then echo AC # echo ------ AC in ----- # cat tmp.in # echo ------ my ------ # cat my.out # echo ------ std ------ # cat std.out else echo WA echo ------ WA in ----- cat tmp.in echo ------ my ------ cat my.out echo ------ std ------ cat std.out exit 0 fidone]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[codevs 1135] 选择客栈 - 预处理]]></title>
    <url>%2F2017%2F05%2F30%2Fhotel%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1135 选择客栈 【题目描述】丽江河边有 $ n $ 家很有特色的客栈，客栈按照其位置顺序从$ 1 $ 到 $ n $ 编号。每家客栈都按照某一种色调进行装饰（总共 $ k $ 种），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。 两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $ p $。 他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $ p $ 元的咖啡店小聚。 【输入描述】共 $ n + 1 $ 行。 第一行三个整数 $ n, k, p $ ，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值； 接下来的 $ n $ 行，第 $ i + 1 $ 行两个整数，之间用一个空格隔开，分别表示 $ i $ 号客栈的装饰色调和 $ i $ 号客栈的咖啡店的最低消费。 【输出描述】输出只有一行，一个整数，表示可选的住宿方案的总数。 【题解】这题~$O(n^3)$暴力能有60分 这题没有什么特别的算法，似乎乱搞就可以了，需要预处理出下面这些东西。 对于每一个区间$(i, j)$，是否存在价格小于$p$的客栈。 具体来说用sum[i]表示到 $i$ 号客栈为止有多少价格小于$p$的客栈，查询区间的时候就用sum[j] - sum[i]，不为$0$就说明这个区间里存在价格小于$p$的客栈。 第 $i$ 号客栈的与他相同色调的前一个客栈，称为“前驱客栈” 具体来说用last[hotel[i].color]表示与 $i$ 号客栈色调相同的最后一个客栈的编号，扫描一遍每次更新即可 第 $i$ 号客栈之前有多少客栈和他色调相同 在上一步预处理中可以顺便做到 预处理好之后只需要扫描一遍整个序列，枚举右边的那个客栈，每次检查他和他的前驱客栈所构成的区间里是否存在价格小于$p$的客栈，若存在则方案数加上前驱客栈前与他色调相同的客栈数，若不存在则将左端点变为前驱的前驱，直到为$0$。 最后答案为方案数。复杂度感觉在$O(n)$左右…… 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;const int MAXN = 200000 + 10;const int MAXK = 50 + 10;struct Hotel &#123; int color, price; int pre, sum; Hotel() : color(0), price(0), pre(0), sum(1) &#123;&#125;&#125; hotels[MAXN];int sum[MAXN], last[MAXK];int main() &#123; int n, k, p; scanf("%d%d%d", &amp;n, &amp;k, &amp;p); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;hotels[i].color, &amp;hotels[i].price); if (hotels[i].price &lt;= p) sum[i] = sum[i - 1] + 1; else sum[i] = sum[i - 1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (last[hotels[i].color] == 0) &#123; last[hotels[i].color] = i; continue; &#125; hotels[i].pre = last[hotels[i].color]; hotels[i].sum = hotels[hotels[i].pre].sum + 1; last[hotels[i].color] = i; &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (hotels[i].pre == 0) continue; int pre = hotels[i].pre; while (pre != 0) &#123; if (sum[i] - sum[pre - 1] &gt; 0) &#123; ans += hotels[pre].sum; break; &#125; pre = hotels[pre].pre; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1066]引水入城 - BFS + 贪心]]></title>
    <url>%2F2017%2F05%2F12%2Fflow%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1066 引水入城 【题目描述】在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个 $n$ 行 $m$ 列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的 蓄水池中。因此，只有与湖泊毗邻的第 $1$ 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提是，存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第 $n$ 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。 【输入描述】输入的每行中两个数之间用一个空格隔开。 输入的第一行是两个正整数 $n$ 和 $m$ ，表示矩形的规模。 接下来 $n$ 行，每行 $m$ 个正整数，依次代表每座城市的海拔高度。 【输出描述】输出有两行。如果能满足要求，输出的第一行是整数 $1$ ，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数 $0$ ，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。 【题解】本题存在这样一个事实 ： 如果最后一行能被全部覆盖，那么第一行每一个点扩展来的一定是一条连续的线段。 考虑反证，假设如图， $A$ 点到达的为图中的蓝色部分，而由于最后一行能被全部覆盖，所以中间空出的点一定会被另一个点到达，如 $B$，绿色的为路径，但 $A$ 想到达更靠右的部分则必须穿过绿色的路径，既然穿过了该条路径，那就一定可以沿着这条路经到达图中空出的点，与 $A$ 不能到达的假设矛盾，所以原命题成立。 在确认了这一点之后，只需要对第一行每一个点做一次 BFS 就可以在最后一行标记出若干线段，而问题就转化成了在若干条线段中选择尽量少的线段来覆盖一个区间。 接下来可贪心可 DP ，先把每个区间按左端点从小到大为第一关键字，右端点从大到小为第二关键字排序，贪心策略就是若这个位置被多个区间覆盖，那么我们优先选右端点更大的那一个。 设置一个变量表示“当前已经覆盖到的位置”，在剩下的线段中选出左端点小于等于这个位置的右端点最大的线段使用，直到区间被完全覆盖。 正确性显然。 另外在 BFS 的时候有一个重要的剪枝，如果一个点比他左边或右边的某个/某两个要低，那么我们就不去搜索它，因为它所到达的位置一定会被它旁边比他高的点到达。 还有在向队列里 pop new 出来的对象的指针的时候，一定要记得把它 delete 掉，不然会 MLE ，尤其是像这道题这样需要重复 BFS 多次的时候。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;const int MAXN = 500 + 10;int altitude[MAXN][MAXN];bool vis[MAXN][MAXN], canBeVisited[MAXN], can[MAXN];int f[MAXN];int dx[4] = &#123;1, 0, -1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;struct Node &#123; int x, y; Node(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;&#125;;struct Range &#123; int l, r; Range(int l = 0, int r = 0) : l(l), r(r) &#123;&#125; bool operator&lt;(const Range &amp;a) const &#123; if (l != a.l) return l &lt; a.l; else return r &gt; a.r; &#125;&#125; ranges[MAXN];std::queue&lt;Node*&gt; q;inline void init(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; vis[i][j] = false; &#125; &#125;&#125;int n, m;void bfs(Node *x) &#123; q.push(x); vis[x-&gt;x][x-&gt;y] = true; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); int X = v-&gt;x; int Y = v-&gt;y; delete v; v = NULL; for (int i = 0; i &lt; 4; i++) &#123; int nX = X + dx[i]; int nY = Y + dy[i]; if ((nX &gt;= 1) &amp;&amp; (nX &lt;= n) &amp;&amp; (nY &gt;= 1) &amp;&amp; (nY &lt;= m) &amp;&amp; (altitude[nX][nY] &lt; altitude[X][Y]) &amp;&amp; (!vis[nX][nY])) &#123; q.push(new Node(nX, nY)); vis[nX][nY] = true; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; altitude[i][j] = INT_MAX; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;altitude[i][j]); &#125; &#125; for(int i = 1; i &lt;= m; i++) &#123; if((altitude[1][i] &lt; altitude[1][i - 1] &amp;&amp; (i != 1)) || (altitude[1][i] &lt; altitude[1][i + 1] &amp;&amp; (i != m))) &#123; can[i] = true; &#125; &#125; int tot = 0; for (int i = 1; i &lt;= m; i++) &#123; if (!can[i]) &#123; init(n, m); bfs(new Node(1, i)); &#125; tot++; ranges[tot].l = ranges[tot].r = 0; for (int j = 1; j &lt;= m; j++) &#123; if (vis[n][j]) &#123; canBeVisited[j] = true; if (!ranges[tot].l) &#123; ranges[tot].l = j; &#125; else &#123; ranges[tot].r = j; &#125; &#125; &#125; if (!ranges[tot].l &amp;&amp; !ranges[tot].r) tot--; &#125; int cnt = 0; for (int i = 1; i &lt;= m; i++) &#123; if (!canBeVisited[i]) cnt++; &#125; if (cnt != 0) &#123; printf("0\n%d\n", cnt); return 0; &#125; std::sort(ranges + 1, ranges + tot + 1); int now = 0; int to = 0; int ans = 0; for(int i = 1; i &lt;= tot; i++) &#123; if(ranges[i].l &lt;= now + 1) &#123; to = std::max(to, ranges[i].r); &#125; else &#123; now = to; to = std::max(to, ranges[i].r); ans++; &#125; &#125; if(now != m) &#123; ans++; &#125; printf("1\n%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1021]玛丽卡 - 最短路]]></title>
    <url>%2F2017%2F04%2F04%2FCodevs_1021%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 1021 玛丽卡 【题目描述】麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。 因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。 在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。 麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。 玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。 编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间(用分钟表示)。 【输入描述】第一行有两个用空格隔开的数$N$和$M$，分别表示城市的数量以及城市间道路的数量。$1 \le N \le 1000，1 \le M \le N \times \frac{(N - 1)} {2} $。城市用数字$1$至$N$标识，麦克在城市$1$中，玛丽卡在城市$N$中。 接下来的$M$行中每行包含三个用空格隔开的数$A$，$B$和$V$。其中$1 \le A$，$B \le N$，$1 \le V \le 1000$。这些数字表示在$A$和城市$B$中间有一条双行道，并且在$V$分钟内是就能通过。 【输出描述】输出文件的第一行中写出用分钟表示的最长时间，在这段时间中，无论哪条路在堵车，玛丽卡应该能够到达麦克处，如果少于这个时间的话，则必定存在一条路，该条路一旦堵车，玛丽卡就不能够赶到麦克处。 【题解】枚举每一条路断开的情况，求最短路即可 需要注意的是我们可以在这个算法的基础上做一些简单而有效的优化，我们先跑一遍最短路，标记出最短路上的边，考虑删除某一条边的时候，如果它不在原图的最短路中，那就不要管他，因为删掉之后跑最短路出来的还是原图的最短路，所以只需要枚举原图中最短路里的边删除即可 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;const int MAXN = 1000 + 10;int a[MAXN][MAXN];int inNode[MAXN];int dis[MAXN];bool vis[MAXN];int n, m;void dijkstra(int x, bool flag) &#123; typedef std::pair&lt;int, int&gt; info; std::priority_queue&lt;int, std::vector&lt;info&gt;, std::greater&lt;info&gt; &gt; pq; dis[x] = 0; pq.push(info(0, x)); while (!pq.empty()) &#123; info x = pq.top(); pq.pop(); int v = x.second; if (dis[v] != x.first) continue; for (int i = 1; i &lt;= n; i++) &#123; if (a[v][i] != INT_MAX &amp;&amp; dis[i] &gt; dis[v] + a[v][i]) &#123; dis[i] = dis[v] + a[v][i]; if (!flag) &#123; inNode[i] = v; &#125; pq.push(info(dis[i], i)); &#125; &#125; &#125;&#125; void init() &#123; for (int i = 1; i &lt;= n; i++) &#123; dis[i] = INT_MAX; vis[i] = false; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; a[i][j] = INT_MAX; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; dis[i] = INT_MAX; &#125; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); a[u][v] = a[v][u] = w; &#125; dijkstra(1, false);#ifdef DBG printf("--------shortest is %d---------\n", dis[n]);#endif init();#ifdef DBG for (int i = n; i; i = inNode[i]) &#123; printf("%d&lt;-", i); &#125; printf("\n");#endif int ans = 0; for (int i = n; i; i = inNode[i]) &#123; int tmp = a[i][inNode[i]]; a[i][inNode[i]] = a[inNode[i]][i] = INT_MAX; dijkstra(1, true); ans = std::max(ans, dis[n]); a[i][inNode[i]] = a[inNode[i]][i] = tmp; init(); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1026]逃跑的拉尔夫 - BFS]]></title>
    <url>%2F2017%2F03%2F03%2Fescape%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1026 逃跑的拉尔夫 【题目描述】年轻的拉尔夫开玩笑地从一个小镇上偷走了一辆车，但他没想到的是那辆车属于警察局，并且车上装有用于发射车子移动路线的装置。 那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。 编写程序，通过使用一张小镇的地图帮助警察局找到那辆车。程序必须能表示出该车最终所有可能的位置。 小镇的地图是矩形的，上面的符号用来标明哪儿可以行车哪儿不行。.表示小镇上那块地方是可以行车的，而符号X表示此处不能行车。拉尔夫所开小车的初始位置用字符的*表示，且汽车能从初始位置通过。 汽车能向四个方向移动：向北(向上)，向南(向下)，向西(向左)，向东(向右)。 拉尔夫所开小车的行动路线是通过一组给定的方向来描述的。在每个给定的方向，拉尔夫驾驶小车通过小镇上一个或更多的可行车地点。 【输入描述】输入文件的第一行包含两个用空格隔开的自然数 $ R $ 和 $ C $，$ 1 \leq R \leq 50 $ ，$ 1 \leq C \leq 50 $，分别表示小镇地图中的行数和列数。 以下的R行中每行都包含一组 $ C $ 个符号(.或X或*)用来描述地图上相应的部位。 接下来的第 $ R + 2 $ 行包含一个自然数 $ N $ ，$ 1 \leq N \leq 1000 $，表示一组方向的长度。 接下来的N行幅行包含下述单词中的任一个：NORTH、SOUTH、WEST和EAST，表示汽车移动的方向，任何两个连续的方向都不相同。 【输出描述】输出文件应包含用 $ R $ 行表示的小镇的地图(像输入文件中一样)，字符*应该仅用来表示汽车最终可能出现的位置。 【题解】裸的BFS，唯一要注意的就是判重，不能像原先一样简单使用一个二维数组来做，因为实际上这个题不是要求完全不能访问之间走过的点（比如样例），而是在一个操作（即一个行走方向）中不能重复访问点，所以可以每进行一次操作就把vis数组初始化，但这题空间充足所以也可以使用一个三维数组vis[x][y][z]表示在第z次行动时(x, y)这个点是不是访问过，这样会更快（没有了$O(n ^ 2)$ 的初始化）。 我在一开始写的时候没有判重（辣鸡tst写BFS忘判重），结果在TLE之前先MLE了…… 后来naive的加了普通的判重之后发现过不了样例了…… 最后的代码很长，有很多重复的地方可以压缩，但是自己懒得搞了，就这样。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;queue&gt;const int MAXN = 50 + 10;bool flag;int sum = 1;struct Node &#123; int x, y; Node(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;&#125;;char a[MAXN][MAXN];bool vis[MAXN][MAXN][MAXN + 10000];int main() &#123; int r, c; scanf("%d%d", &amp;r, &amp;c); for (int i = 0; i &lt; r; i++) &#123; scanf("%s", a[i]); &#125; std::queue&lt;Node*&gt; q; for (int i = 0; i &lt; r; i++) &#123; if (!flag) &#123; for (int j = 0; j &lt; c; j++) &#123; if (a[i][j] == '*') &#123; q.push(new Node(i, j)); flag = true; a[i][j] = '.'; break; &#125; &#125; &#125; else break; &#125; int n; scanf("%d", &amp;n); int tmp = 0; for (int i = 1; i &lt;= n; i++) &#123; char cmd[6]; scanf("%s", cmd); if (cmd[0] == 'N') &#123; while (sum--) &#123; Node *v = q.front(); q.pop(); // if (vis[v-&gt;x][v-&gt;y]) continue; // if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false; for (int j = v-&gt;x - 1; j &gt;= 0; j--) &#123; if (a[j][v-&gt;y] == 'X') break; else if (!vis[j][v-&gt;y][i]) &#123; tmp++; vis[j][v-&gt;y][i] = true; q.push(new Node(j, v-&gt;y)); &#125; &#125; &#125; sum = tmp, tmp = 0; &#125; else if (cmd[0] == 'S') &#123; while (sum--) &#123; Node *v = q.front(); q.pop(); // if (vis[v-&gt;x][v-&gt;y]) continue; // if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false; for (int j = v-&gt;x + 1; j &lt; r; j++) &#123; if (a[j][v-&gt;y] == 'X') break; else if (!vis[j][v-&gt;y][i]) &#123; tmp++; vis[j][v-&gt;y][i] = true; q.push(new Node(j, v-&gt;y)); &#125; &#125; &#125; sum = tmp, tmp = 0; &#125; else if (cmd[0] == 'E') &#123; while (sum--) &#123; Node *v = q.front(); q.pop(); // if (vis[v-&gt;x][v-&gt;y]) continue; // if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false; for (int j = v-&gt;y + 1; j &lt; c; j++) &#123; if (a[v-&gt;x][j] == 'X') break; else if (!vis[v-&gt;x][j][i]) &#123; tmp++; vis[v-&gt;x][j][i] = true; q.push(new Node(v-&gt;x, j)); &#125; &#125; &#125; sum = tmp, tmp = 0; &#125; else if (cmd[0] == 'W') &#123; while (sum--) &#123; Node *v = q.front(); q.pop(); // if (vis[v-&gt;x][v-&gt;y]) continue; // if (vis[v-&gt;x][v-&gt;y]) vis[v-&gt;x][v-&gt;y] = false; for (int j = v-&gt;y - 1; j &gt;= 0; j--) &#123; if (a[v-&gt;x][j] == 'X') break; else if (!vis[v-&gt;x][j][i]) &#123; tmp++; vis[v-&gt;x][j][i] = true; q.push(new Node(v-&gt;x, j)); &#125; &#125; &#125; sum = tmp, tmp = 0; &#125; &#125; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); a[v-&gt;x][v-&gt;y] = '*'; &#125; for (int i = 0; i &lt; r; i++) &#123; printf("%s\n", a[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Graphviz方便地绘制图形]]></title>
    <url>%2F2017%2F02%2F25%2FGraphviz%2F</url>
    <content type="text"><![CDATA[Graphviz是一个在linux下的一个能快速绘制流程图的工具，在写图论题的题解的时候，每一次都要费一番心思来画图，但是还有可能不那么美观，有了这个工具，就可以方便的完成这样的任务了。 简介Graphviz （Graph Visualization Software的缩写）是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。它提供了一种简单的描述图形的方法，并且可以为人类和计算机程序所理解。DOT语言文件通常是具有.gv或是.dot的文件扩展名。 安装在终端下使用1sudo apt install graphviz 命令来安装graphviz 命令用法1dot -T&lt;type&gt; &lt;infile.dot&gt; -o &lt;outfile&gt; 输入文件是&lt;infile.dot&gt;，生成的格式由&lt;type&gt;指定，生成的文件是&lt;outfile&gt;。 DOT语言的简单用法绘制无向图下面的代码被用作生成一张简单的无向图1234graph test &#123; 1 -- 2 -- 3; 1 -- 3;&#125; 使用关键字graph说明绘制的是一张无向图，用花括号扩起来需要描述的节点，相连的节点用--连接。 上面的那几行代码所绘制出的图形是这个样子的： 绘制有向图下面的代码被用作生成一张简单的有向图1234digraph test &#123; 1 -&gt; 2 -&gt; 3; 1 -&gt; 3;&#125; 发生的变化仅仅是graph变成了digraph，--变成了-&gt; 上面的那几行代码所绘制出的图形是这个样子的： 属性如果graphviz只能做到这些那未免也太low了，我们还可以给点和边增加一些属性12345678digraph &#123; 1 [shape = box]; 2 [style = filled, color = &quot;1, 1, 1&quot;]; 3; 1 -&gt; 2 [label = &quot;10&quot;]; 2 -&gt; 3 [label = &quot;5&quot;]; 1 -&gt; 3 [style = dotted, label = &quot;20&quot;]&#125; 上面的代码所绘制出的图形是这样的： 注释DOT支持C与C++风格的单行与多行注释，同时也支持Shell脚本风格的以#开头的注释 参考DOT语言 - 维基百科 Graphviz - 维基百科]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 4543]普通平衡树 - Splay]]></title>
    <url>%2F2017%2F02%2F05%2FnormalSplay%2F</url>
    <content type="text"><![CDATA[这是一个（几乎完全）从 Hellc 那里抄来的Splay模板，虽然大概领会了原理但似乎还不能很好手动实现，先挂在这里给自己看。 写完Splay学习笔记之后就删掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;const int MAXN = 100000;struct Spaly &#123; struct Node &#123; int data; Node *fa, *ch[2]; //ch[0]-&gt;lc, ch[1]-&gt;rc int size, cnt; Node(int data = 0, int cnt = 1) : data(data), size(cnt), cnt(cnt) &#123; fa = ch[0] = ch[1] = NULL; &#125; void update() &#123; size = cnt; if (ch[0]) size += ch[0]-&gt;size; if (ch[1]) size += ch[1]-&gt;size; &#125; int relation() &#123; return this == fa-&gt;ch[0] ? 0 : 1; &#125; void addChild(Node *v, int d) &#123; if (this) ch[d] = v; if (v) v-&gt;fa = this; &#125; int getSize(int d) &#123; return ch[d] ? ch[d]-&gt;size : 0; // 0-&gt;lc, 1-&gt;rc; &#125; &#125; *root, nodes[MAXN]; Spaly() &#123; root = new Node(INT_MIN, 0); root-&gt;addChild(new Node(INT_MAX, 0), 1); &#125; void rotate(Node *v) &#123; Node *old = v-&gt;fa; int d = v-&gt;relation(); if (old-&gt;fa) old-&gt;fa-&gt;addChild(v, old-&gt;relation()); else v-&gt;fa = NULL; old-&gt;addChild(v-&gt;ch[d ^ 1], d); v-&gt;addChild(old, d ^ 1); old-&gt;update(); v-&gt;update(); &#125; void splay(Node *v, Node *target = NULL) &#123; while (v-&gt;fa != target) &#123; if (v-&gt;fa-&gt;fa != target) &#123; rotate(v-&gt;relation() == v-&gt;fa-&gt;relation() ? v-&gt;fa : v); &#125; rotate(v); &#125; if (target == NULL) root = v; &#125; Node *getMinOrMax(Node *v, int d) &#123; // d == 0 ? min : max while (v-&gt;ch[d]) v = v-&gt;ch[d]; return v; &#125; Node *pre(Node *v) &#123; splay(v); return getMinOrMax(v-&gt;ch[0], 1); &#125; Node *succ(Node *v) &#123; splay(v); return getMinOrMax(v-&gt;ch[1], 0); &#125; Node *search(int x) &#123; for (Node *v = root; v; v = v-&gt;ch[x &gt; v-&gt;data]) &#123; if (v-&gt;data == x) &#123; splay(v); return v; &#125; &#125; return NULL; &#125; Node *insert(int x) &#123; Node *v = root, *father = NULL; while (v) &#123; if (v-&gt;data == x) &#123; v-&gt;cnt++, v-&gt;size++; splay(v); return v; &#125; else &#123; father = v; v = v-&gt;ch[x &gt; v-&gt;data]; &#125; &#125; Node *newNode = new Node(x); father-&gt;addChild(newNode, x &gt; father-&gt;data); splay(newNode); return newNode; &#125; void erase(Node *v) &#123; Node *preTmp = pre(v); Node *succTmp = succ(v); splay(preTmp); splay(succTmp, preTmp); succTmp-&gt;ch[0] = NULL; succTmp-&gt;update(); preTmp-&gt;update(); &#125; void erase(int x) &#123; Node *v = search(x); if (v-&gt;cnt &gt; 1) &#123; v-&gt;cnt--; v-&gt;size--; &#125; else &#123; erase(v); &#125; &#125; int pre(int x) &#123; Node *v = insert(x); int ans = pre(v)-&gt;data; erase (x); return ans; &#125; int succ(int x) &#123; Node *v = insert(x); int ans = succ(v)-&gt;data; erase(x); return ans; &#125; int rank(int x) &#123; Node *v = insert(x); int ans = v-&gt;getSize(0) + 1; erase(x); return ans; &#125; int select(int k) &#123; Node *v = root; while (true) &#123; if (v-&gt;getSize(0) + 1 &lt;= k &amp;&amp; k &lt;= v-&gt;getSize(0) + v-&gt;cnt) &#123; splay(v); return v-&gt;data; &#125; else if (k &lt;= v-&gt;getSize(0)) &#123; v = v-&gt;ch[0]; &#125; else &#123; k -= v-&gt;getSize(0) + v-&gt;cnt; v = v-&gt;ch[1]; &#125; &#125; &#125;&#125;;int main() &#123; Spaly *splay = new Spaly(); int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int opt, x; scanf("%d%d", &amp;opt, &amp;x); switch (opt) &#123; case 1 : &#123; splay-&gt;insert(x); break; &#125; case 2 : &#123; splay-&gt;erase(x); break; &#125; case 3 : &#123; printf("%d\n", splay-&gt;rank(x)); break; &#125; case 4 : &#123; printf("%d\n", splay-&gt;select(x)); break; &#125; case 5 : &#123; printf("%d\n", splay-&gt;pre(x)); break; &#125; case 6 : &#123; printf("%d\n", splay-&gt;succ(x)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1702] 素数判定2 - MillerRabin素数快速判定]]></title>
    <url>%2F2017%2F01%2F21%2Fprime2%2F</url>
    <content type="text"><![CDATA[关于素数(筛选/判定)的算法有很多，这篇文章主要讨论MillerRabin素数测试算法。 预备知识快速幂快速幂被用作在 $O( \log n)$ 的时间内快速计算出 $a^b$ 的值。12345inline long long fastPowMod(long long a, long long b) &#123; if (b == 1) return a; else if (b % 2 != 0) return mulMod(fastPowMod(a, b - 1), a); else return fastPowMod(mulMod(a, a), b &gt;&gt; 1);&#125; 上面代码中的mulMod是相乘取摸的另一个函数。 费马小定理(Fermat Theory)假如$p$是质数，且$\gcd(a,p)=1$，那么$a^{p-1} \equiv 1 \pmod p$ 事实上，费马小定理给出的是关于素数判定的必要非充分条件。 MillerRabinMillerRabin素数判定法基于这样一个事实：取$S$次不超过$n - 1$的基$b$，若每次都存在$b^{n - 1} \equiv 1 \pmod n$，则$n$几乎一定是素数。 这里说的几乎一定说明这是一个概率算法，但是在OI中我们是可以放心使用的，因为我们选取的基越多，这个算法出错的概率就越低，而且实际上如果你每次都用前$7$个素数$(2, 3, 5, 7, 11, 13, 17)$进行测试，所有不超过$341550071728320$的数都是正确的。 模板题链接Codevs 1702 素数判定2 题目描述一个数，他是素数么？设他为p满足$(p \leq 2^{63} - 1)$ 题解裸的MillerRabin就可以过了，要注意的一点是这里的$p$在long long范围内，所以中间结果可能会爆long long，所以请使用快速乘法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;long long prime[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;long long mod;// inline long long mulMod(long long a, long long b) &#123;// return (long long)((a % mod) * (b % mod)) % mod;// &#125;long long mulMod( long long a, long long b) &#123; long long ans = 0; while(b) &#123; if(b &amp; 1) &#123; b--; ans = (ans + a) % mod; &#125; b /= 2; a = (a + a) % mod; &#125; return ans;&#125;inline long long fastPowMod(long long a, long long b) &#123; if (b == 1) return a; else if (b % 2 != 0) return mulMod(fastPowMod(a, b - 1), a); else return fastPowMod(mulMod(a, a), b &gt;&gt; 1);&#125;inline bool millerRabin() &#123; if (mod == 2) return true; else if ((mod &lt; 2) || (mod &amp; 1) == 0) return false; for (int i = 0; i &lt; 10; i++) &#123; int tmp = fastPowMod(prime[i], mod - 1); if (tmp != 1) return false; &#125; return true;&#125;int main() &#123; scanf("%lld", &amp;mod); printf(millerRabin() ? "Yes\n" : "No\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1088] 神经网络 - 拓扑排序]]></title>
    <url>%2F2017%2F01%2F19%2Fneural%2F</url>
    <content type="text"><![CDATA[【链接】Codevs 1088 神经网络 【题目描述】在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子： 图中，$X_1 - X_3$是信息输入渠道，$Y_1 - Y_2$是信息输出渠道，$C_1$表示神经元目前的状态，$U_i$是阈值，可视为神经元的一个内在参数。 神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层，称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。图是一个简单的三层神经网络的例子。 兰兰规定，$C_i$服从公式： C_i = \sum_{(i, j) \in E}W_{ji}C_j - U_i（其中n是网络中所有神经元的数目） 公式中的$W_{ji}$（可能为负值）表示连接$j$号神经元和$i$号神经元的边的权值。当$C_i$大于$0$时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为$C_i$。 如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。 现在，给定一个神经网络，及当前输入层神经元的状态$(C_i)$，要求你的程序运算出最后网络输出层的状态。 【输入描述】输入文件第一行是两个整数$n(1 \leq n \leq 100)$和$p$。接下来$n$行，每行两个整数，第$i+1$行是神经元$i$最初状态和其阈值$(Ui)$，非输入层的神经元开始时状态必然为0。再下面$p$行，每行由两个整数$i$，$j$及一个整数$W{ij}$，表示连接神经元$i$、$j$的边权值为$W_{ij}$。 【输出描述】输出文件包含若干行，每行有两个整数，分别对应一个神经元的编号，及其最后的状态，两个整数间以空格分隔。仅输出最后状态非零的输出层神经元状态，并且按照编号由小到大顺序输出。若输出层的神经元最后状态均为0，则输出NULL。 【题解】这题乍一看给人一种很高端的感觉，实际上看明白题面之后其实就是一个类似于拓扑排序的题目，先找到所有没有入边的点，也就是输入层的点，依次向它连向的点输送信息，并每次吧它连向的点的入度减一，有入度为零的点就扔到队列里，出队的时候看看$C_i$是不是大于零，是就发送信息，不是就continue掉，队列空了之后找到输出层的点然后输出大于零的那部分就可以了。反正数据只有100的规模，怎么乱搞都是可以的嘛。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;queue&gt;const int MAXN = 100 + 10;struct Node;struct Edge;struct Node &#123; int now, threshold, inEdge; bool flag; Edge *edges; Node() : now(0), threshold(0), inEdge(0), flag(false), edges(NULL) &#123;&#125;&#125; nodes[MAXN];struct Edge &#123; Node *fr, *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *fr, Node *to, int w) &#123; fr-&gt;edges = new Edge(fr, to, w); to-&gt;inEdge++;&#125;int main() &#123; int n, p; scanf("%d%d", &amp;n, &amp;p); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;nodes[i].now, &amp;nodes[i].threshold); &#125; for (int i = 1; i &lt;= p; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(nodes + u, nodes + v, w); &#125; std::queue&lt;Node*&gt; q; for (int i = 1; i &lt;= n; i++) &#123; if (nodes[i].inEdge == 0) &#123; q.push(nodes + i); &#125; &#125; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; e-&gt;to-&gt;inEdge--; if (!e-&gt;to-&gt;flag) &#123; e-&gt;to-&gt;flag = true; e-&gt;to-&gt;now -= e-&gt;to-&gt;threshold; &#125; e-&gt;to-&gt;now += (v-&gt;now * e-&gt;w); // e-&gt;to-&gt;now -= v-&gt;threshold; if (!e-&gt;to-&gt;inEdge &amp;&amp; e-&gt;to-&gt;now &gt; 0) &#123; q.push(e-&gt;to); &#125; &#125; &#125; bool flag2 = false; for (int i = 1; i &lt;= n; i++) &#123; if (!nodes[i].edges &amp;&amp; nodes[i].now &gt; 0) &#123; printf("%d %d\n", i, nodes[i].now); flag2 = true; &#125; &#125; if (!flag2) printf("NULL\n"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>NOIp</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Markdown中插入本地图片]]></title>
    <url>%2F2017%2F01%2F19%2Fpicture%2F</url>
    <content type="text"><![CDATA[在Markdown中插入本地图片的语法很简单，但是当我们把这篇文章作为一篇博客上传到网上的时候，他是找不到本地图片的，所以我们需要一些特殊的方法来解决这个问题 其实就是把这个图片先传到某个图床上然后复制它的外部链接，把这张图当做网络上的图片插入到Markdown中 这里我使用的是七牛云来作为一个图床，新建存储空间之后就可以在内容管理里上传图片了，在后面的 操作 中提供了 复制外链。 然后就可以使用正常的Markdown语法123![name](url)eg：![Pictures](http://ojzeatu2s.bkt.clouddn.com/niu.png) 来插入图片了。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux下使用hexo + coding搭建自己的博客]]></title>
    <url>%2F2017%2F01%2F18%2Fblog%2F</url>
    <content type="text"><![CDATA[不知不觉两个月没写博客了，其中有大部分的原因是自己太辣鸡根本搞不定博客而且学校文化课时间比较紧没有空去做，现在终于到了寒假，就一口气搞定了在自己的电脑上配置博客环境的问题 说明我目前用的linux发行版是Deepin 15.3之前在集训的时候用过一阵Elementary OS，但是并不会用……于是后来就用了新人友好向Deepin 什么是Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要的东西在安装hexo之前，需要先保证电脑里安装了Node.js和Git Node.js安装Node.js的时候我们选择的工具是nvm，它是一个Node版本管理工具，可以方便的安装最新的Node 在终端中使用 1wget -qO https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash 命令可以安装nvm 在安装完成后可以看到这样一句话 Close and reopen your terminal to start using nvm 然后重启终端，使用nvm install stable命令来安装最新的稳定版 Git在终端中使用sudo apt-get install git-core命令即可安装Git hexo在安装好上述程序之后就可以使用npm install -g hexo-cli命令来安装hexo 建站在处理好上面的那些东西之后就可以开始建站了，在官网里有详细的说明，我把博客的数据存放在了U盘里面，大概是这个样子 其中我们用于存放文章的文件夹为source/_posts，简单来说就是在这个文件夹用markdown语法写好一篇文章之后就可以使用hexo g -d命令生成并上传新的内容了。 在做完了上面的那一点微小的工作之后，如果直接使用hexo g -d命令的话，他其实是不能正常使用的，比如说可能会这样 这个时候直接在自己的那个目录下使用npm install命令 Coding在这个时候生成的网页并没有地方保存，所以我们在coding上新建一个Blog的项目，然后就可以把数据都扔在里面了 SSH公钥虽然并不知道这是什么但是没了他似乎不行，按照这个网页的指示来做就可以生成一个公钥，在ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;这个命令之后按四下回车，会得到一个正方形的图案，那就说明成功了，接下来使用ssh-add ~/.ssh/id_rsa命令就可以显示出来，把他复制到Coding的那个添加公钥页面就可以了 copy and paste在配置好了SSH公钥之后，直接使用hexo g -d会出现像这样的提示 然后按照他提示的使用1git config --global user.email &quot;you@example.com&quot; 和1git config --global user.name &quot;Your Name&quot; 再试一次hexo g -d发现好像成功啦！]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2016游记]]></title>
    <url>%2F2017%2F01%2F18%2Fnoip2016%2F</url>
    <content type="text"><![CDATA[这是一篇普通的游记，本来在NOIp之后没多久就写好了但是因为自己太辣鸡搞不定博客就拖到了现在…… Day 0今天算是Noip前的最后一天，上午十点坐上TangSir租的大巴，经过三个多小时（？？）的颠（tui）簸（fei），顺利到了夏令营的时候曾经来过的日照一中。非常愉快的抽了考场考号，吃了午饭就回了宿舍，对了一下考场发现他们居然有人抽到连坐Orz。下午在宿舍里写模板，很愉快地敲了一遍Dijkstra和SPFA，不过没有网没法评测，但据Hellc说应该靠谱。 晚上是超级丰盛的晚饭但食欲不好并没怎么吃，晚饭后和SZ，iovo7，Hellc去操场走了一圈一路瞎扯感觉还是很愉快的。 晚上八点多试机，在门口等的时候超级慌，瞬间感觉自己什么都不会了（其实本来就什么都不会），进去之后发现是Win7系统，稍微有点开心，简单测试了一下gdb和g++应该都可用，重启了一次确认F盘不会还原，试着敲了一遍LCA居然稍微调了一下就过样例了，真是奥妙重重……不过机房并没有出现传闻中可怕的键盘声，可能是因为键盘太虚，也有可能是我太虚……我的键盘左shift键不太好用本来想换键盘但后来一想还是算了，坐在我右边的小哥把每个游戏都试了一边，不知道他来试机是试什么的（一定是太神了！！）。 晚上回去听Menci有Linux和Vim，iovo7有VS可以用，简直飞起。 睡觉之前看了一下背包，听神犇们讲了一些从来没听过的算法，感觉自己这辈子也没什么机会学，膜了一下就睡了。 Day1上午八点半开始考试，带了一大桶冰露进去，简单熟悉了一下电脑环境，调了一下Dev-c++的配置，打了一个背包和Dijkstra的板子，老师就公布了（奇怪的）密码。 喝水看题……第一题应该是小模拟，链表？顺着找应该就没有什么问题了……写写写……二十分钟过去了……测一下样例结果没过EXM？！滚回去看题发现理解错题意，……改改改……十五分钟过去了……测一下过了样例，检查好文件放在一边。 喝水看题……树？两点间路径？我好像会LCA！算一算复杂度好像不对，想了想好像没有什么好办法，不管了开始写……写写写……一个小时过去了……终于写出来了，试一试样例……样例二顺利过了但是样例一死循环？？先输出一下每对点LCA看看……(2, 6)这对点跑不出来，单步一下发现是没有及时退出循环，不过我怎么记得我以前写的LCA没有那一句照样飞快……瞬间开始虚……加了条件之后样例一也过了不过感觉超级虚……检查完文件放一边。 喝水看题……换教室？难不成是借教室一样的区间操作？不对这个数学期望是什么鬼，怎么一股浓郁的DP气息？再往后看……路径？最短路？EXM？！什么鬼，瞬间感觉药丸，看一看部分分感觉似乎可骗，开始写暴力……飞速复制来之前的Dijkstra调试一下发现不对，似乎应该是最小生成树？改改改……这题里的教室改变怎么搞，dfs暴力枚举吧，写写写……新教室和旧教室间的边分离不出来了，怎么查询是否存在过来着，是不是要用set，可是set根本用不熟啊啊啊啊，这个时候老师说离结束还有15分钟了，看到满屏混乱的代码……完蛋，弃疗了，输出样例看看出题人能不能…… 出了考场一讨论发现T2根本就没有那么简单，SZ树剖加线段树不知道是不是正解，听Menci说这难度不对估计上不了200（一定是谦虚），省实验的dalao说T2写了400+行……感觉自己好虚……第一年Noip难道就要滚粗了……悲伤辣么大…… 晚上去阶梯教室学（tui）习（fei）了一会，学到了“磁场”……恩对，磁场。 回去之后没什么心情看板子就直接睡了。 Day2昨天晚上做了奇妙的梦，一觉醒来感觉无限虚。 在压缩包里看到AngryBrid瞬间就开始慌了，喝了口水冷静了一下老师就发密码了，恩仍然是没有什么意义的字符串。 喝水看题……组合数？我知道组合数可以递推！NOIp之前刚好做过一道递推求组合数的题，于是非常愉快的开始写，写完之后打了暴力稍微手动对拍了一下，感觉似乎没有什么问题。 喝水看题……这么长的题面是什么鬼，直接就是一道阅读理解题吧，仔细读完题第一反应是堆感觉似乎能拿不少分的样子, 然后就开始写 std::priority_queue&lt;&gt;。一开始在pq里作死传结构体但发现自己根本不会写什么比较器，然后一直段错误……时间不知不觉就过去了，在还有最后45分钟左右的时候还是没能调出来，然而T3还没开始看，这时候我已经慌到不能仔细思考了，出去洗了把脸冷静了一下，开始改成pq里传int，大概改了半个小时，第二部分的样例还是没过，感觉完蛋了，随便写了15分的骗分，最后一题直接输出了样例。 出考场讨论的时候都说Day2比Day1简单，感觉NOIp之前立的Flag生效了……只有我考挂了，估计连200都没有，三等滚粗…… 总结一下的话应该是考场经验不够丰富，乱用自己并不熟悉的语言特性，心态爆炸没有及时调整，时间分配不好，没有仔细分析部分分，该骗的分也没有骗到。 Update：Day2T1忘分步取模，直接爆longlong，身败名裂。只能明年再战了。 Update 2：测了XJ的山寨数据，170，还没有学妹考的高…… Update 3：三考场出现重大失误导致全部爆零？？诶不对我好像就是三考场的，什么鬼，虽然考的不好但直接爆零不能接受（是不是传说不爆零就有三等来着）。 Update 4：突然想到Day1T1好像是从1开始标的号，感觉要爆0，不过XJ数据是怎么给我评到80分的…… Update 5:终于下来成绩了，185，二等，明年再战拿一等吧。]]></content>
      <categories>
        <category>NOIp</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在NOIp2016之后]]></title>
    <url>%2F2016%2F11%2F27%2Ftalk%2F</url>
    <content type="text"><![CDATA[有很多事情，在想象中发生的时候，神圣无比，而当真实的发生的时候，人们却总是失望的发现，他并不像想象中的那样神奇与壮观。 NOIp2016的到来就是如此。全一中的选手们，在很早之前就对这一天的到来精心设计了各种场面，于是，我们百年一中用倒计时的心态来等待着这一天的到来。在幻想中，是有些激动的。 但很快我们就发现，这所谓神奇的比赛，似乎只是一场全国限时的模拟赛而已，三个半小时过得飞快，在两天后返程的客车上，我出奇的困，于是倒头便睡，忘了这是一段旅程的结束，更是另一段旅行的开始。 但NOIp毕竟来了。 在此之前，我们都像一个个爬山的旅人，走过的路程陡峭无比，理想、欢笑、汗水、眼泪铺就的登山之路异常艰辛。在之前短短的一年中，不断有人停下来，离开队伍，选择放弃，当然也有新的力量加入进来。终于，在倒计时的指引下，我们相互搀扶着，到达了NOIp的山顶。 原本以为这山顶是一个可以休息的地方，上来了才发现，这不过是一个新的地平线，前方还有一个又一个的山顶，2017赛季的比赛才刚刚开始，而我们，则是千千万万选手中最普通的那几个，是在一轮轮残酷的筛选中，最早被筛选下来的那一批人。有人收获一等，光荣退役，有人颗粒无收，在叹息之后惨淡收场，每个人都有自己的选择，但这并不意味着我们会停下脚步，地平线从来只用来出发，于是我们只能简单回头看看，掸掸身上的的灰尘，又该上路了。 回首过去的一年，仔细查看自己的心路历程，发现其中的痛苦和快乐紧密的交织在一起。每一步都走的并不容易，有时甚至有想放弃的念头，痛苦自然会在这时候出现，但坚持住了，又向前迈出了一步，快乐就在我们回首望向自己那一条前进轨迹时出现了。痛苦与快乐在心中此起彼伏，恐怕就是我们每一个竞赛选手的心灵宿命，但只要每次回首时，都能看到自己坚定的步伐所留下的脚印，那继续前行时的痛苦，也便好忍受多了。 其我们别无选择不是吗。 NOIp2016的结束到现在也只是短短的时间，相信我们2015级老一辈的OI选手站在地平线上，多少还有些手足无措，多少还有些忐忑不安，没有人知道前路会是怎样的。 我想，LYOI一代又一代的选手们，不管是怎样的不受家长和老师的支持，经历过怎样的挫折与困难，在面对未来的时候，总会投入最多的希望和歌唱，因为我们知道自己追求的是什么，知道当我们在赛场上双手飞速敲击着键盘，将自己脑海中的构思转化成一行行构思精巧的代码的时候，比以往任何时刻都要接近自己的梦想。 有不少同学都退役了，高三的学姐学长们也回到教室捧起理化生的课本开始备战高考，LYOI的历史又翻过了一页，这算不算的上是一个时代呢？明年，又会是怎样的呢？ 一切我们都不得而知。接下来的路，雾气依然很重，前方还是一如既往的模糊，但是，让我们出发吧！ 走下去，就有希望！]]></content>
      <categories>
        <category>NOIp</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp可能需要的板子]]></title>
    <url>%2F2016%2F11%2F17%2FRp%2B%2B%2F</url>
    <content type="text"><![CDATA[现在离NOIp大概还有不到40个小时的时间了，感觉超级慌，所以打了写模板题，然后贴些板子上来，给自己稍微增加一点自信…… 还是很虚啊Orz 【数学】【快速幂】123456789101112131415const long long MOD = 2769433;inline long long mulMod(long long a, long long b) &#123; return ((a % MOD) * (b % MOD)) % MOD&#125;inline long long fastPowMod(long long n, long long m) &#123; if (m == 0) return 1; if (m == 1) return n; else &#123; if (m % 2 == 0) &#123; return fastPowMod(n * n, m &gt;&gt; 1); &#125; else &#123; return mulMod(fastPowMod(n, m - 1), n); &#125; &#125;&#125; 【Eratosthenes 筛法】12345678inline void eratosthenes &#123; memset(vis, 0, sizeof(vis)); for (int i = 2; i &lt;= n; i++) &#123; for (int j = i * 2; j &lt;= n; j += i) &#123; vis[j] = 1; &#125; &#125;&#125; 【欧几里得算法】123inline int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125; 【拓展欧几里得】12345678inilne void exgcd(int a, int b, int &amp;d, int &amp;x, int &amp;y) &#123; if (!b) &#123; d = a; x = 1; y = 0; &#125; else &#123; exgcd(a % b, b, d, y, x); y -= x * (a / b); &#125;&#125; 【欧拉函数】12345678910111213141516int phi(int n) &#123; int m = (int)sqrt(n + 0.5); int ans = n; for (int i = 2; i &lt;= n; i++) &#123; if (n % 1 == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) &#123; n /= i; &#125; &#125; &#125; if (n &gt; 1) &#123; ans = ans / n * (n - i); &#125; return ans;&#125; 【图论】【最短路】【Dijkstra】1234567891011121314151617181920212223242526void dijkstra(Node *x) &#123; typedef std::pair&lt;int, Node*&gt; info; std::priority_queue&lt; info, std::vector&lt;info&gt;, std::greater&lt;info&gt; &gt; pq; x-&gt;dis = 0; pq.push(info(0, x)); while (!pq.empty()) &#123; info x = pq.top(); pq.pop(); Node *v = x.second; if (v-&gt;dis != x.first) &#123; continue; &#125; for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; Node *vi = e-&gt;to; if (v-&gt;dis + e-&gt;w &lt; vi-&gt;dis) &#123; vi-&gt;dis = v-&gt;dis + e-&gt;w; pq.push(info(vi-&gt;dis, vi)); &#125; &#125; &#125;&#125; 【Floyd】123456789for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (a[i][k] + a[k][j] &lt; a[i][j]) &#123; a[i][j] = a[i][k] + a[k][j]; &#125; &#125; &#125;&#125; 【SPFA】12345678910111213141516171819202122232425void spfa(Node *x) &#123; std::queue&lt;Node*&gt; q; x-&gt;dis = 0; x-&gt;inQue = true; q.push(x); while (!q.empty()) &#123; Node *v = q.front(); q.pop(); v-&gt;inQue = false; for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123; e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w; if (!e-&gt;to-&gt;inQue) &#123; q.push(e-&gt;to); e-&gt;to-&gt;inQue = true; &#125; &#125; &#125; &#125;&#125; 【最小生成树】【Kruskal】12345678910111213inline int kruskal &#123; std::sort(edges + 1; edges + m + 1); int sum = 0; for (int i = 1; i &lt;= m; i++) &#123; if (find(edges[i].fr) != find(edges[i].to)) &#123; merge(edges[i].fr, edges[i].to); sum += edges[i].w; &#125; &#125; return sum;&#125; 【并查集】1234567891011121314151617int father[MAXN];inline void init(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125;&#125;inline int find(int x) &#123; if (father[x] != x) &#123; father[x] = find(father[x]); &#125; return father[x];&#125;inline merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); father[r1] = r2;&#125; 【区间操作】【线段树】单点修改，区间查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct SegmentTree &#123; int l, r, mid, sum; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; sum = 0; lc = rc = NULL; &#125; void update() &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void build() &#123; if (r - l == 1) &#123; sum = a[l]; &#125; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void modify(int index, int delta) &#123; if (r - l == 1) &#123; sum += delta; &#125; else &#123; if (index &lt; mid) &#123; lc-&gt;modify(index, delta); &#125; else &#123; rc-&gt;modify(index, delta); &#125; update(); &#125; &#125; int query(int l, int r) &#123; int ans = 0; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; return sum; &#125; else &#123; if (l &lt; mid) &#123; ans += lc-&gt;query(l, std::min(mid, r)); &#125; if (r &gt; mid) &#123; ans += rc-&gt;query(std::max(mid, l), r); &#125; &#125; return ans; &#125;&#125;; 区间修改，单点查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct SegmentTree &#123; int l, r, mid, sum, lazy; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; mid = (l + r) / 2; sum = lazy = 0; lc = rc = NULL; &#125; void update() &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void build() &#123; if (r - l == 1) &#123; sum = a[l]; &#125; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void addTag(int delta) &#123; lazy += delta; sum += (r - l) * delta; &#125; void pushDown() &#123; if (lazy) &#123; lc-&gt;addTag(lazy); rc-&gt;addTag(lazy); lazy = 0; &#125; &#125; void modify(int l, int r, int delta) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; addTag(delta); &#125; else &#123; if (l &lt; mid) &#123; lc-&gt;modify(l, std::min(mid, r), delta); &#125; if (r &gt; mid) &#123; rc-&gt;modify(std::max(mid, l), r, delta); &#125; update(); &#125; &#125; int query(int index) &#123; if (r - l == 1) &#123; return sum; &#125; else &#123; pushDown(); if (index &lt; mid) &#123; return lc-&gt;query(index); &#125; else &#123; return rc-&gt;query(index); &#125; &#125; &#125;&#125;; 区间修改，单点查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct SegmentTree &#123; long long l, r, mid, lazy, sum; SegmentTree *lc, *rc; SegmentTree(long long l, long long r) : l(l), r(r) &#123; mid = (l + r) / 2; lazy = sum = 0; lc = rc = NULL; &#125; void update() &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void build() &#123; if (r - l == 1) &#123; sum = a[l]; &#125; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void addTag(long long delta) &#123; lazy += delta; sum += (r - l) * delta; &#125; void pushDown() &#123; if (lazy) &#123; lc-&gt;addTag(lazy); rc-&gt;addTag(lazy); lazy = 0; &#125; &#125; void modify(long long l, long long r, long long delta) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; addTag(delta); &#125; else &#123; pushDown(); if (l &lt; mid) &#123; lc-&gt;modify(l, std::min(mid, r), delta); &#125; if (r &gt; mid) &#123; rc-&gt;modify(std::max(mid, l), r, delta); &#125; update(); &#125; &#125; long long query(long long l, long long r) &#123; long long ans = 0; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; return sum; &#125; else &#123; pushDown(); if (l &lt; mid) &#123; ans += lc-&gt;query(l, std::min(mid, r)); &#125; if (r &gt; mid) &#123; ans += rc-&gt;query(std::max(l, mid), r); &#125; return ans; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>NOIp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[codevs 1137] 计算系数 - 数论相关 + 排列组合]]></title>
    <url>%2F2016%2F11%2F14%2Fcalc%2F</url>
    <content type="text"><![CDATA[【链接】codevs 1137 计算系数 【题目描述】给定一个多项式 $ (ax + by)^k $，请求出多项式展开后 $ x^n y^m $项的系数。 【输入描述】共一行，包含 $ 5 $ 个整数，分别为 $ a $ ， $ b $ ，$ k $，$ n $，$ m $，每两个整数之间用一个空格隔开。 【输出描述】输出共 $ 1 $ 行，包含一个整数，表示所求的系数，这个系数可能很大，输出对 $ 10007 $ 取模后的结果。 【数据范围及提示】对于 $ 30\% $ 的数据，有 $ 0 \leq k \leq 10 $； 对于 $ 50\% $ 的数据，有 $ a = 1 $ ，$ b = 1 $； 对于 $ 100\% $的数据，有 $ 0\leq k \leq 1000 $，$ 0 \leq n $, $ m \leq k $，且 $ n + m = k $ ，$ 0 \leq a $，$ b \leq 1000000 $。 【题解】这题和之前的同余方程一样，一看就是一道裸的数学题，一看题目描述就能想到二项式定理： \begin{align} (a + b)^n & = \sum_{i = 0}^n C_n^i a^{n - i}b^i \\ & = \sum_{i = 0}^n \frac{n!}{i!(n - i)!} a^{n - i}b^i \\ \end{align}对于这题存在系数的 $ ax $ 和 $ by $ 把他们可以看做一个整体来做二项式定理，最后计算系数的时候别忘记乘上他们本来的系数就好了 经过使用二项式定理来展开，我们得到这样一个式子： \frac{k!}{m!(k - m)!} x^{k - m}y^m所以发现题目中让求的多项式展开后 $ x^n y^m $ 项的系数其实就是 $C_k^m \times a^n \times b^m = \frac{k!}{m!(k - m)!} \times a^n \times b^m$ 所以这个时候就可以愉快的写一个阶乘函数然后去愉快的TLE和RE了。因为 $ k $ 是小于等于 $ 1000 $ 的，那么大的阶乘根本没法算 听说你很会写高精度? 所以要考虑其他方法。 查询百度百科之后，我们 惊讶地 发现组合数其实是可以递推的，也就是所谓的组合恒等式： C_m^n = C_{n - m}^n = C_{m - 1}^{n - 1} + C_m^{n - 1}这样一来事情就变得简单了很多，只要递推就可以了，可以设f(i, j)表示 $ C_j^i $ , 按照上面的递推关系一直推到f(m, k)就可以了，注意边界条件为f(0, 0) = 1， f(i, i) = 1 最后不要忘了乘上 $ a^n $ 和 $ b^m $ 两个系数，可以随便写个快速幂什么的…… 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;const int MOD = 10007;const int MAXN = 1000 + 10;long long f[MAXN][MAXN];inline long long mulMod(long long a, long long b) &#123; return ((a % MOD) * (b % MOD)) % MOD;&#125;inline long long fastPowMod(long long a, long long b) &#123; if (b == 0) return 1; if (b == 1) return a; else &#123; if (b % 2 == 0) &#123; return fastPowMod(mulMod(a, a), b &gt;&gt; 1); &#125; else if (b % 2 != 0) &#123; return mulMod(fastPowMod(a, b - 1), a); &#125; &#125;&#125;int main() &#123; int a, b, k, n, m; scanf("%d%d%d%d%d", &amp;a, &amp;b, &amp;k, &amp;n, &amp;m); f[0][0] = 1; for (int i = 1; i &lt;= m; i++) &#123; f[i][0] = f[i - 1][0]; &#125; for (int i = 1; i &lt;= k; i++) &#123; f[0][i] = f[0][i - 1]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; if (i == j) &#123; f[i][j] = 1; &#125; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; if (f[i][j] == 0) &#123; f[i][j] = (f[i - 1][j - 1] % MOD + f[i][j - 1] % MOD) % MOD; &#125; &#125; &#125; int ans = (f[m][k] % MOD * fastPowMod(a, n) * fastPowMod(b, m)) % MOD; printf("%d\n", ans); return 0;&#125; 【最后】一开始推错式子没乘原来的那个系数，结果莫名其妙50分 ？？ 我真是太弱了，这就快NOIp了感觉好虚……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[codevs 4600] 程序自动分析 - 并查集 + map]]></title>
    <url>%2F2016%2F11%2F13%2Fanalysis%2F</url>
    <content type="text"><![CDATA[【链接】codevs 4600 程序自动分析 【题目大意】 在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设 $ x_1 $，$ x_2 $ ，$ x_3 $，$ \dots $ 代表程序中出现的变量，给定 $ n $ 个形如 $ x_i = x_j $ 或 $ x_i \neq x_j $ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$ x_1 = x_2 $，$ x_2 = x_3 $，$ x_3 = x_4 $，$ x_1 \neq x_4 $，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 【输入描述】输入文件的第 $ 1 $ 行包含 $ 1 $ 个正整数 $ t $，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第 $ 1 $ 行包含 $ 1 $ 个正整数 $ n $ ，表示该问题中需要被满足的约束条件个数。 接下来 $ n $ 行，每行包括 $ 3 $ 个整数 $ i $, $ j $ , $ e $ ,描述 $ 1 $ 个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $ e = 1 $，则该约束条件为$ x_i = x_j $；若$ e = 0 $，则该约束条件为 $ x_i \neq x_j $。 【输出描述】输出文件包括 $ t $ 行。 输出文件的第k行输出一个字符串YES或者NO（不包含引号，字母全部大写），YES表示输入中的第 $ k $ 个问题判定为可以被满足，NO表示不可被满足。 【数据范围及提示】$ 1 \leq n \leq 1000000 $ $ 1 \leq i,j \leq 1000000000 $ 【题解】这是NOI2015的一道神题，Menci神犇说这题应该放到普及组，真是太神啦%%% 方法很简单，就是把每一个相等的条件加到并查集里面，然后离线处理每一个不能的条件，如果都成立那就是YES，反之那当然就是NO了 但是有一个问题，就是 $ i $ 和 $ j $ 都非常大，开一个那么大的数组显然不靠谱，但是 $ n $ 却并不大，所以我们并不需要开一个很大的数组来存储并不多的数，只需要把他们区分开就好了，所以最多只需要 $ 2n $ 的空间，这个操作用 std::map 就可以轻松实现. 但是用我用map的时候TLE了，所以选择使用std::tr1::unordered_map，来加快速度 不过据说这个东西很容易被卡，所以还是尽量少用它比较好。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;tr1/unordered_map&gt;const int MAXN = 2000000 + 5;struct Cmd &#123; int a, b;&#125;cmd[MAXN];int father[MAXN];std::tr1::unordered_map&lt;int , int&gt; mp;inline void init(int n) &#123; for (int i = 1; i &lt;= n * 2; i++) &#123; father[i] = i; &#125;&#125;inline int find(int x) &#123; if (father[x] != x) &#123; father[x] = find(father[x]); &#125; return father[x];&#125;inline void merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); father[r1] = r2;&#125;int cnt = 1;inline int getId(int x) &#123; if (!mp.count(x)) &#123; mp[x] = cnt; cnt++; &#125; return mp[x];&#125;int main() &#123; int t; scanf("%d", &amp;t); begin: while (t--) &#123; int n; scanf("%d", &amp;n); init(n); int tot = 1; cnt = 1; mp.clear(); for (int i = 1; i &lt;= n; i++) &#123; cmd[i].a = 0; cmd[i].b = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; int a, b, type; scanf("%d%d%d", &amp;a, &amp;b, &amp;type); if (type == 1) &#123; a = getId(a); b = getId(b); merge(a, b); &#125; else if (type == 0) &#123; cmd[tot].a = getId(a); cmd[tot].b = getId(b); tot++; &#125; &#125; for (int i = 1; i &lt; tot; i++) &#123; if (find(cmd[i].a) == find(cmd[i].b)) &#123; printf("NO\n"); goto begin; &#125; &#125; printf("YES\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>STL</tag>
        <tag>离散化</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[codevs 1138] 聪明的质监员 - 二分答案 + 前缀和]]></title>
    <url>%2F2016%2F11%2F10%2Fclever%2F</url>
    <content type="text"><![CDATA[【链接】codevs 1138 聪明的质监员 【题目大意】有一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $ n $ 个矿石，从 $ 1 $ 到 $ n $ 逐一编号，每个矿石都有自己的重量 $ w_i $ 以及价值 $ v_i $。 检验矿产的流程是： 给定 $ m $ 个区间 $ [L_i, R_i] $ 选出一个参数 $ W $ 对于每一个区间，其检验值定义为Y_i = \sum_j 1 \times \sum_j v_j,j \in [L_i, R_i] , w_j \ge W 对于这一批矿产，其检验值为Y = \sum_i^m Y_i 若这批矿产的检验结果与所给标准值 $ S $ 相差太多，就需要再去检验另一批矿产。质监员不想费时间去检验另一批矿产，所以他想通过调整参数 $ W $ 的值，让检验结果尽可能的靠近标准值 $ S $ ，即使得 $ S - Y $ 的绝对值最小。请你帮忙求出这个最小值。 【输入描述】第一行包含三个整数 $ n，m，S $，分别表示矿石的个数、区间的个数和标准值。接下来的 $ n $ 行，每行 $ 2 $ 个整数，中间用空格隔开，第 $ i + 1 $ 行表示 $ i $ 号矿石的重量 $ w_i $ 和价值 $ v_i $ 。接下来的 $ m $ 行，表示区间，每行 $ 2 $ 个整数，中间用空格隔开，第 $ i + n + 1 $ 行表示区间 $ [Li,Ri] $ 的两个端点 $ L_i $ 和 $ R_i $。注意：不同区间可能重合或相互重叠。） 【输出描述】输出只有一行，包含一个整数，表示所求的最小值。 【数据范围及提示】对于 $ 10\% $ 的数据， $ 1 \le n,m \le 10 $； 对于 $ 30\% $ 的数据，$ 1 \le n,m \le 500 $； 对于 $ 50\% $ 的数据，$ 1 \le n,m \le 5000 $； 对于 $ 70\% $ 的数据，$ 1 \le n,m \le 10000 $； 对于 $ 100\% $ 的数据，$ 1 \le n,m \le 200000,0 &lt; w_i,v_i \le 10^6,0 &lt; S \le 10^{12},1 \le L_i \le R_i \le n $ 。 【题解】 这题怎么做? 二分 为什么可以二分？ 对于每一个 $ W $ 都可以由题目中提到的公式求出一个 $ Y_i $，显然 $ W $ 越大，能满足条件的 $ w_i $ 越少，所以 $ Y_i $ 越小，所以 $ Y_i $ 和 $ W $ 负相关，所以答案单调，所以可以二分 怎么二分？ 二分的对象是 $ W $，目的是找到一个和 $ S $ 最接近的 $ Y $，二分边界设为 $[1,maxw)$ 。当二分出的 $ W $ 计算得到的 $ Y $ 大于 $ S $ 时，在左半部分继续二分，反之在右半部分二分 我 TLE 了怎么办？ 在计算 $ Y $ 的时候顺便计算出在当前 $ W $ 下满足条件的 $ w_i $ 的前缀和，这样就可以每次 $ O(1) $ 查询了 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cstring&gt;const int MAXN = 200000 + 10;const int MAXM = 200000 + 10;struct Thing&#123; long long w, v;&#125;things[MAXN];struct Area &#123; long long l, r;&#125;areas[MAXM];long long sum[MAXN];long long sum1[MAXN];long long n, m, s;inline long long calc(long long w) &#123; memset(sum1, 0, sizeof(sum1)); memset(sum, 0, sizeof(sum)); long long ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (things[i].w &gt;= w) &#123; sum1[i] = sum1[i - 1] + 1; sum[i] = sum[i - 1] + things[i].v; &#125; else &#123; sum1[i] = sum1[i - 1]; sum[i] = sum[i - 1]; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; ans += (sum1[areas[i].r] - sum1[areas[i].l - 1]) * (sum[areas[i].r] - sum[areas[i].l - 1]); &#125; return ans;&#125;long long maxw;int main() &#123; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld%lld", &amp;things[i].w, &amp;things[i].v); maxw = std::max(maxw, things[i].w); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%lld%lld", &amp;areas[i].l, &amp;areas[i].r); &#125; int left = 1, right = maxw; long long ans = LLONG_MAX; while (left &lt;= right) &#123; long long w = (left + right) / 2; long long tmp = calc(w); if (tmp &lt; s) &#123; right = w - 1; ans = std::min(ans, s - tmp); &#125; else &#123; left = w + 1; ans = std::min(ans, tmp - s); &#125; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分答案</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[codevs 1285]宠物收养所 - 平衡树]]></title>
    <url>%2F2016%2F11%2F09%2Fpets%2F</url>
    <content type="text"><![CDATA[【链接】codevs 1285 宠物收养所 【题目大意】维护一种支持插入和删除元素、查询与一个值最接近的元素的数据结构 【输入描述】第一行为一个正整数 $ n $，$ n \leq 80000 $，表示一年当中来到收养所的宠物和领养者的总数。接下来的 $ n $ 行，按到来时间的先后顺序描述了一年当中来到收养所的宠物和领养者的情况。每行有两个正整数 $ a,b $，其中 $ a = 0 $表示宠物，$ a = 1 $表示领养者，$ b $表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间待在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过 $ 10000 $ 个） 【输出描述】仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和对 $1000000$ 取模以后的结果。 【题解】传闻这是一道平衡树的入门题，但是只用到了正儿八经的平衡树的一部分功能，所以正好可以用 std::set 来解决 所以说其实是set的入门题 具体的做法就是按照题目要求的做，要注意的是set的迭代器是没有operator-的，但是有operator--，所以 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;set&gt;#include &lt;algorithm&gt;const int MOD = 1000000;int ans;std::set&lt;int&gt; s; int main() &#123; int n; scanf("%d", &amp;n); s.insert(INT_MAX); s.insert(INT_MIN); bool flag; for (int i = 1; i &lt;= n; i++) &#123; int type, data; scanf("%d%d", &amp;type, &amp;data); if (s.size() == 2) &#123; flag = type; s.insert(data); &#125; else if (type != flag) &#123; int small = *(--s.lower_bound(data)); int big = *s.lower_bound(data); if (data - small &lt;= big - data &amp;&amp; small &gt; INT_MIN) &#123; ans += (data - small); ans %= MOD; s.erase(small); &#125; else &#123; ans += (big - data); ans %= MOD; s.erase(big); &#125; &#125; else &#123; s.insert(data); &#125; &#125; printf("%d\n", ans); return 0;&#125; 【最后】感觉平衡树这种 搞基 高级数据结构可能这辈子都不会学到了，有那么一丝丝的小遗憾呢]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>STL</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3286]火柴排队 - 贪心 + 逆序对]]></title>
    <url>%2F2016%2F11%2F07%2Fmatch%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 3286 火柴排队 【题目描述】有两盒火柴，每盒装有 $ n $ 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为 \sum_{i = 1}^n \left( a_i - b_i \right) ^2其中 $ a_i $ 表示第一列火柴中第 $ i $ 个火柴的高度， $ b_i $ 表示第二列火柴中第 $ i $ 个火柴的高度。每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 $ 99999997 $ 取模的结果。 【输入描述】共三行，第一行包含一个整数 $ n $，表示每盒中火柴的数目。 第二行有 $ n $ 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。 第三行有 $ n $ 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。 【输出描述】输出共一行，包含一个整数，表示最少交换次数对 $ 99999997 $ 取模的结果。 【数据范围及提示】对于 $ 10\% $ 的数据， $ 1 \leq n \leq 10 $； 对于 $ 30\% $ 的数据，$ 1 \leq n \leq 100 $； 对于 $ 60\% $ 的数据，$ 1 \leq n \leq 1000 $; 对于 $ 100\% $ 的数据，$ 1 \leq n \leq 1000000 \leq a_i, b_i \leq 2^{31} - 1 $ 【题解】看到题目要求两列火柴间的距离最小，很自然的就能YY出一种方案：每一列中高度名次相同的对应放在一起，可以实现两列火柴间的距离最小。 证明如下： 设两列火柴间距离为 $ sum $ ，则： \begin{align} sum & = \sum_{i = 1}^n \left( a_i - b_i \right) ^2 \\ & = \sum_{i = 1}^n \left( a_i^2 + b_i^2 - 2a_ib_i\right) \\ & = \sum_{i = 1}^n a_i^2 + \sum_{i = 1}^n b_i^2 - 2\sum_{i = 1}^n a_ib_i \end{align}所以题目要求 $ sum $ 最小，就是要求 $ \sum_{i = 1}^n a_ib_i $ 最大，这里存在的贪心策略是当 $a_1 &lt; a_2 &lt; a_3 &lt; \dots &lt; a_n $ 且 $ b_1 &lt; b_2 &lt; b_3 &lt; \dots &lt; b_n $时上式最大。 考虑反证，假如存在 $ ai &lt; a{i + 1} $， $bi &lt; b{i + 1} $ 且 $a{i + 1} \times b_i + b{i + 1} \times ai &gt; a_i \times b_i + a{i + 1} \times b{i + 1}$，则 $a_i \times (b{i + 1} - bi) &gt; a{i + 1} \times (b{i + 1} - b_i)$ 在 $a_i, b_i$ 均大于零的前提下，推得 $a{i + 1} &lt; a_i$ ，与题设不符，命题不成立，所以贪心策略正确。 update:在我们学习了排序不等式之后不难发现，这其实就是所谓顺序和，而根据排序不等式容易得到上述结论。 然后，将两个序列分别排序，确定每对数的对应关系，明显，同时移动两个序列中的数等效于只移动一个序列中的数，那么，我们就保持一个序列不动，然后根据另外那个序列中的数对应的数的位置，重新定义一个数组，求逆序对个数，就是答案。 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100000 + 5;const int MOD = 99999997;struct Stick &#123; int id, val; bool operator&lt;(const Stick &amp;a) const &#123; return val &lt; a.val; &#125;&#125;stk1[MAXN], stk2[MAXN];int t[MAXN], tmp[MAXN];int ans;inline void mergeSort(int *a, int l, int r) &#123; if (l &gt;= r) return; int mid = (l + r) / 2; mergeSort(a, l, mid); mergeSort(a, mid + 1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &gt; a[j]) &#123; tmp[k++] = a[j++]; //ans += mid - i + 1; ans = (ans % MOD + mid % MOD - i % MOD + 1 % MOD) % MOD; &#125; else &#123; tmp[k++] = a[i++]; &#125; &#125; while (i &lt;= mid) &#123; tmp[k++] = a[i++]; &#125; while (j &lt;= r) &#123; tmp[k++] = a[j++]; &#125; for (int i = l; i &lt;= r; i++) &#123; a[i] = tmp[i]; &#125; return;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;stk1[i].val); stk1[i].id = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;stk2[i].val); stk2[i].id = i; &#125; std::sort(stk1 + 1, stk1 + n + 1); std::sort(stk2 + 1, stk2 + n + 1); for (int i = 1; i &lt;= n; i++) &#123; t[stk2[i].id] = stk1[i].id; &#125; mergeSort(t, 1, n); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3731]寻找道路 - BFS]]></title>
    <url>%2F2016%2F11%2F06%2Froadb%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 3731 寻找道路 【题目描述】在有向图 $ G $ 中，每条边的长度均为 $ 1 $，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件： 1．路径上的所有点的出边所指向的点都直接或间接与终点连通。 2．在满足条件 $ 1 $ 的情况下使路径最短。 注意：图 $ G $ 中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。 【输入描述】第一行有两个用一个空格隔开的整数 $ n $ 和 $ m $，表示图有 $ n $ 个点和 $ m $ 条边。 接下来的 $ m $ 行每行 $ 2 $ 个整数 $ x,y $,之间用一个空格隔开，表示有一条边从点 $ x $ 指向点 $ y $。 最后一行有两个用一个空格隔开的整数 $ s,t $ ，表示起点为$ s $，终点为 $ t $ 。 【输出描述】输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出 $ -1 $ 。 【数据范围及提示】对于 $ 30\% $的数据， $ 0 &lt; n \leq 10，0 &lt; m \leq 20 $； 对于 $ 60\% $的数据，$ 0 &lt; n \leq 100，0 &lt; m \leq 2000 $； 对于 $ 100\% $的数据，$ 0 &lt; n \leq 10,000，0 &lt; m \leq 200,000，0 &lt; x,y,s,t \leq n，x \neq t $。 【题解】两遍 BFS 就可以 AC la! 第一遍从终点开始 BFS 不能遍历到的点就是不与终点联通的点，把它们打上标记。 第二遍从起点开始 BFS ，每找到一个点就考虑它所连出的点，如果存在在第一遍 BFS中被标记过的点，那么这个点就是不合法的，不去搜索它。在 Node 结构体里记录一个 dist 值，每搜索一层就 dist++ 最后终点的 dist 值就是要求的答案。 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;queue&gt;const int MAXN = 10000 + 10;struct Node;struct Edge;struct Node &#123; Edge *edges; bool vis, can, imp; int dist; Node() : edges(NULL), vis(false), can(false), imp(false) &#123;&#125;&#125;nodes[MAXN], nodesB[MAXN];struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v);&#125;inline void bfs1(Node *x) &#123; std::queue&lt;Node*&gt; q; q.push(x); while (!q.empty()) &#123; Node *v = q.front(); q.pop(); if (!v-&gt;vis) &#123; v-&gt;vis = true; v-&gt;can = true; &#125; else &#123; continue; &#125; for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; q.push(e-&gt;to); &#125; &#125;&#125;inline bool check(Node *v)&#123; for(Edge *e = v-&gt;edges; e; e = e-&gt;next)&#123; if(!e-&gt;to-&gt;can) return false; &#125; return true;&#125;inline int bfs(Node *s, Node *t)&#123; std::queue&lt;Node*&gt; Q; Q.push(s), s-&gt;vis = true, s-&gt;dist = 0; while(!Q.empty())&#123; Node *v = Q.front(); Q.pop(); if(v == t) return v-&gt;dist; for(Edge *e = v-&gt;edges; e; e = e-&gt;next)&#123; if(check(e-&gt;to) &amp;&amp; !e-&gt;to-&gt;vis)&#123; Q.push(e-&gt;to); e-&gt;to-&gt;dist = v-&gt;dist + 1; e-&gt;to-&gt;vis = true; &#125; &#125; &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); addEdge(nodes + x, nodes + y); addEdge(nodesB + y, nodesB + x); &#125; int s, t; scanf("%d%d", &amp;s, &amp;t); bfs1(nodesB + t); for (int i = 1; i &lt;= n; i++) &#123; if (nodesB[i].can == true) &#123; nodes[i].can = true; &#125; &#125;/* printf("-----------------------\n"); for (int i = 1; i &lt;= n; i++) &#123; printf("%d: ", i); for (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123; printf("%d ", (e-&gt;to) - nodes); &#125; printf("\n"); &#125; printf("-----------------------\n"); printf("-----------------------\n"); for (int i = 1; i &lt;= n; i++) &#123; if (nodesB[i].can == true) &#123; printf("%d can be found\n", i); &#125; else &#123; printf("%d can't be found\n", i); &#125; &#125; printf("-----------------------\n");*/ if (nodes[s].can == false) &#123; printf("-1\n"); &#125; else &#123; printf("%d\n", bfs2(nodes + s, nodes + t)); &#125; return 0;&#125; 【最后】写的时候犯了一个沙茶错误，本来每搜一层 dist++，结果变成了每搜一个点 sum++ 结果只过了前三个小数据。 在最初的版本里没有用节点的 dist 而是全局记录了一个 sum。 大概学到了 BFS 的正确姿势。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3728]联合权值 - 图论 + 枚举]]></title>
    <url>%2F2016%2F11%2F05%2Flinks%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 3728 联合权值 【题目描述】无向连通图 $ G $ 有 $ n $ 个点，$ n - 1 $ 条边。点从 $ 1 $ 到 $ n $ 依次编号，编号为 $ i $ 的点的权值为$ W_i $，每条边的长度均为 $ 1 $ 。图上两点 $ (u, v) $ 的距离定义为 $ u $ 点到 $ v $ 点的最短距离。对于图 $ G $ 上的点对 $ (u, v) $，若它们的距离为 $ 2 $ ，则它们之间会产生 $ W_u \times W_v $ 的联合权值。 请问图 $ G $ 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？ 【输入描述】第一行包含 $ 1 $ 个整数 $ n $ 。 接下来 $ n - 1 $ 行，每行包含 $ 2 $ 个用空格隔开的正整数 $ u, v $，表示编号为 $ u $ 和编号为 $ v $ 的点之间有边相连。 最后 $ 1 $ 行，包含 $ n $ 个正整数，每两个正整数之间用一个空格隔开，其中第 $ i $ 个整数表示图 $ G $ 上编号为 $ i $ 的点的权值为 $ W_i $ 【输出描述】输出共 $ 1 $ 行，包含 $ 2 $ 个整数，之间用一个空格隔开，依次为图 $ G $ 上联合权值的最大值 和所有联合权值之和。由于所有联合权值之和可能很大，输出它时要对 $ 10007 $ 取余。 【题解】考虑能形成联合权值的点对，他们一定中间会经过一个点，所以最暴力的做法就是枚举每一个点和它周围的点，它周围的点两两之间都能形成联合权值，这样做就能拿到60分了（大概），但是这里可以用一种 奇技淫巧 来有效降低复杂度，考虑一个点 $ A $ 周围有 $A1, A_2, A_3, A_4, A_5$ 五个点，设 $ A $ 点周围所有点的权值和(包括 $ A $ 点)为 $ S_A $ ,那么所形成的联合权值为 $ \sum{i = 1}^5 A_i \times (S_A - A_i)$，其中 $ S_A $ 可以对于每个点枚举与他相连的点就可以预处理得到。 关于第一问，求最大的联合权值，一定是每个点周围的点形成的最大值的最大值，也就是说，对于每一个点都求出他周围的点所形成的联合权值的最大值，在对所有的最大值取max就可以得到，这个过程可以在预处理 $ S_A $ 的时候算出来 另外一点，可能会爆int,所以应该尽量使用long long,不过据说分步取模就不会爆int了，但是自己太弱分步取模写炸……………… 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;algorithm&gt; const int MAXN = 200000 + 10;const int MOD = 10007; unsigned long long a[MAXN]; struct Node;struct Edge; struct Node &#123; Edge *edges; int val, sum; Node() : edges(NULL), val(0), sum(0) &#123;&#125;&#125;nodes[MAXN]; struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;; inline void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v); v-&gt;edges = new Edge(v, u); u-&gt;sum++; v-&gt;sum++;&#125; int max;long long summ;int tmp1, tmp2;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(nodes + u, nodes + v); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;nodes[i].val); &#125; for (int i = 1; i &lt;= n; i++) &#123; tmp1 = 0; tmp2 = 0; for (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123; a[i] += e-&gt;to-&gt;val; if (e-&gt;to-&gt;val &gt; tmp1) &#123; tmp1 = e-&gt;to-&gt;val; &#125; else if (e-&gt;to-&gt;val &gt; tmp2) &#123; tmp2 = e-&gt;to-&gt;val; &#125; max = std::max(max, tmp1 * tmp2); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (Edge *e = nodes[i].edges; e; e = e-&gt;next) &#123; //summ = ((e-&gt;to-&gt;val % MOD * (a[i] % MOD - e-&gt;to-&gt;val % MOD) % MOD) % MOD + summ % MOD) % MOD; summ += e-&gt;to-&gt;val * (a[i] - e-&gt;to-&gt;val); summ %= MOD; &#125; &#125; printf("%d %lld", max, summ); return 0;&#125; 【最后】开始的时候有一个奇奇怪怪的想法，题目中给出的是一棵树，在一棵树上和一个节点相距距离为2的点要么是他父亲的父亲，要么是他的兄弟，所以考虑在树上进行操作 结果爆炸了 不过看到黄学长的博客上写的算法似乎就是这样的做法 Orz]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1001]舒适的路线 - 并查集]]></title>
    <url>%2F2016%2F11%2F02%2Fcomf%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1001 舒适的路线 【题目描述】求一个无向图中两点间的一条路径使得其中最大边权和最小边权的比值尽量大，输出最大边与最小边的比值 【输入描述】第一行包含两个正整数，$ n $ 和 $ m $。 接下来的M行每行包含三个正整数： $ x $，$ y $ 和 $ v $ $ (1 \leq x,y \leq N) $最后一行包含两个正整数 $ s $，$ t $，表示想知道从景点 $ s $ 到景点 $ t $ 最大最小速度比最小的路径。$ s $ 和 $ t $不可能相同 【输出描述】如果景点 $ s $ 到景点 $ t $ 没有路径，输出“IMPOSSIBLE”。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。 【数据范围及提示】$ N(1 &lt; N \leq 500)$ $ M(0 &lt; M \leq 5000)$ $ V_i $在 int 范围内 【题解】这是 Codevs 上的第二道题，所以难度只比 1000 A + B Problem 高那么一点点 因为数据范围比较小，所以这题的正解是一个非常 暴力 精巧的暴力，考虑并查集，可以方便的确定一个图是否联通，先对所有的边按边权排序，从第一条边开始设为当前路径中最大的边，然后从大到小枚举剩下的边，每枚举一条边就用并查集把他的两个点合并，然后每次都判断一下两个目标节点是否联通，当这两个点终于联通的时候，我们就得到了一条路径，一开始设的最大边就是最大的，最后加入的那条边是最小的，这样就得到了当前路径中最大的边和最小的边，而且他们的比值是最小的，重复上述操作，遇到更小的比值就更新答案，直到每条边都作为最大边考虑过 另外一个问题就是要求输出一个既约分数，对分子和分母求一下 gcd 然后分子和分母同除 gcd 就实现了约分 最后一个问题就是在比较是否需要更新答案的时候要用 double 存储，其他地方都用 int 就好了 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cfloat&gt;const int MAXN = 500 * 10;const int MAXM = 5000 * 10;const double INF = DBL_MAX;int father[MAXN];struct Edge &#123; int fr, to, w; struct cmp &#123; bool operator() (const Edge &amp;a, const Edge &amp;b) &#123; return a.w &gt; b.w; &#125; &#125;;&#125;edges[MAXM];void init(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125; return;&#125;int find(int x) &#123; if(father[x] != x) &#123; father[x] = find(father[x]); &#125; return father[x];&#125;void merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); father[r1] = r2; return;&#125;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); init(n); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;edges[i].fr, &amp;edges[i].to, &amp;edges[i].w); merge(edges[i].fr, edges[i].to); &#125; int s, t; scanf("%d%d", &amp;s, &amp;t); if (find(s) != find(t)) &#123; printf("IMPOSSIBLE\n"); return 0; &#125; std::sort(edges + 1, edges + m + 1, Edge::cmp()); double ans = INF; int ansMax = 0, ansMin = 0; int ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= m; i++) &#123; init(n); ansMax = edges[i].w; merge(edges[i].fr, edges[i].to); if(find(s) == find(t)) &#123; printf("1\n"); return 0; &#125;else &#123; for (int j = i + 1; j &lt;= n; j++) &#123; merge(edges[j].fr, edges[j].to); if (find(s) == find(t)) &#123; ansMin = edges[j].w; if ((double)ansMax / (double)ansMin &lt; ans) &#123; ans = (double)ansMax / (double)ansMin; int gcdd = gcd(ansMax, ansMin); ans1 = ansMax / gcdd; ans2 = ansMin / gcdd; &#125; break; &#125; &#125; &#125; &#125;if (ans2 != 1)&#123; printf("%d/%d\n", ans1, ans2); &#125;else if (ans2 == 1) &#123; printf("%d\n", ans1); &#125; return 0;&#125; 【最后】60 分卡了好久，最后花了一晚上生成数据对拍，最后发现是在枚举边的时候把 m 打成了 n 这种沙茶错误，自己好弱……然而居然拍几千组数据都不带出错的真是迷 %%% Hellc %%% %%% Menci %%%]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1380] 没有上司的舞会 - 树形DP]]></title>
    <url>%2F2016%2F10%2F31%2FDance%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1380 没有上司的舞会 【题目描述】Ural大学有 $ N $ 个职员，编号为 $ 1 \dots N $。他们有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。每个职员有一个快乐指数。现在有个周年庆宴会，要求与会职员的快乐指数最大。但是，没有职员愿和直接上司一起与会。 【输入描述】第一行一个整数 $ N $。$ ( 1 \leq N \leq 6000) $接下来N行，第 $ i + 1 $ 行表示 $ i $ 号职员的快乐指数 $ R_i $。$(-128 \leq R_i \leq 127)$接下来 $ N - 1 $ 行，每行输入一对整数 $ L,K $ 。表示 $ K $ 是 $ L $ 的直接上司。最后一行输入$ 0 ,0 $。 【输出描述】输出最大的快乐指数。 【题解】这是一道 树形 DP的经典题目，其中存在明显的层次关系（上司和下属），所以可以构造一棵树来进行一些操作，但是一个节点的子节点的数目是不一定的，所以可以保存每一个节点的 最后一个子节点 并记录下该子节点的 下一个节点 在构造好一棵树之后就可以进行树形DP了，对于一个点只有两种情况即选或不选，所以设 $f(i, j) $ 表示第 $ i $ 号节点选或不选所能得到的最大价值，其中 $ j $ 等于 $ 0 $ 或 $ 1 $, 用 $ 1 $ 表示选，用 $ 0 $表示不选，可以得到状态转移方程为： f(i, j) = \begin{cases} \sum \max(f(i \rightarrow child)(0), f(i \rightarrow child)(1)), & \text{if $j$ is 0} \\\[2ex] \sum f(i \rightarrow child)(0) + i \rightarrow value, & \text{if $j$ is 1} \end{cases}其原理不难理解：当 $ j $ 等于 $ 1 $ 即 $ i $ 号点被选择时， $ i $ 号点的所有子节点都不能被选，结果就是所有子节点都不选所得到的价值总和加上 $ i $ 本身的价值；当 $ j $ 等于 $ 0 $ 即 $ j $ 号点不被选择时，他的子节点可选可不选，所以对于每一个子节点都要在选或不选中取一个较大值，再对他们求和。 边界条件为当 $ i $ 为叶节点时，$f(i, j) = \begin{cases} 0, &amp; \text{if j is 0}\[2ex] i \rightarrow value, &amp; \text{if j is 1} \end{cases}$ 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 6000 + 10;struct Node &#123; Node *ch, *next; int val; bool isRoot; int f[2]; Node() &#123; ch = next = NULL; val = 0; isRoot = true; f[0] = f[1] = 0; &#125; void solve() &#123; for (Node *v = ch; v; v = v-&gt;next) &#123; v-&gt;solve(); f[0] += std::max(v-&gt;f[0], v-&gt;f[1]); f[1] += v-&gt;f[0]; &#125; f[1] += val; &#125;&#125;nodes[MAXN];void addChild(Node *x, Node *y) &#123; x-&gt;next = y-&gt;ch; y-&gt;ch = x;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;nodes[i].val); &#125; for (int i = 1; i &lt;= n - 1; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); nodes[x].isRoot = false; addChild(nodes + x, nodes + y); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (nodes[i].isRoot) &#123; nodes[i].solve(); printf("%d", std::max(nodes[i].f[1], nodes[i].f[0])); break; &#125; &#125; return 0;&#125; 代码在实现上没有用刚才提到的 $ f $ 数组，而是在Node结构体里加入了一个成员数组 $ f $ 来表示原来 $ f $ 数组中的第二维（选或不选），但里面存储的内容仍然和原来一样（这个点选或不选得到的最大价值）]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度计算模板]]></title>
    <url>%2F2016%2F10%2F29%2FBigInt%2F</url>
    <content type="text"><![CDATA[在写完 国王游戏 之后，我们就得到了一个可以用的高精度模板，挂在这里先备用着好了，目前只支持正整数的高精度计算 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;struct BigInt &#123; std::vector&lt;int&gt; v; static const int BASE = 10; BigInt(long long x) &#123; do &#123; v.push_back(x % 10); &#125;while (x /= 10); &#125; BigInt(const std::string &amp;str) &#123; v.reserve(str.length()); for(int i = str.length() - 1; i &gt;= 0; i--)&#123; v.push_back(str[i] - '0'); &#125; &#125; BigInt() &#123; ; &#125; void removePreZero() &#123; while(v.size() &gt; 1 &amp;&amp; v.back() == 0) v.pop_back(); &#125; bool operator&lt;(const BigInt &amp;a) const &#123; if (v.size() != a.v.size()) &#123; return v.size() &lt; a.v.size(); &#125; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; if (v[i] != a.v[i]) &#123; return v[i] &lt; a.v[i]; &#125; &#125; return false; &#125; bool operator&gt;(const BigInt &amp;a) const &#123;return a &lt; *this;&#125; bool operator&lt;=(const BigInt &amp;a) const &#123;return !(a &lt; *this);&#125; bool operator&gt;=(const BigInt &amp;a) const &#123;return !(*this &lt; a);&#125; bool operator!=(const BigInt &amp;a) const &#123;return a &lt; *this || a &gt; *this;&#125; bool operator==(const BigInt &amp;a) const &#123;return !(a &lt; *this) &amp;&amp; !(a &gt; *this);&#125; BigInt operator+(const BigInt &amp;a) const &#123; BigInt ans; int sum = 0; for (int i = 0; i &lt; std::max(a.v.size(), v.size()); i++) &#123; if (i &lt; a.v.size()) sum += a.v[i]; if (i &lt; v.size()) sum += v[i]; ans.v.push_back(sum % BASE); sum /= BASE; &#125; if (sum) ans.v.push_back(sum); ans.removePreZero(); return ans; &#125;/* BigInt operator+=(const BigInt &amp;a) const &#123; return *this = *this + a; &#125;*/ //if a &lt; b, print '-', print b - a BigInt operator-(const BigInt &amp;a) const &#123; BigInt ans; int dif = 0; for (int i = 0; i &lt; std::max(a.v.size(), v.size()); i++) &#123; if (i &lt; v.size()) dif += v[i]; if (i &lt; a.v.size()) dif -= a.v[i]; if (dif &gt;= 0) &#123; ans.v.push_back(dif); dif = 0; &#125; else &#123; ans.v.push_back((dif + BASE) % BASE); dif = -1; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator-=(const BigInt &amp;a) const &#123; return *this = *this - a; &#125;*/ BigInt operator*(const BigInt &amp;a) const &#123; BigInt ans; ans.v.resize(v.size() + a.v.size(), 0); for (int i = 0; i &lt; v.size(); i++) &#123; for (int j = 0; j &lt; a.v.size(); j++) &#123; ans.v[i + j] += v[i] * a.v[j]; ans.v[i + j + 1] += ans.v[i + j] / BASE; ans.v[i + j] %= BASE; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator*=(const BigInt &amp;a) const &#123; return *this = *this * a; &#125;*/ BigInt operator/(const BigInt &amp;a) const &#123; BigInt ans, ret(0); ans.v.resize(v.size(), 0); ret = 0; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; ret = ret * 10 + v[i]; while (ret &gt;= a) &#123; ret = ret - a; ans.v[i]++; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator/=(const BigInt &amp;a) const &#123; return *this = *this / a; &#125;*/ BigInt operator%(const BigInt &amp;a) const &#123; return (*this) - (*this / a) * a; &#125;&#125;;std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const BigInt &amp;x) &#123; for (int i = x.v.size() - 1; i &gt;= 0; i--) &#123; out &lt;&lt; x.v[i]; &#125; return out;&#125;std::istream&amp; operator&gt;&gt; (std::istream &amp;in, BigInt &amp;x) &#123; std::string str; in &gt;&gt; str; x = BigInt(str); return in;&#125; update：修正了RemovePreZero()中$0$会被当做前导pop的情况 update: 增加了对大整数取模运算的支持]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1198] 国王游戏 - 贪心 + 高精度]]></title>
    <url>%2F2016%2F10%2F28%2FKing%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1198 国王游戏 【题目描述】恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 【输入描述】第一行包含一个整数 $n$，表示大臣的人数。 第二行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 【输出描述】输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 【数据范围及提示】对于$ 20 \% $的数据，有$1 \leq n \leq 10 $，$ 0 &lt; a,b &lt; 8 $； 对于 $ 40 \% $ 的数据，有$ 1 \leq n \leq 20 $ ， $ 0 &lt; a,b &lt; 8 $； 对于 $ 60 \% $ 的数据，有$ 1 \leq n \leq 100 $； 对于 $ 60 \% $ 的数据，保证答案不超过$ 10^9 $; 对于 $ 100 \% $ 的数据，有$ 1 \leq n \leq 1000 $ ，$ 0 &lt; a,b &lt; 10000 $。 【题解】这题 表面上 是一道贪心的题目，但是真正奇怪的地方是高精度，之前只用long long被卡到60分，不过据超强的Hellc神犇说只要随便YY一下用两个long long 拼起来 就可以不用高精度过掉了 Orz 下面写题解:题目要求求最大值最小，第一反应是二分答案，但发现并不会（其实因为答案本身不具有单调性所以是不可二分的），看了题解明白了是贪心，但是贪心标准是玄学的将每个大臣的两只手上的价格相乘。 但要注意的一点是这样排序之后，最后一位大臣不一定就是得到金币最多的，要记录一个每个大臣之前的大臣的左手上的乘积（类似前缀和），再从头到尾扫一遍，得到最大值。 然后写一个高精度就可以了 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;struct BigInt &#123; std::vector&lt;int&gt; v; static const int BASE = 10; BigInt(long long x) &#123; do &#123; v.push_back(x % 10); &#125;while (x /= 10); &#125; BigInt(const std::string &amp;str) &#123; v.reserve(str.length()); for(int i = str.length() - 1; i &gt;= 0; i--)&#123; v.push_back(str[i] - '0'); &#125; &#125; BigInt() &#123; ; &#125; void removePreZero() &#123; while(v.size() &gt;= 1 &amp;&amp; v.back() == 0) v.pop_back(); &#125; bool operator&lt;(const BigInt &amp;a) const &#123; if (v.size() != a.v.size()) &#123; return v.size() &lt; a.v.size(); &#125; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; if (v[i] != a.v[i]) &#123; return v[i] &lt; a.v[i]; &#125; &#125; return false; &#125; bool operator&gt;(const BigInt &amp;a) const &#123;return a &lt; *this;&#125; bool operator&lt;=(const BigInt &amp;a) const &#123;return !(a &lt; *this);&#125; bool operator&gt;=(const BigInt &amp;a) const &#123;return !(*this &lt; a);&#125; bool operator!=(const BigInt &amp;a) const &#123;return a &lt; *this || a &gt; *this;&#125; bool operator==(const BigInt &amp;a) const &#123;return !(a &lt; *this) &amp;&amp; !(a &gt; *this);&#125; BigInt operator+(const BigInt &amp;a) const &#123; BigInt ans; int sum = 0; for (int i = 0; i &lt; std::max(a.v.size(), v.size()); i++) &#123; if (i &lt; a.v.size()) sum += a.v[i]; if (i &lt; v.size()) sum += v[i]; ans.v.push_back(sum % BASE); sum /= BASE; &#125; if (sum) ans.v.push_back(sum); ans.removePreZero(); return ans; &#125;/* BigInt operator+=(const BigInt &amp;a) const &#123; return *this = *this + a; &#125;*/ BigInt operator-(const BigInt &amp;a) const &#123; BigInt ans; int dif = 0; for (int i = 0; i &lt; std::max(a.v.size(), v.size()); i++) &#123; if (i &lt; v.size()) dif += v[i]; if (i &lt; a.v.size()) dif -= a.v[i]; if (dif &gt;= 0) &#123; ans.v.push_back(dif); dif = 0; &#125; else &#123; ans.v.push_back((dif + BASE) % BASE); dif = -1; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator-=(const BigInt &amp;a) const &#123; return *this = *this - a; &#125;*/ BigInt operator*(const BigInt &amp;a) const &#123; BigInt ans; ans.v.resize(v.size() + a.v.size(), 0); for (int i = 0; i &lt; v.size(); i++) &#123; for (int j = 0; j &lt; a.v.size(); j++) &#123; ans.v[i + j] += v[i] * a.v[j]; ans.v[i + j + 1] += ans.v[i + j] / BASE; ans.v[i + j] %= BASE; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator*=(const BigInt &amp;a) const &#123; return *this = *this * a; &#125;*/ BigInt operator/(const BigInt &amp;a) const &#123; BigInt ans, ret(0); ans.v.resize(v.size(), 0); ret = 0; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; ret = ret * 10 + v[i]; while (ret &gt;= a) &#123; ret = ret - a; ans.v[i]++; &#125; &#125; ans.removePreZero(); return ans; &#125;/* BigInt operator/=(const BigInt &amp;a) const &#123; return *this = *this / a; &#125;*/&#125;;std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const BigInt &amp;x) &#123; for (int i = x.v.size() - 1; i &gt;= 0; i--) &#123; out &lt;&lt; x.v[i]; &#125; return out;&#125;std::istream&amp; operator&gt;&gt; (std::istream &amp;in, BigInt &amp;x) &#123; std::string str; in &gt;&gt; str; x = BigInt(str); return in;&#125;const int MAXN = 1000 + 5;struct Minister&#123; int l, r; struct cmp &#123; bool operator() (const Minister &amp;a, const Minister &amp;b) &#123; return a.l * a.r &lt; b.l * b.r; &#125; &#125;;&#125;minister[MAXN];int main() &#123; int n; scanf("%d", &amp;n); scanf("%d%d", &amp;minister[0].l, &amp;minister[0].r); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;minister[i].l, &amp;minister[i].r); &#125; std::sort(minister + 1, minister + n + 1, Minister::cmp()); BigInt max = 1; BigInt sum = 1; for(int i = 0; i &lt;= n; i++) &#123; sum = sum * minister[i].l; &#125; max = sum / minister[n].l / minister[n].r; if(max &lt;= 1) &#123; max = 1; &#125; //printf("%.0f", max); std::cout &lt;&lt; max; return 0;&#125; 代码实现了一个 比较完整的 高精度类， 但是实际上很多功能在这题中用不到的，纯粹为了写高精度模板而写的 所以特别长 【其他】在我刚开始写的时候直接naive地取了最后一位大臣为最优，结果A掉了，然而在我改成每次扫一遍判断后TLE了…… 这是TLE代码12345678910111213141516171819202122int main() &#123; int n; scanf("%d", &amp;n); scanf("%d%d", &amp;minister[0].l, &amp;minister[0].r); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;minister[i].l, &amp;minister[i].r); &#125; std::sort(minister + 1, minister + n + 1, Minister::cmp()); BigInt max = 1; BigInt sum = minister[0].l; for(int i = 2; i &lt;= n; i++) &#123; sum = sum * minister[i - 1].l; max = std::max(max, sum / minister[i].r); &#125; std::cout &lt;&lt; max &lt;&lt; std::endl; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3287] 货车运输 - 最大生成树 + LCA]]></title>
    <url>%2F2016%2F10%2F27%2Ftransport%2F</url>
    <content type="text"><![CDATA[【题目描述】$A$ 国有 $n$ 座城市，编号从 $1$ 到 $n$，城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 $q$ 辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 【输入描述】第一行有两个用一个空格隔开的整数 $n$，$m$，表示 $A$ 国有 $n$ 座城市和 $m$ 条道路。接下来 $m$ 行每行 $3$ 个整数 $x$ 、$y$ 、$z$ ，每两个整数之间用一个空格隔开，表示从 $x $ 号城市到 $y$ 号城市有一条限重为 $z$ 的道路。注意：$x \neq y$，两座城市之间可能有多条道路。接下来一行有一个整数 $q$，表示有 $q$ 辆货车需要运货。接下来 $q$ 行，每行两个整数 $x$ 、$y$，之间用一个空格隔开，表示一辆货车需要从 $x$ 城市运输货物到 $y$ 城市，注意：$x \neq y$。 【输出描述】输出共有 $q$ 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出 $-1$ 。 【题解】考虑在不超过限重的情况下运输的最大重量，显然受这条道路上最小值的限制，所以我们要找到一条道路使得 $x$ 到 $y$ 间的最小值最大，也就是要求出这个图中的最大生成树，其实现方法和最小生成树类似，同样可以使用Kruskal来高效解决，只要把排序的时候变成从大到小就可以了。 在求出最大生成树之后，就要在树上求出 $x$ , $y$之间的道路上的最小值，可以选择BFS一遍，但是多次询问这显然就不靠谱，所以考虑求LCA,并在求LCA的同时维护最小值，实现方法就是在g数组中把原先的求和操作变成求最小值操作。 需要注意的一点就是这个图可能会不连通，所以在BFS求深度的时候不能简单的从1号节点开始，否则会有无法到达的点，f数组中就会是一些奇怪的值，然后就RE了 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 1e4 + 5;const int MAXM = 5e4 + 5;const int MAXLOG = 20;struct Node;struct Edge;struct Node &#123; Edge *edges; int depth; Node() : edges(NULL), depth(0) &#123;&#125;&#125;nodes[MAXN], *f[MAXN][MAXLOG + 5];struct Edge &#123; Node *fr, *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v, int w) &#123; v-&gt;edges = new Edge(v, u, w); u-&gt;edges = new Edge(u, v, w);&#125;/*-------------------------------------------------------------------*/int father[MAXN];struct UEdge &#123; int u, v, w; struct Cmp &#123; bool operator() (const UEdge &amp;a, const UEdge &amp;b) &#123; return a.w &gt; b.w; &#125; &#125;;&#125;uEdges[MAXM];void init(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125;&#125;int find(int x) &#123; if (father[x] != x) &#123; father[x] = find(father[x]); &#125; return father[x];&#125;void merge(int x, int y) &#123; int r1 = find(x); int r2 = find(y); father[r1] = r2;&#125;void kruskal(int m) &#123; for (int i = 1; i &lt;= m; i++) &#123; if (find(uEdges[i].u) != find(uEdges[i].v)) &#123; merge(uEdges[i].u, uEdges[i].v); addEdge(nodes + uEdges[i].u, nodes + uEdges[i].v, uEdges[i].w); &#125; &#125;&#125;/*-------------------------------------------------------------------*/int g[MAXN][MAXLOG + 5];inline void bfs(Node *x) &#123; std::queue&lt;Node*&gt; q; q.push(x); x-&gt;depth = 1; f[x - nodes][0] = x; g[x - nodes][0] = INT_MAX; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if(e-&gt;to-&gt;depth == 0) &#123; e-&gt;to-&gt;depth = v-&gt;depth + 1; f[(e-&gt;to) - nodes][0] = v; g[(e-&gt;to) - nodes][0] = e-&gt;w; q.push(e-&gt;to); &#125; &#125; &#125;&#125;inline void build(int n) &#123; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][j] = f[f[i][j - 1] - nodes][j - 1]; //g[i][j] = g[i][j - 1] + g[f[i][j - 1] - nodes][j - 1]; g[i][j] = std::min(g[i][j - 1], g[f[i][j - 1] - nodes][j - 1]); &#125; &#125;&#125;inline int lca(Node *x, Node *y) &#123; if (x-&gt;depth &lt; y-&gt;depth) &#123; std::swap(x, y); &#125; int min = INT_MAX; if (x-&gt;depth &gt; y-&gt;depth) &#123; for (int i = MAXLOG; i &gt;= 0; i--) &#123; if (f[x - nodes][i] &amp;&amp; f[x - nodes][i]-&gt;depth &gt;= y-&gt;depth) &#123; min = std::min(min, g[x - nodes][i]); x = f[x - nodes][i]; &#125; &#125; &#125; if (x != y) &#123; for (int i = MAXLOG; i &gt;= 0; i--) &#123; if (f[x - nodes][i] != f[y - nodes][i]) &#123; min = std::min(min, g[x - nodes][i]); min = std::min(min, g[y - nodes][i]); x = f[x - nodes][i]; y = f[y - nodes][i]; &#125; &#125; min = std::min(min, g[x - nodes][0]); min = std::min(min, g[y - nodes][0]); &#125; return min;&#125;/*-------------------------------------------------------------------*/int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; scanf("%d%d%d", &amp;uEdges[i].u, &amp;uEdges[i].v, &amp;uEdges[i].w); &#125; std::sort(uEdges + 1, uEdges + m + 1, UEdge::Cmp()); init(n); kruskal(m); for(int i = 1; i &lt;= n; i++) &#123; if(nodes[i].depth == 0) bfs(nodes + i); &#125; build(n); int q; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); if (find(x) != find(y)) &#123; printf("-1\n"); &#125; else &#123; printf("%d\n", lca(nodes + x, nodes + y)); &#125; &#125; return 0;&#125; 【写的时候犯的错误】1、邻接表写反了本来应该是这样1234inline void addEdge(Node *u, Node *v, int w) &#123; v-&gt;edges = new Edge(v, u, w); u-&gt;edges = new Edge(u, v, w);&#125; 结果被写成了这样1234inline void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(v, u, w); v-&gt;edges = new Edge(u, v, w);&#125; 2、BFS的时候没有处理好图不连通的情况，Naive的从1号点开始搜索了【吐槽】调了一个下午，我选择狗带 cyr太神啦，交了两次就A了！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LCA</tag>
        <tag>最大生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1217] 借教室 - 线段树 + 卡常数]]></title>
    <url>%2F2016%2F10%2F25%2Fcodevs-1217%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1217 借教室 【题目描述】在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来$n$天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j, s_j, t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 【输入描述】第一行包含两个正整数$n, m$，表示天数和订单的数量。 第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。 接下来有$m$行，每行包含三个正整数$d_j, s_j, t_j$，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。 【输出描述】如果所有订单均可满足，则输出只有一行，包含一个整数 $0$ 。否则（订单无法完全满足）输出两行，第一行输出一个负整数$-1$，第二行输出需要修改订单的申请人编号。 【题解】建立线段树维护区间最小值，一旦某个区间在修改之后最小值变为了负数那么这个方案就是不可满足的。 裸的线段树可以得到95分，在加入一些常数优化之后就可以A了。 比如我的代码自己是写的max和min，没有用algorithm里面的那个，结果就过掉了。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;climits&gt;const int MAXN = 1e6 + 5;int a[MAXN];inline int minn(int a, int b) &#123; return a &gt; b ? b : a;&#125;inline int maxx(int a, int b) &#123; return a &gt; b ? a : b;&#125;struct SegmentTree &#123; int l, r, min, lazy, mid; SegmentTree *lc, *rc; SegmentTree(int l, int r) : l(l), r(r) &#123; min = INT_MAX, lazy = 0, mid = (l + r) / 2; &#125; void update() &#123; min = minn(lc-&gt;min, rc-&gt;min); &#125; void build() &#123; if (r - l == 1) &#123; min = a[l]; &#125; else &#123; lc = new SegmentTree(l, mid); lc-&gt;build(); rc = new SegmentTree(mid, r); rc-&gt;build(); update(); &#125; &#125; void addTags(int delta) &#123; lazy += delta; min -= delta; &#125; void pushDown() &#123; if (lazy) &#123; lc-&gt;addTags(lazy); rc-&gt;addTags(lazy); lazy = 0; &#125; &#125; void modify(int l, int r, int delta) &#123; if (l == this-&gt;l &amp;&amp; r == this-&gt;r) &#123; addTags(delta); &#125; else &#123; pushDown(); if (l &lt; mid) &#123; lc-&gt;modify(l, minn(r, mid), delta); &#125; if (r &gt; mid) &#123; rc-&gt;modify(maxx(l, mid), r, delta); &#125; update(); &#125; &#125;&#125;;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; SegmentTree st(1, n + 1); st.build(); for (int i = 1; i &lt;= m; i++) &#123; int delta, l, r; scanf("%d%d%d", &amp;delta, &amp;l, &amp;r); st.modify(l, r + 1, delta); if (st.min &lt; 0) &#123; printf("-1\n%d", i); return 0; &#125; &#125; printf("0"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1287] 矩阵乘法 - 矩阵乘法]]></title>
    <url>%2F2016%2F10%2F23%2FMatrix%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1287 矩阵乘法 这是一道矩阵乘法的模板题，题目没有什么好说的，但是可以正好通过这个题目来学习一下矩阵乘法。 【正文】在学习矩阵的时候，先学习了矩阵的加法、减法和数乘，都非常的简单和正常，只要每个对应位置做对应的操作就好了，然而到了乘法的时候，事情就开始变得奇♂怪起来了 两个矩阵的乘法仅当第一个矩阵 $ A $ 的列数和另一个矩阵 $ B $ 的行数相等时才能定义。如 $ A $是 $ m \times p $矩阵， $ B $ 是 $ p \times n $ 矩阵，它们的乘积 $ C $ 是一个 $ m\times p $ 矩阵，它的一个元素$ C_{i, j} $由下面的运算得到： C_{ij} = \sum_{k = 1}^p A_{i, k}B_{k, j} 这是什么鬼定义！为什么两个矩阵相乘会是这个鬼！根本就记不住好吧！关于为什么两个矩阵相乘会变成这个鬼，实际上是这个样子的：矩阵本身就是线性方程式的简单表示法，它和线性方程式是一一对应的 比如这是一个线性方程组： \left\{ \begin{array}{c} 2x + y = 3 \\ 4x + 3y = 7 \end{array} \right.矩阵的最初目的本来就是为这样的方程组提供一个简写形式，上面的方程组可以简写为这样的矩阵的形式 \left( \begin{array}{ccc} 2 & 1 \\ 4 & 3 \end{array} \right) \times \left( \begin{array}{ccc} x \\ y \end{array} \right) = \left( \begin{array}{ccc} 3 \\ 7 \end{array} \right)上面这个式子就基本说明了矩阵乘法的规则，在想不起来怎么做的时候自己写一个方程组然后变一下型就能想起来了 在这篇文章和这篇文章中比较详细的推导并证明了矩阵乘法的计算方式. 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;const int MAXN = 200 + 5;struct Matrix &#123; int sizeX, sizeY; int array[MAXN][MAXN]; Matrix operator* (const Matrix &amp;b) const &#123; Matrix c(sizeX, b.sizeY); for (int i = 1; i &lt;= sizeX; i++) &#123; for (int j = 1; j &lt;= b.sizeY; j++) &#123; for (int k = 1; k &lt;= sizeY; k++) &#123; c.array[i][j] += array[i][k] * b.array[k][j]; &#125; &#125; &#125; return c; &#125; Matrix(int sizeX, int sizeY) : sizeX(sizeX), sizeY(sizeY) &#123;&#125;&#125;;int main() &#123; int ai, aj; scanf("%d%d", &amp;ai, &amp;aj); Matrix a(ai, aj); for (int i = 1; i &lt;= ai; i++) &#123; for (int j = 1; j &lt;= aj; j++) &#123; scanf("%d", &amp;a.array[i][j]); &#125; &#125; int bi, bj; scanf("%d%d", &amp;bi, &amp;bj); Matrix b(bi, bj); for (int i = 1; i &lt;= bi; i++) &#123; for (int j = 1; j &lt;= bj; j++) &#123; scanf("%d", &amp;b.array[i][j]); &#125; &#125; Matrix c(ai, bj); c = a * b;/* printf("The first matrix:\n"); for (int i = 1; i &lt;= ai; i++) &#123; for (int j = 1; j &lt;= aj; j++) &#123; printf("%d ", a.array[i][j]); &#125; printf("\n"); &#125; printf("The second matrix:\n"); for (int i = 1; i &lt;= bi; i++) &#123; for (int j = 1; j &lt;= bj; j++) &#123; printf("%d ", b.array[i][j]); &#125; printf("\n"); &#125;*/ for (int i = 1; i &lt;= c.sizeX; i++) &#123; for (int j = 1; j &lt;= c.sizeY; j++) &#123; printf("%d ", c.array[i][j]); &#125; printf("\n"); &#125; return 0;&#125; 在代码实现上构造了一个矩阵类，并通过运算符重载使其支持乘法。还有一些细节，在乘法计算的三重循环中，对于一个$ m \times p $矩阵 $ A $，$ p \times n $ 矩阵 $ B $ ，第一重循环枚举 $ m $，第二重循环枚举 $ n $ ，第三重循环枚举 $ p $. 【剩下的部分】矩阵乘法究竟有什么用呢？只要能计算乘法就可以计算幂，只要能计算幂就能用快速幂，所以就可以用矩阵快速幂来优化齐次线性递推的计算，将复杂度优化至 $ O(k^3 logn) $]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1048] 石子归并 - 区间DP]]></title>
    <url>%2F2016%2F10%2F21%2Fmerge%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1048 石子归并 【题目描述】有 $ n $ 堆石子排成一列，每堆石子有一个重量 $ wi $,每次合并可以合并相邻的两堆石子，一次合并的代价为两堆石子的重量和 $ w_i + w{i - 1} $ 。问安排怎样的合并顺序，能够使得总合并代价达到最小。 【输入描述】第一行一个整数 $ n (n \leq 100) $ 第二行n个整数 $ w_1,w_2 \dots w_n(w_i \leq 100) $ 【输出描述】一个整数表示最小合并代价 【题解】 这是一道区间DP入门题 —— Hellc 那我们就暂且认为这是一道区间DP的入门题，考虑按区间长度进行转移，设 $ f(l, r) $ 表示将闭区间 $ [l, r] $ 合并的最小代价，则状态转移为 f(l, r) = \min\{f(l, k), f(k + 1, r)\} + sum(l ,r), k \in [l, r)其中 $ sum(l, r) $ 表示 $ l $ 到 $ r $ 的区间和， 即 sum(l ,r) = \sum_{i = l} ^ r w_i边界条件为 f(i, i) = 0【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;const int MAXN = 100 + 5;const int INF = 0x7f;int a[MAXN];int f[MAXN][MAXN];inline int sum(int l, int r) &#123; if(l == 1) &#123; return a[r]; &#125; else &#123; return a[r] - a[l - 1]; &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); a[i] += a[i - 1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; f[i][i] = 0; &#125; for (int len = 2; len &lt;= n; len++) &#123; for (int l = 1; l &lt;= n - len + 1; l++) &#123; int r = l + len - 1;#ifdef DEBUG printf("[%d, %d] : \n", l, r);#endif int min = INT_MAX; for (int k = l; k &lt; r; k++) &#123;#ifdef DEBUG printf(" from: [%d, %d] + [%d, %d]\n", l, k, k + 1, r);#endif min = std::min(f[l][k] + f[k + 1][r], min); &#125; if(min != INT_MAX)&#123; f[l][r] = min + sum(l, r); &#125; else f[l][r] = sum(l, r); &#125; &#125; printf("%d", f[1][n]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1068] 乌龟棋 - 背包DP]]></title>
    <url>%2F2016%2F10%2F20%2Fchess%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1068 乌龟棋 【题目描述】乌龟棋的棋盘是一行$ n $个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$ n $格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。乌龟棋中 $ m $ 张爬行卡片，分成4种不同的类型，每种类型的卡片上分别标有1、2、3、4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的 分数总和。求最多能得到多少分。 【输入描述】输入的每行中两个数之间用一个空格隔开。 第1行2个正整数 $ n $ 和 $ m $ ，分别表示棋盘格子数和爬行卡片数。 第2行 $ n $ 个非负整数，其中 $ a_i $ 表示棋盘第 $ i $ 个格子上的分数。 第3行 $ m $ 个整数，$ b_1,b_2 \dots b_m $，表示 $ m $ 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光 $ m $ 张爬行卡片。 【输出描述】输出一行一个整数 【数据范围及提示】对于 $ 30 \% $ 的数据有 $ 1 \leq n \leq 30 $，$ 1 \leq m \leq 12 $。 对于 $ 50 \% $ 的数据有 $ 1 \leq n \leq 120 $，$ 1 \leq m \leq 50 $，且 $ 4 $ 种爬行卡片，每种卡片的张数不会超过 $ 20 $。 对于 $ 100 \% $ 的数据有 $ 1 \leq n \leq 350 $ ，$ 1 \leq m \leq 120 $ ，且 $ 4 $ 种爬行卡片，每种卡片的张数不会超过 $ 40 $，$ 0 \leq ai \leq 100$ ，$ 1 \leq i \leq n $ ，$ 1 \leq bi \leq 4 $，$ 1 \leq i \leq m $。 【题解】传说这是一道背包DP题，然而我并不知道是为什么。 因为最多只有 $ 4 $ 种卡片，所以我们可以使用四维数组 $ f[i][j][k][l] $ 来表示当前使用 $ i $ 张 $ 1 $ 号卡片，$ j $ 张 $ 2 $ 号卡片，$ k $ 张 $ 3 $ 号卡片，$ l $ 张 $ 4 $ 号卡片所获得的最大价值 状态转移为 f(i, j, k, l) = \max \begin{cases} f(i - 1, j, k, l) \\\[2ex] f(i, j - 1, k, l) \\\[2ex] f(i, j, k - 1, l) \\\[2ex] f(i, j, k, l - 1) \end{cases}+a(i \times 1 + j \times 2 + k \times 3 + l \times 4)【代码】123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;const int MAXN = 350 + 5;const int MAXM = 5;const int MAXX = 50;int a[MAXN], b[MAXM];int f[MAXX][MAXX][MAXX][MAXX];int main() &#123; int n, m ; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;b[0]); b[b[0]]++; &#125; int maxx = 0; for (int i = 0; i &lt;= b[1]; i++) &#123; for (int j = 0; j &lt;= b[2]; j++) &#123; for (int k = 0; k &lt;= b[3]; k++) &#123; for (int l = 0; l &lt;= b[4]; l++) &#123; int maxx = 0; if (i) maxx = maxx &gt; f[i - 1][j][k][l] ? maxx : f[i - 1][j][k][l]; if (j) maxx = maxx &gt; f[i][j - 1][k][l] ? maxx : f[i][j - 1][k][l]; if (k) maxx = maxx &gt; f[i][j][k - 1][l] ? maxx : f[i][j][k - 1][l]; if (l) maxx = maxx &gt; f[i][j][k][l - 1] ? maxx : f[i][j][k][l - 1]; f[i][j][k][l] = maxx + a[i + 2 * j + 3 * k + 4 * l + 1]; &#125; &#125; &#125; &#125; printf("%d", f[b[1]][b[2]][b[3]][b[4]]); return 0;&#125; 【其他】每次重新计算 $maxx$ 时一定要记得先初始化为 $ 0 $ ，每一次都要初始化]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1058]合唱队形 - 序列DP]]></title>
    <url>%2F2016%2F10%2F19%2FCodevs_1058%2F</url>
    <content type="text"><![CDATA[【题目描述】$n$位同学站成一排，音乐老师要请其中的$(n-k)$位同学出列，使得剩下的$k$位同学排成合唱队形。 合唱队形是指这样的一种队形：设$k$位同学从左到右依次编号为$1，2 \dots K$，他们的身高分别为$t1，t_2，…，t_k$， 则他们的身高满足$t_1&lt; \dots &lt; t_i &gt; t{i+1} &gt; \dots &gt;t_k(1 \leq i \leq k)$。 你的任务是，已知所有$n$位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 【输入描述】第一行是一个整数$n(2 \leq N \leq 100)$，表示同学的总数。第一行有$n$个整数，用空格分隔，第$i$个整数$t_i(130 \leq t_i \leq 230)$是第$i$位同学的身高(厘米)。 【输出描述】包括一行，这一行只包含一个整数，就是最少需要几位同学出列。 【数据范围及提示】对于$50\%$的数据，保证有$n \leq 20$ 对于$100\%$的数据，保证有$n \leq 100$。 【题解】正着跑一边LIS反着跑一遍LIS，然后枚举中间点选出最大值即可，反正$n$这么小随便怎么搞都可以啦。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100 + 5;const int INF = 0x7f;int a[MAXN], b[MAXN], f[MAXN], g[MAXN];inline void lis(int l, int r, int *tmp, int *in) &#123; for (int i = l; i &lt;= r; i++) &#123; tmp[i] = 1; for (int j = l; j &lt;= i; j++) &#123; if (in[i] &gt; in[j] &amp;&amp; tmp[j] + 1 &gt; tmp[i]) &#123; tmp[i] = tmp[j] + 1; &#125; &#125; &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[n - i + 1] = a[i]; &#125; lis(1, n, f, a); lis(1, n, g, b); int max = -INF; for (int i = 1; i &lt;= n; i++) &#123; if (max &lt;= f[i] + g[n - i + 1] - 1) &#123; max = f[i] + g[n - i + 1] - 1; &#125; &#125; printf("%d", n - max); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 2370] 小机房的树 - 最近公共祖先 + 倍增]]></title>
    <url>%2F2016%2F10%2F17%2FLCA%2F</url>
    <content type="text"><![CDATA[倍增算法的上一部分：利用倍增算法加速区间操作 【倍增算法求LCA】LCA(Lowest Common Ancestors), 字面意思为“最近公共祖先” 对于有根树$T$的两个结点$u$、$v$，最近公共祖先$LCA(T, u, v)$表示一个结点$x$，满足$x$是$u$、$v$的祖先且$x$的深度尽可能大。 设 $f(i, j)$ 表示 $i$ 号节点向上跳 $2^j$ 步所到达的节点的编号，则可以用下面的式子递推得到 f(i, j) = f(f(i, j - 1), j - 1)在处理的时候先$DFS$一遍处理出每个节点的深度，然后开始让两个节点中较深的那一个向上跳直到两个节点到同一深度，然后让两个节点一起向上跳， 直到两个节点到重合前的前一层， 向上再走一步， 到达的就是两个点的最近公共祖先。 【题目描述】树上有N个节点，节点标号为0到N-1，已知从某个节点爬到其父亲节点要花费 c 的能量（从父亲节点爬到此节点也相同），找出一条花费精力最短的路 【输入描述】第一行一个$n$，接下来$n-1$行每一行有三个整数$u，v， c$ 。表示节点$u$ 爬到节点 $v$ 需要花费 $c$ 的精力。第$n+1$行有一个整数$m$表示有$m$次询问。接下来$m$行每一行有两个整数$ u, v $表示两只虫子所在的节点。 【输出描述】一共有$m$行，每一行一个整数，表示对于该次询问所得出的最短距离。 【数据范围及提示】$1 \leq n \leq 50000$ $1 \leq m \leq 75000$ $0 \leq c \leq 1000$ 【题解】已知在一棵树上两个节点间的简单路径是唯一的，就是经过LCA的那一条，所以只需要求出LCA并且顺便维护两个点在跳到LCA之前所经过的路径和就好了 【代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAXN = 50000 + 10;const int MAXLOG = 15;struct Node;struct Edge;struct Node &#123; int depth; Edge *edges; Node() : depth(0), edges(NULL) &#123;&#125;&#125; nodes[MAXN], *f[MAXN][MAXLOG + 1];int g[MAXN][MAXLOG + 1];struct Edge &#123; Node *fr, *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(u, v, w); v-&gt;edges = new Edge(v, u ,w);&#125;inline void bfs(Node *x) &#123; std::queue&lt;Node*&gt; q; q.push(x); x-&gt;depth = 1; f[x - nodes][0] = x; g[x - nodes][0] = 0; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if(e-&gt;to-&gt;depth == 0) &#123; e-&gt;to-&gt;depth = v-&gt;depth + 1; f[(e-&gt;to) - nodes][0] = v; g[(e-&gt;to) - nodes][0] = e-&gt;w; q.push(e-&gt;to); &#125; &#125; &#125;&#125;inline void build(int n) &#123; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i][j] = f[f[i][j - 1] - nodes][j - 1]; g[i][j] = g[i][j - 1] + g[f[i][j - 1] - nodes][j - 1]; &#125; &#125;&#125;inline int lca(Node *x, Node *y) &#123; if (x-&gt;depth &lt; y-&gt;depth) &#123; std::swap(x, y); &#125; int sum = 0; if (x-&gt;depth &gt; y-&gt;depth) &#123; for (int i = MAXLOG; i &gt;= 0; i--) &#123; if (f[x - nodes][i] &amp;&amp; f[x - nodes][i]-&gt;depth &gt;= y-&gt;depth) &#123; sum += g[x - nodes][i]; x = f[x - nodes][i]; &#125; &#125; &#125; if (x != y) &#123; for (int i = MAXLOG; i &gt;= 0; i--) &#123; if (f[x - nodes][i] != f[y - nodes][i]) &#123; sum += g[x - nodes][i]; sum += g[y - nodes][i]; x = f[x - nodes][i]; y = f[y - nodes][i]; &#125; &#125; sum += g[x - nodes][0]; sum += g[y - nodes][0]; &#125; return sum;&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); u++, v++; addEdge(nodes + u, nodes + v, w); &#125; bfs(nodes + 1); build(n); int m; scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); x++, y++; printf("%d\n", lca(nodes + x, nodes + y)); &#125; return 0;&#125; 【写的时候犯的错误】1、数组从 1 开始编号，编号不统一 2、在lca()中sum和x的修改顺序颠倒了 3、取节点编号的时候把x - nodes写成了nodes - x结果就段错误了 4、在bfs()中只给f数组赋了初值而没有初始化g数组 【对代码内容的一点说明】$f(i, j)$表示从$i$号节点向上跳$2^j$步后到达的节点 $g(i, j)$表示从$i$号节点向上跳$2^j$步后所经过的路径和 树用邻接表存，因为在这道题当中树的形态是不重要的 数组从 1 开始编号，而题目中是从 0 开始编号的，所以有些地方会 +1s 加一 MAXLOG是树最大层数，数值上等于节点数的以二位底的对数 【最后】%%% Hellc大神，自己调了一上午没过的题，Hellc半个小时就调过了，真是太神啦！ 自己还是太弱……不过似乎学到了一些实用的调试技巧，以后要尝试应用在自己调试的过程中。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>倍增</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1200] 同余方程 - 数论相关 + 逆元]]></title>
    <url>%2F2016%2F10%2F16%2Fphi%2F</url>
    <content type="text"><![CDATA[【传送门】Codevs 1200 同余方程 【题目描述】求关于方程$ax \equiv 1 \pmod b$的最小正整数解 【输入描述】输入只有一行，包含两个正整数$a$, $b$, 中间用一个空格间隔开 【输出描述】输出只有一行一个正整数$x_0$, 即最小正整数解, 输入数据保证一定有解 【数据范围及提示】对于$40\%$的数据，$2 \leq b \leq 1000$ 对于$60\%$的数据，$2 \leq b \leq 50000000$ 对于$100\%$的数据，$2 \leq a, b \leq 2000000000$ 【题解】这是一道数论题, 题目要求解一个简单的同余方程, 出题人很良心地让$ax$ 与 $1$ 同余, 这样题目就变成了裸的求逆元, 解法也就不止一种了 算法一【欧拉定理求逆元】欧拉定理： a^{\varphi(b)} \equiv 1 \pmod b稍微变形可得： a \times a^{\varphi(b) - 1} \equiv 1 \pmod b会发现这里的$a^{\varphi(b) - 1}$就是我们要求的$x$, 用快速幂算一下就可以了。 $\varphi(n)$是什么?它叫做欧拉函数, 表示的是不大于$n$的正整数中与$n$互质的数的个数…… 算法二 【拓展欧几里得求逆元】这种算法据说常数会比用欧拉函数来求要小一些, 所以对于求逆元来说更优一些 留坑待填…… 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cmath&gt;long long a, b;int phi(long long n) &#123; int m = (int) sqrt(n + 0.5); int ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) &#123; n /= i; &#125; &#125; &#125; if (n &gt; 1) &#123; ans = ans / n * (n - 1); &#125; return ans;&#125;inline long long mulMod(long long x, long long y) &#123; return ((x % b) * (y % b)) % b;&#125;inline long long fastPowMod(long long m, long long n) &#123; if (n == 1) &#123; return m; &#125;else if(n % 2 != 0) &#123; return mulMod(fastPowMod(m, n-1), m); &#125;else&#123; return fastPowMod(mulMod(m, m), n &gt;&gt; 1); &#125;&#125;int main() &#123; scanf("%lld%lld", &amp;a, &amp;b); int x = phi(b); printf("%lld\n", fastPowMod(a, x - 1)); return 0;&#125; 【最后】这是Hellc关于数论的博客1 这是Hellc关于数论的博客2]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>NOIp</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写数据生成器并实现对拍]]></title>
    <url>%2F2016%2F10%2F13%2FDO%2F</url>
    <content type="text"><![CDATA[在算法竞赛的过程中， 常常会遇到自己想出了一个复杂度低的算法但却不能严格证明其正确性的情况， 或者说一道题调试了很久就是有那么一两个点过不去， 这个时候常会让人有种弃疗的冲动， 所以这个时候一个简单而有用的技巧就非常有用了，就是传说中的对拍 所谓对拍， 就是指让两个程序同时运行， 比较他们的输出， 如果出现不同， 就停止。 比如说在竞赛中不能确定高效的算法是否真的正确， 就可以写一个暴力， 让他们同时运行， 如果出现了不一样的输出， 那么肯定说明这两个程序中至少有一个写错了， 这时我们得到了一组使程序错误的数据， 然后就可以面向数据调试了。 在实现对拍之前，我们首先需要一个数据生成器，可以自己产生随机数据，输出到标程和自己程序的输入文件中， 再调用Windows下的fc命令比较标程和自己程序的输出文件， 相同就再生成一组，再运行一次， 直到找到不同为止。 下面是一个例子：对于音乐会的等待这道 毒瘤 题目， 可以用这样的数据生成器1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;climits&gt;#include &lt;ctime&gt;const int MAX = 100;int main() &#123; freopen("in.txt", "w", stdout); srand(time(0)); int n = rand() % MAX; printf("%d\n", n); for(int i = 1; i &lt;= n ; i++) &#123; int x = rand() % INT_MAX; printf("%d\n", x); &#125; fclose(stdout); return 0;&#125; 而对拍程序就像这样：12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;const int MAXN = 10000;int main() &#123; for(int i = 1; i &lt;= MAXN; i++) &#123; system("datamaker.exe"); system("1823.exe"); system("1823_b.exe"); if("fc out1.txt out2.txt") &#123; printf("YES"); &#125;else &#123; printf("Error!%d", i); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷 1823]音乐会的等待 - 单调栈]]></title>
    <url>%2F2016%2F10%2F12%2FStack%2F</url>
    <content type="text"><![CDATA[【入场券】洛谷 1823 音乐会的等待 【题目描述】$N$个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人$A$和$B$，如果他们是相邻或他们之间没有人比$A$或$B$高，那么他们是可以互相看得见的。 写一个程序计算出有多少对人可以互相看见。 【输入描述】输入的第一行包含一个整数$N (1 \leq N \leq 500000)$, 表示队伍中共有$N$个人。 接下来的$N$行中，每行包含一个整数，表示人的高度，以毫微米(等于$10 ^ {-9}$米)为单位，每个人的调度都小于$2^{31}$毫微米。这些高度分别表示队伍中人的身高。 【输出描述】输出仅有一行，包含一个数$S$，表示队伍中共有$S$对人可以互相看见。 【题解】考虑维护一个单调递减的单调栈。 在第$i$个人进入时， 栈里保存的是能和$i$互相看到的人。 先从栈顶向下搜索， 遇到不比$i$ 高的就把答案加一，当遇到第一个比$i$高的人的时候再加一， 退出循环。 然后再从栈顶开始向下找， 在栈里一个个弹出比$i$矮的人， 因为为了维护栈内元素的单调性， 如果栈中存在比$i$矮的人，当$i$ 进来之后他就会被$i$挡住， 后面的人就再也不能看到他了， 这个时候保存他是没有意义的， 反而会在第一步统计答案的过程中被多加进去。 另外特别要注意的一点就是当栈中存在身高相等的人，后边的人是两个人都能看到的（计入答案），所以这个时候不存在挡住的情况（不弹出），所以这样的情况只计入答案但不弹出。 【代码】123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;const int MAXN = 500000 + 5;int a[MAXN];int cnt = 0;long long ans = 0;int main() &#123; int n; scanf("%d", &amp;n); while (n--) &#123; int x; scanf("%d", &amp;x); if (cnt == 0) &#123; a[++cnt] = x; &#125; else &#123; for (int i = cnt; i &gt;= 1; i--) &#123; ans++; if (a[i] &gt; x) break; &#125; while(a[cnt] &lt; x &amp;&amp; cnt &gt;= 1) cnt--; a[++cnt] = x; &#125; &#125; printf("%lld\n", ans); return 0;&#125; 【吐槽】这题虽然是一个裸的单调栈结果我却写了两个晚上， 交了20多次才AC，开始试图使用std::stack， 后来又尝试std::vector, 但是因为迭代器不会用所以爆炸了 orz ,最后无奈只能手动实现单调栈（虽然并不难写）， 就是这样一道并不难写代码只有短短30几行的题莫名其妙困住了多名LYOI选手， 最后还是Menci神犇一遍AC %%% 另外就是在做这题的过程中收获到了各种各样的错误信息， 甚至18AC 2TLE， 最后把一个for循环改成while循环就莫名其妙AC了， 真是神奇……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1044]拦截导弹 - 序列DP]]></title>
    <url>%2F2016%2F10%2F12%2F%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[【题目链接】Codevs 1044 拦截导弹 【题目描述】某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹 【输入描述】输入导弹依次飞来的高度（雷达给出的高度数据是不大于 $ 30000 $ 的正整数） 【输出描述】输出这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 【数据范围及提示】导弹的高度$\leq 30000$，导弹个数$\leq 20$ 【题解】这道题目的第一问是非常经典的“最长不上升子序列”问题, 有复杂度为$O(n ^ 2)$的算法和$O(nlogn)$的算法， 其中$O(n ^ 2)$的算法很容易想到， 用$d[i]$表示以$i$为结尾的最长不上升子序列长度， 状态转移为 d(i) = \max \{0, d(j) | j < i, A_i \leq A_j\} + 1初始化时每个$i$的$d[i] = 1$ 类似的， 还有“最长不下降子序列”， “最长上升子序列”， “最长下降子序列”， 解决方法都是类似的。甚至说要求一个序列的最长不下降子序列只要把这个序列倒序存储然后求一下新序列的最长上升子序列就好了。 至于第二问……可以看做是最长链的最小划分，根据某玄学的$Dilworth$定理: 反链是一种偏序集，其任意两个元素不可比；而链则是一种任意两个元素可比的偏序集。Dilworth定理说明，存在一个反链A与一个将序列划分为链族P的划分，使得划分中链的数量等于集合A的基数。当存在这种情况时，对任何至多能包含来自P中每一个成员一个元素的反链，A一定是此序列中的最大反链。同样地，对于任何最少包含A中的每一个元素的一个链的划分，P也一定是序列可以划分出的最小链族。偏序集的宽度被定义为A与P的共同大小。另一种Dilworth定理的等价表述是：在有穷偏序集中，任何反链最大元素数目等于任何将集合到链的划分中链的最小数目。一个关于无限偏序集的理论指出，在此种情况下，一个偏序集具有有限的宽度w，当且仅当它可以划分为最少w条链。反链是一种偏序集，其任意两个元素不可比；而链则是一种任意两个元素可比的偏序集。Dilworth定理说明，存在一个反链A与一个将序列划分为链族P的划分，使得划分中链的数量等于集合A的基数。当存在这种情况时，对任何至多能包含来自P中每一个成员一个元素的反链，A一定是此序列中的最大反链。同样地，对于任何最少包含A中的每一个元素的一个链的划分，P也一定是序列可以划分出的最小链族。偏序集的宽度被定义为A与P的共同大小。另一种Dilworth定理的等价表述是：在有穷偏序集中，任何反链最大元素数目等于任何将集合到链的划分中链的最小数目。一个关于无限偏序集的理论指出，在此种情况下，一个偏序集具有有限的宽度w，当且仅当它可以划分为最少w条链。 显然我根本看不懂它在说什么 可知， 链的最少划分数 = 反链的最长长度。 所以只要求出最长不上升子序列的反链也就是最长下降子序列的长度就好了， 这个时候我们只需要把整个序列倒过来然后再跑一边第一问的代码，代码都不用改 【代码】#include &lt;cstdio&gt; const int MAXN = 20 + 5; int a[MAXN], d[MAXN], tmp[MAXN], f[MAXN]; int main() { int cnt = 1; while(scanf(&quot;%d&quot;, &amp;a[cnt]) == 1) { cnt++; } for(int i = 1; i &lt; cnt; i++) { tmp[i] = a[cnt - i]; } for(int i = 1; i &lt; cnt; i++) { d[i] = 1; f[i] = 1; for(int j = 1; j &lt; i; j++) { if(tmp[j] &lt; tmp[i] &amp;&amp; d[j] + 1 &gt; d[i]) { d[i] = d[j] + 1; } if(a[j] &lt;= a[i] &amp;&amp; f[j] + 1 &gt; f[i]) { f[i] = f[j] + 1; } } } int max1 = d[1], max2 = f[1]; for(int i = 1; i &lt; cnt; i++) { if(max1 &lt; d[i]) { max1 = d[i]; } if(max2 &lt; f[i]) { max2 = f[i]; } } printf(&quot;%d\n%d&quot;, max1, max2); return 0; } 【吐槽】再刚开始写这道题的时候， 听信了辣鸡参考书《信息学奥赛一本通》p273上的题解，错误的算成了最长不下降子序列的长度， 结果每次输出的结果和样例正好相反 Orz]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>序列DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习题整理]]></title>
    <url>%2F2016%2F10%2F10%2Fproblems2%2F</url>
    <content type="text"><![CDATA[整理了在国庆集训期间的习题，以后加油慢慢啃掉 完成度(12 / 17) [x] 音乐会的等待 —— 单调栈 [x] POJ 2823 Sliding Window —— 单调队列 [ ] Codevs 3622 假期 —— 并查集优化 [x] Codevs 4600 程序自动分析 —— 并查集 [ ] POJ 1456 Supermarket—— 贪心 + 并查集优化 [x] POJ 3264 Balanced Lineup ——ST表求RMQ [x] 线段树练习1~5 —— 线段树 [x] POJ 2777 Count Color —— 线段树 [x] POJ 3468 A Simple Problem with Integers —— 线段树 [x] Codevs 2152 滑雪 —— 普通DP [x] Codevs 1102 采药—— 背包DP [ ] POJ 1952 BUY LOW, BUY LOWER —— 线性DP [x] POJ 1738 石子归并 —— 区间DP [x] Codevs 1380 没有上司的舞会 —— 树形DP [ ] POJ 2486 Apple tree —— 树形DP [ ] POJ 2152 Fire —— 树形DP [x] POJ 2367 Genealogical tree —— 拓扑排序]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[codevs 2833]奇怪的梦境 - 拓扑排序]]></title>
    <url>%2F2016%2F09%2F25%2Fsort%2F</url>
    <content type="text"><![CDATA[【题目大意】给出$n$个按钮，和其中要求的顺序关系， 判断是否存在拓扑序列 【链接】codevs 2833 奇怪的梦境 【题解】裸 水 的拓扑排序，每在拓扑序列中加入一个点就 sum++ ， 最后要求的不在拓扑序列中的数目就直接用总数减掉就好了 在实现上使用了邻接表（乱搞）我也不知道为什么会这么长orz 【代码】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;queue&gt;const int MAXN = 10000;struct Node;struct Edge;struct Node &#123; Edge *edges; int num; Node() : edges(NULL), num(0) &#123;&#125;&#125;nodes[MAXN];struct Edge &#123; Node *fr, *to; Edge *next; Edge(Node *fr, Node *to) : fr(fr), to(to) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v) &#123; u-&gt;edges = new Edge(u, v); v-&gt;num++; return;&#125;inline void delEdge(Node *u) &#123; for(Edge *e = u-&gt;edges; e; e = e-&gt;next) &#123; e-&gt;to-&gt;num--; //delete e; &#125; return;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addEdge(nodes + u, nodes + v); &#125; std::queue&lt;Node*&gt; q; for(int i = 1; i &lt;= n; i++) &#123; if(nodes[i].num == 0) &#123; q.push(nodes + i); &#125; &#125; int sum = 0; while(!q.empty()) &#123; Node *v = q.front(); q.pop(); sum++; delEdge(v); for(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if(e-&gt;to-&gt;num == 0) &#123; q.push(e-&gt;to); &#125; &#125; &#125; if(sum == n) &#123; printf("o(∩_∩)o"); &#125;else &#123; printf("T_T\n%d", n - sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 3538 && Codevs 1696]奇怪的函数 - 二分答案]]></title>
    <url>%2F2016%2F09%2F16%2F%E4%BA%8C%E5%88%862%2F</url>
    <content type="text"><![CDATA[codevs 3538 &amp;&amp; codevs 1696 奇怪的函数【题目链接】codevs 3538 奇怪的函数codevs 1696 奇怪的函数 【题目内容】使得$x^x$达到或超过$n$位数字的最小正整数$x$是多少? $n \leq 2 000 000 000$ (2后面9个0) 【题解】当时学分治的时候的一道没写的例题，突然想起来就花点时间A掉了. 在codevs 1696中给出了一个公式可以来求一个数的位数，大概长这个样子： ans = \lfloor n \times \log_{10}n \rfloor + 1知道了这个公式那就好办了，二分答案，边界直接设$1$到$2 000 000 000$就可以，因为最坏递归计算$log_22 000 000 000 \thickapprox 31$次 另外就是因为$n$很大所以尽量用long long否则 可能 会 莫名 狗带 【代码】12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cmath&gt;const long long MAXN = 2000000000;long long n;inline long long calc(long long n) &#123; //if(n == 1) return 1; //return floor(n * log10(n)) + 1; long long ans = floor(n * log10(n)) + 1; return ans;&#125;inline void func(long long l, long long r) &#123; if(l == r) &#123; printf("%lld", l); return; &#125;else &#123; long long mid = (l + r) / 2; if(calc(mid) &gt;= n) &#123; func(l, mid); &#125;else &#123; func(mid + 1, r); &#125; &#125;&#125;int main() &#123; scanf("%lld", &amp;n); func(1, MAXN); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp历届题目]]></title>
    <url>%2F2016%2F09%2F11%2FNOIp%2F</url>
    <content type="text"><![CDATA[NOIP完成度(54 / 80） 2016 [x] 玩具谜题 [ ] 天天爱跑步 [x] 换教室 [x] 组合数问题 [x] 蚯蚓 [x] 愤怒的小鸟 2015 [x] 神奇的幻方 [x] 信息传递 [ ] 斗地主 [x] 跳石头 [ ] 子串 [ ] 运输计划 2014 [x] 生活大爆炸版石头剪刀布 [x] 联合权值 [ ] 飞扬的小鸟 [x] 无线网络发射器选址 [x] 寻找道路 [ ] 解方程 2013 [x] 转圈游戏 [x] 火柴排队 [x] 货车运输 [x] 积木大赛 [x] 花匠 [ ] 华容道 2012 [x] Vigenère 密码 [x] 国王游戏 [ ] 开车旅行 [x] 同余方程 [x] 借教室 [ ] 疫情控制 2011 [x] 铺地毯 [x] 选择客栈 [ ] mayan 游戏 [x] 计算系数 [x] 聪明的质检员 [ ] 观光公交 2010 [x] 机器翻译 [x] 乌龟棋 [x] 关押罪犯 [x] 饮水入城 2009 [x] 潜伏者 [x] Hankson 的趣味题 [ ] 最优贸易 [ ] 靶型数独 2008 [x] 笨小猴 [x] 火柴棒等式 [x] 传纸条 [ ] 双栈排序 2007 [x] 统计数字 [ ] 字符串的展开 [x] 矩阵取数游戏 [ ] 树网的核 2006 [x] 能量项链 [x] 金明的预算方案 [ ] 作业调度方案 [ ] 2k进制数 2005 [x] 谁拿了最多奖学金 [ ] 过河 [ ] 篝火晚会 [ ] 等价表达式 2004 [x] 津津的储蓄计划 [x] 合并果子 [x] 合唱队形 [ ] 虫食算 2003 [x] 神经网络 [ ] 侦探推理 [x] 加分二叉树 [ ] 传染病控制 2002 [x] 均分纸牌 [x] 字串变换 [x] 自由落体 [ ] 矩形覆盖 2001 [x] 一元三次方程求解 [x] 数的划分 [x] 统计单词个数 [ ] Car的旅行路线 2000 [x] 进制转换 [x] 乘积最大 [x] 单词接龙 [x] 方格取数]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于结构体]]></title>
    <url>%2F2016%2F09%2F11%2Fstruct%2F</url>
    <content type="text"><![CDATA[听 Hellc 神犇讲了结构体，写来总结一下 在c++当中，允许用户自定义结构体，结构体就是一个可以包含不同数据类型的一个结构，它是一种可以自己定义的数据类型，定义一个 结构体 就相当于定义了一个自己的 类型 ，可以对其进行一些方便的操作 成员变量当我们定义了一个结构体时，其中通常会有一些成员变量，来描述这个这个类型的数据的某一部分，比如对于一个学生，我们建立一个Student结构体(类)，其中包含name和birthday两个成员，分别描述这个学生的姓名和生日1234struct Student &#123; string name; int birthday;&#125;student, *student_1; 对于每一个成员，我们可以使用.运算符,通过 student.name 这种语法从一个结构体中获得；类似的，当我们拥有一个指向某个Student类型的指针的时候，可以使用 -&gt; 运算符，通过 student_1-&gt;name 这种语法来获得某一个成员变量，相当于 *student_1.name。 成员函数在 c++ 当中，除了允许在结构体中包含一些成员变量，还允许一个结构体中有成员函数。成员变量相当于这个结构的某一个部分，那么成员函数就是可以对这个结构进行的一些操作。 就像车.轮子和车.开车() 12345678struct Student &#123; string name; int birthday; void printAge() &#123; printf("%d", 2016 - birthday); return; &#125;&#125;student; 在上面这个结构体中，定义了一个成员函数，用来输出这个学生的年龄，因为成员函数也是结构体中的一个成员，所以同样可以用. 和 -&gt; 运算符来访问 12345678910111213141516171819202122#include &lt;cstdio&gt;struct Student &#123; int birthday; void printAge() &#123; printf("%d", 2016 - birthday); return; &#125;&#125;st, *st_1;int main() &#123; st_1 = new Student();// 否则st_1作为一个野指针指向0x00000000这个地址，不能直接访问，会段错误； scanf("%d", &amp;st.birthday); scanf("%d", &amp;st_1-&gt;birthday); printf("%d\n", st.birthday); printf("%d\n", st_1-&gt;birthday); st.printAge(); printf("\n"); st_1-&gt;printAge(); delete st_1;// new出来的东西要记得delete掉，这是一个好习惯 return 0;&#125; 构造函数构造函数是一种特殊的成员函数，它与结构体的名称相同，在每次定义该结构体类型的变量的时候都会被调用，作用就是 构造 一个该结构体类型的变量 下面的代码演示了使用构造函数讲一个分数结构体初始化为 $\frac{1}{1}$ 如果不使用构造函数，在结构体定义在全局的情况下会默认初始化为$0$，但是定义在局部，就会被初始化为一个莫名其妙的数 12345678910111213#include &lt;cstdio&gt;struct Number &#123; int a, b; Number() &#123; a = b = 1; &#125;&#125;number;int main() &#123; printf("%d / %d", number.a, number.b); return 0;&#125; 重载运算符c++当中提供了很多运算符， 但这些运算符只能滋磁c++内置的类型，对于自己定义的类型，可以使用“重载运算符”的方法为自定义的类型定义运算符，比如可以对刚才的分数结构体定义加减乘除等运算]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些习题]]></title>
    <url>%2F2016%2F08%2F29%2Fproblems%2F</url>
    <content type="text"><![CDATA[很久以前Menci同学整理的 水 习题，但是因为 懒 没时间所以一直没有做…… 完成度(21 / 25) 树二叉树 [x] codevs 2010 求后序遍历 [ ] codevs 1094 FBI树 堆 [x] codevs 1063 合并果子 [x] codevs 2573 黑匣子 并查集 [x] codevs 1073 家族 [x] codevs 3554 犯罪团伙 [x] codevs 4600 程序自动分析 NOI 2013 最近公共祖先 [x] codevs 2370 小机房的树 [x] codevs 1036 商务旅行 [x] codevs 3287 货车运输 NOIp 2013 图连通性 [x] codevs 1019 集合论与图论 [x] codevs 3554 犯罪团伙 [x] codevs 1173 最优贸易 NOIp 2009 [x] codevs 3731 寻找道路 NOIp 2014 [x] codevs 4511 信息传递 NOIp 2015 [x] codevs 3278 联合权值 NOIp 2014 最短路 [x] codevs 1077 多源最短路 [x] codevs 1557 热浪 [ ] codevs 2059 逃出克隆岛 [ ] codevs 4175 收费站 [ ] codevs 4416 FFF团卧底的后宫 最小生成树 [x] codevs 1231 最优布线问题 [x] codevs 1001 舒适的路线 HAOI 2006 拓扑排序 [x] codevs 2763 封路 [x] codevs 2833 奇怪的梦境]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀和与差分学习笔记]]></title>
    <url>%2F2016%2F08%2F20%2FpremixSum%2F</url>
    <content type="text"><![CDATA[前缀和与差分前缀和 (Prefix Sum)对于一维数组数组a，前缀和sum[i]表示从开始到a[i]的所有数字的和(包括a[i]) 差分(difference）差分，又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。 【前缀和 (Prefix Sum)】对于一维数组数组a，前缀和sum[i]表示从开始到a[i]的所有数字的和(包括$a[i]$).(数列的前$i$项和) 递推求前缀和：12345sum[1] = a[1];for(int i = 1; i &lt;= len; i++) &#123; sum[i] = sum[i - 1] + a[i];&#125; 同样，对于二维数组b，前缀和sum[i][j]表示所有b[m][n]$(1 \leq m \leq i, i \leq n \leq k)$的和(包括$b[m][n]$). 1 2 3 4 5 6 7 8 9 10 11 12 对于上面这个二维数组B，前缀和数组B’为 1 3 6 5 12 21 12 27 45 22 48 78 递推求前缀和： 1234567sum[1][1] = b[1][1];for(int i = 1; i &lt;= len; i++) &#123; for(int j = 1; j &lt;= len; j++) &#123; sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i - 1][j - 1]+b[i][j]; &#125;&#125; 【差分(difference)】 差分，又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数$f(x)$ 映射到$f(x+a)-f(x+b)$ 。差分运算，相应于微分运算，是微积分中重要的一个概念。总而言之，差分对应离散，微分对应连续。差分又分为前向差分和逆向差分两种。 比如，在一个等差数列${ an }$中，公差$d$定义为$a_i - a{i - 1}$，这就是一种简单的差分。 对于一个一维数组，如果我们要求区间[i .. k]的和，可以用一个循环加起来，但是这样是比较耗时间的，如果我们利用前缀和，只需要用sum[k] - sum[i-1]就可以快速得到答案。 1int ans = sum[k] - sum[i - 1]; 对于一个二维数组，也可以进行同样的操作。下面的代码演示了如何求一个二维数组a中从$a[x][y]$到$a[x1][y1]$所有数值的和 1int ans = sum[x1][y1] - sum[x - 1][y1] - sum[x1][y - 1] + sum[x - 1][y - 1]; 【用差分实现区间操作】如果我们想让我们的数据结构支持一个add(l, r, v)的操作，即让一个区间中的所有数都加上一个数或减去一个数，该怎么操作呢，当然可以使用强(xuan)大(xue)的线段树，但是据说在NOIp阶段不会考，实际上这个操作可以利用差分来解决 设A数组为 A=\{2, 3, 1, 4, 5, 2, 6\}C数组为修改数组，表示 $[1..n]$ 这些元素都加上 $c[i]$ 这个数 C=\{ 1, 4, 3, -1, -4\}S数组为C数组的前缀和数组 S=\{1, 5, 8, 7, 3, 3, 3\}对于每一个add(l, r, a)我们对$[L,R]$区间进行加$a$操作，在$C[L]$处加上$a$，在$C[R+1]$处减去$a$ 最后求序列的每个位置变成了多少，只要看一下这个位置上$C$数组的前缀和就可以。 对于二维数组，处理方法也是类似的 对于一个$n \times m$的表格，要求支持操作add(x1,y1,x2,y2,a)，表示对于以$(x1,y1)$为左下角,$(x2,y2)$为右上角的矩形区域，每个元素都加上$a$。问最后的表格的样子 用数组$C$存修改信息。在$C[x1][y1]$处加上$a$，在$C[x2+1][y1]$和$C[x1][y2+1]$处减$a$，在$C[x2+1][y2+1]$再加上$a$。最后$(i,k)$位置上的数值就是$C$数组在$(i,k)$位置的前缀和。 最后贴段代码好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;const int MAXN = 100;int a[MAXN][MAXN];int sum[MAXN][MAXN];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; sum[1][1] = a[1][1]; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j]; &#125; &#125; printf("----------------\n"); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; printf("%d ", sum[i][j]); &#125; printf("\n"); &#125; printf("---------------\n"); int x, y; scanf("%d%d", &amp;x, &amp;y); int x1, y1; scanf("%d%d", &amp;x1, &amp;y1); printf("----------------\n"); int ans = sum[x1][y1] - sum[x - 1][y1] - sum[x1][y - 1] + sum[x - 1][y - 1]; printf("%d\n", ans); return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2015跳石头 - 二分答案]]></title>
    <url>%2F2016%2F08%2F17%2Fstone%2F</url>
    <content type="text"><![CDATA[在很多求最大值最小或者求最小值最大的问题中，不是那么容易地可以直接构造解，但判断一个解是否合法却很容易，这个时候通常考虑二分答案。 所谓二分答案就是在答案可能的区间里“猜”一个答案，然后验证这个答案是否合法，在每次取中点的情况下，复杂度是$O(log_2n)$，是完全可以接受的。 比如 NOIp2015 DAY2 T1 跳石头 就是一道很好的利用了二分答案的题目 传送门:NOIp2015 D2 T1 跳石头 题目【题目描述】一年一度的“跳石头”比赛又要开始了！ 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $ N $ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 【输入描述】输入文件第一行包含三个整数 $ L,N,M $，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。 接下来 $ N $ 行，每行一个整数，第 $ i $ 行的整数 $ D_i $（$ 0 &lt; D_i &lt; L $）表示第 $ i $ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同 一个位置。 【输出描述】输出文件只包含一个整数，即最短跳跃距离的最大值 【输入样例】 25 5 2211141721 【输出样例】 4 【数据范围及提示】对于 $ 20\% $ 的数据，$ 0 \leq M \leq N \leq 10 $。对于 $ 50\% $ 的数据，$ 0 \leq M \leq N \leq 100 $。对于 $ 100\% $ 的数据，$ 0 \leq M \leq N \leq 50,000 $，$ 1 \leq L \leq 1,000,000,000 $。 题解看到最大值最小或者最小值最大之类的问题，很容易想到是二分答案。 具体说明:假设我们已经知道答案是k，也就是满足最小的距离最大为$k$，那么最终搬走石头以后任意两个石头之间的距离都是大于等于$k$的,那么我们只要检验是否能搬走$m$块石头使得满足$k$就可以了。 首先，题目告诉我们，起点石头也就是$0$是固定的，然后如果我们搬走一个石头$i$的话，如果左边的石头已经满足答案$k$，那么移除$i$对答案是没有影响的，因为到左边石头的距离只会变大，不可能小于$k$。 对于当前的石头$i$，下一块石头为$j$，$pre[i]$为$i$上一块石头，$sub[j]$为$j$下一块石头 有两种可能：1.$i$到$j$的距离小于等于$k$,也就是不满足答案，那么我们要做的是，移除$j$。 因为$i$到$pre[i]$是大于等于$k$的，那么$j$到$pre[i]$一定也大于等于$k$，但是$i$都不一定满足$i$到$sub[j]$的距离大于等于$k$，更不谈离$sub[j]$更近的$j$了，所以为了之后的石头考虑，我们需要移除$j$。 2.$i$到$j$的距离大于$k$，也就是$i$,$j$之间已经符合条件了，那么就可以什么都不动了。 因为$i$到$j$的距离已经大于$k$了，所以对于$j$之后每一块石头，都是满足条件的，所以$i$对检验答案并没有什么影响了，那$j$如何考虑呢？$j$之后就会成了下一个$i$，再如上文分两种情况处理了。 所以具体就是二分答案$k$，然后$O(n)$检验，总复杂度$O(nlogL)$。 最后还有一个小问题，二分的区间怎么确定？因为对数的增长是非常慢的，所以区间稍微取大一点也没有关系，对于这题来说直接取$L$就可以了，这样还顺便解决了$n=0$的问题 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;const int MAXN = 50005;int n, a[MAXN], L, M, stk[MAXN], tp;inline bool check(int mid) &#123; int ans = 0; tp = 0; stk[++tp] = 0; for(int i = 1; i &lt;= n; i ++) &#123; if(a[i] - a[stk[tp]] &gt;= mid) &#123; stk[++tp] = i; &#125; else &#123; ++ans; &#125; &#125; while(L - a[stk[tp]] &lt; mid) &#123; --tp; ++ans; &#125; return (ans &lt;= M);&#125;int main() &#123; scanf("%d%d%d", &amp;L, &amp;n, &amp;M); for(int i = 1; i &lt;= n; i ++) &#123; scanf("%d", &amp;a[i]); &#125; int l = 0, r = L, mid, ans = 0; while(l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if(check(mid)) &#123; ans = mid; l = mid+1; &#125; else &#123; r = mid-1; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用倍增算法加速区间操作]]></title>
    <url>%2F2016%2F08%2F13%2F%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[【倍增算法求RMQ】RMQ(Range Minimum/Maximum Quary)，顾名思义，即为区间最值查询，主要用来解决对于长度为$n$的数列$A$,求解其中$i,j$之间的最大/最小值的问题 在这之前先考虑这个问题的暴力解法 1.每次暴力膜扫描数组，复杂度$O(n)$.2.开一个二维数组，对于每一个区间的数预处理进数组中，这基于这样一个原理，对于一个数组，其中前$m$个数中的最大/最小值等于前$m-1$个数的最大/最小值和第$m$个数相比产生的最大/最小值，复杂度$O(n^2)$预处理，$O(1)$查询. 这么low的算法怎么能满足我们呢(大雾),我们需要更加强悍的算法. ST表（Sparse Table）以求最大值为例，设$A$数组存储我们待求最大值的序列，$f[i][j]$表示从第$i$个数字开始，往后第$2^j$个数字中的最大值是多少. 为什么要是往后$2^j$个数呢，在学习多重背包时，提到过二进制拆分，比如对于$7(111_2)$,可以拆分成$1(001_2)$、$2(010_2)$、$4(100_2)$这三个数，通过这三个数就可以表示出1到7之间的所有整数，而这三个数正好就是$2^0$,$2^1$,$2^2$,所以，按照这个方法，我们从小到大枚举$j$,每次处理$f[i][j]$的时候，都可以保证$f[i][0..j-1]$都是已经处理好的. 注意$2^j \leq n$，因此$f$数组的元素不超过$nlog_2n$,并且每一项都可以在常数时间内解决，总复杂度为$O(nlog_2n)$. 【预处理代码】 1234567891011inline void RMQ_init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; f[i][0] = a[i]; &#125; for(int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for(int i = 0; i &lt;= i + (i &lt;&lt; j) - 1 &lt; n; i++) &#123; f[i][j] = std::max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125; 这样，我们就预处理好了$f$数组， 但是该怎样进行查询呢，我们的$f$数组保存的是区间中的最大/最小值，假如说要查询的区间为$(i,j)$,则设$k = \lfloor log_2(i + j - 1) \rfloor$，要查询的结果为$max(f[i][k], f[j - 2 ^ k + 1][k])$ 为什么$k$是这样一个奇怪的取值？对于区间$(i, j)$，它的长度不一定正好是$2$的整数倍，这样可以得到两个最长的 比总区间短的 覆盖查询区间的 区间 两个区间中的最大值中的较大值一定是总区间的最大值 【查询代码】12345int RMQ(int l, int r) &#123; int k = 0; while((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return std::max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125; 这样我们就可以快速完成区间最值查询（RMQ）的任务了 但是，这个算法存在一定的局限性，对于区间和之类的信息无法进行维护，这就需要用到一种玄学神奇的数据结构——线段树，（单纯对于区间和可以考虑使用前缀和）然而据说NOIp是不会考线段树的，然后就没有然后了 【倍增查找LCA】还没有开始写(xue)OVO 2016.10.17 20:29 写完啦！ 传送门[Codevs 2370] 小机房的树 - 最近公共祖先 + 倍增]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>倍增</tag>
        <tag>区间操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Codevs 1120] 采药 - 背包DP]]></title>
    <url>%2F2016%2F08%2F10%2F01%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[codevs 1102 采药 题目描述：辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”如果你是辰辰，你能完成这个任务吗 题目链接：codevs 1102 采药 题解最基本的01背包问题，，设$w[i]$表示第$i$件物品的体积，$c[i]$表示第$i$件物品的价值，状态转移方程为 f(i,v) = max(f(i-1, v),f(i-1,v-w[i])+c[i])其中用$f(i,v)$表示在前$i$件物品中选择占用体积为$v$所能获得的最大价值 代码 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAXV 1100#define MAXN 110int c[MAXN];int w[MAXV];int f[MAXN][MAXV]; int main () &#123; int m,n,i,v; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;w[i], &amp;c[i]); &#125; for(int i=1; i&lt;=n; i++) &#123; for(int v = m; v &gt; 0; v--) &#123; if(w[i] &lt;= v) &#123; f[i][v] = std::max(f[i - 1][v],f[i - 1][v - w[i]] + c[i]); &#125; else &#123; f[i][v] = f[i - 1][v]; &#125; &#125; &#125; printf("%d",f[n][m]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线处理的逆序并查集]]></title>
    <url>%2F2016%2F08%2F09%2F%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86%E7%9A%84%E9%80%86%E5%BA%8F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[传送门：七夕的分组 七夕的分组【题目描述】七夕到了，FFF 团开始活动了。 FFF 团是一个有组织的团体——所有团员按照团长的指挥分为若干个组。今年七夕，由于新加入FFF团的人越来越多，FFF 团需要重新分组。 FFF 团的分组方式为：开始时，所有团员为一个分组，在一个图上，他们由一些Edge相连；之后，团长会每次去掉一条 Edge。在图上同一个联通块内的人为同一组。 Jrisme 很害怕FFF团，因此他偷听了FFF团分组的全过程，他希望能在途中询问你，当前时刻下： $ u_i $ 和 $ v_i $ 两名团员是否在同一组中； 当前有多少个组。 【输入描述】第一行两个整数 $ n $、$ m $，表示 FFF 团有 $ n $ 名团员，通过 $ m $ 条 Edge 相连；之后的 $ m $ 行，每行两个整数 $ u_i $、$ v_i $ 表示有一条从 $ u_i $ 到 $ v_i $ 的无向边。之后一行一个整数 ，表示有 $ q $ 次操作；之后的 $ q $ 行，每行表示一次操作，为以下几种格式之一： F i 表示 FFF 团团长命令去掉第 $ i $ 条边（边的编号按照读入顺序，从 $ i $ 开始）； FF u v 表示 Jrisme 询问第 $ u $ 和第 $ v $ 号团员是否在同一组中； FFF 表示 Jrisme 询问当前有多少个组； 【输出描述】为了表示你对 FFF 团的虔诚，你需要在输出文件的第一行输出「FFF!」。之后的若干行，对于每个第二种操作，如果第 $ u $ 和第 $ v $ 号团员在同一组中，输出true，否则输出false；对于每个第三种操作，输出一个整数，表示当前有多少个组；每个输出占一行。 【输入样例】 4 31 22 33 44F 1FF 2 3F 3FFF 【输出样例】 FFF!true3 【数据范围及提示】对于 $ 10\% $ 的数据，$ q = 0 $；对于 $ 30\% $ 的数据，$ n, m, q \leq 10 $；对于另外 $ 20\% $ 的数据，所有第一种操作均在第二、三种操作前；对于另外 $ 20\% $ 的数据，没有第二种操作；对于另外 $ 20\% $ 的数据，没有第三种操作；对于 $ 100\% $ 的数据，$ 1 \leq n \leq 50000, 0 \leq m \leq 200000, 1 \leq q \leq 100000, 1 \leq u_i, v_i \leq n $；保证没有重边和自环。 由于某些原因，本题只有六组数据。 题解这题一看就是并查集嘛初看此题有种并查集的感觉，但又有些不同，并查集可以方便支持的是“并”与“查”两种操作，但是题目中要求的是“去掉某一条边”，我们并没有“拆查集”，所以需要一些特殊的技巧来实现这些操作。就是传说中的离线处理的逆序并查集。所谓离线处理，就是先把每一条命令存下来，全部读完之后再处理。然后拆边操作，则可以看做倒序的加边操作，所以就可以从末状态开始利用并查集来加边，最后倒过来输出各种询问的结果 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;const int MAXN = 50000;const int MAXM = 200000;const int MAXQ = 100000;struct UnionFindSet &#123; int a[MAXN]; void init(const int n) &#123; for (int i = 0; i &lt; n; i++) a[i] = i; &#125; int find(const int x) &#123; return x == a[x] ? x : a[x] = find(a[x]); &#125; void merge(const int x, const int y) &#123; a[find(x)] = find(y); &#125; bool test(const int x, const int y) &#123; return find(x) == find(y); &#125;&#125; ufs;struct Edge &#123; int u, v; bool del;&#125; E[MAXM];struct Query &#123; int type, u, v, i, ans;&#125; Q[MAXQ];int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;E[i].u, &amp;E[i].v), E[i].u--, E[i].v--; &#125; int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; char s[10]; scanf("%s", s); if (s[1] == '\0') &#123; Q[i].type = 0; scanf("%d", &amp;Q[i].i), Q[i].i--; E[Q[i].i].del = true; &#125; else if (s[2] == '\0') &#123; Q[i].type = 1; scanf("%d %d", &amp;Q[i].u, &amp;Q[i].v), Q[i].u--, Q[i].v--; &#125; else &#123; Q[i].type = 2; &#125; // printf(" %d\n", Q[i].type); &#125; int cnt = n; ufs.init(n); for (int i = 0; i &lt; m; i++) &#123; if (!E[i].del &amp;&amp; !ufs.test(E[i].u, E[i].v)) &#123; ufs.merge(E[i].u, E[i].v); cnt--; &#125; &#125; for (int i = q - 1; i &gt;= 0; i--) &#123; if (Q[i].type == 0 &amp;&amp; !ufs.test(E[Q[i].i].u, E[Q[i].i].v)) &#123; ufs.merge(E[Q[i].i].u, E[Q[i].i].v); cnt--; &#125; else if (Q[i].type == 1) Q[i].ans = ufs.test(Q[i].u, Q[i].v); else Q[i].ans = cnt; &#125; puts("FFF!"); for (int i = 0; i &lt; q; i++) &#123; if (Q[i].type == 1) puts(Q[i].ans ? "true" : "false"); else if (Q[i].type == 2) printf("%d\n", Q[i].ans); &#125; return 0;&#125; 这是Menci的标程，自己写的版本以后再放出来吧……]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路学习笔记]]></title>
    <url>%2F2016%2F08%2F05%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最近做了好多需要用到最短路的题，但是其实我是不会写最短路的[滑稽]，所以现在要学一下[严肃] 相关题目【模板题】Codevs1077 多源最短路 Codevs1557 热浪 Codevs1021 玛丽卡 数据结构【邻接矩阵】对于一张图，最简单的存储方式就是邻接矩阵，它用一个二维数组实现，$graph[u][v] = w$ 表示从$u$到$v$有一条边权为$w$的有向边 【邻接表】对于一张图，可以使用邻接矩阵来存储，但是如果节点数特别多，邻接矩阵的效率会异常低下，要找到一条边需要遍历整个数组，所以我们需要更强(N)大(B)的存储方式邻接表。 邻接表使用链表实现，有一个Node结构体存储点的相关信息，其中必不可少的是一个Node所连接的最后一条出边；有一个Edge结构体存储边的相关信息，比如起点，终点，边权等，其中必不可少的是一个Edge的下一条边。 这样就实现了基于指针的邻接表，优点是灵活，需要什么直接在结构体里加就好了。 123456789101112131415161718192021struct Node;struct Edge;//可以在结构体里添加其他东西struct Node&#123; Edge *edges; Node() : edges(NULL)&#123;&#125;&#125;;struct Edge&#123; Node *fr; Node *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : to(to), w(w), next(fr-&gt;edges) &#123;&#125;&#125;;inline void addEdge(Node *u, Node *v, int w)&#123; u-&gt;edges = new Edge(u, v, w);&#125; 算法【Floyd】floyd是最简单的最短路算法，能够计算出图中任意两点间的最短路，这其实是一个DP算法，核心代码只有四行，缺点是复杂度达到了$O(n^3)$，这在很大程度上是不能接受的，(热浪交上去会T3个点)，如果数据范围小可以选择. 传送门:根据数据范围估算时间复杂度 1234567for(int k = 1; k &lt;= n; k++) &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125;&#125; 其中$k$枚举的是$i$到$j$的中间点,一定要写在最外面. 【Dijkstra_heap】dijkstra是一个单源最短路算法，可以用$O(MlogN)$的时间求出从起点到其他每个点的最短路,(把dijkstra交上去就可以过了),但是因为dijkstra是基于贪心的，所以不能处理负边权的情况,常使用堆(优先队列)来优化 在Dijkstra中边权要么全正，要么全负，有正有负考虑SPFA 123456789101112131415161718inline void dijkstra(Node *S) &#123; std::priority_queue&lt;Node*, std::vector&lt;Node*&gt;, Node::Comp&gt; Q; //优先队列需要队列中的元素支持比较操作，虽然指针支持比较，但显然比较的不是我们想比较的东西所以需要传入一个自定义的比较器 S-&gt;d = 0, Q.push(S); while(!Q.empty()) &#123; Node *v = Q.top(); Q.pop(); if(v-&gt;done) continue; else v-&gt;done = true;//done是一个访问标记，说明这个点的最短路已经确定 for(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if(e-&gt;to-&gt;d &gt; v-&gt;d + e-&gt;w) &#123; e-&gt;to-&gt;d = v-&gt;d + e-&gt;w;//d为从起点到当前点的最短路径的估计值，进行一轮“松弛操作” Q.push(e-&gt;to); &#125; &#125; &#125;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//一号点的最短路，热浪直接交上去会WA#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAXV = 5000; //节点数const int INF = 0x7fffffff; //每个点的初始最短路径估计为正无穷struct Node;struct Edge;struct Node &#123; Edge *edges; //最后一条出边 int dis;//最短路径估计 bool visited;//访问标记 struct comp &#123; bool operator()(const Node *a, const Node *b) &#123; return a-&gt;dis &gt; b-&gt;dis; &#125;//比较器 &#125;; Node() : edges(NULL), dis(INF), visited(false) &#123;&#125;&#125;nodes[MAXV];struct Edge &#123; Node *fr;//起点 Node *to;//终点 int w;//边权 Edge *next;//下一条边 Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(u,v,w);//无向图，边要正着加一次反着加一次 v-&gt;edges = new Edge(v,u,w); return;&#125;inline void dijkstra(Node *x) &#123; std::priority_queue&lt;Node*,std::vector&lt;Node*&gt;,Node::comp&gt; pq; x-&gt;dis = 0; pq.push(x); while(!pq.empty()) &#123; Node *v = pq.top(); pq.pop(); //v-&gt;visited == true ? continue; : v-&gt;visited = true; if(v-&gt;visited == true) &#123; continue; &#125;else &#123; v-&gt;visited = true; &#125; for(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; //e-&gt;to-&gt;dis = std::max(e-&gt;to-&gt;dis, v-&gt;dis + e-&gt;w); if(e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123; e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w; pq.push(e-&gt;to); &#125; //pq.push(e-&gt;to); &#125; &#125;&#125;int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m);//n is the number of nodes,m is the number of edges for(int i = 1; i &lt;= m; i++) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addEdge(nodes + u,nodes + v,w); &#125; printf("\n"); dijkstra(nodes + 1); for(int i = 1; i &lt;= n; i++) &#123; printf("%d\n",nodes[i].dis); &#125; return 0;&#125; 【SPFA】SPFA用两重循环，一重枚举每一个点，一重枚举每一条边，进行$n - 1$轮松弛后得到单源最短路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//热浪代码，直接交上去是可以过的#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int MAXN = 5000 + 10;const int INF = 0x7fffffff;struct Node;struct Edge;struct Node &#123; Edge *edges; int dis; bool inQueue; Node() : edges(NULL), dis(INF), inQueue(false) &#123;&#125;&#125;nodes[MAXN];struct Edge &#123; Node *fr; Node *to; int w; Edge *next; Edge(Node *fr, Node *to, int w) : fr(fr), to(to), w(w) &#123; next = fr-&gt;edges; &#125;&#125;;inline void addEdge(Node *u, Node *v, int w) &#123; u-&gt;edges = new Edge(u,v,w); v-&gt;edges = new Edge(v,u,w); return;&#125;inline void SPFA(Node *x) &#123; std::queue&lt;Node*&gt;q; x-&gt;dis = 0; x-&gt;inQueue = true; q.push(x); while(!q.empty()) &#123; Node *v = q.front(); q.pop(); v-&gt;inQueue = false; for(Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123; if(e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123; e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w; if(!e-&gt;to-&gt;inQueue) &#123; q.push(e-&gt;to); e-&gt;to-&gt;inQueue = true; &#125; &#125; &#125; &#125;&#125;int main() &#123; int n,m; int x,y; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;x,&amp;y); for(int i = 1; i &lt;= m; i++) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addEdge(nodes + u,nodes + v,w); &#125; SPFA(nodes + x); printf("%d",nodes[y].dis); return 0;&#125; 总结和吐槽【总结】Floyd 空间复杂度$O(N^2)$ 时间复杂度$O(N^3)$ 支持负边权 时间复杂度高但是编码难度低(然而并没有什么用) 是不是可以拿来跑暴力 Dijkstra 空间复杂度$O(M)$ 时间复杂度$O(MlogN)$ 不支持负边权 堆优化之后时间复杂度优秀，结合邻接表之后空间复杂度优秀，但是不支持负边权(不过问题不大,没有负权时首选Dijkstra) SPFA 空间复杂度$O(M)$ 时间复杂度$O(NM)$ 支持负权 存在负权时好像只剩下这个选择了…… 据说时间复杂度得不到保证…… 据说NOIp是绝对不会卡SPFA的，但是真要是卡了那也没办法…… 据说改成双端队列会更快，不过我也不知道为什么…… 【吐槽】1.指针好难写，总是爆出莫名其妙的错误，不过理解之后看起来也挺舒服的 2.本来总结想打个表 @各单位提供丰富 但是Markdown的表格好难写……是真的难写。所以最后放弃了 3.终于写完了 4.完结撒花]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据数据范围估算时间复杂度]]></title>
    <url>%2F2016%2F08%2F05%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在算法竞赛中，算法的优劣直接决定了最终的得分，但在想不出正解的情况下，一个不那么优秀的算法也是可以得到部分分数的，在一道算法竞赛的题目中通常都会给出几个层次的数据范围，而我们就可以根据数据范围来合理设计算法的时间复杂度 $N \leq 20$ ============ $O(2^N)$ $20 &lt; N \leq 100$ ===== $O(N^3)$ $100 &lt; N \leq 1000$ === $O(N^2)$ $10000 &lt; N \leq 10^5$ ==$O(nlogn)$ $10^5 &lt; N \leq 10^8$======$O(n)$ $N &gt; 10^8$=============$O(logn)$]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法的典型应用 - 区间类问题]]></title>
    <url>%2F2016%2F08%2F05%2F%E8%B4%AA%E5%BF%83and%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[区间选择问题codevs 1214 线段覆盖 &amp;&amp; codevs 1643 线段覆盖3 题目描述给定$x$轴上的$n$ $(0&lt;n&lt;100)$ 条线段，每个线段由它的二个端点$a_i$和$b_i$确定，$i = 1,2, \dots n$.这些坐标都是区间$(-999，999)$的整数。有些线段之间会相互交叠或覆盖。请你编写一个程序，从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点。所谓的内部公共点是指一个点同时属于两条线段且至少在其中一条线段的内部（即除去端点的部分）。 输入描述输入第一行是一个整数$n$。接下来有$n$行，每行有二个空格隔开的整数，表示一条线段的二个端点的坐标。 输出描述输出第一行是一个整数表示最多剩下的线段数。 题目连接codevs 1214 线段覆盖codevs 1643 线段覆盖3 显然我们要做的就是找出尽量多的两两不相交的区间。 考虑先按照右端点排序，然后从左往右取不相交的区间。能选就选，不能选就跳过废话 简要证明正确性，假如我们能选该区间 $x$ 而不选，而选择的后面的某个区间 $y$，那么考虑 $x$ 和 $y$ 的关系，如果它们没有交集，那么多选一个 $x$ 更合算；假如有交集，那么将 $y$ 换成 $x$ 后，结果不会更劣，这是因为后面所有与 $x$ 冲突的区间必然与 $y$ 冲突，故该贪心策略可以得到最优解。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 1e6 + 10;struct Area&#123; int l, r; bool done; struct cmp &#123; bool operator() (const Area &amp;a, const Area &amp;b) &#123; return a.r &lt; b.r; &#125; &#125;; Area() : l(0), r(0), done(false) &#123;&#125;&#125;area[MAXN];int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;area[i].l, &amp;area[i].r); if (area[i].l &gt; area[i].r) &#123; std::swap(area[i].l, area[i].r); &#125; &#125; std::sort(area + 1, area + n + 1, Area::cmp()); int sum = 1; int now = 1; for (int i = 2; i &lt;= n; i++) &#123; if (area[i].l &gt;= area[now].r) &#123; sum++; now = i; &#125; &#125; printf("%d\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
        <tag>区间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 快捷键总结]]></title>
    <url>%2F2016%2F08%2F05%2Fsublime%20text%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[以下是个人总结不完全的快捷键总汇，祝愿各位顺利解放自己的鼠标。 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift + ↓ 效果一样。 Ctrl + Shift + L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl + Shift + M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl + M 光标移动至括号内结束或开始的位置。 Ctrl + Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl + Shift + Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl + Shift + [ 选中代码，按下快捷键，折叠代码。 Ctrl + Shift + ] 选中代码，按下快捷键，展开代码。 Ctrl + K + 0 展开所有折叠代码。 Ctrl + ← 向左单位性地移动光标，快速移动光标。 Ctrl + → 向右单位性地移动光标，快速移动光标。 shift + ↑ 向上选中多行。 shift + ↓ 向下选中多行。 hift + ← 向左选中文本。 Shift + → 向右选中文本。 Ctrl + Shift + ← 向左单位性地选中文本。 Ctrl + Shift + → 向右单位性地选中文本。 Ctrl + Shift + ↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl + Shift + ↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl + Alt + ↑ 向上添加多行光标，可同时编辑多行。 Ctrl + Alt + ↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl + J 合并选中的多行代码为一行。举个栗子：将多行格式的$CSS$属性合并为一行。 Ctrl + Shift + D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift + Tab 向左缩进。 Ctrl + K + K 从光标处开始删除代码至行尾。 Ctrl + Shift + K 删除整行。 Ctrl + / 注释单行。 Ctrl + Shift + / 注释多行。 Ctrl + K + U 转换大写。 Ctrl + K + L 转换小写。 Ctrl + Z 撤销。 Ctrl + Y 恢复撤销。 Ctrl + U 软撤销，可以撤销一些操作。 Ctrl + F2 设置书签 Ctrl + T 左右字母互换。 F6 单词检测拼写 搜索类Ctrl + F 打开底部搜索框，查找关键字。 Ctrl + shift + F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl + P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl + G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl + R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl + ： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl + Shift + P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl + Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl + PageDown 向左切换当前窗口的标签页。 Ctrl + PageUp 向右切换当前窗口的标签页。 Alt + Shift + 1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt + Shift + 2 左右分屏-2列 Alt + Shift + 3 左右分屏3列 Alt + Shift + 4 左右分屏4列 Alt + Shift + 5 等分4屏 Alt + Shift + 8 垂直分屏-2屏 Alt + Shift + 9 垂直分屏-3屏 Ctrl + K + B 开启/关闭侧边栏。 F11 全屏模式 Shift + F11 免打扰模式 感谢资源搬运自豆瓣网址：https://www.douban.com/note/362268947/传送门：Sublime Text 3 快捷键总结（拿走）]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>整理</tag>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法的典型应用 - 归并排序 && 求逆序对]]></title>
    <url>%2F2016%2F08%2F05%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序虽然STL中的&lt;algorithm&gt;为我们提供了方便的排序函数，但是我们还是闲的想自己手动实现一个排序，并用它顺便算一算逆序对。 归并排序的大致思路就是把一个无序表分成两个无序表，再把两个无序表用某种特殊的方法变成两个有序表，再用另一种特殊的方法把两个有序表合并成一个有序表。 归并排序的时间复杂度为$O(nlogn)$,是速度仅次于快速排序的稳定排序方式，但是需要$O(n)$的辅助空间。 那么这两种特殊的方法是如何实现的呢？在第一个特殊方法中要求我们对数组的一半分别进行排序，所以想对整个数组排序需要先对数组的一半排序，那么想对数组的一半排序需要对数组一半的一半排序……这显然用递归就可以简单的实现，所以我们现在主要的问题就只剩下如何把两个有序表合并成一个有序表。 逐元素比较：把较小的元素加到辅助数组中(所以会有蜜汁$O(n)$的空间) 123456789101112 int i=left,j=mid+1,k=left; //k的初值要设成leftwhile((i &lt;= mid) &amp;&amp; (j &lt;= right))&#123; if(a[i] &lt;= a[j]) &#123; c[k] = a[i];k++;i++; &#125; else if(a[i] &gt; a[j]) &#123; c[k] = a[j];k++;j++; &#125;&#125; 剩余的部分： 12345678while(i &lt;= mid) &#123; c[k] = a[i];i++;k++; &#125; while(j &lt;= right) &#123; c[k] = a[j];j++;k++; &#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#define MAXN 10000int a[MAXN],c[MAXN];int n;inline void merge_sort(int* a,int left,int right)&#123; if(left == right) &#123; return; &#125; int mid = (left+right)/2; merge_sort(a,left,mid); merge_sort(a,mid+1,right); int i=left,j=mid+1,k=left; //k的初值要设成left while((i &lt;= mid) &amp;&amp; (j &lt;= right)) &#123; if(a[i] &lt;= a[j]) &#123; c[k] = a[i];k++;i++; &#125; else if(a[i] &gt; a[j]) &#123; c[k] = a[j];k++;j++; &#125; &#125; while(i &lt;= mid) &#123; c[k] = a[i];i++;k++; &#125; while(j &lt;= right) &#123; c[k] = a[j];j++;k++; &#125; for(int m=left;m&lt;=right;m++) &#123; a[m] = c[m]; &#125; return;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; merge_sort(a,1,n); for(int i=1;i&lt;=n;i++) &#123; printf("%d ",a[i]); &#125; return 0;&#125; 逆序对之前提到过写归并排序可以顺便求一下逆序对问题 设$ A $为一个有$ n $个数字的有序集 $(n&gt;1)$，其中所有数字各不相同。如果存在正整数 $i, j$ 使得$ 1 ≤ i &lt; j ≤ n $而且 $A[i]&gt;A[j]$，则$$ 这个有序对称为的一个逆序对，也称作逆序数。 当然可以两重循环来做，但是可以在归并排序的过程中顺便解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; using namespace std; const int N = 1005; int a[N],tmp[N]; int ans; void Merge(int l,int m,int r) &#123; int i = l; int j = m + 1; int k = l; while(i &lt;= m &amp;&amp; j &lt;= r) &#123; if(a[i] &gt; a[j]) &#123; tmp[k++] = a[j++]; ans += m - i + 1; &#125; else &#123; tmp[k++] = a[i++]; &#125; &#125; while(i &lt;= m) tmp[k++] = a[i++]; while(j &lt;= r) tmp[k++] = a[j++]; for(int i=l;i&lt;=r;i++) a[i] = tmp[i]; &#125; void Merge_sort(int l,int r) &#123; if(l &lt; r) &#123; int m = (l + r) &gt;&gt; 1; Merge_sort(l,m); Merge_sort(m+1,r); Merge(l,m,r); &#125; &#125; int main() &#123; int n,T,tt=1; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); ans = 0; Merge_sort(0,n-1); printf("Scenario #%d:\n%d\n\n",tt++,ans); &#125; return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法的典型应用 - 二分查找]]></title>
    <url>%2F2016%2F08%2F05%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找STL 中排序(std::sort())与去重(std::unique())的实现为我们的信息检索创造了方便. 对于信息的检索我们不难想到暴力的算法，即用一个数组存储所有数据，遍历这个数组查看是否有需要的数据存在，在数据已经排序好的情况下，查找一个元素的最坏时间复杂度为$O(n)$，而如果查找多个元素，我们就会得到一个爆炸的复杂度…… 所以我们需要一个简单而有效的优化，那就是二分查找。二分查找利用分治的思想，先查找中间元素，如果待查找数据大于中间数据，则查找前半部分，反之则查找后半部分，因为每一次都会把查找的范围减半，所以二分查找的期望时间复杂度为$O(logn)$.加上排序的预处理($O(nlogn)$),总复杂度为$O(logn+nlogn)$. 二分查找可以递归，但是一般写成非递归的。 &lt;例题&gt; codevs 1230 元素查找 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAXN 100010int a[MAXN];inline bool find(int *a,int left,int right,int x)&#123; int mid; while(left &lt; right) &#123; mid=left+(right-left)/2; if(a[mid] == x) &#123; return true; &#125; else if(a[mid] &gt; x) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return false;&#125;int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; std::sort(a+1,a+n+1); int x,ans; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;x); if( find(a,1,n+1,x) ) &#123; printf("YES\n"); &#125; else &#123; printf("NO\n"); &#125; &#125; return 0;&#125; 最后注意一点，用二分查找之前一定要记得排序！用二分查找之前一定要记得排序！用二分查找之前一定要记得排序！ 当然如果你要用STL里的lower_pound()也可以。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
</search>
