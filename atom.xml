<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iLern&#39;s Blog</title>
  
  <subtitle>Do what you love, love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ilern.github.io/"/>
  <updated>2021-04-11T15:39:08.830Z</updated>
  <id>http://ilern.github.io/</id>
  
  <author>
    <name>iLern</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常数项级数</title>
    <link href="http://ilern.github.io/2021/04/11/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0/"/>
    <id>http://ilern.github.io/2021/04/11/常数项级数/</id>
    <published>2021-04-11T02:00:53.000Z</published>
    <updated>2021-04-11T15:39:08.830Z</updated>
    
    <content type="html"><![CDATA[<p>常数项级数的研究核心在于其敛散性判定，若收敛，其值为多少。</p><p>首先给出定义和五条性质，对于所有级数都适用，但是不够方便，于是分类研究，正项级数四种方法，交错级数一种方法，任意项级数一种方法（绝对收敛一定收敛）。</p><p>拿到一个级数首先判断类型，对于不同类型的级数采用不同的方法。</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>无穷级数</p><script type="math/tex; mode=display">\sum_{n=1}^\infty u_n</script><p>的实质是部分和$s_n$的极限</p><script type="math/tex; mode=display">\lim_{n \to \infty} s_n</script><p>因此可以用定义来判定常数项级数的敛散性，即求数列极限。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>判定</p><script type="math/tex; mode=display">\sum_{n=1}^\infty \ln(1 + \frac{1}{n})</script><p>的敛散性，取部分和：</p><script type="math/tex; mode=display">\begin{align}s_n &= \sum_{i=1}^n \ln(\frac{i+1}{i}) \\&= \ln[(\frac{2}{1})(\frac{3}{2}) \cdots (\frac{n}{n-1})(\frac{n+1}{n})] \\&= \ln(n+1)\end{align}</script><p>对部分和取极限：</p><script type="math/tex; mode=display">\lim_{n\to\infty}s_n = \lim_{n \to \infty} \ln(n+1) = \infty</script><p>显然是发散的</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul><li>一个收敛级数的每一项都乘一个常数$k$，则新级数的值为原来的$k$倍</li><li>两个数列<ul><li>都收，和差收</li><li>都发，和差不一定</li><li>一收一发，和差发<ul><li>相当于一个极限存在加一个极限不存在，最终结果极限不存在</li></ul></li></ul></li><li>级数的敛散性与其前面有限项无关，与其后面无穷多项有关<ul><li>去掉任意有限项不影响级数的敛散性</li></ul></li><li>收敛级数中任意加括号，结果仍然收敛，值不变<ul><li>加括号相当于在原来的级数中去掉了有限项，由上一条可知去掉有限项对级数的敛散性和值不会产生任何影响</li></ul></li><li>若级数收敛，则通项趋于零<ul><li>如果不趋于零，往后就会越加越多，肯定不会收敛</li><li>级数收敛的<strong>必要条件</strong></li><li>反之不成立<ul><li>调和级数$\sum_{n=1}^\infty \frac{1}{n}$</li><li>通项趋于零，但是发散</li></ul></li></ul></li></ul><h1 id="审敛法"><a href="#审敛法" class="headerlink" title="审敛法"></a>审敛法</h1><h2 id="正项级数"><a href="#正项级数" class="headerlink" title="正项级数"></a>正项级数</h2><h3 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h3><p>$\sum_{n=1}^\infty u_n$ 收敛，则$s_n$上有界</p><p>因为级数本质是部分和的极限，正向级数部分和一定单增，单增数列极限存在则必有上界</p><h3 id="比较审敛法"><a href="#比较审敛法" class="headerlink" title="比较审敛法"></a>比较审敛法</h3><h4 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h4><ul><li><p>大收小收</p></li><li><p>小发大发</p></li></ul><p>通常需要进行适当的放缩</p><h4 id="极限形式"><a href="#极限形式" class="headerlink" title="极限形式"></a>极限形式</h4><script type="math/tex; mode=display">\lim_{n\to \infty} \frac{u_n}{v_n} = l</script><ul><li>$l$ 为非零常数，两个级数“同阶”，同敛散</li><li>$l = 0$，下面的更大，一般方法</li><li>$l = \infty$，上面的更大，一般方法</li></ul><p>通常需要将已知敛散性的级数作为一个参照标准，最常用的：</p><script type="math/tex; mode=display">\sum_{n=1}^\infty \frac{1}{n^p}, p > 1 \text{收敛}，p \leq 1 \text{发散}</script><script type="math/tex; mode=display">\sum_{n=1}^\infty aq^n, q < 1 \text{收敛}，q \geq 1 \text{发散}</script><h3 id="比值法-根值法"><a href="#比值法-根值法" class="headerlink" title="比值法 / 根值法"></a>比值法 / 根值法</h3><p>不需要依赖别的已知级数</p><script type="math/tex; mode=display">\lim_{n\to\infty} \frac{u_{n+1}}{u_n} = \rho</script><script type="math/tex; mode=display">\lim_{n\to\infty} \sqrt[n]{u_n} = \rho</script><p>大于一发散，小于一收敛，等于一不确定</p><p>带有$n!$ 用比值</p><p>带有$a^n, n^n$ 用根值</p><h3 id="方法的选择"><a href="#方法的选择" class="headerlink" title="方法的选择"></a>方法的选择</h3><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">1， 2</td><td style="text-align:center">适用范围广</td><td style="text-align:center">需要找别的级数还要找的恰当，不方便</td><td style="text-align:center">$n^p$ $\ln n$</td></tr><tr><td style="text-align:center">3， 4</td><td style="text-align:center">方便，不需要依赖其他级数</td><td style="text-align:center">适用范围狭窄，有些简单的级数无法判断</td><td style="text-align:center">$a^n$ $n^n$ $n!$</td></tr></tbody></table></div><p>拿到题目先考虑34，不能再考虑12</p><h2 id="交错级数"><a href="#交错级数" class="headerlink" title="交错级数"></a>交错级数</h2><script type="math/tex; mode=display">\sum_{n=1}^\infty (-1)^{n-1} u_n</script><p>只有一种方法，莱布尼茨准则</p><p>两个条件：</p><ul><li>通项单调减</li><li>通项趋于零</li></ul><p>都满足则收敛，是收敛的<strong>充分条件</strong></p><p>若已知交错级数收敛，可推出通项极限为零，不一定能推出通项单调减</p><h2 id="任意项级数"><a href="#任意项级数" class="headerlink" title="任意项级数"></a>任意项级数</h2><p>任意项级数的正数项和负数项都应当有无穷多项，若其中某一类有有限项，则去掉有限项不影响级数的敛散性，即可轻松转化为正项级数的判定。</p><p>解决任意项级数的敛散性，考虑转化成正项级数，对原级数的每一项取绝对值。原级数和取绝对值之后的正项级数之间有没有什么联系呢？</p><p>有以下结论：</p><ul><li>取绝对值后的正项级数若收敛，原级数一定收敛（绝对收敛）</li><li><p>原级数收敛，取绝对值后的正项级数不一定收敛（条件收敛）</p></li><li><p>条件收敛的级数所有正项/负项构成的级数一定发散</p><ul><li>$\sum_{n=1}^\infty u_n$收敛</li><li>$\sum_{n=1}^\infty \frac{u_n + |u_n|}{2}$ 发散，看成两个级数的和，第一个级数是原级数的一半，收敛；第二个级数是绝对值级数，发散；收敛加发散结果发散</li><li>$\sum_{n=1}^\infty \frac{u_n - |u_n|}{2}$同理，发散</li></ul></li></ul><p>拿到一个任意项级数，先取绝对值，看看是不是收，收则原级数一定收，发则不能确定，此时往往回到定义和性质</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ul><li><p>可以使用等价</p><script type="math/tex; mode=display">\begin{align}  \sum_{n=1}^\infty \frac{1}{\sqrt{n}} \ln(1 + \frac{1}{n})   &= \lim_{n \to \infty} \sum_{k = 1}^n \frac{1}{\sqrt{k}} \ln(1+\frac{1}{k})\\  &= \lim_{n \to \infty} \sum_{k=1}^n \frac{1}{\sqrt{k}} \cdot \frac{1}{k} \\  &= \lim_{n \to \infty} \sum_{k=1}^n \frac{1}{k^{3/2}}  \end{align}</script><p>  接下来利用P级数判定</p></li><li><p>拆项，利用两个级数和差的性质</p></li><li><p>题目中给出一个级数的通项乘别人的极限存在，一定写成通项除别人的形式</p><blockquote><p>若存在常数$p&gt;1$，使得 $\lim<em>{n\to \infty} n^p a_n$ 存在，则 $\sum</em>{n=1}^\infty a_n$ 收敛</p></blockquote><p>改写成</p><script type="math/tex; mode=display">\lim_{n\to \infty} \frac{a_n}{\frac{1}{n^p}} = A \geq 0</script><p>$A&gt;0$时，由比较审敛法的极限形式可以得$a_n$和$\frac{1}{n^p}$同敛散</p><p>$A = 0$时，上面小下面大，大的收小的一定收</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常数项级数的研究核心在于其敛散性判定，若收敛，其值为多少。&lt;/p&gt;
&lt;p&gt;首先给出定义和五条性质，对于所有级数都适用，但是不够方便，于是分类研究，正项级数四种方法，交错级数一种方法，任意项级数一种方法（绝对收敛一定收敛）。&lt;/p&gt;
&lt;p&gt;拿到一个级数首先判断类型，对于不同类型的级数采用不同的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ilern.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="无穷级数" scheme="http://ilern.github.io/tags/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 146 LRU缓存机制</title>
    <link href="http://ilern.github.io/2021/03/27/Leetcode-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://ilern.github.io/2021/03/27/Leetcode-146-LRU缓存机制/</id>
    <published>2021-03-27T02:38:12.000Z</published>
    <updated>2021-03-27T03:33:46.517Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个LRU Cache</p><a id="more"></a><h3 id="【思路】"><a href="#【思路】" class="headerlink" title="【思路】"></a>【思路】</h3><p>使用哈希表实现$O(1)$查找，可以用各种语言自带的<code>map</code>存储一个<code>&lt;int, *Node&gt;</code>键值对</p><p>$O(1)$的插入删除使用链表实现，对于一个查询操作，先在哈希表中查找到元素的指针，然后在链表中找到其值，并把该元素移动到链表的头部</p><p>链表的头部表示最近使用，尾部表示最近最久未被使用，正好符合LRU的规则，当Cache满的时候就将链表中最后一个位置删除</p><p>插入操作总是要插入到链表的头部</p><p>为了方便获取到整个链表的头和尾，使用双向链表</p><p>把某个节点从中间移动到头部可以先删掉这个节点然后再在头部插入</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">before, next *Node</span><br><span class="line">value        <span class="keyword">int</span></span><br><span class="line">key          <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNode</span><span class="params">(key, value <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Node&#123;</span><br><span class="line">before: <span class="literal">nil</span>,</span><br><span class="line">next:   <span class="literal">nil</span>,</span><br><span class="line">value:  value,</span><br><span class="line">key:    key,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">cache    <span class="keyword">map</span>[<span class="keyword">int</span>]*Node</span><br><span class="line">capacity <span class="keyword">int</span></span><br><span class="line">size     <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">head *Node</span><br><span class="line">tail *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret = LRUCache&#123;</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Node),</span><br><span class="line">capacity: capacity,</span><br><span class="line">size:     <span class="number">0</span>,</span><br><span class="line">head:     newNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">tail:     newNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret.head.next = ret.tail</span><br><span class="line">ret.tail.before = ret.head</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node, _ := this.cache[key]</span><br><span class="line">this.moveToHead(node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := this.cache[key]; ok &#123;</span><br><span class="line">node.value = value</span><br><span class="line">this.moveToHead(node)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node := newNode(key, value)</span><br><span class="line">this.cache[key] = node</span><br><span class="line"></span><br><span class="line">this.addToHead(node)</span><br><span class="line"></span><br><span class="line">this.size++</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">removed := this.removeTail()</span><br><span class="line"><span class="built_in">delete</span>(this.cache, removed.key)</span><br><span class="line">this.size--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeNode</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">node.before.next = node.next</span><br><span class="line">node.next.before = node.before</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addToHead</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">node.before = this.head</span><br><span class="line">node.next = this.head.next</span><br><span class="line">this.head.next.before = node</span><br><span class="line">this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">moveToHead</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">this.removeNode(node)</span><br><span class="line">this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">removeTail</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">node := this.tail.before</span><br><span class="line">this.removeNode(node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cache := Constructor(<span class="number">2</span>)</span><br><span class="line">cache.Put(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//[&#123;1: 1&#125;]</span></span><br><span class="line">cache.Put(<span class="number">2</span>, <span class="number">2</span>) <span class="comment">//[&#123;1: 1&#125;, &#123;2, 2&#125;]</span></span><br><span class="line"></span><br><span class="line">val1 := cache.Get(<span class="number">1</span>)</span><br><span class="line">fmt.Println(val1)</span><br><span class="line"></span><br><span class="line">cache.Put(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">//[&#123;1: 1&#125;, &#123;3, 3&#125;]</span></span><br><span class="line"></span><br><span class="line">val2 := cache.Get(<span class="number">2</span>)</span><br><span class="line">fmt.Println(val2)</span><br><span class="line"></span><br><span class="line">cache.Put(<span class="number">4</span>, <span class="number">4</span>) <span class="comment">//[&#123;3: 3&#125;, &#123;4, 4&#125;]</span></span><br><span class="line"></span><br><span class="line">val3 := cache.Get(<span class="number">1</span>)</span><br><span class="line">fmt.Println(val3)</span><br><span class="line"></span><br><span class="line">val4 := cache.Get(<span class="number">3</span>)</span><br><span class="line">fmt.Println(val4)</span><br><span class="line"></span><br><span class="line">val5 := cache.Get(<span class="number">4</span>)</span><br><span class="line">fmt.Println(val5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个LRU Cache&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://ilern.github.io/categories/Leetcode/"/>
    
    
      <category term="数据结构" scheme="http://ilern.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>基本积分公式</title>
    <link href="http://ilern.github.io/2021/03/12/%E5%9F%BA%E6%9C%AC%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/"/>
    <id>http://ilern.github.io/2021/03/12/基本积分公式/</id>
    <published>2021-03-12T08:13:03.000Z</published>
    <updated>2021-03-12T11:28:16.258Z</updated>
    
    <content type="html"><![CDATA[<p>积分学的基础，基本积分公式</p><a id="more"></a><h1 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h1><script type="math/tex; mode=display">\int x^\alpha \mathop{}\!\mathrm{d}x = \frac{1}{\alpha + 1} x^{\alpha+1} + C</script><p>非常简单，最容易想到的求导逆运算。注意其中$\alpha \neq -1$</p><p>特别地，</p><script type="math/tex; mode=display">\int x^{-1} \mathop{}\!\mathrm{d}x = \int \frac{1}{x} \mathrm{d}x = \ln |x| + C</script><h1 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h1><script type="math/tex; mode=display">\int a^x \mathop{}\!\mathrm{d}x = \frac{1}{\ln a}a^x + C</script><p>特别地，</p><script type="math/tex; mode=display">\int e^x \mathop{}\!\mathrm{d}x = e^x + C</script><h1 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h1><script type="math/tex; mode=display">\int \ln x \mathop{}\!\mathrm{d}x = x \ln x - \int x \mathop{}\!\mathrm{d} \ln x = x \ln x - \int x \cdot\frac{1}{x} \mathop{}\!\mathrm{d}x = x\ln x - x + C</script><p>用到了分部积分法</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><script type="math/tex; mode=display">\begin{align}\int \sin x \mathop{}\!\mathrm{d}x &= -\cos x + C \\\int \cos x \mathop{}\!\mathrm{d}x &= \sin x + C \\\int \tan x \mathop{}\!\mathrm{d}x &= \int \frac{\sin x}{\cos x} \mathop{}\!\mathrm{d}x = -\int \frac{1}{\cos x} \mathop{}\!\mathrm{d}\cos x = -\ln |\cos x| + C \\\int \cot x \mathop{}\!\mathrm{d}x &= \int \frac{\cos x}{\sin x} \mathop{}\!\mathrm{d}x = \int \frac{1}{\sin x} \mathop{}\!\mathrm{d}x = \ln |\sin x| + C \\\int \sec x\mathop{}\!\mathrm{d}x &= \int \frac{\sec x(\sec x + \tan x)}{\sec x + \tan x}\mathop{}\!\mathrm{d}x = \int \frac{\mathop{}\!\mathrm{d}(\sec x + \tan x)}{\sec x + \tan x} = \ln |\sec x + \tan x| + C \\\int \csc x\mathop{}\!\mathrm{d}x &= \int \frac{\csc x(\csc x + \cot x)}{\csc x + \cot x}\mathop{}\!\mathrm{d}x = \int \frac{\mathop{}\!\mathrm{d}(\csc x + \cot x)}{\csc x + \cot x} = -\ln |\csc x + \cot x| + C \\\end{align}</script><p>前两条非常简单</p><p>中间两条用到了凑微分的方法</p><p>最后两条常人难以想到，很依靠人类智慧</p><h1 id="1-x-2-or-1-x-2"><a href="#1-x-2-or-1-x-2" class="headerlink" title="$1+x^2 \or 1-x^2$"></a>$1+x^2 \or 1-x^2$</h1><h2 id="1-x-2"><a href="#1-x-2" class="headerlink" title="$1 + x^2$"></a>$1 + x^2$</h2><script type="math/tex; mode=display">\int \frac{1}{1 + x^2} \mathop{}\!\mathrm{d}x = \arctan x + C</script><p>推广：</p><script type="math/tex; mode=display">\int \frac{1}{a^2 + x^2} \mathop{}\!\mathrm{d} x = \int \frac{1}{a^2(1 + \frac{x^2}{a^2})}\mathop{}\!\mathrm{d}x = \frac{1}{a^2} \int \frac{1}{1 + (\frac{x}{a})^2}\mathop{}\!\mathrm{d}x = \frac{1}{a^2} \cdot a \cdot \frac{\mathop{}\!\mathrm{d}(\frac{x}{a})}{1 + (\frac{x}{a})^2} = \frac{1}{a} \arctan \frac{x}{a} + C(a > 0)</script><h2 id="1-x-2-1"><a href="#1-x-2-1" class="headerlink" title="$1 - x^2$"></a>$1 - x^2$</h2><script type="math/tex; mode=display">\int \frac{1}{1 - x^2} \mathop{}\!\mathrm{d}x = \frac{1}{2} \int (\frac{1}{1 - x} + \frac{1}{1 + x}) \mathop{}\!\mathrm{d}x = \frac{1}{2}(-\ln|1 - x| + \ln|1 + x|) + C = \frac{1}{2} \ln|\frac{1 + x}{1 - x}| + C</script><p>推广：</p><script type="math/tex; mode=display">\int \frac{1}{a^2 - x^2} \mathop{}\!\mathrm{d}x = \frac{1}{2a} \int (\frac{1}{a-x} + \frac{1}{a+x}) \mathop{}\!\mathrm{d}x = \frac{1}{2a}\ln|\frac{a+x}{a-x}| + C</script><h1 id="sqrt-1-x-2"><a href="#sqrt-1-x-2" class="headerlink" title="$\sqrt{1-x^2}$"></a>$\sqrt{1-x^2}$</h1><script type="math/tex; mode=display">\int \frac{1}{\sqrt{1-x^2}} \mathop{}\!\mathrm{d}x = \arcsin x + C</script><p>推广：</p><script type="math/tex; mode=display">\int \frac{1}{\sqrt{a^2 - x^2}} \mathop{}\!\mathrm{d}x = \frac{1}{a}\int \frac{1}{\sqrt{1-(\frac{x}{a})^2}} \mathop{}\!\mathrm{d}x = \int \frac{\mathop{}\!\mathrm{d}(\frac{x}{a})}{\sqrt{1-(\frac{x}{a})^2}} = \arcsin \frac{x}{a} + C</script><script type="math/tex; mode=display">\int \frac{1}{\sqrt{x^2 + a^2}} \mathop{}\!\mathrm{d}x = \ln(x + \sqrt{x^2 + a^2}) + C</script><script type="math/tex; mode=display">\int \frac{1}{\sqrt{x^2 - a^2}} \mathop{}\!\mathrm{d}x = \ln |x + \sqrt{x^2 - a^2}| + C</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;积分学的基础，基本积分公式&lt;/p&gt;
    
    </summary>
    
      <category term="高等数学" scheme="http://ilern.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="微积分" scheme="http://ilern.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>凹凸性与拐点</title>
    <link href="http://ilern.github.io/2021/03/10/%E5%87%B9%E5%87%B8%E6%80%A7%E4%B8%8E%E6%8B%90%E7%82%B9/"/>
    <id>http://ilern.github.io/2021/03/10/凹凸性与拐点/</id>
    <published>2021-03-10T08:52:58.000Z</published>
    <updated>2021-03-10T10:56:36.004Z</updated>
    
    <content type="html"><![CDATA[<p>函数的二阶导数值如何影响函数的凹凸性</p><a id="more"></a><p>定理一：</p><blockquote><p>设函数$f(x)$在区间$[a,b]$上连续，$(a,b)$内二阶可导，</p><ol><li>如果在区间$(a,b)$上$f’’(x)&gt;0$，那么$f(x)$在$[a,b]$上是凸函数（图像为凹的）</li><li>如果在区间$(a,b)$上$f’’(x)&lt;0$，那么$f(x)$在$[a,b]$上是凹函数（图像为凸的）</li></ol></blockquote><p>证明：</p><p>设$f’’(x) &gt; 0$，则对于 $\forall x_1 &lt; x_2 \in I$，取$\xi_1 \in (x_1, \frac{x_1 + x_2}{2}), \xi_2 \in (\frac{x_1 + x_2}{2}, x_2)$<br>根据拉格朗日中值定理</p><script type="math/tex; mode=display">\exists \xi_1 \in (x_1, \frac{x_1 + x_2}{2}), f(\frac{x_1 + x_2}{2}) - f(x_1) = f'(\xi_1)\frac{x_2 - x_1}{2} \\\exists \xi_2 \in (\frac{x_1 + x_2}{2}, x_2), f(x_2) - f(\frac{x_1 + x_2}{2}) = f'(\xi_2)\frac{x_2 - x_1}{2}</script><p>两式相减</p><script type="math/tex; mode=display">f(x_1) + f(x_2) - 2f(\frac{x_1 + x_2}{2}) = [f'(\xi_2) - f'(\xi_1)]\frac{x_2 - x_1}{2}</script><p>又</p><script type="math/tex; mode=display">\begin{align}& \because f''(x) > 0, \xi_1 < \xi_2\\[2ex]& \therefore f'(\xi_1) < f'(\xi_2) \\[2ex]& \therefore f'(\xi_2) - f'(\xi_1) > 0 \\[2ex]& \therefore [f'(\xi_2) - f'(\xi_1)]\frac{x_1 + x_2}{2} >0 \\[2ex]& \therefore f(x_1) + f(x_2) - 2f(\frac{x_1 + x_2}{2}) > 0 \\[2ex]& \therefore f(x_1) + f(x_2) > 2f(\frac{x_1 + x_2}{2})\end{align}</script><p>满足凸函数定义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数的二阶导数值如何影响函数的凹凸性&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ilern.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="微积分" scheme="http://ilern.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>导数的四则运算法则</title>
    <link href="http://ilern.github.io/2021/03/06/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/"/>
    <id>http://ilern.github.io/2021/03/06/导数的四则运算法则/</id>
    <published>2021-03-06T13:44:05.000Z</published>
    <updated>2021-03-07T12:33:42.943Z</updated>
    
    <content type="html"><![CDATA[<p>导数四则运算法则的推导，$u$ 和 $v$ 均可导</p><a id="more"></a><h1 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h1><script type="math/tex; mode=display">\begin{align}(u \pm v)'&= \lim_{\Delta x \to 0} \frac{(u(x + \Delta x) \pm v(x + \Delta x)) - (u(x) \pm v(x))}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{(u(x + \Delta x) - u(x)) }{\Delta x} \pm \lim_{\Delta x \to 0} \frac{(v(x + \Delta x) - v(x))}{\Delta x} \\[2ex]&= u' \pm v'\end{align}</script><h1 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h1><p>乘法和除法都是凑了一项，感觉很巧妙</p><script type="math/tex; mode=display">\begin{align}(uv)'&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x + \Delta x) - u(x)v(x)}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x + \Delta x) - u(x + \Delta x)v(x)}{\Delta x} + \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - u(x)v(x)}{\Delta x}\\[2ex]&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)[v(x + \Delta x) - v(x)]}{\Delta x} + \lim_{\Delta x \to 0} \frac{v(x)[u(x + \Delta x) - u(x)]}{\Delta x} \\[2ex]&= u(x) \lim_{\Delta x \to 0} \frac{v(x + \Delta x) - v(x)}{\Delta x} + v(x) \lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} \\[2ex]&= uv' + vu'\end{align}</script><p>第三步到第四步，因为$v(x)$与极限中的变量$\Delta x$无关，因此可以提到极限的外面，这样右边的式子容易看出就是$v(x)u’(x)$，问题在于左边的部分。</p><p>根据连续的定义，$\lim_{\Delta x \to 0}u(x + \Delta x) = u(x)$，这样就可以先计算这个因子的极限然后提到外面来，得到和右边相同的结构了。</p><h1 id="除"><a href="#除" class="headerlink" title="除"></a>除</h1><p>第二步到第三步同样用到了函数连续的定义</p><script type="math/tex; mode=display">\begin{align}(\frac{u}{v})'&= \lim_{\Delta x \to 0} \frac{\frac{u(x + \Delta x)}{v(x + \Delta x)} - \frac{u(x)}{v(x)}}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - v(x + \Delta x)u(x)}{\Delta x \cdot v(x + \Delta x)v(x)} \\[2ex]&= \frac{1}{v^2(x)} \lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - v(x + \Delta x)u(x)}{\Delta x} \\[2ex]&= \frac{1}{v^2(x)} [\lim_{\Delta x \to 0} \frac{u(x + \Delta x)v(x) - u(x)v(x)}{\Delta x} + \frac{u(x)v(x) - v(x + \Delta x)u(x)}{\Delta x}] \\[2ex]&= \frac{1}{v^2(x)} [v(x)\lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} + u(x)\lim_{\Delta x \to 0} \frac{v(x) - v(x + \Delta x)}{\Delta x}] \\[2ex]&= \frac{1}{v^2(x)} [v(x)\lim_{\Delta x \to 0} \frac{u(x + \Delta x) - u(x)}{\Delta x} - u(x)\lim_{\Delta x \to 0} \frac{v(x + \Delta x) - v(x)}{\Delta x}] \\[2ex]&= \frac{vu' - uv'}{v^2}\end{align}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导数四则运算法则的推导，$u$ 和 $v$ 均可导&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ilern.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="微积分" scheme="http://ilern.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>基本初等函数的导数</title>
    <link href="http://ilern.github.io/2021/03/05/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/"/>
    <id>http://ilern.github.io/2021/03/05/基本初等函数的导数/</id>
    <published>2021-03-05T11:36:58.000Z</published>
    <updated>2021-03-06T01:13:37.991Z</updated>
    
    <content type="html"><![CDATA[<p>基本初等函数导数的证明 / 推导</p><p>很大程度上是因为手痒想写 $\LaTeX$ 了</p><a id="more"></a><h1 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h1><script type="math/tex; mode=display">\begin{align}(a^x)'&= \lim_{\Delta x \to 0} \frac{a^{x + \Delta x} - a^x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{a^x(a^{\Delta x} - 1)}{\Delta x} \\[2ex]&= a^x \lim_{\Delta x \to 0} \frac{\Delta x \ln a}{\Delta x} \\[2ex]&= a^x \ln a \\\end{align}</script><p>特殊地，$(e^x)’ = e^x$</p><p>另外也可两边取对数然后同时求导</p><script type="math/tex; mode=display">\begin{align}& y = a^x \\& \ln y = x \ln a \\& \frac{\mathrm{d}}{\mathrm{d} x} \ln y = \frac{\mathrm{d}}{\mathrm{d} x} x \ln a\\& \frac{1}{y} \cdot \frac{\mathrm{d} y}{\mathrm{d} x} = \ln a\\& \frac{\mathrm{d} y}{\mathrm{d} x} = y \ln a = a^x \ln a\end{align}</script><h1 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h1><p>两边取对数然后同时求导</p><script type="math/tex; mode=display">\begin{align}& y = x^a\\& \ln y = \ln x^a = a\ln x\\& \frac{\mathrm{d}}{\mathrm{d} x} \ln y = \frac{\mathrm{d}}{\mathrm{d} x} a \ln x\\& \frac{1}{y} \cdot \frac{\mathrm{d} y}{\mathrm{d} x} = \frac{a}{x}\\& \frac{\mathrm{d} y}{\mathrm{d} x} = \frac{ay}{x} = \frac{a x^a}{x} = ax^{a - 1}\end{align}</script><h1 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h1><script type="math/tex; mode=display">\begin{align}(\log_ax)'&= \lim_{\Delta x \to 0} \frac{\log_a (x + \Delta x) - \log_a x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\log_a \frac{x + \Delta x}{x}}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\frac{\ln \frac{x + \Delta x}{x}}{\ln a}}{\Delta x} \\[2ex]&= \frac{1}{\ln a} \lim_{\Delta x \to 0} \frac{\ln \frac{x + \Delta x}{x}}{\Delta x} \\[2ex]&= \frac{1}{\ln a} \lim_{\Delta x \to 0} \frac{\ln (1 + \frac{\Delta x}{x})}{\Delta x} \\[2ex]&= \frac{1}{x\ln a}\end{align}</script><p>特殊地，$(\ln x)’ = \frac{1}{x}$</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p>三角函数的导数证明需要熟悉以下三角变换 / 恒等式：</p><script type="math/tex; mode=display">\sin(\alpha \pm \beta) = \sin \alpha \cos \beta \pm \cos \alpha \sin \beta</script><script type="math/tex; mode=display">\cos(\alpha \pm \beta) = \cos \alpha \cos \beta \mp \sin \alpha \sin \beta</script><script type="math/tex; mode=display">\sin^2 x + \cos^2 x = 1</script><script type="math/tex; mode=display">\sec^2 x = 1 + \tan^2 x = \frac{\cos^2 x}{\cos^2 x} + \frac{\sin^2 x}{\cos^2 x} = \frac{1}{\cos^2 x}</script><script type="math/tex; mode=display">\csc^2 x = 1 + \cot^2 x = \frac{\sin^2 x}{\sin^2 x} + \frac{\cos^2 x}{\sin^2 x} = \frac{1}{\sin^2 x}</script><p>先证明“正”相关函数，对应的“余”相关函数在其基础上略微修改即可，思路相似。</p><h2 id="正"><a href="#正" class="headerlink" title="正"></a>正</h2><h3 id="正弦"><a href="#正弦" class="headerlink" title="正弦"></a>正弦</h3><script type="math/tex; mode=display">\begin{align}(\sin x)'&= \lim_{\Delta x \to 0} \frac{\sin(x + \Delta x) - \sin x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\sin x \cos \Delta x + \cos x \sin \Delta x - \sin x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\sin x(\cos \Delta x - 1) + \cos x \sin \Delta x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0}  \frac{\sin x(\cos \Delta x - 1)}{\Delta x} +  \lim_{\Delta x \to 0}  \frac{\cos x \sin \Delta x}{\Delta x} \\[2ex]&= \sin x \lim_{\Delta x \to 0}  \frac{\cos \Delta x - 1}{\Delta x} + \cos x \\[2ex]&= \cos x\end{align}</script><h3 id="正切"><a href="#正切" class="headerlink" title="正切"></a>正切</h3><script type="math/tex; mode=display">\begin{align}(\tan x)'&= (\frac{\sin x}{\cos x})' \\[2ex]&= \frac{\cos x \cos x - \sin x (-\sin x)}{\cos^2x} \\[2ex]&= \frac{1}{\cos^2 x} \\[2ex]&= \sec^2x\end{align}</script><h3 id="正割"><a href="#正割" class="headerlink" title="正割"></a>正割</h3><script type="math/tex; mode=display">\begin{align}(\sec x)' &= (\frac{1}{\cos x})' \\[2ex]&= \frac{\sin x}{\cos^2 x} \\[3ex]&= \tan x \sec x\end{align}</script><h3 id="反正弦"><a href="#反正弦" class="headerlink" title="反正弦"></a>反正弦</h3><script type="math/tex; mode=display">\begin{align}& y = \arcsin x, x = \sin y \\& \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{\cos y} = \frac{1}{\sqrt{1 - \sin^2 y}} = \frac{1}{\sqrt{1 - x^2}}\end{align}</script><h3 id="反正切"><a href="#反正切" class="headerlink" title="反正切"></a>反正切</h3><script type="math/tex; mode=display">\begin{align}& y = \arctan x, x = \tan y \\& \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{\sec^2 y} = \frac{1}{1 + \tan^2 y} = \frac{1}{1 + x^2}\end{align}</script><h2 id="余"><a href="#余" class="headerlink" title="余"></a>余</h2><h3 id="余弦"><a href="#余弦" class="headerlink" title="余弦"></a>余弦</h3><script type="math/tex; mode=display">\begin{align}(\cos x)'&= \lim_{\Delta x \to 0} \frac{\cos(x + \Delta x) - cos x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\cos x \cos \Delta x - \sin x \sin \Delta x - \cos x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\cos x(\cos \Delta x - 1) - \sin x \sin \Delta x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{\cos x(\cos \Delta x - 1)}{\Delta x} -  \lim_{\Delta x \to 0}  \frac{\sin x \sin \Delta x}{\Delta x} \\[2ex]&= \cos x \lim_{\Delta x \to 0}  \frac{\cos \Delta x - 1}{\Delta x} - \sin x \\[2ex]&= -\sin x\end{align}</script><h3 id="余切"><a href="#余切" class="headerlink" title="余切"></a>余切</h3><script type="math/tex; mode=display">\begin{align}(\cot x)'&= (\frac{\cos x}{\sin x})' \\[2ex]&= \frac{-\sin x \sin x - \cos x \cos x}{\sin^2x} \\[2ex]&= -\frac{1}{\sin^2 x} \\[2ex]&= -\csc^2x\end{align}</script><h3 id="余割"><a href="#余割" class="headerlink" title="余割"></a>余割</h3><script type="math/tex; mode=display">\begin{align}(\csc x)' &= (\frac{1}{\sin x})' \\[2ex]&= \frac{-\cos x}{\sin^2 x} \\[3ex]&= -\cot x \csc x\end{align}</script><h3 id="反余弦"><a href="#反余弦" class="headerlink" title="反余弦"></a>反余弦</h3><script type="math/tex; mode=display">\begin{align}& y = \arccos x, x = \cos y \\& \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{-\sin y} = -\frac{1}{\sqrt{1 - \cos^2 y}} = -\frac{1}{\sqrt{1 - x^2}}\end{align}</script><h3 id="反余切"><a href="#反余切" class="headerlink" title="反余切"></a>反余切</h3><script type="math/tex; mode=display">\DeclareMathOperator{\arccot}{arccot}\begin{align}& y = \arccot x, x = \cot y \\& \frac{\mathrm{d} y }{\mathrm{d} x} = \frac{1}{\frac{\mathrm{d} x }{\mathrm{d} y}} = \frac{1}{-\csc^2 y} = -\frac{1}{1 + \cot^2 y} = -\frac{1}{1 + x^2}\end{align}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本初等函数导数的证明 / 推导&lt;/p&gt;
&lt;p&gt;很大程度上是因为手痒想写 $\LaTeX$ 了&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ilern.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="微积分" scheme="http://ilern.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>七和弦</title>
    <link href="http://ilern.github.io/2021/01/19/%E4%B8%83%E5%92%8C%E5%BC%A6/"/>
    <id>http://ilern.github.io/2021/01/19/七和弦/</id>
    <published>2021-01-19T05:43:29.000Z</published>
    <updated>2021-01-19T08:58:31.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七和弦"><a href="#七和弦" class="headerlink" title="七和弦"></a>七和弦</h1><p>关于七和弦自己的部分理解与总结</p><a id="more"></a><p>众所周知，构成三和弦的三个音依次成三度关系，以最简单的大三和弦和小三和弦为例：</p><ul><li><p>大三和弦根音和三音相距一个大三度，三音和五音相距一个小三度，根音和五音相距一个纯五度，</p></li><li><p>小三和弦根音和三音相距一个小三度，三音和五音相距一个大三度，根音和五音相距一个纯五度，</p></li></ul><p>也就是说仅仅是和弦的三音决定了和弦的色彩，五音是不变的</p><p>而七和弦，仅仅是在三和弦的<strong>基础上</strong>增加了七音，然后根据七音距离根音的不同音程关系具体分为很多种类</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;七和弦&quot;&gt;&lt;a href=&quot;#七和弦&quot; class=&quot;headerlink&quot; title=&quot;七和弦&quot;&gt;&lt;/a&gt;七和弦&lt;/h1&gt;&lt;p&gt;关于七和弦自己的部分理解与总结&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://ilern.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="乐理" scheme="http://ilern.github.io/tags/%E4%B9%90%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NJU ics 2020 概要</title>
    <link href="http://ilern.github.io/2021/01/12/NJU-ics-2020-%E6%A6%82%E8%A6%81/"/>
    <id>http://ilern.github.io/2021/01/12/NJU-ics-2020-概要/</id>
    <published>2021-01-12T12:12:26.000Z</published>
    <updated>2021-06-04T14:21:43.860Z</updated>
    
    <content type="html"><![CDATA[<p>填坑</p><a id="more"></a><h1 id="PA1-开天辟地的篇章：最简单的计算机"><a href="#PA1-开天辟地的篇章：最简单的计算机" class="headerlink" title="PA1 - 开天辟地的篇章：最简单的计算机"></a>PA1 - 开天辟地的篇章：最简单的计算机</h1><h2 id="实现x86的寄存器"><a href="#实现x86的寄存器" class="headerlink" title="实现x86的寄存器"></a>实现x86的寄存器</h2><p>很关键的一张图</p><p><img src="1.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> _32;</span><br><span class="line">        <span class="keyword">uint16_t</span> _16;</span><br><span class="line">        <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">&#125; gpr[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//relreg_t === uint32_t</span></span><br><span class="line">    <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125; x86_CPU_state;</span><br></pre></td></tr></table></figure><p>希望下面的每一个寄存器（eax…）能和上面结构体中的结构进行对应</p><p>x86寄存器的这种结构很适合用<code>union</code>来表达</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> _32;</span><br><span class="line">                <span class="keyword">uint16_t</span> _16;</span><br><span class="line">                <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; gpr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//relreg_t === uint32_t</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125; x86_CPU_state;</span><br></pre></td></tr></table></figure><h3 id="reg-test-是如何测试你的实现的"><a href="#reg-test-是如何测试你的实现的" class="headerlink" title="reg_test()是如何测试你的实现的?"></a>reg_test()是如何测试你的实现的?</h3><p><img src="2.png" alt></p><p><code>reg_l</code>,<code>reg_w</code>,<code>reg_b</code>是<code>/nemu/src/isa/x86/local-include/reg.h</code>定义的三个宏，分别对应32位、16位、8位寄存器</p><p>给每一个32位寄存器赋一个随机值，然后依次检查其低16位低8位的值，最后检查pc</p><h3 id="在cmd-c-函数中-调用cpu-exec-的时候传入了参数-1-你知道这是什么意思吗"><a href="#在cmd-c-函数中-调用cpu-exec-的时候传入了参数-1-你知道这是什么意思吗" class="headerlink" title="在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?"></a>在<code>cmd_c()</code>函数中, 调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>, 你知道这是什么意思吗?</h3><p>循环<code>for (; n &gt; 0; n--)</code>，传入<code>-1</code>使得这个循环总是成立，所以会执行完全部的指令</p><h2 id="完善调试器"><a href="#完善调试器" class="headerlink" title="完善调试器"></a>完善调试器</h2><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_si</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">int</span> n = atoi(arg);</span><br><span class="line">    </span><br><span class="line">    cpu_exec(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_info</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(arg, <span class="string">"r"</span>)) &#123;</span><br><span class="line">        <span class="comment">//for registers</span></span><br><span class="line">        isa_reg_display();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(arg, <span class="string">"w"</span>)) &#123;</span><br><span class="line">        <span class="comment">//for watch point</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_reg_display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = R_EAX; i &lt;= R_EDI; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8s %-16x %-16d\n"</span>, regsl[i], reg_l(i), reg_l(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = R_AX; i &lt;= R_DI; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8s %-16x %-16d\n"</span>, regsw[i], reg_w(i), reg_w(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = R_AL; i &lt;= R_BH; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8s %-16x %-16d\n"</span>, regsb[i], reg_b(i), reg_b(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h3><p><img src="3.png" alt></p><p>注意要<code>#include &quot;../../../include/memory/vaddr.h&quot;</code></p><p>PA1第一阶段到此结束</p><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="实现算术表达式的词法分析"><a href="#实现算术表达式的词法分析" class="headerlink" title="实现算术表达式的词法分析"></a>实现算术表达式的词法分析</h3><p>RTFC找到这部分的执行逻辑</p><p>表达式求值相关代码位于<code>/home/leyan/ics2020/nemu/src/monitor/debug/expr.c</code>，在<code>./ui.c</code>中<code>#include &quot;expr.h&quot;</code>，<code>./expr.h</code>中只有一个函数声明<code>word_t expr(char*, char*)</code>，也就是说在<code>./ui.c</code>中所有表达式求值的功能都由<code>expr()</code>这个函数来进行。</p><p>词法分析的任务相对简单，只需要把token类型写进枚举中，rule数组中存放由正则表达式和类型组成的规则</p><p>对表达式进行匹配的部分框架已经写好了，只需要对于识别出的token一次扔到<code>tokens</code>数组中即可，有些特殊的token需要特殊处理，例如<code>TK_NOTYPE</code>，表示空格，空格在词法解析中会被忽略，因此直接break就行。</p><p><img src="4.png" alt></p><p>这里有一个小坑就是<code>strncpy</code>不会包含最后的<code>\0</code>，需要手动加上。</p><h3 id="实现算术表达式的递归求值"><a href="#实现算术表达式的递归求值" class="headerlink" title="实现算术表达式的递归求值"></a>实现算术表达式的递归求值</h3><p>递归求值的部分文档里写的很清晰，只要填框架就行了，目前没有发现坑。</p><h2 id="实现表达式生成器"><a href="#实现表达式生成器" class="headerlink" title="实现表达式生成器"></a>实现表达式生成器</h2><p>这一部分的代码在<code>/nemu/tools/gen-expr.c</code>中，大体的思路就是先生成表达式字符串，在把它塞进这样一个C语言代码字符串里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;#include &lt;stdio.h&gt;\n&quot;</span><br><span class="line">&quot;int main() &#123; &quot;</span><br><span class="line">&quot;  unsigned result = %s; &quot;</span><br><span class="line">&quot;  printf(\&quot;%%u\&quot;, result); &quot;</span><br><span class="line">&quot;  return 0; &quot;</span><br><span class="line">&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>然后输出到文件里，调用gcc编译运行并获得输出结果。</p><p>一些细节：</p><ul><li>如何保证表达式进行无符号运算?<ul><li>先进行有符号运算最后转成无符号数</li></ul></li><li>如何生成长表达式, 同时不会使<code>buf</code>溢出?<ul><li>设定一个上限，超过了就返回</li></ul></li><li>如何过滤求值过程中有除0行为的表达式?<ul><li>调用gcc的时候把所有警告视为错误，这样<code>system</code>的返回值不为零，就不会写进文件里</li></ul></li></ul><p>有了表达式生成器就可以测试之前的递归求值了</p><p>PA1阶段2到此结束</p><h2 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h2><p>监视点的功能是监视一个表达式的值何时发生变化。</p><h3 id="扩展算数表达式求值功能"><a href="#扩展算数表达式求值功能" class="headerlink" title="扩展算数表达式求值功能"></a>扩展算数表达式求值功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;    # 以&quot;0x&quot;开头</span><br><span class="line">  | &lt;reg_name&gt;              # 以&quot;$&quot;开头</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;==&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;</span><br><span class="line">  | &quot;*&quot; &lt;expr&gt;              # 指针解引用</span><br></pre></td></tr></table></figure><p>这个部分硬写就行，重点是单目运算符的实现，框架中给出了思路，在正则匹配的阶段是无法区分乘号<code>*</code>和解引用<code>*</code>的，需要在识别出token之后，求值之前，把解引用标识出来</p><p>解引用是单目运算，因此左边不能是数字或右括号</p><p>在寻找主运算符的过程中，要注意单目运算符的优先级高，找主运算符时应该跳过</p><p>负数的处理也类似</p><p><img src="5.png" alt></p><h3 id="实现监视点"><a href="#实现监视点" class="headerlink" title="实现监视点"></a>实现监视点</h3><p>监视点池就是一个链表，注意删除的时候判断空，否则会触发段错误</p><p>没什么好说的，就是一些链表操作、</p><h3 id="调试的建议"><a href="#调试的建议" class="headerlink" title="调试的建议"></a>调试的建议</h3><ul><li>总是使用<code>-Wall</code>和<code>-Werror</code></li><li>尽可能多地在代码中插入<code>assert()</code></li><li><code>assert()</code>无法捕捉到error时, 通过<code>printf()</code>输出可疑的变量, 期望能观测到error</li><li><code>printf()</code>不易观测error时, 通过GDB理解程序的精确行为</li></ul><h3 id="断点的工作原理"><a href="#断点的工作原理" class="headerlink" title="断点的工作原理"></a>断点的工作原理</h3><p>在PA中可以用<code>w pc == ADDR</code>来模拟断点，但是这样会影响效率</p><p><a href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints" target="_blank" rel="noopener">How debuggers work: Part 2 - Breakpoints</a></p><p>这篇文章介绍了GDB打断点的原理，简要概括如下：</p><ul><li>断点通过软中断（trap / software interrupts）实现<ul><li>发生中断时，CPU会保存当前的状态，跳转到一个事先确定的处理相应中断的程序的位置</li><li>硬件中断和软件中断都是如此</li></ul></li><li>断点通过一种特殊的trap——<code>int3</code>来实现<ul><li>这里的<code>int</code>不是类型，而是x86对于trap指令的一种术语，指的是对预先定义的处理程序的调用，<code>interrupt</code></li><li><code>int</code>指令可以跟一个8位的操作数，这个操作数表明了中断的编号，理论上可以有$2^8 = 256$种中断，我们关心的中断是三号中断<code>int3</code></li><li><code>int3</code>称为<code>trap to debugger</code></li></ul></li><li>当进程执行<code>int3</code>指令时，OS会停止当前的进程，并向他发送一个<code>SIGTRAP</code>信号</li></ul><p>思考题：</p><ul><li>x86的<code>int3</code>指令不带任何操作数, 操作码为1个字节, 因此指令的长度是1个字节. 这是必须的吗? 假设有一种x86体系结构的变种my-x86, 除了<code>int3</code>指令的长度变成了2个字节之外, 其余指令和x86相同. 在my-x86中, 上述文章中的断点机制还可以正常工作吗? 为什么?</li></ul><h2 id="如何阅读手册"><a href="#如何阅读手册" class="headerlink" title="如何阅读手册"></a>如何阅读手册</h2><h3 id="查阅手册回答"><a href="#查阅手册回答" class="headerlink" title="查阅手册回答"></a>查阅手册回答</h3><ul><li><p>EFLAGS寄存器中的CF位是什么意思?</p><p><a href="https://nju-projectn.github.io/i386-manual/s02_03.htm#fig2-8" target="_blank" rel="noopener">Figure 2-8.  EFLAGS Register  </a></p><p>CF：Carry Flag 进位标志</p><p><img src="8.png" alt></p></li><li><p>ModR/M字节是什么?</p><p>ModR/M是x86指令中的一个字节</p><p>x86指令的一般格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+-----------+--------+------+------+------+------------+-----------+</span><br><span class="line">|instruction| address-  |  operand- |segment |opcode|ModR/M| SIB  |displacement| immediate |</span><br><span class="line">|  prefix   |size prefix|size prefix|override|      |      |      |            |           |</span><br><span class="line">|-----------+-----------+-----------+--------+------+------+------+------------+-----------|</span><br><span class="line">|   0 OR 1  |  0 OR 1   |   0 OR 1  | 0 OR 1 |1 OR 2|0 OR 1|0 OR 1| 0,1,2 OR 4 |0,1,2 OR 4 |</span><br><span class="line">| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|</span><br><span class="line">|                                     number of bytes                                      |</span><br><span class="line">+------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>除了opcode(操作码)必定出现之外, 其余组成部分可能不出现, 而对于某些组成部分, 其长度并不是固定的. 但给定一条具体指令的二进制形式, 其组成部分的划分是有办法确定的, 不会产生歧义(即把一串比特串看成指令的时候, 不会出现两种不同的解释). </p><p>去手册中查询指令的一般格式 <code>17.2 Instruction Format</code></p><ul><li>ModR/M 和 SIB 字节跟在 opcode 后面， 包括以下信息<ul><li>指令中要使用的索引类型或者寄存器号</li><li>要使用的寄存器或者用来选择指令的更多信息</li><li>base, index, 和 scale 的相关信息</li></ul></li><li>ModR/M 字节包括三部分信息:<ul><li>mod field, 占用字节的两个最高位, 和 r/m field 结合表示32个可能的值: 8个寄存器和和24个 index mode。</li><li>The reg field, 占用 mod field 接下来的三位，决定是寄存器号还是 opdode 的额外3位，取决于 opcode 的第一个字节。</li><li>The r/m field, 占用三个最低位, 决定寄存器是操作数的位置或者可以与上述字段结合形成寻址模式编码的一部分。</li></ul></li></ul></li><li><p>mov指令的具体格式是怎么样的?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Opcode   Instruction       Clocks        Description</span><br><span class="line"></span><br><span class="line">88  /r   MOV r/m8,r8       2/2           Move byte register to r/m byte</span><br><span class="line">89  /r   MOV r/m16,r16     2/2           Move word register to r/m word</span><br><span class="line">89  /r   MOV r/m32,r32     2/2           Move dword register to r/m dword</span><br><span class="line">8A  /r   MOV r8,r/m8       2/4           Move r/m byte to byte register</span><br><span class="line">8B  /r   MOV r16,r/m16     2/4           Move r/m word to word register</span><br><span class="line">8B  /r   MOV r32,r/m32     2/4           Move r/m dword to dword register</span><br><span class="line">8C  /r   MOV r/m16,Sreg    2/2           Move segment register to r/m word</span><br><span class="line">8E  /r   MOV Sreg,r/m16    2/5,pm=18/19  Move r/m word to segment register</span><br><span class="line">A0       MOV AL,moffs8     4             Move byte at (seg:offset) to AL</span><br><span class="line">A1       MOV AX,moffs16    4             Move word at (seg:offset) to AX</span><br><span class="line">A1       MOV EAX,moffs32   4             Move dword at (seg:offset) to EAX</span><br><span class="line">A2       MOV moffs8,AL     2             Move AL to (seg:offset)</span><br><span class="line">A3       MOV moffs16,AX    2             Move AX to (seg:offset)</span><br><span class="line">A3       MOV moffs32,EAX   2             Move EAX to (seg:offset)</span><br><span class="line">B0 + rb ib  MOV reg8,imm8     2          Move immediate byte to register</span><br><span class="line">B8 + rw iw  MOV reg16,imm16   2          Move immediate word to register</span><br><span class="line">B8 + rd id  MOV reg32,imm32   2          Move immediate dword to register</span><br><span class="line">C6 ib    MOV r/m8,imm8     2/2           Move immediate byte to r/m byte</span><br><span class="line">C7 iw    MOV r/m16,imm16   2/2           Move immediate word to r/m word</span><br><span class="line">C7 id    MOV r/m32,imm32   2/2           Move immediate dword to r/m dword</span><br></pre></td></tr></table></figure></li></ul><h3 id="统计代码行数"><a href="#统计代码行数" class="headerlink" title="统计代码行数"></a>统计代码行数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name "*.[ch]" | xargs wc -l &gt; statistic</span><br></pre></td></tr></table></figure><p><img src="6.png" alt></p><p>PA0 时的代码行数:</p><p><img src="7.png" alt></p><font color="blue"><strong>PA1到此结束</strong></font><h1 id="PA2-简单复杂的机器-冯诺依曼计算机系统"><a href="#PA2-简单复杂的机器-冯诺依曼计算机系统" class="headerlink" title="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"></a>PA2 - 简单复杂的机器: 冯诺依曼计算机系统</h1><p>先给出了一段YEMU的代码，其中模拟了最简单的计算机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义指令格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">uint8_t</span> rs : <span class="number">2</span>, rt : <span class="number">2</span>, op : <span class="number">4</span>; &#125; rtype;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">uint8_t</span> addr : <span class="number">4</span>      , op : <span class="number">4</span>; &#125; mtype;</span><br><span class="line">  <span class="keyword">uint8_t</span> inst;</span><br><span class="line">&#125; <span class="keyword">inst_t</span>;</span><br></pre></td></tr></table></figure><p>这部分定义了指令格式，其中用到了<strong>位域（Bit field）</strong>的结构</p><h2 id="RTFC"><a href="#RTFC" class="headerlink" title="RTFC"></a>RTFC</h2><p><code>isa-cpu-exec()</code>中，代码首先定义了一个<code>DecodeExecState</code>类型的结构体变量<code>s</code>, 它用于存放在执行一条指令过程中的译码和执行信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> opcode;</span><br><span class="line">  <span class="keyword">vaddr_t</span> seq_pc;  <span class="comment">// sequential pc</span></span><br><span class="line">  <span class="keyword">uint32_t</span> is_jmp;</span><br><span class="line">  <span class="keyword">vaddr_t</span> jmp_pc;</span><br><span class="line">  Operand src1, dest, src2;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">  <span class="keyword">rtlreg_t</span> tmp_reg[<span class="number">4</span>];</span><br><span class="line">  ISADecodeInfo isa;</span><br><span class="line">&#125; DecodeExecState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> type;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> reg;</span><br><span class="line">        <span class="keyword">word_t</span> imm;</span><br><span class="line">        <span class="keyword">sword_t</span> simm;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">rtlreg_t</span> *prg;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为了提高性能, 我们在Operand结构体中定义了一个RTL寄存器的指针preg, 用于直接指向那些已经存在的RTL寄存器. 例如如果在进行译码的时候发现操作数是eax寄存器, 那么只需要通过让preg指向cpu.eax, 将来就可以直接通过preg来访问到正确的操作数了, 而不需要通过rtl_mv()来将cpu.eax读到别处, 从而避免引入额外的开销. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">rtlreg_t</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> str[OP_STR_SIZE];</span><br><span class="line">&#125; Operand;</span><br></pre></td></tr></table></figure><p>部分isa相关信息存放在<code>ISADecodeInfo</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> is_operand_size_16;</span><br><span class="line">  <span class="keyword">uint8_t</span> ext_opcode;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *mbase;</span><br><span class="line">  <span class="keyword">rtlreg_t</span> mbr;</span><br><span class="line">  <span class="keyword">word_t</span> moff;</span><br><span class="line">&#125; x86_ISADecodeInfo;</span><br></pre></td></tr></table></figure></p><p>这里定义的是<code>x86_ISADecodeInfo</code>，但是在代码中直接用的是<code>ISADecodeInfo</code>，是因为</p><p><code>include/isa.h:13:typedef concat(__ISA__, _ISADecodeInfo) ISADecodeInfo;</code></p><p>这样可以让框架代码不随ISA而改变</p><p><code>concat(x, y)</code>同样是一个宏，作用是把两个字符串<code>x,y</code>拼在一起，也就是说<code>concat(x86, _ISADecodeInfo) == x86_ISADecodeInfo</code></p><h3 id="取指"><a href="#取指" class="headerlink" title="取指"></a>取指</h3><p>取指实质上就是读内存，在<code>pc</code>指向的位置读一条长度为<code>len</code>的指令，返回读到的指令</p><p>Debug状态下会把指令的每一个字节放到一个外部数组<code>log_bytebuf[]</code>中。</p><p>这里读内存使用的是<code>vaddr_ifetch()</code>，看上去是读虚拟内存，实际上现阶段都是直接访问物理内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//read address</span></span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_ifetch(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">"%02x "</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h3><p>译码实质上就是查表，把取出的指令的<code>opcode</code>提取出来，然后根据<code>opcode</code>去查表确定指令类型，这里用一个很大的<code>switch-case</code>来进行，其中用到了一些宏。</p><p>这些宏先设置操作数的宽度，再进行操作数译码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty decode helper</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> decode_empty(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(idx, id, ex, w) CASE_ENTRY(idx, concat(decode_, id), concat(exec_, ex), w)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(idx, id, ex)     IDEXW(idx, id, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXW(idx, ex, w)       IDEXW(idx, empty, ex, w)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX(idx, ex)           EXW(idx, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY(idx)            EX(idx, inv)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE_ENTRY(idx, id, ex, w) case idx: set_width(s, w), id(s), ex(s); break;</span></span><br></pre></td></tr></table></figure><p>这些宏一个套一个，最终都是来自<code>CASE_ENTRY</code>，其中的<code>s</code>是<code>DecodeExecState *s</code>，他被用作这些函数的参数，且总叫做<code>s</code>。</p><p>例如：</p><p><code>IDEXW(0x80, I2E, gp1, 1) == CASE_ENTRY(0x80, decode_I2E, exec_gp1, 1)</code></p><p><code>IDEX(0x81, I2E, gp1) == IDEXW(0x80, I2E, gp1, 0) == CASE_ENTRY(0x81, decode_I2E, exec_gp1, 0)</code></p><p><code>EX(0x0f, 2byte_esc) == EXW(0x0f, 2byte_esc, 0) == IDEXW(0x0f, empty, 2byte_esc, 0) == CASE_ENTRY(0x0f, decode_empty, exec_2byte_esc, 0)</code></p><p>其中的<code>decode_</code>开头的函数都是译码辅助函数</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><code>#define def_EHelper(name) void concat(exec_, name) (DecodeExecState *s)</code>，用于执行，<code>exec_</code>开头的都是执行辅助函数。</p><h3 id="更新PC"><a href="#更新PC" class="headerlink" title="更新PC"></a>更新PC</h3><p>下一条指令有静态动态两种，默认情况下取指结束后<code>s-&gt;seq_pc</code>会指向下一条静态地址，如果有跳转指令，<code>s-&gt;jmp_pc</code>会指向下一条动态指令，真正修改的时候调用<code>update_pc()</code>即可。</p><h2 id="使用RTL表示指令行为"><a href="#使用RTL表示指令行为" class="headerlink" title="使用RTL表示指令行为"></a>使用RTL表示指令行为</h2><ul><li><p>RTL寄存器</p><ul><li>PA1中已经实现</li><li>在NEMU中, RTL寄存器只有以下这些<ul><li>不同ISA的通用寄存器(在<code>nemu/include/isa/$ISA.h</code>中定义)</li><li><code>id_src</code>, <code>id_src2</code>和<code>id_dest</code>中的操作数内容<code>val</code>(在<code>nemu/include/cpu/decode.h</code>中定义).</li><li>临时寄存器<code>s0, s1, s2</code>和<code>t0</code>(在<code>nemu/include/rtl/rtl.h</code>中定义)</li><li>零寄存器<code>rz</code>(在<code>nemu/src/monitor/cpu-exec.c</code>中定义), 它的值总是0</li><li>x86的ISA相关译码信息中的内存基地址<code>mbr</code></li></ul></li></ul></li><li><p>RTL指令</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> def_rtl(name, ...) void concat(rtl_, name)(DecodeExecState *s, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure></li><li><p>以<code>def_rtl_compute_reg_imm(add)</code>为例，完全展开为</p></li><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_add</span><span class="params">(DecodeExecState *s, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*dest = c_add(*src1, *src2);</span></span><br><span class="line">    *dest = (*src1) + (*src2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_addi</span><span class="params">(DecodeExecState *s, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">sword_t</span> imm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*dest = c_add(*src1, imm);</span></span><br><span class="line">    *dest = (*src1) + (imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><h2 id="请整理一条指令在NEMU中的执行过程"><a href="#请整理一条指令在NEMU中的执行过程" class="headerlink" title="请整理一条指令在NEMU中的执行过程"></a>请整理一条指令在NEMU中的执行过程</h2><ul><li><code>si 1</code></li><li><code>cpu_exec(n=1) at src/monitor/cpu_exec.c</code></li><li><code>isa_exec_once() at src/isa/x86/exec/exec.c</code></li><li><code>fetch_decode_exec (s=0x7ffffffed860) at src/isa/x86/exec/exec.c:144</code><ul><li><code>instr_fetch (pc=0x7ffffffed864, len=1) at src/isa/x86/exec/exec.c:144</code> 取指<ul><li>此时<code>s-&gt;seq_pc</code>往后移动了一个字节</li><li>读到了<code>opcode</code>，放在<code>s</code>中的<code>opcode</code>中</li></ul></li><li><code>IDEX(0xb8, mov_I2r, mov)</code> 指令是移动立即数到寄存器<ul><li><code>set_width (width=0, s=0x7ffffffed860) at src/isa/x86/exec/exec.c:108</code></li><li><code>s-&gt;src1.width = s-&gt;dest.width = s-&gt;src2.width = width; //width = 4</code> 设置操作数宽度</li><li><code>decode_mov_I2r (s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:166</code> 开始译码操作数</li><li><code>decode_op_r (load_val=0 &#39;\000&#39;, op=0x7ffffffed8b8, s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:167</code> load_val = 0表示这个操作数不需要存储到<code>s</code>中供后续使用<ul><li><code>operand_reg (s=0x7ffffffed860, width=4, r=0, load_val=0 &#39;\000&#39;, op=0x7ffffffed8b8) at src/isa/x86/exec/../local-include/decode.h:8</code> 找出要用到的寄存器<ul><li>在x86中, 通用寄存器都有自己的编号,<code>I2r</code>形式的指令把寄存器编号也放在指令的第一个字节里面, 我们可以通过位运算将寄存器编号抽取出来;</li><li><code>r = s-&gt;opcode &amp; 0x7  == 0</code></li></ul></li></ul></li><li><code>decode_op_I (load_val=1 &#39;\001&#39;, op=0x7ffffffed870, s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:168</code><ul><li><code>imm</code>即为指令中的立即数，是指令的后四个字节，使用<code>instr_fetch(&amp;s-&gt;seq_pc, op-&gt;width)</code>获取，此时<code>seq_pc</code>又往后移动了四个字节。</li><li><code>operand_imm (width=&lt;optimized out&gt;, imm=&lt;optimized out&gt;, load_val=&lt;optimized out&gt;,op=&lt;optimized out&gt;, s=&lt;optimized out&gt;) at src/isa/x86/exec/../local-include/decode.h:40</code> 把立即数写到<code>s</code>中合理的位置</li></ul></li><li>执行指令调用<code>exec_move()</code>，位于<code>/src/isa/x86/exec/data-mov.h</code></li></ul></li></ul></li><li>更新PC</li></ul><p><img src="10.JPG" alt></p><h2 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h2><p><img src="11.png" alt></p><h3 id="CALL-rel32"><a href="#CALL-rel32" class="headerlink" title="CALL rel32"></a>CALL rel32</h3><p>这里遇到的第一个障碍就是call指令，查看x86手册，其中给出了执行过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IF rel16 or rel32 type of call</span><br><span class="line">THEN (* near relative call *)</span><br><span class="line">   IF OperandSize = 16</span><br><span class="line">   THEN</span><br><span class="line">      Push(IP);</span><br><span class="line">      EIP := (EIP + rel16) AND 0000FFFFH;</span><br><span class="line">   ELSE (* OperandSize = 32 *)</span><br><span class="line">      Push(EIP);</span><br><span class="line">      EIP := EIP + rel32;</span><br><span class="line">   FI;</span><br><span class="line">FI;</span><br></pre></td></tr></table></figure><p><code>EIP</code>是当前的指令地址，先压到栈中（<code>push</code>），再将<code>EIP</code>后移<code>rel32</code> <del>条指令</del> 个字节</p><p><del>从上面的反汇编看就是从<code>10000a</code>往后走<code>5</code>条指令，到了<code>100014</code></del></p><p>这里完全是我看错了，其实是往后走了5个<strong>字节</strong>，从下一条指令算起，这样下面的<code>main</code>函数的跳转也解释的通了。</p><h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><p>通过<code>trl_push</code>来实现，<code>rtl_push</code>位于<code>nemu/src/isa/x86/local-include/rtl.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IF StackAddrSize = 16</span><br><span class="line">THEN</span><br><span class="line">   IF OperandSize = 16 THEN</span><br><span class="line">      SP := SP - 2;</span><br><span class="line">      (SS:SP) := (SOURCE); (* word assignment *)</span><br><span class="line">   ELSE</span><br><span class="line">      SP := SP - 4;</span><br><span class="line">      (SS:SP) := (SOURCE); (* dword assignment *)</span><br><span class="line">   FI;</span><br><span class="line">ELSE (* StackAddrSize = 32 *)</span><br><span class="line">   IF OperandSize = 16</span><br><span class="line">   THEN</span><br><span class="line">      ESP := ESP - 2;</span><br><span class="line">      (SS:ESP) := (SOURCE); (* word assignment *)</span><br><span class="line">   ELSE</span><br><span class="line">      ESP := ESP - 4;</span><br><span class="line">      (SS:ESP) := (SOURCE); (* dword assignment *)</span><br><span class="line">   FI;</span><br><span class="line">FI;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(push, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//esp &lt;- esp - 4</span></span><br><span class="line">    <span class="comment">//M[esp] &lt;- src1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>esp</code>是栈顶指针</p><p>除了<code>PUSH imm</code>以外还需要实现<code>PUSH r32</code>，也就是<code>10014</code>的指令，将<code>ebp</code>的值入栈，<code>ebp</code>是栈基址，新的函数开始时应当把旧的栈基址保存下来然后把新的栈基址设为和栈顶一致，也就是<code>10014</code>和<code>10015</code>做的事情。</p><p>这个指令比较特殊因为它没有操作数，在处理的时候特判一下opcode，把要push的内容设置成ebp。更通用的push r32还没有实现。</p><h3 id="SUB-r-m16-imm8"><a href="#SUB-r-m16-imm8" class="headerlink" title="　SUB r/m16, imm8"></a>　SUB r/m16, imm8</h3><h2 id="运行第一个C程序"><a href="#运行第一个C程序" class="headerlink" title="运行第一个C程序"></a>运行第一个C程序</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;填坑&lt;/p&gt;
    
    </summary>
    
      <category term="计算机系统基础" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机系统基础" scheme="http://ilern.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机组成原理" scheme="http://ilern.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://ilern.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记 物理层</title>
    <link href="http://ilern.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/12/30/计算机网络复习笔记-物理层/</id>
    <published>2020-12-30T13:41:06.000Z</published>
    <updated>2021-01-04T11:31:18.122Z</updated>
    
    <content type="html"><![CDATA[<p>复习笔记，学的时候没整理，欠的还是要还</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="物理层的四个特性"><a href="#物理层的四个特性" class="headerlink" title="物理层的四个特性"></a>物理层的四个特性</h2><ol><li><p>机械特性</p><ol><li>接口的形状尺寸、引线数目、排列方式</li></ol></li><li><p>电气特性</p><ol><li>各条线上电压的范围</li></ol></li><li><p>功能特性</p><ol><li>某个电压代表的具体含义</li></ol></li><li>过程特性<ol><li>对于不同功能的各种事件出现的顺序</li></ol></li></ol><h2 id="两种信号"><a href="#两种信号" class="headerlink" title="两种信号"></a>两种信号</h2><ol><li>数字信号<ol><li>不连续变化的信号，是离散的</li></ol></li><li>模拟信号<ol><li>连续变化的信号</li></ol></li></ol><ol><li>基带信号<ol><li>基本频带信号，包含较多的低频分量 / 直流分量，不易在信道中传输</li></ol></li><li>带通信号<ol><li>基带信号经过调制后把低频转化为高频</li></ol></li></ol><h2 id="两种调制方法"><a href="#两种调制方法" class="headerlink" title="两种调制方法"></a>两种调制方法</h2><ol><li>基带调制<ol><li>编码，把数字信号转换为另一种形式的数字信号</li></ol></li><li>带通调制<ol><li>利用载波进行调制，把基带信号移动到较高频段，转换为模拟信号</li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><h1 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h1><h2 id="不归零制-NRZ"><a href="#不归零制-NRZ" class="headerlink" title="　不归零制 NRZ"></a>　不归零制 NRZ</h2><p>有电压表示1，无电压表示0</p><p>效率高，但是接收方不易同步</p><h2 id="归零制-RZ"><a href="#归零制-RZ" class="headerlink" title="归零制 RZ"></a>归零制 RZ</h2><p>发送窄脉冲，发送完归零</p><p>把时钟信号包含在内，但是大部分的数据带宽被浪费了</p><h2 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h2><p>每一位的中间进行一次跳变，向上向下分别代表0和1</p><h2 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h2><p>每一位的中间进行一次跳变，这次跳变用来时钟同步</p><p>每一位开始进行一次跳变，这次有无跳变表示0和1</p><h2 id="非归零反相编码-NRZI"><a href="#非归零反相编码-NRZI" class="headerlink" title="　非归零反相编码 NRZI"></a>　非归零反相编码 NRZI</h2><p>信号反转与否代表0和1</p><p>USB使用NRZI编码进行传输</p><p>不具有自同步特性，但可以使用前同步码的方式进行同步</p><p>对于连续的多个1，需要进行比特填充，每7个连续的1之后插一个0</p><h1 id="带通调制方法"><a href="#带通调制方法" class="headerlink" title="带通调制方法"></a>带通调制方法</h1><p>调幅</p><p>调频</p><p>调相</p><p><img src="IMG_1616.PNG" alt></p><p>正交振幅调制</p><h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><h2 id="极限传输速率"><a href="#极限传输速率" class="headerlink" title="极限传输速率"></a>极限传输速率</h2><p>信道极限传输速率：</p><script type="math/tex; mode=display">C = W \log_2(1 + \frac{S}{N})</script><p>$W$ 为带宽，单位是Hz</p><p>$S$ 为信号的平均功率</p><p>$N$ 为信道内部高斯噪声功率</p><h2 id="信噪比"><a href="#信噪比" class="headerlink" title="　信噪比"></a>　信噪比</h2><p>信号的平均功率比上噪声的平均功率</p><script type="math/tex; mode=display">\frac{S}{N}</script><p>以分贝为单位的信噪比</p><script type="math/tex; mode=display"> 10 \log_{10} (\frac{S}{N})</script><p>给出分贝计算出比值，进而计算出极限传输速率</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>理论上讲，只要信道传输速率低于信道极限传输速率，就一定能实现无差错传输</p><p>在存在高斯白噪声的信道中，最大传输速率为</p><script type="math/tex; mode=display">\begin{align}C &= B \times \log_2(1 + \frac{S}{N}) \\&= B \times \log_2(1 + \frac{S}{n_0 B})\end{align}</script><p>也就是说噪声功率是受带宽影响的，当带宽增大时，噪声也会随之增大，因此无法无限制提高带宽</p><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><ul><li><p>双绞线 </p><ul><li><p>有屏蔽的双绞线  STP</p></li><li><p>无屏蔽的双绞线  UTP</p></li><li><p>光纤</p><ul><li>单模光纤<ul><li>高能量、长距离，需要激光源，成本高</li><li>1310nm 1510nm</li></ul></li><li>多模光纤<ul><li>传输速度低、距离短、整体性能差，但成本低</li><li>850nm</li></ul></li></ul></li></ul></li><li><p>地面微波接力</p></li><li><p>卫星通信</p></li></ul><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>每个用户被分配一个频带,不同的用户在相同时间内使用不同的频带</p><h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>把时间划分为若干时分复用帧,每一个用户所占用的时隙周期性出现\</p><p>又分同步时分复用和异步时分复用</p><p>时分复用中时隙预先分配且保持不变,可能会造成时隙浪费</p><h2 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h2><p>又叫异步时分复用</p><p>能够动态按需分配时隙</p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="　波分复用"></a>　波分复用</h2><p>一根光纤上同时传送多个不同的光载波</p><p>波分复用就是光的频分复用</p><p>使用掺铒光纤放大器</p><h2 id="码分复用-码分多址"><a href="#码分复用-码分多址" class="headerlink" title="码分复用 / 码分多址"></a>码分复用 / 码分多址</h2><p>CDMA 码分多址</p><p>每个站有自己的码片序列,对于1,发送自己码片的源码,对于0,发送自己码片的二进制反码(按位取反)</p><p>码片序列中用-1表示0</p><p>各个站点之间的码片相互正交</p><script type="math/tex; mode=display">S \cdot T = \frac{1}{m} \sum_{i=1}^m S_iT_i = 0</script><p>任何一个码片向量和该码片向量自己的规格化内积都是1</p><script type="math/tex; mode=display">S \cdot S = \frac{1}{m}\sum_{i=1}^mS_iS_i = \frac{1}{m}\sum_{i=1}^m S_i^2 = 1</script><p>任何一个码片向量和该码片反码的向量的规格化内积值为-1</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>共有四个站进行码分多址CDMA通信.四个站的码片序列为：<br>A.(-1 -1 -1 +1 +1 -1 +1 +1) B.(-1 -1 +1 -1 +1 +1 +1 -1)<br>C.(-1 +1 -1 +1 +1 +1 -1 -1) D.(-1 +1 -1 -1 -1 -1 +1 -1)<br>现收到这样的码片序列：（-1 +1 -3 +1 -1 -3 +1 +1）.问哪个站发送了数据?发送数据的站发送的是1,还是0?</p><p>分别计算正交和,结果是1说明发了1,结果是-1说明发了0,结果是0说明没发</p><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="数字传输系统-PCM-方法"><a href="#数字传输系统-PCM-方法" class="headerlink" title="数字传输系统 PCM 方法"></a>数字传输系统 PCM 方法</h2><p>取样量化编码</p><h2 id="SONET-同步光纤网"><a href="#SONET-同步光纤网" class="headerlink" title="SONET 同步光纤网"></a>SONET 同步光纤网</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习笔记，学的时候没整理，欠的还是要还&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习指北</title>
    <link href="http://ilern.github.io/2020/12/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    <id>http://ilern.github.io/2020/12/27/操作系统复习指北/</id>
    <published>2020-12-27T02:44:25.000Z</published>
    <updated>2020-12-27T09:59:28.554Z</updated>
    
    <content type="html"><![CDATA[<p>期末复习用，主要是上课画的重点</p><a id="more"></a><h1 id="Chapter-1-导论"><a href="#Chapter-1-导论" class="headerlink" title="Chapter 1 导论"></a>Chapter 1 导论</h1><p>buffer 和 Cache 的区别与联系</p><ul><li><strong>Buffer</strong>是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。</li><li><strong>Cache</strong>则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</li></ul><p>软中断</p><h1 id="Chapter-2-操作系统结构"><a href="#Chapter-2-操作系统结构" class="headerlink" title="Chapter 2 操作系统结构"></a>Chapter 2 操作系统结构</h1><h1 id="Chapter3-进程"><a href="#Chapter3-进程" class="headerlink" title="Chapter3 进程"></a>Chapter3 进程</h1><h1 id="Chapter-4-线程"><a href="#Chapter-4-线程" class="headerlink" title="Chapter 4 线程"></a>Chapter 4 线程</h1><h1 id="Chapter-5-同步"><a href="#Chapter-5-同步" class="headerlink" title="Chapter 5 同步"></a>Chapter 5 同步</h1><h1 id="Chapter-6-进程调度"><a href="#Chapter-6-进程调度" class="headerlink" title="Chapter 6 进程调度"></a>Chapter 6 进程调度</h1><h1 id="Chapter-7-死锁"><a href="#Chapter-7-死锁" class="headerlink" title="Chapter 7 死锁"></a>Chapter 7 死锁</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;期末复习用，主要是上课画的重点&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://ilern.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-运输层</title>
    <link href="http://ilern.github.io/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/12/21/计算机网络复习笔记-运输层/</id>
    <published>2020-12-21T06:38:14.000Z</published>
    <updated>2021-01-03T09:01:29.724Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络中最难/复杂的部分</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层考虑的是两个应用进程间的逻辑通信，端到端的通信，端口到端口的通信</p><p>运输层支持复用和分用，不同进程向下提供给网络层，使用一样的服务，由网络层传上来的内容经过运输层的分用发给不同进程</p><p>TCP提供一条全双工的可靠信道</p><p>UDP提供不可靠信道，但是胜在快</p><p>DCCP提供双向单播拥塞控制连接但不可靠的协议，无连接不可靠但仍有拥塞控制</p><p>SCTP</p><ol><li>是面向消息的，</li><li>在socket种TCP只能绑定一个IP，但SCTP可以绑定多个IP，只要其中由一对IP能通， 这条SCTP连接就还可用</li><li>多流独立有序、无序传输</li><li>需要四次握手</li><li>使用心跳机制来管理路径的可用性，如果一条连接上的连续传输失败次数大于连接最大重传次数，就会通知应用程序并关闭连接</li></ol><h1 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP User Datagram Protocol"></a>UDP User Datagram Protocol</h1><p>只在IP之上增加了 <em>复用分用</em>、<em>差错检测</em> 的功能</p><p>不提供 <em>确认</em> 和 <em>重传</em> 的功能，这两个功能需要序号，然而UDP不带序号</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>无连接</p><p>使用尽最大努力交付，不可靠</p><p>面向<strong>报文</strong></p><p>没有拥塞控制，<font color="red">UDP无连接且不带拥塞控制不代表只要无连接就不带拥塞控制</font></p><p>UDP支持一对一、一对多、多对一、多对多的交互通信</p><p>UDP的首部开销小，只有8字节，而TCP有20字节</p><h2 id="如何理解UDP是面向报文的"><a href="#如何理解UDP是面向报文的" class="headerlink" title="如何理解UDP是面向报文的"></a>如何理解UDP是面向报文的</h2><p>UDP把应用层交下来的报文添加头部后就交给网络层，应用层交给UDP多长的报文UDP就发送多长的报文，<strong>既不合并，也不拆分</strong></p><p>接收方接收到UDP报文后去掉头部后一次交付给上层，一次交付一个完整的报文</p><p>因此应用层应当选择恰当的报文长度，若太长则会引发IP分片，若太短则使IP首部相对过大，传输效率低</p><h2 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h2><p><img src="IMG_5691.PNG" alt></p><p>计算检验和时需要把伪首部和UDP数据报连接在一起，检验和是为了检测<strong>整个UDP报文</strong>是否出错</p><p>伪首部是为了二次验证</p><p>计算检验和时先填充、然后以两个字节为单位对整个UDP报文进行二进制反码求和</p><h1 id="TCP-Transport-Control-Protocol"><a href="#TCP-Transport-Control-Protocol" class="headerlink" title="TCP Transport Control Protocol"></a>TCP Transport Control Protocol</h1><p>面向连接，提供<strong>点对点</strong>的全双工服务</p><p>使用socket连接，socket包括IP地址和端口号</p><p>TCP提供可靠交付的服务，有顺序控制、重发机制、端到端校验和、拥塞控制的功能</p><font color="red"> <strong> TCP面向字节流  </strong> </font> <h2 id="报文段格式"><a href="#报文段格式" class="headerlink" title="报文段格式"></a>报文段格式</h2><p><img src="IMG_1597.PNG" alt="IMG_1597.PNG"></p><p>序号</p><ul><li>TCP的每一个字节都有一个序号，首部中的序号字段是本报文段发送的数据的第一个字节的序号</li></ul><p>确认号</p><ul><li>期望收到对方的下一个报文段的数据的第一个字节的序号</li></ul><p>数据偏移（首部长度）</p><ul><li>以四字节为计算单位</li></ul><p>保留</p><ul><li>目前全为0</li></ul><p>六个标志位</p><ul><li>URG 紧急标志，表明高优先级的数据，不排队、不进缓存、直接提交</li><li>ACK 确认标志，当ACK为1时确认号才有效</li><li>PSH 推送标志，用不到</li><li>RST 复位标志，出现重大差错，需要重新建立连接</li><li>SYN 同步标志， 表示是一个连接请求或连接接受报文</li><li>FIN  终止标志，用于释放连接</li></ul><p>窗口</p><ul><li>以字节为单位，告知对方自己的接受能力，从而使对方设置发送窗口的大小</li><li>16位，两个字节，因此窗口最大为$2^{16} - 1$</li></ul><p>检验和</p><ul><li>检验首部和数据部分，计算时要在报文段的前面加上12字节的伪首部</li></ul><p>紧急指针</p><ul><li>配合URG使用，指出紧急数据共有多少字节</li></ul><p>选项</p><ul><li>选项的一般格式为类型一字节、长度一字节、信息若干字节，总和最长40字节</li></ul><p><img src="https://img-blog.csdnimg.cn/20190304204418902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwOTY5MDA=,size_16,color_FFFFFF,t_70" alt></p><ul><li>MSS Maximum Segment Size TCP报文中数据字段的最大长度，可以限制分片的产生，两个方向的MSS可以不同</li><li>窗口扩大选项，窗口最大$2^{16} - 1$，有些长肥管道的时延带宽积非常大，即使窗口到达最大也无法填满信道，此时可以使用窗口扩大因子进行扩大。<ul><li>窗口扩大因子实际是移位数，假设TCP头部中的通告窗口大小为$N$，窗口扩大因子（位移数）是$M$，那么TCP报文段的实际接收通告窗口大小为：$N \times 2 ^ M$。M的取值范围为0 ～ 14</li><li>这样能把窗口最大 扩大到$2^{16 + 14} = 2^{30} = 1G$</li><li>没有那么细致，毕竟只是移位</li></ul></li><li>时间戳，防止序列号回绕，乱序时间判断的依据，计算RTT</li><li>SACK，4号表示支持SACK，5号是SACK的内容，最多三个SACK块</li></ul><p>填充</p><ul><li>整个首部长度需要是4字节的整数倍</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="停止等待协议-（自动重传请求-ARQ协议-Automatic-Repeat-Request）"><a href="#停止等待协议-（自动重传请求-ARQ协议-Automatic-Repeat-Request）" class="headerlink" title="停止等待协议 （自动重传请求 ARQ协议 Automatic Repeat Request）"></a>停止等待协议 （自动重传请求 ARQ协议 Automatic Repeat Request）</h3><p>A向B发送一个分组，B收到后向A进行确认，A收到确认后发送下一个分组</p><p>A发送结束后设置一个超时重传计时器<font color="blue"> &lt;第一个计时器&gt; </font>, 超过等待时间没有收到确认就认为分组丢失，重新发送</p><p>A发送后需要保存一个刚刚发送的报文的副本，收到B的确认后再撤销计时器和副本</p><p>分组和确认分组都需要编号，从而明确收到的确认分组对应于发出去的哪个分组</p><p>分组正确到达B但是没有收到确认，存在两种可能</p><ul><li>确认丢失，重传之后B丢弃重复分组，再次发送确认；</li><li>确认迟到，B收到重传的重复分组，丢弃，A收到迟到的确认报文，什么也不做</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="　缺点"></a>　缺点</h4><p>信道利用率很低，利用率为Ｕ，则</p><script type="math/tex; mode=display">U = \frac{T_D}{T_D + RTT + T_A}</script><p>其中$T_D$是发送时间，$T_A$是发送ACK的时间</p><p>可以使用流水线传输的方式提高效率、</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>只对按序到达的最后一个分组发送确认</p><p>优点是及时确认丢失也不必重传，前面的ACK丢失，后续的ACK可能足以确认前面的报文段了</p><p>缺点是不能向发送方反映出接受方已经城阙收到的所有分组的信息</p><h4 id="Go-back-N"><a href="#Go-back-N" class="headerlink" title="Go back N"></a>Go back N</h4><p>部分分组丢失后发送方只收到一个靠前的ACK，此时需要退回来重传已经发送过的N个分组</p><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>最大为$2^{16}-1$</p><p>发送方和接收方各有一个缓冲（Buffer）</p><p>对于发送方而言，其缓冲数据内的数据可以分为四类</p><p><img src="https://pic1.zhimg.com/80/a1d5c050ad957880094a5f003b1ccd24_720w.png" alt></p><p>其中第二类和第三类在一个发送窗口中</p><p>收到累计确认后，窗口右移 </p><p>对于接收方而言，他的缓冲数据中存在三类，已接收，未接受准备接收，未接受未准备接收</p><p>所谓已接收实际意味着已发送确认，ACK由TCP协议栈回复，不需要等进程回复，因此不存在已接收未回复</p><p>其中<strong>未接受准备接收</strong>就是接收窗口，似乎说成未确认准备确认更合适一些？</p><h4 id="发送窗口和接收窗口的关系"><a href="#发送窗口和接收窗口的关系" class="headerlink" title="发送窗口和接收窗口的关系"></a>发送窗口和接收窗口的关系</h4><p><img src="https://pic4.zhimg.com/80/c798dd393fcf7c03b1db78f5bcf0304b_720w.png" alt></p><h4 id="利用滑动窗口实现可靠传输"><a href="#利用滑动窗口实现可靠传输" class="headerlink" title="利用滑动窗口实现可靠传输"></a>利用滑动窗口实现可靠传输</h4><p>最基本的传输可靠性来自于<strong>确认重传</strong>机制，滑动窗口是实现确认重传的一种方式</p><p>发送端只有在收到对端发送的对于己方发送窗口内的字节的ACK且前面全都完成确认的情况下窗口的左边界才会移动（绕）</p><p>对于已有的确认不能撤销，因此左边沿不能左移</p><p>右边沿通常是不动和右移，在收到缩小窗口大小的信号后可能左移，但是非常不推荐</p><p>举个例子</p><p><img src="IMG_1599.PNG" alt></p><h4 id="Buffer-和窗口的关系"><a href="#Buffer-和窗口的关系" class="headerlink" title="Buffer 和窗口的关系"></a>Buffer 和窗口的关系</h4><p><img src="IMG_1600.PNG" alt></p><p><img src="IMG_1601.PNG" alt></p><h4 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h4><ul><li>发送窗口根据对方的接收窗口进行设置， 但是两者并不总是相等，因为网络传送窗口值是有延迟的</li><li>对于不按序到达的数据，TCP通常是临时存放在接收窗口中，在字节流中缺少的字节收到后再交付给上层（SACK？）</li><li>接收方必须支持累计确认，可以适当推迟确认，也可以捎带确认、</li></ul><h3 id="超时重传时间-RTO-的选择"><a href="#超时重传时间-RTO-的选择" class="headerlink" title="超时重传时间 RTO 的选择"></a>超时重传时间 RTO 的选择</h3><p>为什么需要考虑超时重传时间？</p><p>重传时间过短会引起不必要的重传，占用资源；重传时间过长会导致空闲，降低传输效率</p><p>TCP通过RTT来计算RTO</p><script type="math/tex; mode=display">\begin{align}newRTO &= newRTT_S + 4 \times newRTT_D \\newRTT_S & = (1 - \alpha)RTT_S + \alpha RTT \\newRTT_D & = (1 - \beta)RTT_D + \beta |RTT_ S - RTT|\\end{align}</script><p>第一次测量到$RTT$时，$RTT_S = RTT$，$RTT_D = \frac{RTT}{2}$</p><p>因此第一次测量到$RTT$时，$RTO = RTT + 4 \times \frac{RTT}{2} = 3RTT$</p><p>因为$newRTT_D$需要用到$RTT_S$，所以应该先算，如果先算$RTT_S$，旧的值就被覆盖了</p><p>$\alpha = \frac{1}{8}, \beta = \frac{1}{4}$</p><h4 id="一个题目"><a href="#一个题目" class="headerlink" title=" 一个题目 "></a><font color="red"> 一个题目 </font></h4><blockquote><p>假定TCP在开始建立连接时，发送方设定的超时重传时间$RTO = 6s$</p><p>（1）当发送方收到对方的连接确认报文段时，测量出$RTT$样本值为$1.5s$，计算现在的$RTO$值</p><p>（2）当发送方发送数据报文段并收到确认时，测量出$RTT$样本值为$2.5s$，计算现在的$RTO$值</p></blockquote><p>首先要明确$RTO$的计算和初始值没有任何关系，$6s$ 是一个干扰数据</p><p>第一问：</p><p>第一次测得 $RTT$ 时 $RTO  = 3RTT = 4.5s$</p><p>此时$RTT_S = 1.5, RTT_D = 0.75$</p><p>第二问：</p><p>$newRTT_D = \frac{3}{4} \times 0.75 + \frac{1}{4}|1.5 - 2.5| = \frac{13}{16}$</p><p>$newRTT_S = \frac{7}{8} \times 1.5 + \frac{1}{8} \times 2.5 = \frac{26}{16}$</p><p>$newRTO = newRTT_S + 4RTT_D = \frac{78}{16} = 4.875$    </p><h4 id="Karn-算法"><a href="#Karn-算法" class="headerlink" title="Karn 算法"></a>Karn 算法</h4><p>计算RTT时，如果报文段重传了就不计入往返时间样本</p><p>存在一个问题，如果由于某种神秘力量，时延突然增加，在原本的时间内就收不到确认，发起重传，但是重传的RTT又不被采用，就会导致一直无法更新重传时间</p><h4 id="修正的-Karn-算法"><a href="#修正的-Karn-算法" class="headerlink" title="修正的 Karn 算法"></a>修正的 Karn 算法</h4><p>每重传一次，RTO就增大一些</p><script type="math/tex; mode=display">newRTO = \gamma RTO, \gamma = 2</script><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>双方必须事先商定好</p><p>在选项部分中指明收到的 <strong>不连续字节块</strong> 的边界</p><p>一个SACK报文最多只能指明三个字节块的边界信息</p><ul><li>首部选项部分长度最多四十字节，一个边界用掉四字节，去掉类型和长度</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>控制发送方不要发得太快</p><h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><p>对于接收方发出的每一个ACK，都包含自己的接收窗口大小，表示自己还能接受多少数据，发送方收到之后调整自己的发送窗口</p><p>会带来死锁的局面，当接收窗口为0时发送端便不再发送数据，但是如果接收方之后发送的非零窗口大小的报文丢失了，发送端就永远无法得知接收端已经准备好接收数据，从而产生死锁的情况</p><h3 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h3><p>为了解决死锁的情况，TCP为每一个连接设置了一个持续计时器<font color="blue"> &lt;第二个计时器&gt; </font></p><p>如果持续计时器到时，发送方就向接收方发送一个零窗口探测报文段，若不是零，则在AC中告知，如果仍然是零，发送方就重设计时器</p><h3 id="流量控制下的传输效率-发送时机"><a href="#流量控制下的传输效率-发送时机" class="headerlink" title="流量控制下的传输效率 / 发送时机"></a>流量控制下的传输效率 / 发送时机</h3><ol><li><p>维护一个MSS Max Segment Size，缓冲中存放的数据大于MSS时组装成一个TCP报文发出去</p></li><li><p>发送方的进程显式push</p></li><li>发送方设置一个发送计时器，把缓冲中的数据装入报文段（长度不超过MSS）</li></ol><h4 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h4><p>对于小数据量的传送，Nagle算法会将他们写入缓冲区，累计到一定数目后再一起发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if有新資料要傳送</span><br><span class="line">  if訊窗大小&gt;= MSS and可傳送的資料&gt;= MSS</span><br><span class="line">    立刻傳送完整MSS大小的segment</span><br><span class="line">  else</span><br><span class="line">   if管線中有尚未確認的資料</span><br><span class="line">     在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列</span><br><span class="line">   else</span><br><span class="line">     立即傳送資料</span><br></pre></td></tr></table></figure><p>在任意时刻，网络中最多只能有一个未被确认的小段，在收到确认后才会发送，也就是说发送的频率取决于RTT，是一种自时钟，ACK返回越快，数据传输也就越快。</p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>由于发送方发送能力差（产生数据慢）或者接收方处理能力差（消耗数据慢）导致了发送窗口越来越小，以至于一次只能发送一个字节，造成巨大的浪费</p><p>发送端采用Nagle算法进行问题避免，发送端累计数据到MSS之后进行发送</p><p>接收端采用<code>David D Clark&#39;s solution</code>进行问题避免，暂时关闭接收窗口直到有能容纳MSS的空间；或者使用延迟确认的方法，不立即发送ACK，发送端会一直等待，直到接收方空间够了再发送ACK</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞是一个系统性的问题，仅仅优化局部往往难以解决问题</p><p>流量控制是局部，拥塞控制是全局</p><p>拥塞控制并不能真正控制拥塞，只是让拥塞晚一点来</p><p>拥塞控制是动态的问题</p><h3 id="慢开始-amp-拥塞避免"><a href="#慢开始-amp-拥塞避免" class="headerlink" title="慢开始 &amp; 拥塞避免"></a>慢开始 &amp; 拥塞避免</h3><p>基于窗口的拥塞控制</p><p>发送方维护一个拥塞窗口cwnd，其随着网络状态动态变化，发送方的窗口为对方的接收窗口和拥塞窗口的较小值</p><p>只要没有出现拥塞，拥塞窗口就再增大一点，以便发送更多的分组，一旦出现拥塞，拥塞窗口就减小一点</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li><p>初始情况下设置拥塞窗口大小为1 MSS</p></li><li><p>每收到一个新的报文段的确认，窗口大小加一（以MSS为单位）</p><ol><li>是一个一个增加的，但是在一个传输轮次中的表现是经过一个轮次窗口大小加倍</li><li>一个传输轮次就是一个RTT</li><li>这段时间cwnd以指数规律增长</li></ol><p><img src="IMG_1607.PNG" alt></p></li><li><p>随着cwnd不断增加，会到达一个阈值，之后每一轮cwnd只增加一</p><ol><li>这个部分为拥塞避免，方法为加法增大</li></ol></li><li><p>当网络拥塞发生后，cwnd回到初始值，阈值被重新设定为网络拥塞发生时cwnd大小的一般，重新进行慢开始</p><ol><li>减小阈值的操作被称为乘法减小</li></ol></li></ol><p><img src="IMG_1608.PNG" alt></p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>接收方每收到一个失序报文段后就立即发送重复确认，这样可以让发送方尽早直到有报文段没有到达接收方</p><p>发送方只要连续三次收到重复确认，就重发</p><p><strong>没有取消超时重传计时器</strong>，但是在部分情况下可以更快重发</p><p><img src="IMG_1609.PNG" alt></p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>发送方收到三个重复确认后立即执行乘法减小，修改阈值，但是此时并不从一开始，而是直接从新的阈值开始进行加法增大</p><p>超时执行慢开始，三个重复确认执行快恢复</p><p><img src="IMG_1610.PNG" alt></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="Tahoe"><a href="#Tahoe" class="headerlink" title="Tahoe"></a>Tahoe</h4><p>旧的算法，没有快恢复，在恢复丢失数据报期间不能发送新的数据包，因为此时的已发送未确认大于窗口值</p><h4 id="Reno"><a href="#Reno" class="headerlink" title="Reno"></a>Reno</h4><p>相比Tahoe增加了快恢复</p><h4 id="NewReno"><a href="#NewReno" class="headerlink" title="　NewReno"></a>　NewReno</h4><p><strong>Reno</strong>提出的快速恢复算法提高了包丢失后的吞吐量和健壮性，但缺陷是它只考虑了只丢失一个包的情形，只要丢失了一个包，就被认为是发生了一次拥塞。</p><p>在实际的网络中，一旦发生拥塞，会丢弃大量的包。如果采用<strong>Reno</strong>算法，它会认为网络中发生了多次拥塞，则会多次将<code>cwnd</code>和<code>ssthresh</code>减半，造成吞吐量极具下降，当发送窗口小于3时，将无法产生足够的ACK来触发快重传而导致超时重传，超时是很严重的事情。</p><p>在只丢失一个数据包的情况下，<strong>NewReno</strong>和<strong>Reno</strong>的处理方法是一致的，而在同一个时间段丢失了多个包时，<strong>NewReno</strong>做出了改进。<br><strong>Reno</strong>快速恢复算法中，发送方只要收到一个新的ACK就会退出快速恢复状态而进入拥塞避免阶段，<strong>NewReno</strong>算法中，只有当所有丢失的包都重传并收到确认后才退出。</p><p>NewReno提出了PACK和RACK，在重传完成之前的ACK都是PACK，只有收到RACK之后才会结束快恢复</p><h4 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h4><p>Reno的衍生版本，允许使用SACK来告知接收端自己收到了哪些部分</p><p>但是对于肠肥管道而言，每次告知对方自己收到了哪些部分的代价是很大的，此时的SACK会消耗大量的资源</p><p><img src="IMG_1611.PNG" alt></p><h4 id="随机早期检测-RED-Random-Early-Detection"><a href="#随机早期检测-RED-Random-Early-Detection" class="headerlink" title="随机早期检测 RED Random Early Detection"></a>随机早期检测 RED Random Early Detection</h4><p>网络的主体部分是通信子网，上述算法都是从端系统的角度来考虑的，其实对拥塞影响最大的是路由器的丢弃算法。</p><p>RED将路由器的到达队列划分为了三个部分</p><p><img src="IMG_1612.PNG" alt></p><p>通常而言最大阈值是最小阈值的两倍，如果阈值设置不合适，RED也会引起类似于尾部丢弃导致的全局震荡</p><p>对于P丢弃，P并不是一个确定的值，而是会随着当前的<strong>平均队列长度</strong>不断变化</p><p>平均队列长度的计算</p><script type="math/tex; mode=display">newL_{AV} = (1 - \delta)  L_{AV} + \delta L</script><p>$L$表示当前队列长度的样本，$L_{AV}$是旧的平均队列长度，计算方式和RTO的计算很像，$\delta$ 是零到一之间的数。</p><h2 id="TCP的建立与释放"><a href="#TCP的建立与释放" class="headerlink" title="TCP的建立与释放"></a>TCP的建立与释放</h2><p>大名鼎鼎的三次握手</p><p><img src="IMG_1613.PNG" alt></p><p>TCP的连接实际上是一种<strong>虚连接</strong>，只是维护一些状态值而已</p><p>SYN=1的报文段不携带数据，但是要消耗掉一个序号，因为SYN报文段需要确认，而确认是需要序号的</p><p>ACK报文段可以携带数据（捎带确认），但是如果不携带数据，则不消耗序号，因为不需要对ACK进行确认</p><p>说白了序号就是为了确认，不需要确认就不用序号</p><p><img src="IMG_1617.PNG" alt></p><p>主动关闭一方发送的序号不是随机值,而是发送到这个值了</p><p>被动关闭放的ACK不消耗序号</p><p>此时TCP连接处于半关闭状态</p><p>在左侧发送完最后的确认之后进行一个$2 \times MSL$的计时,使用时间等待计时器 <font color="blue"> &lt;第三个计时器&gt; </font></p><p>MSL为最长报文段寿命</p><p>这个计时器是为了保证A发送的最后一个ACK能到达B,且这个连接持续时间中的所有报文段在网络中失效</p><p>为了防止TCP出现长时间的空闲,通常还有一个保活计时器 <font color="blue"> &lt;第四个计时器&gt;</font></p><p>超时之后每隔一段时间发送一个探测报文段,发送十个探测报文段还没有收到响应就假定客户除了故障,主动终止TCP连接</p><h2 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h2><p><img src="https://upload-images.jianshu.io/upload_images/2846604-6a8557619966204d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络中最难/复杂的部分&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（五）</title>
    <link href="http://ilern.github.io/2020/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/12/17/操作系统实验笔记（五）/</id>
    <published>2020-12-17T02:12:21.000Z</published>
    <updated>2020-12-30T08:52:16.374Z</updated>
    
    <content type="html"><![CDATA[<p>调了很久之后发现是<code>shmget()</code>写成了<code>semget()</code>导致共享内存段attach失败，但是Shell没给提示，一开始以为是死锁了各种检查信号量，最后gdb跑了一下发现是段错误了，顺便学习了怎样用gdb调试多进程并发的程序</p><a id="more"></a><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>用于同步和互斥</p><p>当信号量用于表示资源数量协助我们进行资源分配与回收时，不一定只在零一之间变动</p><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p>创建信号量集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span></span><br></pre></td></tr></table></figure><p><code>semnum</code>是信号量的下标，<code>cmd</code>是操作的动作</p><p><code>cmd</code>使用<code>SETVALUE</code>设置某个信号量的值</p><p><code>cmd</code>使用<code>SETALL</code>设定一组信号量的值</p><p><code>NOWAIT</code>进行一个尝试，不阻塞</p><p><code>UNDO</code>意外退出没有V的时候会自动V，推荐使用</p><h2 id="并发时进程映像的替换"><a href="#并发时进程映像的替换" class="headerlink" title="并发时进程映像的替换"></a>并发时进程映像的替换</h2><p>exec函数族</p><p><code>execl(const char *path, const char *arg, ...)</code> 参数数量不确定</p><p><code>execv(const char *path, char *const argv[])</code></p><p>拿指定的静态的可执行文件，覆盖当前进程的进程映像中的代码和数据，除了PID以外全都换了</p><p>不创建新的进程</p><p>fork之前，父子进程需要共享的内存、信号量、管道，要打开</p><p><img src="IMG_5788.png" alt></p><h2 id="信号量与共享内存共用并使用信号量同步"><a href="#信号量与共享内存共用并使用信号量同步" class="headerlink" title="信号量与共享内存共用并使用信号量同步"></a>信号量与共享内存共用并使用信号量同步</h2><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>以随机间隔生成随机字母并完成大小写转换</p><p>三进程并发，进程1生成字母，进程2大小写转换，进程3输出转换结果，每生成一个随机字母流水线就动一圈</p><p>进程1和进程2之间用共享内存段<code>shm_1</code>通信，进程2和进程3之间用共享内存段<code>shm_2</code>通信</p><p>使用四个信号量分别实现两个共享内存段的互斥访问与访问同步</p><p><img src="IMG_5766.PNG" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem30.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semid, shm1_id, shm2_id, semkey, shm1_key, shm2_key;</span><br><span class="line">  <span class="keyword">int</span> p1, p2, p3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> semun arg;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm1_key = ftok(PATH_FOR_FTOK, <span class="string">'Y'</span>);</span><br><span class="line">  shm2_key = ftok(PATH_FOR_FTOK, <span class="string">'Z'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">4</span> ,IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">  shm1_id = shmget(shm1_key, SHM_SIZE, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">  shm2_id = shmget(shm2_key, SHM_SIZE, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  arg.<span class="built_in">array</span> = (<span class="keyword">unsigned</span> <span class="keyword">short</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span>) * <span class="number">4</span>);</span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//mutex</span></span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//the second arg is ignored</span></span><br><span class="line">  semctl(semid, <span class="number">0</span>, SETALL, arg);</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      p3 = fork();</span><br><span class="line">      <span class="keyword">if</span> (p3) &#123;</span><br><span class="line">        waitpid(p1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        waitpid(p2, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        waitpid(p3, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        semctl(semid, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">        shmctl(shm1_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">        shmctl(shm2_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(arg.<span class="built_in">array</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//chlid3</span></span><br><span class="line">        execl(<span class="string">"./sem33"</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      execl(<span class="string">"./sem32"</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    execl(<span class="string">"./sem31"</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem31.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semkey, shm1_key, semid, shm1_id;</span><br><span class="line">  <span class="keyword">int</span> seed;</span><br><span class="line">  <span class="keyword">char</span> c, *shm1_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm1_key = ftok(PATH_FOR_FTOK, <span class="string">'Y'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm1_id = shmget(shm1_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line"></span><br><span class="line">  seed = getpid();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= atoi(argv[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      c = (<span class="keyword">char</span>)(rand_r(&amp;seed) % <span class="number">128</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">isalpha</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Random letter %c\n"</span>, c);</span><br><span class="line">  </span><br><span class="line">    P(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("sem31: P(sem0)\n");</span></span><br><span class="line">    shm1_addr = (<span class="keyword">char</span>*)shmat(shm1_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("%p\n", shm1_addr);</span></span><br><span class="line">    <span class="comment">// printf("sem31: ated\n");</span></span><br><span class="line">    <span class="comment">// printf("c = %c\n", c);</span></span><br><span class="line">    shm1_addr[<span class="number">0</span>] = c;</span><br><span class="line">    <span class="comment">// printf("sem31: done\n");</span></span><br><span class="line">    shmdt(shm1_addr);</span><br><span class="line">    <span class="comment">// printf("sem31: deted\n");</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// printf("sem31: try to V(sem0)\n");</span></span><br><span class="line">    V(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("sem31: V(sem0) try to V(sem1)\n");</span></span><br><span class="line">    V(semid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf("sem31: I will sleep\n");</span></span><br><span class="line">    sleep(rand_r(&amp;seed) % <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem32.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semkey, shm1_key, shm2_key, semid, shm1_id, shm2_id;</span><br><span class="line">  <span class="keyword">char</span> c, *shm1_addr = <span class="literal">NULL</span>, *shm2_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm1_key = ftok(PATH_FOR_FTOK, <span class="string">'Y'</span>);</span><br><span class="line">  shm2_key = ftok(PATH_FOR_FTOK, <span class="string">'Z'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm1_id = shmget(shm1_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm2_id = shmget(shm2_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= atoi(argv[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="comment">// printf("sem2: try to P(sem1)\n\twaiting\n");</span></span><br><span class="line">    P(semid, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf("sem2: try to P(sem0)\n");</span></span><br><span class="line">    P(semid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    shm1_addr = (<span class="keyword">char</span>*)shmat(shm1_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    c = shm1_addr[<span class="number">0</span>];</span><br><span class="line">    shmdt(shm1_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read c = %c\n"</span>, c);</span><br><span class="line">    V(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("sem2: V(sem0)\n");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    <span class="keyword">else</span> c = <span class="built_in">tolower</span>(c);</span><br><span class="line"></span><br><span class="line">    P(semid, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    shm2_addr = (<span class="keyword">char</span>*)shmat(shm2_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    shm2_addr[<span class="number">0</span>] = c;</span><br><span class="line">    shmdt(shm2_addr);</span><br><span class="line"></span><br><span class="line">    V(semid, <span class="number">2</span>);</span><br><span class="line">    V(semid, <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem33.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semkey, shm2_key, semid, shm2_id;</span><br><span class="line">  <span class="keyword">char</span> c, *shm2_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm2_key = ftok(PATH_FOR_FTOK, <span class="string">'Z'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm2_id = shmget(shm2_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= atoi(argv[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    P(semid, <span class="number">3</span>);</span><br><span class="line">    P(semid, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    shm2_addr = (<span class="keyword">char</span>*)shmat(shm2_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    c = shm2_addr[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After transform %c\n"</span>, c);</span><br><span class="line">    shmdt(shm2_addr);</span><br><span class="line"></span><br><span class="line">    V(semid, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是信号量的使用，四个信号量分别为</p><div class="table-container"><table><thead><tr><th>信号量</th><th>初始值</th><th>用途</th></tr></thead><tbody><tr><td>sem0</td><td>1</td><td>互斥 shm_1</td></tr><tr><td>sem1</td><td>0</td><td>同步进程1进程2</td></tr><tr><td>sem2</td><td>1</td><td>互斥 shm_2</td></tr><tr><td>sem3</td><td>0</td><td>同步进程2进程3</td></tr></tbody></table></div><p>进程1需要先获得<code>shm_1</code>的互斥访问权，等待信号量<code>sem0</code>，将生成的随机字母写入<code>shm_1</code>，然后释放信号量<code>sem0</code></p><p>进程2必须在进程1之后进行，因此进程2应当先等待信号量<code>sem1</code>，进程1在结束后会<code>signal(sem1)</code>唤醒进程2；被唤醒之后进程2取得对<code>shm_1</code>的互斥访问权，读取字母并进行大小写转换，然后释放<code>sem0</code>；接下来进程2取得对<code>shm_2</code>的互斥访问权，把转换后的结果写入<code>shm_2</code>，释放信号量<code>sem1</code></p><p>进程3必须在进程2之后进行，因此进程2应当先等待信号量<code>sem3</code>，进程2在结束后会<code>signal(sem3)</code>唤醒进程3；被唤醒之后进程3取得对<code>shm_2</code>的互斥访问权，读取字母并进行大小写转换，然后释放<code>sem2</code>；</p><p>P操作为wait，V操作为signal，两个操作写在单独的文件里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem3pv.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sops</span> = &#123;</span>semnum, <span class="number">-1</span>, SEM_UNDO&#125;;</span><br><span class="line">  <span class="keyword">return</span> semop(semid, &amp;sops, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sops</span> = &#123;</span>semnum, +<span class="number">1</span>, SEM_UNDO&#125;;</span><br><span class="line">  <span class="keyword">return</span> semop(semid, &amp;sops, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个作业分为五个c文件和一个头文件</p><p><img src="IMG_5777.png" alt></p><p>使用makefile进行自动化编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: sem31 sem32 sem33 sem30</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"></span><br><span class="line"><span class="section">sem31: sem31.c sem3pv.o sem3.h</span></span><br><span class="line">gcc -c sem31.c</span><br><span class="line">gcc -o sem31 sem31.o sem3pv.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem32: sem32.c sem3pv.o sem3.h</span></span><br><span class="line">gcc -c sem32.c</span><br><span class="line">gcc -o sem32 sem32.o sem3pv.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem33: sem33.c sem3pv.o sem3.h</span></span><br><span class="line">gcc -c sem33.c</span><br><span class="line">gcc -o sem33 sem33.o sem3pv.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem30: sem30.c sem3.h</span></span><br><span class="line">gcc -c sem30.c</span><br><span class="line">gcc -o sem30 sem30.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem3pv.o: sem3pv.c</span></span><br><span class="line">gcc -c sem3pv.c -g</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调了很久之后发现是&lt;code&gt;shmget()&lt;/code&gt;写成了&lt;code&gt;semget()&lt;/code&gt;导致共享内存段attach失败，但是Shell没给提示，一开始以为是死锁了各种检查信号量，最后gdb跑了一下发现是段错误了，顺便学习了怎样用gdb调试多进程并发的程序&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（四）</title>
    <link href="http://ilern.github.io/2020/12/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/12/10/操作系统实验笔记（四）/</id>
    <published>2020-12-10T02:10:48.000Z</published>
    <updated>2020-12-30T08:53:27.427Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列通信。消息队列还是经常能听到的一个东西，比如弹幕系统实际上就是一个MQ</p><a id="more"></a><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>本质是一个128个元素的指针数组</p><p>同一条消息只能被摘一次</p><p>挂 消息块</p><p>摘 消息块</p><p>摘没有的消息块会阻塞</p><p>当有期待的消息块被挂上去，被唤醒，摘下来</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg_c.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">  msgget(key, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和共享内存块相似，需要先获取一个<code>key</code>，使用一个系统文件和一个字符进行拼接</p><p><code>IPC_CREAT | 0600</code> 表示创建的消息队列拥有者可读写，其他人不可读写执行</p><p><code>IPC_CREAR | 0666</code> 表示创建的消息队列所有人均可读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg_s.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100 <span class="comment">//size of msg</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype; <span class="comment">//消息编号 &gt; 0</span></span><br><span class="line">  <span class="keyword">char</span> text[SIZE]; <span class="comment">//消息内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key, msqid, i;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line">  </span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line">  msqid = msgget(key, IPC_EXCL);</span><br><span class="line">  </span><br><span class="line">  msg.mtype = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(msg.text, argv[<span class="number">2</span>]);</span><br><span class="line">  msgsnd(msqid, &amp;msg, SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂消息到消息队列需要把消息进行封装，就是代码中的<code>msgbuf</code></p><p>先获取消息队列，<code>msgget(key_t key, int msgflg)</code>，<code>IPC_EXCL</code>表示获取一个已经存在的消息队列</p><p>挂消息到消息队列，<code>msgsnd(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)</code>，把<code>msg</code>的地址传进去，本质是往指针数组中增加一个元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg_r.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype;</span><br><span class="line">  <span class="keyword">char</span> text[SIZE]; <span class="comment">//size of msg</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p, key, msqid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line">  msqid = msgget(key, IPC_EXCL);</span><br><span class="line"></span><br><span class="line">  msgrcv(msqid, &amp;msg, SIZE, atoi(argv[<span class="number">1</span>]), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg.text);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> msqid, key;</span><br><span class="line">  </span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line">  msqid = msgget(key, IPC_EXCL);</span><br><span class="line">  msgctl(msqid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除消息队列，先获取然后调用<code>msgctl(int msqid, int cmd, msqid_ds *buf)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列通信。消息队列还是经常能听到的一个东西，比如弹幕系统实际上就是一个MQ&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（三）</title>
    <link href="http://ilern.github.io/2020/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/12/03/操作系统实验笔记（三）/</id>
    <published>2020-12-03T02:45:26.000Z</published>
    <updated>2020-12-30T09:04:56.661Z</updated>
    
    <content type="html"><![CDATA[<p>管道通信是有局限的，共享内存段和消息队列提供了更灵活的进程间通信方式<br>不过非要说最灵活可能还是用socket</p><a id="more"></a><h1 id="共享内存通信与消息队列通信"><a href="#共享内存通信与消息队列通信" class="headerlink" title="共享内存通信与消息队列通信"></a>共享内存通信与消息队列通信</h1><h2 id="使用管道进行通信的局限"><a href="#使用管道进行通信的局限" class="headerlink" title="使用管道进行通信的局限"></a>使用管道进行通信的局限</h2><p>只能在有家族关系的进程间进行通信</p><p>大小只有4K，不好传输过大的</p><p>Socket一般用于用户进程间的通信</p><p>IP+端口可以唯一定位一台主机上的一个进程，把IP设定为127.0.0.1，可以实现本机间的两个进程通信</p><p>IPC一般用于系统间的通信</p><p>信号量使用集合的方式进行管理，Semaphores Set</p><p>共享内存 Shared Memory Segment</p><p>消息队列 Message Queue</p><p>管道由操作系统进行管理</p><p>IPC需要自己手工管理</p><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><p><code>int shmget(key_t key, size_t size, int shmflg);</code></p><p>创建一个新的共享内存段 / 关联已有的共享内存段，返回一个共享内存段的ID</p><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></p><p>获得共享内存段的地址，通常和脱离配合使用。</p><p><code>int shmdt(const void *shmaddr);</code> </p><p>脱离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。</p><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code> </p><p>操作共享内存段，如果要进行更细致的操作需要用到，在实验中用来删除共享内存段，<code>cmd</code>设定为<code>IPC_RMID</code></p><p>写是覆盖写，读是多次读。</p><p>读多少次都不会影响数据的存在，用于进程间的一对多通信，多个进程先后去读结果是一样的。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>在创建共享内存段时，可以指明共享内存段的权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(shm_key, SHM_SIZE, IPC_CREAT | <span class="number">0600</span>)</span><br></pre></td></tr></table></figure><p>在<code>flag</code>后面或上一个八进制数，这里的数字含义和<code>chomd</code>的数字含义相同，例如<code>0600</code>代表创建者可读可写</p><h2 id="生成Key"><a href="#生成Key" class="headerlink" title="生成Key"></a>生成Key</h2><p>操作系统中唯一标识共享内存段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br></pre></td></tr></table></figure><p><code>ftok()</code>使用一个路径和一个项目编号来生成一个唯一的 system V 进程间通信的 key</p><p>通常情况下<code>pathname</code>选择一个所有Linux都有的路径，比如<code>/boot</code>，<code>proj_id</code>因为只会用到低8位，通常选择一个字符常量</p><p>对于同样的参数会得到同样的key</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY 3456</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *shm_addr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//0600 only for this user's process</span></span><br><span class="line">  <span class="comment">//0666 for all process</span></span><br><span class="line">  <span class="keyword">int</span> shm_id;</span><br><span class="line">  shm_id = shmget(KEY, SIZE, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> p;</span><br><span class="line">  p = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    shm_addr = (<span class="keyword">char</span>*)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, shm_addr);</span><br><span class="line">    shmdt(shm_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//control</span></span><br><span class="line">    <span class="comment">//destroy the shared memory segment</span></span><br><span class="line">    shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//chlid</span></span><br><span class="line">    <span class="comment">//get the address of shared memory segment</span></span><br><span class="line">    <span class="comment">//shmat()</span></span><br><span class="line">    shm_addr = (<span class="keyword">char</span>*)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(shm_addr, <span class="string">"This is a message"</span>);</span><br><span class="line">    shmdt(shm_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建一个多进程并发的环境，实现共享内存段通信</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管道通信是有局限的，共享内存段和消息队列提供了更灵活的进程间通信方式&lt;br&gt;不过非要说最灵活可能还是用socket&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（二）</title>
    <link href="http://ilern.github.io/2020/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/11/26/操作系统实验笔记（二）/</id>
    <published>2020-11-26T02:24:17.000Z</published>
    <updated>2020-12-13T15:20:34.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>中断被封装成信号，多个不同的中断被封装成一个信号。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">称呼</th></tr></thead><tbody><tr><td style="text-align:center">硬件层次</td><td style="text-align:center">中断</td></tr><tr><td style="text-align:center">操作系统层次</td><td style="text-align:center">信号</td></tr><tr><td style="text-align:center">应用程序层次</td><td style="text-align:center">事件</td></tr></tbody></table></div><p>信号可以用编号、名称表示，名称是编号的宏。</p><p><img src="1.png" alt></p><h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>过滤信号，每个进程都有对signal的mask，滤掉的就忽略，没有滤掉的就响应</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><p><img src="2.png" alt></p><p>返回信号处理程序的入口指针，<code>signal()</code>根据编号设置信号处理程序</p><p><img src="3.JPG" alt></p><p>实际是修改进程PCB中的信号表中的函数指针</p><p><img src="3.png" alt></p><p>注意唤醒的时刻，4和alarm有一秒停顿，alarm和5没有间隔，说明收到信号之后进程被立即唤醒</p><p>信号什么时候到来和<code>signal()</code>没有关系</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h2><p>给某个进程发信号</p><p><img src="4.png" alt></p><p><img src="5.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><p>发9号信号给进程，表示终止进程，不能被拦截或忽略</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><p>杀死自己，返回0</p><h2 id="进程软中断通信"><a href="#进程软中断通信" class="headerlink" title="进程软中断通信"></a>进程软中断通信</h2><p>信号是传送给进程的一种事件通知，Linux 系统中所有信号均定义在头文件 中。 </p><p>信号发生时，Linux 内核可以采取下面 3 种动作之一：</p><ul><li><p>忽略信号 大部分信号可以被忽略，除 SIGSTOP 信号和 SIGKILL 例外； </p></li><li><p>捕获信号 指定动作；</p></li><li><p>信号默认动作起作用。</p></li></ul><p>编写程序，使用系统调用 <code>fork()</code>创建两个子进程，再用系统调用 <code>signal()</code>让父进程捕捉键盘上发出的中断信号(即按 ctrl+c 或是 ctrl+\键)，5 秒钟内若父进程未接收到这两个软中断的某一个，则父进程用系统调用 <code>kill()</code>向两个子进程分别发送软中断信号 <code>SIGUSR1</code> 和 <code>SIGUSR2</code>，子进程获得对应的软中断信号，然后分别输出下列信息后终止： <code>Child process (pid=?) be killed</code>！ 21<code>Child process (pid=?) be killed！</code> 父进程调用<code>wait()</code>等待两个子进程终止后，输出以下信息，结束进程执行： <code>Parent process (pid=?) finished！</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent_stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Parent process (pid = %d) be killed (get SIGINT / SIGQUIT)\n"</span>, getpid());</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Chlid process (pid = %d) be killed\n"</span>, getpid());</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">      signal(SIGINT, parent_stop);</span><br><span class="line">      signal(SIGQUIT, parent_stop);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is Parent process, pid = %d\n"</span>, getpid());</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"parent sleep\n"</span>);</span><br><span class="line">      sleep(<span class="number">3</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"parent get up\n"</span>);</span><br><span class="line"></span><br><span class="line">      kill(p1, SIGUSR1);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"kill p1\n"</span>);</span><br><span class="line">      kill(p2, SIGUSR2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"kill p2\n"</span>);</span><br><span class="line"></span><br><span class="line">      waitpid(p1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      waitpid(p2, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Parent process %d terminated\n"</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is chlid process 2, pid = %d\n"</span>, getpid());</span><br><span class="line">      </span><br><span class="line">      signal(SIGUSR1, child_stop);</span><br><span class="line">      signal(SIGUSR2, child_stop);</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child2 sleep\n"</span>);</span><br><span class="line">      sleep(<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child2 get up\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is child process 1, pid = %d\n"</span>, getpid());</span><br><span class="line">    </span><br><span class="line">    signal(SIGUSR1, child_stop);</span><br><span class="line">    signal(SIGUSR2, child_stop); </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1 sleep\n"</span>);</span><br><span class="line">    sleep(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1 get up\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h1&gt;&lt;p&gt;中断被封装成信号，多个不同的中断被封装成一个信号。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据清洗中空格的处理</title>
    <link href="http://ilern.github.io/2020/11/18/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%AD%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://ilern.github.io/2020/11/18/数据清洗中空格的处理/</id>
    <published>2020-11-18T03:26:32.000Z</published>
    <updated>2020-11-18T03:53:46.779Z</updated>
    
    <content type="html"><![CDATA[<p><code>pandas</code>中使用<code>fillna()</code>或者<code>drop()</code>来填充或丢弃包含空值的行和列，但是<code>pandas</code>只认为<code>numpy.nan</code>是空值，实际情况里可能使用空格等空字符来代表空值，这时需要一些特殊处理</p><a id="more"></a><p>原始数据中存在空格</p><p><img src="1.png" alt="1"></p><p><code>df</code>是一个<code>DataFrame</code>，以<code>DataFrame</code>中的列名为索引可以得到一个<code>Series</code>，其中有一个<code>apply</code>方法可以修改其中的值</p><p><code>apply</code>方法为一个高阶函数，接受一个函数<code>func</code>为参数，对<code>Series</code>中的每个元素调用<code>func</code></p><blockquote><p>“””<br>Invoke function on values of Series.</p><p>Can be ufunc (a NumPy function that applies to the entire Series)<br>or a Python function that only works on single values.</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>func : function<br>   Python function or NumPy ufunc to apply.<br>convert_dtype : bool, default True<br>   Try to find better dtype for elementwise function results. If<br>   False, leave as dtype=object.<br>args : tuple<br>   Positional arguments passed to func after the series value.<br>**kwds<br>   Additional keyword arguments passed to func.</p><h2 id="Returns"><a href="#Returns" class="headerlink" title="Returns"></a>Returns</h2><p>Series or DataFrame<br>   If func returns a Series object the result will be a DataFrame.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><p>Series.map: For element-wise operations.<br>Series.agg: Only perform aggregating type operations.<br>Series.transform: Only perform transforming type operations.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Create a series with typical summer temperatures for each city.</p><blockquote><blockquote><blockquote><p>s = pd.Series([20, 21, 12],<br>…               index=[‘London’, ‘New York’, ‘Helsinki’])<br>s<br>London      20<br>New York    21<br>Helsinki    12<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Square the values by defining a function and passing it as an<br>argument to <code>apply()</code>.</p><blockquote><blockquote><blockquote><p>def square(x):<br>…     return x ** 2<br>s.apply(square)<br>London      400<br>New York    441<br>Helsinki    144<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Square the values by passing an anonymous function as an<br>argument to <code>apply()</code>.</p><blockquote><blockquote><blockquote><p>s.apply(lambda x: x ** 2)<br>London      400<br>New York    441<br>Helsinki    144<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Define a custom function that needs additional positional<br>arguments and pass these additional arguments using the<br><code>args</code> keyword.</p><blockquote><blockquote><blockquote><p>def subtract_custom_value(x, custom_value):<br>…     return x - custom_value</p><p>s.apply(subtract_custom_value, args=(5,))<br>London      15<br>New York    16<br>Helsinki     7<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Define a custom function that takes keyword arguments<br>and pass these arguments to <code>apply</code>.</p><blockquote><blockquote><blockquote><p>def add_custom_values(x, **kwargs):<br>…     for month in kwargs:<br>…         x += kwargs[month]<br>…     return x</p><p>s.apply(add_custom_values, june=30, july=20, august=25)<br>London      95<br>New York    96<br>Helsinki    87<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Use a function from the Numpy library.</p><blockquote><blockquote><blockquote><p>s.apply(np.log)<br>London      2.995732<br>New York    3.044522<br>Helsinki    2.484907<br>dtype: float64<br>“””</p></blockquote></blockquote></blockquote></blockquote><p>了解了<code>apply()</code>函数之后，就可以替换原先的空格为<code>np.nan</code>了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'./newFile.csv'</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># none_score = (df['成绩'].isnull()) | (df['成绩'].apply(lambda x: str(x).isspace()))</span></span><br><span class="line"><span class="comment"># df_null = df[none_score]</span></span><br><span class="line"><span class="comment"># print(df_null)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># df_not_null = df[~none_score]</span></span><br><span class="line"><span class="comment"># data1 = df_not_null</span></span><br><span class="line"><span class="comment"># data1.to_csv('./cleaned_newFile.csv', encoding='utf-8_sig', index=None)</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">'成绩'</span>] = df[<span class="string">'成绩'</span>].apply(<span class="keyword">lambda</span> x: np.nan <span class="keyword">if</span> str(x).isspace() <span class="keyword">else</span> x)</span><br><span class="line">df = df.fillna(<span class="number">0</span>)</span><br><span class="line">df.to_csv(<span class="string">'./cleaned_newFile.csv'</span>, encoding=<span class="string">'utf-8_sig'</span>, index=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure></p><p>清洗之后，原本的空值被替换成了0</p><p><img src="2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;pandas&lt;/code&gt;中使用&lt;code&gt;fillna()&lt;/code&gt;或者&lt;code&gt;drop()&lt;/code&gt;来填充或丢弃包含空值的行和列，但是&lt;code&gt;pandas&lt;/code&gt;只认为&lt;code&gt;numpy.nan&lt;/code&gt;是空值，实际情况里可能使用空格等空字符来代表空值，这时需要一些特殊处理&lt;/p&gt;
    
    </summary>
    
      <category term="数据挖掘" scheme="http://ilern.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="数据清洗" scheme="http://ilern.github.io/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（一）</title>
    <link href="http://ilern.github.io/2020/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/11/12/操作系统实验笔记（一）/</id>
    <published>2020-11-12T02:07:47.000Z</published>
    <updated>2020-11-26T02:17:50.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h2><p>创建子进程，继承父进程<code>fork()</code>之后的的指令序列，复制父进程的数据部分</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p, x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">      x = <span class="number">200</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is parent, x = %d\n"</span>, x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = <span class="number">300</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is child, x = %d\n"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过汇编语言可以很容易理解<code>fork()</code>具有两个返回值的事情，<code>p = fork()</code>是两条指令，而子进程会执行函数调用<code>call fork</code>之后的所有指令，这样子进程和父进程的<code>p</code>就是不一样的。</p><p>当创建失败时<code>fork()</code>会返回<code>-1</code>，为了鲁棒性应该判断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span><span class="string">"test1.c"</span></span><br><span class="line"><span class="meta">.section</span>.rodata</span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"Hello world"</span></span><br><span class="line"><span class="symbol">.LC1:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is parent, x = %d\n"</span></span><br><span class="line"><span class="symbol">.LC2:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is child, x = %d\n"</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span>main</span><br><span class="line"><span class="meta">.type</span>main, @function</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line">leal<span class="number">4</span>(%esp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">andl$-<span class="number">16</span>, %esp</span><br><span class="line">pushl-<span class="number">4</span>(%ecx)</span><br><span class="line">pushl%ebp</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0x10</span>,<span class="number">0x5</span>,<span class="number">0x2</span>,<span class="number">0x75</span>,<span class="number">0</span></span><br><span class="line">movl%esp, %ebp</span><br><span class="line">pushl%ecx</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0xf</span>,<span class="number">0x3</span>,<span class="number">0x75</span>,<span class="number">0x7c</span>,<span class="number">0x6</span></span><br><span class="line">subl<span class="number">$20</span>, %esp</span><br><span class="line">movl<span class="number">$100</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$12</span>, %esp</span><br><span class="line">pushl$.LC0</span><br><span class="line"><span class="keyword">call</span>puts</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span>fork</span><br><span class="line"></span><br><span class="line"><span class="comment">;子进程会执行的部分</span></span><br><span class="line">movl%eax, -<span class="number">12</span>(%ebp)</span><br><span class="line">cmpl<span class="number">$0</span>, -<span class="number">12</span>(%ebp)</span><br><span class="line"><span class="keyword">je</span>.L2</span><br><span class="line">movl<span class="number">$200</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC1</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="keyword">jmp</span>.L3</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">movl<span class="number">$300</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC2</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">movl<span class="number">$0</span>, %eax</span><br><span class="line">movl-<span class="number">4</span>(%ebp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="meta">.cfi_restore</span> <span class="number">5</span></span><br><span class="line">leal-<span class="number">4</span>(%ecx), %esp</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">.size</span>main, .-main</span><br><span class="line"><span class="meta">.ident</span><span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line"><span class="meta">.section</span>.note.GNU-stack,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>下面的代码会构成怎样的进程树？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br></pre></td></tr></table></figure><h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid()"></a>getpid()</h2><p>获得当前进程的进程号</p><p><code>getppid()</code>获得父进程的进程号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//running to blocked</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is parent, my pid = %d, my child = %d\n"</span>, getpid(), p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is child, my pid = %d, my parent = %d\n"</span>, getpid(), getppid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>发现子进程的父进程编号不对，这是因为在执行子进程之前父进程已经执行结束，此时子进程称为孤儿进程<strong>Orphan Process</strong>，父进程被设置成了1305号进程</p><p><img src="4.png" alt="4"></p><p>查看所有进程发现1305号为upstart进程，用于接管孤儿进程</p><p>但是维基百科上说孤儿进程会被<code>init</code>进程或者<code>systemd</code>进程接管</p><p>想要父进程不那么快结束，可以使用<code>sleep(1)</code>让父进程进入阻塞状态一秒钟</p><p><img src="5.png" alt="5"></p><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><ul><li><p>框架的搭建</p></li><li><p>分别完成两个进程的功能</p></li><li><p>互斥和同步</p></li></ul><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line">  p1 = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print from parent process: %d\n"</span>, i);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      <span class="keyword">char</span> ch2 = <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">while</span> (ch2 &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print from Child process 2: %c\n"</span>, ch2);</span><br><span class="line">        ch2++;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    <span class="keyword">char</span> ch1 = <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch1 &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print from Child process 1: %c\n"</span>, ch1);</span><br><span class="line">      ch1++;</span><br><span class="line"></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区长度为一行，\n表示一行结束，会刷新缓冲区</p><p><code>fflush()</code> 刷新缓冲区</p><p>普通进程只往缓冲区写数据，往屏幕写数据是操作系统的事情</p><p>多个进程的缓冲区共用</p><h3 id="两个进程并发的执行情况"><a href="#两个进程并发的执行情况" class="headerlink" title="两个进程并发的执行情况"></a>两个进程并发的执行情况</h3><p><img src="6.png" alt="6"></p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br></pre></td></tr></table></figure><p>父进程一旦调用了<code>wait()</code>就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，<code>wait()</code>就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，<code>wait()</code>就会一直阻塞在这里，直到有一个出现为止。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>对于一个进程，当其进行结束时，进入<strong>终止状态</strong>，此时操作系统的进程表中还留有子进程的PCB。</p><p><img src="7.PNG" alt></p><p>如果此时父进程没有<code>wait()</code>，PCB将会保留，会导致资源泄露。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_pair</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> fd[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct fd_pair <span class="title">pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//on other architectures</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span> <span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><code>fd</code>参数会被设置成两个文件描述符，<code>f[0]</code>表示读，<code>f[1]</code>表示写</p><p><code>pipe</code>会自动保持同步</p><p>管道面向字节流</p><p>管道只允许单向通信（单工？</p><h3 id="使用管道进行进程间通信"><a href="#使用管道进行进程间通信" class="headerlink" title="使用管道进行进程间通信"></a>使用管道进行进程间通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">  pipe(fd1);</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork Error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2[<span class="number">2</span>];</span><br><span class="line">    pipe(fd2);</span><br><span class="line"></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      <span class="keyword">while</span> (read(fd1[<span class="number">0</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent: got data from child1\n"</span>);</span><br><span class="line">        write(fd2[<span class="number">1</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent: sent data to child2\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      <span class="keyword">while</span> (read(fd2[<span class="number">0</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child2: Got the char, print to the screen\n"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        <span class="keyword">else</span> ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putchar(ch);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child2: Done\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf("child1: Waiting for input: \n");</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> ch = getchar();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child1: Got the char '%c', sent to the parent process\n"</span>, ch);</span><br><span class="line">        write(fd1[<span class="number">1</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"char %c, ascii code %d is invaild\n"</span>, ch, ch);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//printf("child1: Waiting for input: \n");</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三进程并发，父进程拥有两个管道，子进程一负责从键盘读取输入，通过管道1发送给父进程，父进程通过管道2把输入发送给子进程2，子进程2进行大小写转换并输出。</p><p>子进程一进行输入过滤，不符合条件的输入会被忽略。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;h2 id=&quot;fork（）&quot;&gt;&lt;a href=&quot;#fork（）&quot; class=&quot;headerlink&quot; title=&quot;fork（）&quot;&gt;&lt;/a&gt;fork（）&lt;/h2&gt;&lt;p&gt;创建子进程，继承父进程&lt;code&gt;fork()&lt;/code&gt;之后的的指令序列，复制父进程的数据部分&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-内存管理</title>
    <link href="http://ilern.github.io/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"/>
    <id>http://ilern.github.io/2020/11/11/操作系统学习笔记-内存管理策略/</id>
    <published>2020-11-11T13:28:50.000Z</published>
    <updated>2020-12-27T02:46:10.970Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://ilern.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-网络层</title>
    <link href="http://ilern.github.io/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/11/08/计算机网络复习笔记-网络层/</id>
    <published>2020-11-08T08:52:16.000Z</published>
    <updated>2020-12-21T06:44:40.400Z</updated>
    
    <content type="html"><![CDATA[<p>内容贼多</p><a id="more"></a><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>网络层向运输层提供服务</li><li>网络保证可靠 or 端系统保证可靠</li></ul><h3 id="网络负责可靠交互"><a href="#网络负责可靠交互" class="headerlink" title="网络负责可靠交互"></a>网络负责可靠交互</h3><ul><li>虚电路<ul><li>和电路交换类似，都需要建立连接，有电路交换的特点</li><li>但是电路交换具有排他性，虚电路没有，所以称为<strong>虚</strong>电路</li></ul></li><li>虚电路建立<strong>逻辑上</strong>的连接，分组沿着逻辑上的连接进行分组转发</li></ul><h3 id="网络负责最大努力交互"><a href="#网络负责最大努力交互" class="headerlink" title="网络负责最大努力交互"></a>网络负责最大努力交互</h3><ul><li><p>因特网真正的设计思路</p></li><li><p>不提供服务质量的承诺，只进行最大努力、无连接的<strong>数据报服务</strong></p><ul><li><p>可能出错、丢失、重复、失序</p></li><li><p>出错由ICMP解决</p></li></ul></li></ul><h4 id="尽最大努力交付的好处"><a href="#尽最大努力交付的好处" class="headerlink" title="尽最大努力交付的好处"></a>尽最大努力交付的好处</h4><ul><li>路由器可以比较简单，价格低廉</li><li>运输层负责差错处理、流量控制</li><li>网络的造假大大降低，运行方式灵活，能适用多种应用</li></ul><h3 id="虚电路与数据报的对比"><a href="#虚电路与数据报的对比" class="headerlink" title="虚电路与数据报的对比"></a>虚电路与数据报的对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚电路</th><th style="text-align:center">数据报</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">网络保证可靠通信</td><td style="text-align:center">端系统保证可靠通信</td></tr><tr><td style="text-align:center">连接</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">只有建立连接时使用</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发</td><td style="text-align:center">同一条虚电路的分组按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当节点故障时</td><td style="text-align:center">所有通过故障接待您的虚电路均不能工作</td><td style="text-align:center">出故障的节点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按照顺序到达终点</td><td style="text-align:center">到达顺序不一定按照发送顺序</td></tr><tr><td style="text-align:center">差错处理 / 流量控制</td><td style="text-align:center">可以由网络负责， 也可以由主机负责</td><td style="text-align:center">主机负责</td></tr></tbody></table></div><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="配套使用的三个协议"><a href="#配套使用的三个协议" class="headerlink" title="配套使用的三个协议"></a>配套使用的三个协议</h3><ul><li>地址解析协议 ARP<ul><li>Address Reesolution Protocol</li><li>IP地址转换为MAC地址</li><li>IP协议族的较下层</li></ul></li><li>网际控制报文协议 ICMP<ul><li>Internet Control Message Protocol</li><li>控制信息</li><li>IP协议族的较上层</li></ul></li><li>忘记组管理协议 IGMP<ul><li>Internet Group Management Protocol</li><li>实现多播/组播</li><li>IP协议族的较上层</li></ul></li></ul><h3 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h3><ul><li>扩展<ul><li>转发器 物理层</li><li>网桥 数据链路层</li></ul></li><li>互联<ul><li>路由器 网络层</li><li>桥路器 网桥+ 路由器</li><li>网关 网络层以上</li></ul></li></ul><h3 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h3><p>又称逻辑互联网络，当互联网上的主机进行通信时，好像在一个网络上通信一样，虽然不同物理网络的异构性客观存在，但是被屏蔽掉了，对于用户而言，只能看到像在同一个网络上通信而看不到异构细节。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>32位二进制，四个点分十进制数，每个数取值在0 - 255</li><li>定义为 网络号+主机号</li><li>8位一组</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>A类<ul><li>第一位一定是0，前8位（一个字节）表示网络号，后24位表示主机号（三个字节）</li><li>一个网络中主机数最多有$2^{24} - 2 = 16777214$</li><li>最大网络数$2^7 - 2 = 126$<ul><li>全零作为保留地址，意为本网络，不能指派</li><li>全一作为环回测试地址，不能指派</li></ul></li><li>前8位 1 - 127</li></ul></li><li>B类<ul><li>前两位一定是10，前16位（两个字节）表示网络号，后16位表示主机号（两个字节）</li><li>一个网络中主机数最多有$2^{16} - 2 = 65534$</li><li>最大网络数$2 ^ {14} = 16384$<ul><li>最小网络号为 128.0</li><li>二进制为 1000 0000 . 0000 0000</li></ul></li><li>前8位 128 - 191</li></ul></li><li>C类<ul><li>前三位一定是110，前24位（三个字节）表示网络号，后8位表示主机号（一个字节)</li><li>一个网络中主机数最多有$2^{8} - 2= 254$</li><li>最大网络数$2 ^ {21} = 2097152$<ul><li>最小网络号为 192.0.0</li><li>二进制为 1100 0000 . 0000 0000 . 0000 0000</li></ul></li><li>前8位 192 - 223</li></ul></li><li>D类<ul><li>前四位一定是1110，用于多播地址</li><li>前8位 224 - 239</li></ul></li><li>E类<ul><li>前四位为1111，留作以后使用</li><li>前8位 240 - 255</li></ul></li></ul><p><img src="IMG_1551.PNG" alt="IMG-1551"></p><h4 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h4><p><img src="IMG_1552.PNG" alt="IMG-1552"></p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">用作源地址</th><th style="text-align:center">用作目的地址</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">可</td><td style="text-align:center">不n可</td><td style="text-align:center">本网络的本主机，相当于临时牌照，申请IP地址时使用</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">host-id</td><td style="text-align:center">可</td><td style="text-align:center">不可</td><td style="text-align:center">本网络的某台主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">只在本网络进行广播，所有路由器不进行转发</td></tr><tr><td style="text-align:center">net-id</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">网络外成员对net-id中的的所有成员进行广播</td></tr><tr><td style="text-align:center">127（0111 1111）</td><td style="text-align:center">非全零全一</td><td style="text-align:center">可</td><td style="text-align:center">可</td><td style="text-align:center">本地软件环回测试</td></tr></tbody></table></div><h4 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h4><p>10.0.0.0 ———— 10.255.255.255</p><p>(0000 1010 . 0000 0000 . 0000 0000 . 0000 0000 —— 0000 1010 . 1111 1111 . 1111 1111 . 1111 1111)</p><p>172.16.0.0 ———— 172.131.255.255</p><p>(1010 1100 . 0001 0000 . 0000 0000 . 0000 0000 —— 1010 1100 . 1000 0011 . 1111 1111 . 1111 1111)</p><p>192.168.0.0 ———— 192.168.255.255</p><p>(1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 —— 1100 0000 . 1010 1000 . 1111 1111 . 1111 1111)</p><h4 id="重要特点"><a href="#重要特点" class="headerlink" title="重要特点"></a>重要特点</h4><ul><li>分等级<ul><li>IP地址管理机构分配IP只分配网络号，主机号由网络号管理单位自行分配</li><li>路由器仅仅根据目的主机所连接的网络号来转发分组</li><li>这样就可以大大减少路由表的大小</li><li>找到了网络，再找主机就很容易了</li></ul></li><li>IP地址标志一个主机 / 路由器 / 链路的接口<ul><li>路由器属于不同网络的接口有不同的IP地址</li><li>至少有两个不同的IP地址</li></ul></li><li>网桥连接的若干局域网仍拥有相同的网络号，仍属于同一个网络<ul><li>网桥 / 转发器仅仅是扩展网络</li></ul></li><li>只包含一段线路的网络不指明IP地址</li></ul><h2 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h2><p>这里说硬件地址而不是MAC地址，因为链路层及以下使用的的硬件地址有很多种，其中以太网使用MAC地址</p><p>MAC地址 $\in$ 硬件地址</p><ul><li>路由器转发不改变IP源和目的，但是改变MAC源和目的<ul><li>网桥转发不改变MAC源和目的</li><li>路由器转发改变了链路</li></ul></li><li>数据包中间经过的路由器的IP不会出现在IP数据报的首部中</li><li>虽然首部有源站，但是路由器<strong>仅根据</strong>目的站的IP的网络号进行转发<ul><li>只找到网络就行</li></ul></li></ul><h3 id="地址解析协议-ARP-Address-Resolution-Protocal"><a href="#地址解析协议-ARP-Address-Resolution-Protocal" class="headerlink" title="地址解析协议 ARP Address Resolution Protocal"></a>地址解析协议 ARP Address Resolution Protocal</h3><ul><li>从网络层使用的IP地址解析出链路层使用的硬件地址</li><li>每个主机都有一个ARP Cache，里面有所在<strong>局域网</strong>上的各个主机和路由器的IP地址到硬件地址的映射表<ul><li>IP Address；MAC Address；TTL (Time to live) 使用老化策略，过久不使用的地址会被删除</li><li>能够减少ARP广播的数量</li></ul></li><li>发送过程<ul><li>向本局域网中的主机发送</li><li>有就把目的MAC地址写入MAC帧</li><li>没有就<strong>本地广播</strong>发送一个<strong>ARP请求分组</strong>，目的主机<strong>响应</strong>，把目的主机的MAC地址加入ARP Cache<ul><li><strong>本地广播</strong>：路由器不转发；链路层广播，MAC地址全1</li><li><strong>ARP请求分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 <strong>未知时填零</strong>/ 目标方IP地址；所有主机都会记录下发送方的硬件地址</li><li><strong>ARP响应分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 / 目标方IP地址；是广播实现的一对一通信</li></ul></li><li>如果目的主机和源主机不在同一个局域网，发送主机获得的就不是真正目的主机的MAC地址，而是能通往目的主机的路由器的IP地址。此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或<strong>ARP代理（ARP Proxy）</strong>。</li></ul></li><li>为什么不使用硬件地址进行通信<ul><li>异构网络很多，互相通信需要进行复杂的地址转换</li><li>IP使得所有网络像连接在同一个网络一样，把脏活累活交给ARP去做</li></ul></li></ul><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p><img src="IMG_1554.PNG" alt="ip"></p><p>首部、数据</p><p>首部包括固定部分20字节，可选部分长度不定，总共不超过60字节</p><ul><li>版本 4位<ul><li>0100 IPv4   0110 IPv6</li></ul></li><li>首部长度 4位<ul><li>最大表示15个单位，一个单位4字节，所以首部最长60字节</li></ul></li><li>区分服务 8位</li><li>总长度 16位<ul><li>首部长度 + 数据长度</li><li>单位为字节，因此数据报最大长度为$2^{16} - 1 = 65535$字节</li><li>总长度不能超过MTU</li></ul></li><li>标识 16位<ul><li>长度超过MTU则需要分片</li><li>分片后标识来自同一个数据报</li></ul></li><li>标志 3位<ul><li>目前只有前两位有意义</li><li>最低位是MF（More Fragment），中间一位是DF（Don’t Fragment）<ul><li>MF=0 没有分片了</li><li>DF=0 允许分片</li></ul></li></ul></li><li>片偏移 13位<ul><li>表示某片在原分组中的相对位置</li><li>以8字节为偏移单位，需要乘八，也就是左移三位，正好补上标志部分三位的空缺</li></ul></li><li>生存事件TTL 8位<ul><li>每经过一次路由转发，减少一，变成零了还没到目的就丢弃</li></ul></li><li>协议<ul><li>指出为谁服务，上层协议是什么</li></ul></li><li>首部检验和  16位<ul><li>验证首部在传输中有没有出现差错</li><li>二进制反码求和</li><li>IP不检验数据部分，扔给链路层做</li></ul></li><li>源地址、目的地址 各32位</li><li>可变部分<ul><li>最大40字节，需要使长度为4的整数倍，不足则用零填充</li><li>其实很少用</li></ul></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><p>IP分片不是一件好事情，应该能不分就不分</p><ul><li><p>分片之后有哪些字段会变</p><ul><li>总长度</li><li>报头检验和</li><li>MF位</li><li>片偏移</li></ul></li><li><p>分片的坏处</p><ul><li>效率低</li><li>需要缓存</li><li>防火墙可能会拦截</li></ul></li></ul><h2 id="二进制反码求和"><a href="#二进制反码求和" class="headerlink" title="二进制反码求和"></a>二进制反码求和</h2><ul><li>此反码非计组之反码 （ones’ complement）<ul><li>计组中的反码 正数的反码是本身 负数的反码是符号位不变，其余位取反</li></ul></li><li>逐位取反之后再相加（再取反）</li><li>最高位的进位加在最后一位上 (回卷)<ul><li>这样可以使得先加后取反和先取反后加的结果一样</li></ul></li><li>不依赖大端表示 / 小端表示<ul><li>交换十六位数的字节顺序，得到的结果相同，只是字节顺序也相应发生变化</li></ul></li></ul><h2 id="转发分组的流程"><a href="#转发分组的流程" class="headerlink" title="转发分组的流程"></a>转发分组的流程</h2><h3 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a>特定主机路由</h3><p>将IP数据报发送到特定的某个主机上，而不是发送到网络上就结束了</p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>路由表中的Default项，不在匹配其他任何项时按照默认路由进行转发</p><p>可以减少路由表中的条目数</p><h2 id="划分子网与构造超网"><a href="#划分子网与构造超网" class="headerlink" title="划分子网与构造超网"></a>划分子网与构造超网</h2><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><ul><li>网络号、主机号的两级IP 变为网络号、子网号、主机号的三级IP</li><li>网络号侵占主机号</li><li>因为全零全一不允许使用，每划分一个子网就会废掉两个IP</li><li>子网号的位数不能为0、1、15、16<ul><li>为0则没有划分子网</li><li>为16则没有主机</li><li>为1则网络号要么0要么1，不允许使用</li><li>为15则主机号要么0要么1，不允许使用</li></ul></li><li>定长子网划分、变长子网划分</li></ul><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a><font color="red">一个问题</font></h4><p>一个C类IP，划分为四个子网，分别在全零全一可用 / 不可用的时候损失了多少IP？</p><p>四个子网需要两个位的子网号，剩余六个位的主机号</p><p>网络号为00， 01， 10， 11，全零全一不可用，只剩下01， 10两个网络</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>用于找出IP地址中的子网部分</li><li>前面为1， 主机号部分为0，与IP做按位与运算，可以去掉主机号</li><li>最小IP网络的子网掩码是多少<ul><li>255.255.255.252</li><li>留出两位作为主机号，00， 01， 10， 11个主机，全零全一不让用，只有两台主机，其中一台是路由器</li></ul></li></ul><h3 id="构造超网-无分类编址CIDR-路由聚合"><a href="#构造超网-无分类编址CIDR-路由聚合" class="headerlink" title="构造超网 无分类编址CIDR 路由聚合"></a>构造超网 无分类编址CIDR 路由聚合</h3><p>无分类域间路由选择 Classless Inter-Domain Routing</p><ul><li>取消了传统ABC类网络，改用网络前缀来代替网络号与子网号<ul><li>主机号侵占网络号</li></ul></li><li>又变成两级编址</li><li>可以把多个C类网络合并，相当于侵占网络号</li><li>使用斜线记法，斜线后面表示网络前缀所占的位数<ul><li>数值上对应三级编址中子网掩码的1的位数</li></ul></li><li>仍然使用掩码</li><li>路由表中的一个项目可以表示很多传统分类的路由</li></ul><h4 id="构造超网的规则"><a href="#构造超网的规则" class="headerlink" title="构造超网的规则"></a>构造超网的规则</h4><ul><li>构成超网的地址块数必须是$2^n$</li><li>构成超网的地址快必须连续</li><li>第一个地址的第三字节必须能被块数整除</li></ul><h4 id="一些问题"><a href="#一些问题" class="headerlink" title=" 一些问题"></a><font color="red"> 一些问题</font></h4><ul><li>超网的网络地址能不能是X.Y.33.0？<ul><li>X.Y.00100001.0，发现主机号只有最后一个字节，相当于C类网络，没有聚合，也就不能叫超网</li></ul></li><li>X.Y.32.0 能不能确定网络<ul><li>X.Y.00100000.0，不能确定主机号的零从哪里开始</li><li>必须加上掩码/斜线才能确定网络号</li></ul></li></ul><h2 id="查找路由表"><a href="#查找路由表" class="headerlink" title="查找路由表"></a>查找路由表</h2><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>匹配路由表中最长的那个，因为越长越具体，有特定主机路由就不用网络前缀路由，有网络前缀路由就不用默认路由</p><p>路由器取出IP分组中的目的地址，与前缀对应的掩码进行按位与运算提取到网络号，进行匹配</p><h3 id="二叉线索"><a href="#二叉线索" class="headerlink" title="二叉线索"></a>二叉线索</h3><p>是一棵Trie</p><p>Trie上的前缀是唯一的，进行<strong>唯一前缀匹配</strong></p><p>唯一前缀匹配不等价于网络前缀匹配</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP在IP之上，ICMP报文作为IP报文的数据部分，也要被封装成IP数据报</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>1字节类型，1字节代码，2字节检验和</p><p>4字节ICMP数据部分，长度可变</p><h3 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h3><p>长度为<strong>36字节</strong></p><p>在收到错误的IP数据报后发送，也要封装为IP数据报</p><p>（封装后的IP数据报）数据部分是ICMP的前8字节 + 收到的IP数据报的首部 + 8字节，为TCP / UDP的端口号</p><p>因为要判定端口不可达</p><h4 id="不需要发送ICMP差错报文的几种情况"><a href="#不需要发送ICMP差错报文的几种情况" class="headerlink" title="不需要发送ICMP差错报文的几种情况"></a>不需要发送ICMP差错报文的几种情况</h4><ul><li>不再为ICMP差错报文发送ICMP差错报文 / 禁止套娃</li><li>只对分片中的第一片发送 / 一个错各个错</li><li>多播地址的数据报不发送</li><li>特殊地址（127.0.0.0 / 0.0.0.0）不发送</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>终点不可达<ul><li>某一环无法继续传递，向发送方发送终点不可达</li><li>报文中的数据表示失败的原因</li><li>不可达有五种情况<ul><li>网络不可达</li><li>主机不可达</li><li>协议不可达 //无法向上提交</li><li>端口不可达</li><li>需要分片但DF位为1</li><li>源路由失败</li></ul></li></ul></li><li>时间超过<ul><li>TTL减到0</li><li>某些分片迟迟不来，组装出问题</li></ul></li><li>参数问题<ul><li>头部参数出错，Pointer部分会指出错误的字节位置</li></ul></li><li>源点抑制<ul><li>流量过大，缓存队列溢出，只能丢弃报文，此时发送一个ICMP源点抑制，告知发送方晚点再来</li></ul></li><li>改变路由 / 重定向<ul><li>找不到目的地址</li></ul></li></ul><h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><p>长度为<strong>40字节</strong></p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>回送请求和回答<ul><li>ping</li></ul></li><li>时间戳请求和回答<ul><li>查询当前时间，提供毫秒级的分辨率</li><li>包含三个时间戳 ：Origin时间、Receive时间、transmit时间 （接收方发送回应的时间）</li><li>即使不同步也能计算正确的往返时间</li></ul></li></ul><h3 id="源路由"><a href="#源路由" class="headerlink" title="源路由"></a>源路由</h3><p>从源路由网桥中提到过，指从源点就确定的路由</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><ul><li><strong>ping非常特殊，应用层直接使用网络层，不经过运输层</strong></li></ul><h4 id="trace-route"><a href="#trace-route" class="headerlink" title="trace route"></a>trace route</h4><ul><li><p>发很多次，第一次发TTL是1，第二次发TTL是2，以此类推，每一次路由器都会给出一个超时</p></li><li><p>当到达目的主机时没法发送超时了，此时设置的一个不可达的UDP端口使得目的主机发送终点不可达</p></li><li><p>因此<strong>trace route 用到了运输层</strong></p></li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><ul><li>正确、完整</li><li>计算上简单</li><li>能适应通信量和网络拓扑的变化</li><li>稳定性，路由不应该不停变化</li><li>公平，除了少数优先级高的用户 / 区分服务</li><li>算法应该是最佳的 / 相对概念，特定约束下的较为合理的选择</li></ul><h3 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h3><p>静态路由 简单开销小，但是不能及时适应网络状态变化</p><p>动态路由 复杂开销大，但是能较好适应网络状态的变化</p><p>内部网关协议 IGP AS内部使用</p><p>外部网关协议 EGP AS之间使用</p><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>Autonomous System 自治系统</p><p>把AS内的网络看作一个整体，屏蔽内部细节和采用的路由协议</p><p>一个AS对其他AS表现出一个单一的一致的路由选择策略</p><h3 id="RIP-Route-information-protocol"><a href="#RIP-Route-information-protocol" class="headerlink" title="RIP Route information protocol"></a>RIP Route information protocol</h3><p>是一种内部网关协议</p><p><strong>分布式</strong>的基于<strong>距离向量</strong>的路由选择协议</p><p>每经过一个路由器距离加一，距离向量的距离指的是最短距离 / 经过路由器的数目最少</p><p>RIP简单粗暴的把距离短的路由认为是好的路由，允许一条路径最多包含15个路由器，距离超过15就标记为不可达</p><p><strong>不存在</strong>负载均衡，有两条长度一样的路径也只会走其中一条</p><p>工作方式为每隔固定的一段时间和相邻路由器交换自己的路由表</p><ul><li>三分钟没收到消息就认为不可达，距离设置为16</li><li>收到之后总总是要更新，距离可能增大也可能减小，应该以最新的更新</li></ul><p>能很快收敛 / 所有路由器达到一致</p><ul><li>路由表一致性不等于路由表表项相同</li></ul><p>路由表包括目的网络（大方向） 距离 下一跳路由器（小方向）</p><h4 id="RIP2报文格式"><a href="#RIP2报文格式" class="headerlink" title="RIP2报文格式"></a>RIP2报文格式</h4><p><img src="IMG_1576.PNG" alt></p><p>RIP2要封装到UDP中再封装到IP中，RIP是应用层协议</p><p>四字节首部，路由信息20字节，最多25个，总长度最大4 + 20 * 25 = 504字节，超过则启用新的RIP2报文</p><p>RIP2和RIP1（最大的）的区别是RIP2支持子网</p><p>路由标记表示是否再同一个自治系统中，填写的是自治系统的编码</p><h4 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h4><ul><li>水平分割<ul><li>从某个接口学到的路由不会再发回去，防止了路由环路</li></ul></li><li>毒性逆转<ul><li>当路由信息变成无效后不是直接删除而是设置为不可达并广播出去，可以清楚路由表中无用的路由</li></ul></li><li>触发更新<ul><li>路由信息改变后立即更新并发送给相邻路由器</li></ul></li><li>抑制计时<ul><li>如果一条路由更新的跳数大于路由表已记录的该路由的跳数，那么将会引起该路由进入长达180秒（即6个路由更新周期）的抑制状态阶段。在抑制计时器超时前，路由器不再接收关于这条路由的更新信息。可以用来防止路由环路。</li></ul></li></ul><h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF Open Shortest Path First"></a>OSPF Open Shortest Path First</h3><p>是一种内部网关协议</p><p><strong>分布式</strong>的，基于<strong>链路状态</strong>的路由选择协议</p><p>工作在网络层，在IP之上，直接使用IP数据报进行传送</p><p>使用Djijkstra算法</p><p>需要一张完整的网络图，来跑Dijkstra算法</p><p>所有的路由器都维护一个完整的链路状态数据库 / 全网的拓扑结构图</p><p>所有路由器的数据库都是完全一致的，和RIP中的一致不同</p><p>OSPF收敛很快</p><h4 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h4><ul><li>使用泛洪法向自治系统内的所有路由器发送信息</li><li>发送与本路由器相邻的所有路由器的链路状态<ul><li>与谁相邻，代价是多少</li></ul></li><li>只有链路状态发生变化时，路由器才使用泛洪法向所有路由器发送信息</li></ul><h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>自治系统通常贼大，需要维护的数据库也就会变大，因此在自治系统的基础上进一步划分区域（Area），这样就只需要在区域内泛洪、维护区域的拓扑结构图</p><p>每个区域用一个32位的区域标识符来表示，和IP一样使用点分十进制</p><p>使用层次结构的区域划分，上层的区域叫做主干区域，标识符为 0.0.0.0，主干区域联通下层区域</p><p>位于主干区域中的路由器称为主干路由器（BR）</p><p>位于区域边缘，与其他区域通信的路由器称为区域边界路由器（Area Border Router)</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>数据报很短<ul><li>减少路由信息的通信量，网络最主要的功能还是处理端系统的消息</li><li>不必将长的数据报分片传送，有效减少重传</li></ul></li><li>具有多路径负载均衡</li><li>具有鉴别功能<ul><li>保证了仅在可信的路由器之间交换链路状态信息</li></ul></li><li>支持变长子网划分和CIDR</li><li>每一个链路状态都有一个32位的序号，序号增长不超过五秒钟一次</li><li>每隔一段时间刷新数据库中的链路状态</li><li>互联网规模很大时，OSPF要比RIP好很多，对网络变化的响应很快不存在坏消息传得慢的情况</li></ul><h4 id="指定路由器"><a href="#指定路由器" class="headerlink" title="指定路由器"></a>指定路由器</h4><p>在一个广播性、多路访问的网络中，如果每个路由器都独立进行链路状态更新包的交换，就会产生巨大流量，不好，因此选举出一个村长来进行链路状态信息的交换。</p><p>有DR（Designated Router)）和BDR（Backup Designated Router）</p><h4 id="分组格式"><a href="#分组格式" class="headerlink" title="分组格式"></a>分组格式</h4><p><img src="IMG_1577.PNG" alt></p><ul><li>版本<ul><li>当前版本为2，版本一版本二不兼容</li></ul></li><li>类型<ul><li>Hello<ul><li>每隔十秒交换一次问候分组，从而得知有哪些路由器是可达的</li></ul></li><li>Database Description</li><li>Link State Request</li><li>Link State Update<ul><li>收到更新报文后需要恢复ACK</li></ul></li><li>Link State Acknowledgment</li></ul></li><li>分组长度<ul><li>包括OFSF头部的分组长度</li></ul></li><li>路由器ID<ul><li>在AS中可以唯一表示路由器</li></ul></li><li>区域ID<ul><li>指定分组所属的区域号</li></ul></li><li>校验和<ul><li>用于分组所有内容的校验和</li></ul></li><li>鉴别1<ul><li>0或1，表示不鉴别和使用口令鉴别</li></ul></li><li>鉴别2<ul><li>鉴别1为0时为0，鉴别1为1时为口令</li></ul></li></ul><h3 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP Border Gateway Protocol"></a>BGP Border Gateway Protocol</h3><p>外部网关协议</p><p>目前版本为4</p><p>难以寻找最佳路由，只在AS之间交换可达性信息，找到一条不兜圈子的<strong>比较好</strong>的路由</p><p>基于<strong>路径向量</strong>的路由选择协议</p><p>每个AS至少要有一个BGP发言人，每个发言人都要属于一个AS</p><p>作用于不同AS，但同一个AS中的不同边界路由器也需要建立BGP连接</p><p>BGP支持CIDR</p><p>是应用层协议，使用TCP进行传输</p><ul><li>对于远距离的传输，需要使用TCP保证可靠性</li></ul><h4 id="BGP热土豆路由选择协议"><a href="#BGP热土豆路由选择协议" class="headerlink" title="BGP热土豆路由选择协议"></a>BGP热土豆路由选择协议</h4><p>热马铃薯路由选择（Hot-potato routing）是在当前AS接收到一个数据包后，使其停留在该AS中的时间尽可能短。它尝试减少当前AS的开销，而忽略了网络中其他组成成分的开销。</p><p>将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS。</p><h4 id="AS的分类"><a href="#AS的分类" class="headerlink" title="AS的分类"></a>AS的分类</h4><p>单口AS，只有一个连接可以到达另一个AS，只能是信源或信宿</p><p>多归路过渡AS，有多个连接到达多个AS，但是拒绝传送流量，只能是信源或信宿 / 拒绝通信量穿越的多归属AS</p><p>过渡AS，不允许通信量穿越的多归属AS</p><h4 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h4><p>OPEN 与相邻的另一个BGP发言人建立关系 / 打招呼</p><p>UPDATE 发送某一路由的信息，列出要撤销的多条路由 / 有新闻</p><p>KEEPALIVE  确认打开报文与周期性证实临站关系 / 表明自己还活着 / 只有报文头</p><p>NOTIFICATION 发送检测到的差错 / 不跟你玩了</p><p><img src="IMG_1579.PNG" alt></p><p>标记部分用于鉴别，但是现在没有鉴别方案，全部置为1</p><p>长度为包括首部在内的总长度</p><p>类型为1-4，上述的四种类型</p><h4 id="一个问题-1"><a href="#一个问题-1" class="headerlink" title=" 一个问题 "></a><font color="red"> 一个问题 </font></h4><p><strong>KeepAlive报文在链路层是否需要进行填充？</strong></p><p>KeepAlive只有报文头，16 + 2 + 1 = 19 字节</p><p>作为TCP的数据部分，需要加上TCP的首部 19 + 20 = 39 字节</p><p>作为IP的数据部分，需要加上IP的首部 39 + 20 = 59 字节</p><p>MAC帧在长度小于46字节时才进行填充，因此不需要进行填充</p><p>以太网最短帧长为64字节，减去16字节头部，4字节FCS，数据部分最短46字节</p><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>多输入端口，多输出端口</p><p>作用是转发分组</p><p>路由选择协议生成路由表，路由表生成转发表</p><h3 id="多播特点"><a href="#多播特点" class="headerlink" title="多播特点"></a>多播特点</h3><p>使用组地址，D类地址</p><p>永久组地址</p><p>动态组成员</p><p>使用硬件进行多播</p><h3 id="IP多播地址与以太网多播地址的转换"><a href="#IP多播地址与以太网多播地址的转换" class="headerlink" title="IP多播地址与以太网多播地址的转换"></a>IP多播地址与以太网多播地址的转换</h3><p>01 + 00 + 5e + 0 + 组播IP低23位</p><h4 id="一个例子"><a href="#一个例子" class="headerlink" title=" 一个例子 "></a><font color="red"> 一个例子 </font></h4><p>226.150.47.33</p><p>首先确定D类IP，D类IP从224到239</p><p>写出后三个字节的二进制</p><p>150 = 128 + 16 + 4 + 2 = 1001 0110</p><p>47 = 32 + 16 - 1 = 0011 0000 - 1 = 0010 1111</p><p>33 = 32 + 1 = 0010 0001</p><p>把正数第二字节第一位换成0，因为只要后23位</p><p>0001 0110 = 16</p><p>0010 1111 = 2F</p><p>0010 0001 = 21</p><p>最终结果为 01 00 5e 16 2F 21</p><h3 id="IGMP-Internet-Group-Management-Protocal"><a href="#IGMP-Internet-Group-Management-Protocal" class="headerlink" title="IGMP Internet Group Management Protocal"></a>IGMP Internet Group Management Protocal</h3><p>使路由器知道多播组成员的信息</p><p>看作IP的一个组成部分</p><h4 id="IGMP的本地使用范围"><a href="#IGMP的本地使用范围" class="headerlink" title="IGMP的本地使用范围"></a>IGMP的本地使用范围</h4><p><strong>并非</strong> 在因特网范围内对所有多播组成员进行管理的协议</p><p>IGMP 不知道IP多播组包含的成员数，也不知道这些成员分布在哪些网络上</p><p>IGMP是让连接在本地局域网的多播路由器知道本剧于网上是否有主机参加或退出了多播组</p><h3 id="为什么多播路由选择协议比单播路由选择协议复杂得多"><a href="#为什么多播路由选择协议比单播路由选择协议复杂得多" class="headerlink" title="为什么多播路由选择协议比单播路由选择协议复杂得多"></a>为什么多播路由选择协议比单播路由选择协议复杂得多</h3><p>多播转发必须动态适应多播组成员的变化，而单播通常是在网络拓扑发生变化时才需要更新路由</p><p>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从哪里来到哪里去</p><p>多播数据报可以从没有加入多播组的主机发出，也可以通过没有组成员接入的网络</p><h3 id="IGMP两个阶段及具体措施"><a href="#IGMP两个阶段及具体措施" class="headerlink" title="IGMP两个阶段及具体措施"></a>IGMP两个阶段及具体措施</h3><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>新主机加入多播组，先向该组的多播地址发送IGMP报文，表明自己要加入，多播路由器收到之后将组成员关系转发到因特网上其他多播路由器，以完善多播路径</p><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>周期性探询本地局域网的主机，确认是否是该组的成员，只要有一个响应认为是活跃的，多次没有响应就不再将组成员关系转发给其他路由器</p><h4 id="具体措施"><a href="#具体措施" class="headerlink" title="具体措施"></a>具体措施</h4><p>使用IP多播</p><p>探寻组成员关系时对所有组发送一个请求信息的询问报文（而不是每个组一个）</p><p>主机收到询问后随机选择一个时延进行发送</p><p>如果组内有其他主机发送了，自己就可以不发送了</p><h3 id="多播路由选择的三种方法"><a href="#多播路由选择的三种方法" class="headerlink" title="多播路由选择的三种方法"></a>多播路由选择的三种方法</h3><p>多播路由选择实际上是要构建以源主机为根节点的多播转发树</p><h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>RBP Reverse Path Broadcasting</p><p>洪泛适用于较小的多播组，为了避免兜圈子，使用了反向路径广播Reverse Path Broadcasting的策略</p><p>剪除指发现下游树枝上没有多播组成员时，把它和下游树枝一起在转发树上剪除</p><h4 id="隧道-lt-第一个隧道-gt"><a href="#隧道-lt-第一个隧道-gt" class="headerlink" title="隧道  &lt;第一个隧道&gt; "></a>隧道 <font color="blue"> &lt;第一个隧道&gt; </font></h4><p>把多播报文封装为单播，使用单播通过不支持多播的网络，出来之后再恢复成多播</p><h4 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="　基于核心的发现技术"></a>　基于核心的发现技术</h4><p>对每一个多播组指定一个核心，核心路由器构建转发树</p><h3 id="RPB特点"><a href="#RPB特点" class="headerlink" title="RPB特点"></a>RPB特点</h3><p>路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的：</p><p>若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外 ）</p><p>否 则 ， 就 丢 弃 而 不 转 发。</p><p>如果 存 在 几 条 同 样 长 度 的 最 短 路 径 ， 那 么 只 能 选 择 一 条 最 短 路 径 ， 选 择 的 准 则 就 是 看 这 几 条 最 短 路 径中的相邻路由器谁的 IP 地址最小。 </p><p>最终得出多播转发树，以后就按其转发多播数据报</p><h2 id="VPN-Virtaul-Private-Network"><a href="#VPN-Virtaul-Private-Network" class="headerlink" title="VPN Virtaul Private Network"></a>VPN Virtaul Private Network</h2><p>利用公用的互联网作为本机构各专用网之间的通信载体</p><p>所有通过互联网传送的数据都必须加密</p><p>使用 <strong>隧道技术</strong> 来实现 <font color="blue"> &lt;第二个隧道&gt; </font></p><p><img src="IMG_1580.PNG" alt="IMG_1580"></p><p>机构内部的VPN为内联网（intranet），不同机构共同建立的VPN为外联网（exrtanet）</p><h2 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT Network Address Translation"></a>NAT Network Address Translation</h2><p>专用网中的主机需要与外部进行通信，需要通过NAT路由器将私有地址转换为全球地址</p><p>转换结果需要记录在NAT地址转换表中</p><p>每次通信需要进行两次转换，离开时一次，进入时一次</p><p>对于有$n$个全球IP地址的NAT路由器，最多可以同时有$n$台主机接入到互联网</p><p>专用网内部的主机不能作为服务器</p><p><img src="IMG_1583.PNG" alt="ING_1583"></p><h3 id="NAPT-Network-Address-and-Port-Translation"><a href="#NAPT-Network-Address-and-Port-Translation" class="headerlink" title="NAPT Network Address and Port Translation"></a>NAPT Network Address and Port Translation</h3><p>多个主机公用一个NAT路由器上的全球IP地址</p><p>把专用网内部的不同IP地址转换为相同的全球IP地址，源主机采用的TCP端口号不管相不相同都转换为不同的新的端口号</p><h2 id="MPLS-Multi-Protocol-Label-Switching"><a href="#MPLS-Multi-Protocol-Label-Switching" class="headerlink" title="MPLS Multi Protocol Label Switching"></a>MPLS Multi Protocol Label Switching</h2><p>属于2.5层协议，是IP的一种增强</p><p><strong>多协议</strong> 表示MPLS的上层可以采用多种网络协议、下层可以采用多种链路层协议</p><p><strong>标记</strong> 表示每<strong>类</strong>分组被打上一个标记，根据标记对分组进行转发</p><font color="red"> **面向连接**</font><blockquote><p>传统的路由决策，路由器需要对网络数据包进行解包，再根据目的IP地址计算归属的FEC。</p><p>而MPLS提出，当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。</p><p>当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。</p></blockquote><p>每类分组会有一个特定的编号</p><h3 id="MPLS特点"><a href="#MPLS特点" class="headerlink" title="MPLS特点"></a>MPLS特点</h3><ul><li>分类意味着面向连接，标记一旦确定，连接的路径就确定了</li><li>支持流量工程，平衡网络负载</li><li>有效支持VPN</li><li>在转发是不上升到第三层查找转发表，而是直接在第二能用硬件进行转发</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>使用LDP label distribution protocol交换报文，找到标记交换路径LSP</li><li>分组进入MPLS域时，在入口打上标记，按照转发表将分组发给下一个LSR</li><li><font color="red">标记具有强烈的本地意义</font>，仅在两个LSR之间才有意义</li><li>分组经过LSR要做两件事情，一是转发，二是标记对换</li><li>离开MPLS域时，MPLS出口节点把标记去除</li><li>这样的转发方式被称为<strong>显式路由选择</strong></li></ul><h4 id="MPLS域"><a href="#MPLS域" class="headerlink" title="MPLS域"></a>MPLS域</h4><p>这个区域中所有路由器都支持MPLS技术，都是LSR Label Switching router</p><p>LSR既可以标记交换也可以路由选择，转发表被用来构造标记交换表</p><h3 id="转发等价类FEC"><a href="#转发等价类FEC" class="headerlink" title="转发等价类FEC"></a>转发等价类FEC</h3><p>如何划分转发等价类是MPLS的核心</p><p>转发等价类是LSR按照同样的方式对待的分组的集合</p><p>划分方式很灵活，通常由网络管理员来控制</p><p>通过设置不同的FEC可以实现负载均衡，也称为流量工程</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>特定前缀进行匹配</p><p>源地址目的地址都相同</p><p>某种服务质量需求的（区分服务）</p><h3 id="MPLS格式"><a href="#MPLS格式" class="headerlink" title="MPLS格式"></a>MPLS格式</h3><p>在IP数据报被封装成以太网帧之前，先插入一个MPLS首部</p><p><img src="IMG_1592.PNG" alt></p><p>生存时间用于防止兜圈子</p><h3 id="LSP隧道-lt-第三个隧道-gt"><a href="#LSP隧道-lt-第三个隧道-gt" class="headerlink" title="LSP隧道  &lt;第三个隧道&gt; "></a>LSP隧道 <font color="blue"> &lt;第三个隧道&gt; </font></h3><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h3><p>允许协议继续扩充</p><p>支持即插即用自动配置</p><p>支持资源预分配</p><p>首部由四字节对齐改为八字节对齐</p><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p><img src="IMG_1593.PNG" alt></p><ul><li>版本<ul><li>4位，目前版本6</li></ul></li><li>通信量类<ul><li>8位，相当于区分服务</li></ul></li><li>流标号</li><li>有效载荷长度</li><li>下一个首部<ul><li>8位，指向扩展首部，串出一个列表</li></ul></li><li>跳数限制<ul><li>8位</li></ul></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>128位</p><p>除Unicast、Multicast外支持Anycast</p><ul><li>对于一组主机，只要找到最近的一个即可</li><li>发向一组，其中只要有一个接收到即可</li></ul><p>使用冒号十六进制记法</p><p>允许把数字前面的0省略</p><p>一串零可以使用零压缩压缩成一对冒号，地址中只能压缩一次</p><p>CIDR斜线表示法仍然适用</p><h4 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h4><p><code>::/128</code> 未指明</p><p><code>::1/128</code> 环回</p><p><code>FF00::/8</code> 多播</p><p><code>FE80::/10</code> 本地链路单播</p><h3 id="v4-to-v6"><a href="#v4-to-v6" class="headerlink" title="v4 to v6"></a>v4 to v6</h3><ul><li>双协议栈</li><li>隧道技术 <font color="blue"> &lt;第四种隧道&gt; </font><ul><li>把v6数据报封装进v4数据报</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容贼多&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-进程同步</title>
    <link href="http://ilern.github.io/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://ilern.github.io/2020/10/15/操作系统学习笔记-进程同步/</id>
    <published>2020-10-15T07:08:38.000Z</published>
    <updated>2020-12-27T02:45:36.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h2><h3 id="About-Critical-Section"><a href="#About-Critical-Section" class="headerlink" title="About Critical Section"></a>About Critical Section</h3><ul><li><p>An atomic action is required in a critical section.</p></li><li><p>When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</p></li><li><p>The critical section is <strong>not</strong> a public section. Each process has its own critical section.</p></li><li>Each process must request permission to enter its critical section. The section of code implementing this request is the <strong>entry section</strong>, the critical section may be followed by an <strong>exit section</strong></li></ul><p><img src="https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG" alt></p><a id="more"></a><h3 id="Solution-of-the-critical-section-problem"><a href="#Solution-of-the-critical-section-problem" class="headerlink" title="Solution of the critical-section problem"></a>Solution of the critical-section problem</h3><ul><li><p>Mutual exclusion 互斥</p><ul><li>If  process $p_i$ is executing its critical section, then no other process can be executing in their critical sections</li></ul></li><li><p>progress 进步？</p><ul><li>If no process is executing in its critical section and some processes with to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which  will enter its critical section next, and this selection cannot be postponed <strong>indefinitely</strong>.</li><li>如果没有进程在执行临界区并且某些进程想要执行他们的临界区，那么只有那些不在他们剩余区的进程可以参与决定谁来执行临界区的筛选，这个选择过程不会无限期推迟。</li></ul></li><li><p>Bounded waiting 有界等待</p><ul><li><p>There exists a bound on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.</p></li><li><pre class="mermaid">    gantt                section Figure1       请求进入临界区            :des1, 1d       等待          :des2, after des1, 3d       被授权进入临界区            :des3, after des2, 5d</pre></li><li><p>如上图，在等待的过程中其他进程被允许进入临界区的次数是有限的</p></li></ul></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p><strong>两个进程</strong>的同步算法，软件实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initicall turn = 0</span></span><br><span class="line"><span class="comment">// turn is a shared variable</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (turn != i); <span class="comment">// only turn == i can this process execute it's critical section</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">//reminder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Satisfies mutual exclusion, but not progress</p><p>机械的规定零号进程一号进程交替进行。</p><p>进程是否有进入临界区的 <strong>意愿</strong> ？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initial flag[0] = flag[1] = false;</span></span><br><span class="line"><span class="comment">//flag[i] == true -&gt; process i ready to enter critical section</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]); <span class="comment">// mutual exclusion</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>不满足 progress ，在<code>flag[i] = true</code>之后，切换到另一个进程<code>flag[j] = true</code>，此时两个进程都想进临界区，但是都在看对方，都不能进入临界区</p><h3 id="Peterson‘s-Solution"><a href="#Peterson‘s-Solution" class="headerlink" title="Peterson‘s Solution"></a>Peterson‘s Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share turn flag[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>最后执行turn等于谁，谁就进入临界区</p><h2 id="Synchronization-Hardware"><a href="#Synchronization-Hardware" class="headerlink" title="Synchronization Hardware"></a>Synchronization Hardware</h2><p>Based on <strong>locking</strong></p><ul><li>Uniprocessors<ul><li>同一时刻指运行一个进程</li><li>disable interrupts 把中断屏蔽即可</li></ul></li><li>special atomic hardware instructions 硬件提供特殊的原子指令<ul><li>原子指令执行期间不允许切换</li><li><code>test memory</code> 查看某内存单元的值</li><li><code>set value</code> 对某内存单元设置为1</li><li><code>swap</code> 交换两个内存单元的值</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    acquire lock</span><br><span class="line">        <span class="comment">//criticla section</span></span><br><span class="line">    release lock</span><br><span class="line">        <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="test-and-set-Instruction"><a href="#test-and-set-Instruction" class="headerlink" title="test_and_set Instruction"></a>test_and_set Instruction</h3><p>做成<strong>一条</strong>机器指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tar 看作一个锁，一堆人去抢这把锁</span></span><br><span class="line"><span class="function">boolean <span class="title">test_and_set</span><span class="params">(boolean *tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> rv = *tar;</span><br><span class="line">    *tar = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">//got the lock or not;</span></span><br><span class="line">    <span class="comment">//flase -&gt; 锁没被锁，自己锁了</span></span><br><span class="line">    <span class="comment">//true -&gt; 已经被锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这条指令加锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutux lock</span></span><br><span class="line"><span class="comment">//锁只是一个普通变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(test_and_set(&amp;lock));</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较倒霉的情况可能不满足有界等待</span></span><br><span class="line"><span class="comment">//几率小，当倒霉处理</span></span><br></pre></td></tr></table></figure></p><h3 id="compare-and-swap-Instruction"><a href="#compare-and-swap-Instruction" class="headerlink" title="compare_and_swap Instruction"></a>compare_and_swap Instruction</h3><p>和<code>test_and_set Instruction</code>做一样的事情，但是实际功能更强。</p><p>用牛刀杀鸡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *value;</span><br><span class="line">    <span class="keyword">if</span> (*value == expected) </span><br><span class="line">        *value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旧值和新值比较</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">//是0就设置为1</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h2><p>Software Tool</p><p>使用原子的<code>acquire()</code>和<code>release()</code>来申请、释放锁，不需要在意底层具体实现方式。</p><ul><li><p>CPU busy waiting 问题</p><ul><li>循环查看锁开没开</li><li>Spinlock 自旋锁</li><li>会浪费CPU的时间</li></ul></li><li><p>更好的办法</p><ul><li>锁可用获得锁</li><li>锁不可用进程挂起</li><li>释放锁时有进程挂起则挑一个唤醒</li><li>没有进程挂起直接释放</li></ul></li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p><p>Synchronization Tool that does not require busy waiting</p><ul><li><p>is an integer</p></li><li><p><code>wait()</code> P 减信号量 请求执行</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//busy wait</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>signal()</code> V 加信号量</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>某个资源的只能被有限的人使用，例如为了保证网络通畅，只允许五个人连接。</p><p>不局限于加锁解锁，可以有一定范围。</p><p>当信号量被限制到二元，则退化（？）为互斥锁。</p><p>生产者 / 消费者问题？</p><p>有界缓冲区问题？</p><p>哲学家就餐问题？如何把这些搞哲学的饿死。</p><p><strong>一个使用信号量解决问题的例子</strong></p><p><img src="1.JPG" alt="figure1"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-Critical-Section-Problem&quot;&gt;&lt;a href=&quot;#The-Critical-Section-Problem&quot; class=&quot;headerlink&quot; title=&quot;The Critical-Section Problem&quot;&gt;&lt;/a&gt;The Critical-Section Problem&lt;/h2&gt;&lt;h3 id=&quot;About-Critical-Section&quot;&gt;&lt;a href=&quot;#About-Critical-Section&quot; class=&quot;headerlink&quot; title=&quot;About Critical Section&quot;&gt;&lt;/a&gt;About Critical Section&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;An atomic action is required in a critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The critical section is &lt;strong&gt;not&lt;/strong&gt; a public section. Each process has its own critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Each process must request permission to enter its critical section. The section of code implementing this request is the &lt;strong&gt;entry section&lt;/strong&gt;, the critical section may be followed by an &lt;strong&gt;exit section&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://ilern.github.io/tags/OS/"/>
    
  </entry>
  
</feed>
