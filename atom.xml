<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iLern&#39;s Blog</title>
  
  <subtitle>Do what you love, love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ilern.github.io/"/>
  <updated>2019-11-06T08:44:24.945Z</updated>
  <id>http://ilern.github.io/</id>
  
  <author>
    <name>iLern</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分图匹配学习笔记</title>
    <link href="http://ilern.github.io/2019/11/06/BipartiteGraphLearn/"/>
    <id>http://ilern.github.io/2019/11/06/BipartiteGraphLearn/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2019-11-06T08:44:24.945Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul><li>二分图一定是一个无向图</li><li>若一个无向图中<strong>不存在</strong>长度为奇数的环，则这个图为二分图</li><li>二分图可以分成两个部分，每部分中的点之间没有边</li></ul><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><ul><li>对于一个二分图，从它的所有边中选出一些，使得任意两条边没有公共端点，这样的边的集合被称为二分图的<strong>匹配</strong></li><li>二分图的匹配并不是唯一的</li><li>在所有的匹配中含边数最多的那一个称为这个二分图的 <strong>最大匹配</strong></li></ul><h3 id="增广路定理"><a href="#增广路定理" class="headerlink" title="增广路定理"></a>增广路定理</h3><p>网络流问题中也存在（类似的）<strong>增广路</strong>的概念。</p><ul><li>对于一个二分图，如果存在一条连接两个非匹配点的路径，使得匹配边与非匹配边交替出现，则这个路径是已知匹配的 <strong>增广路</strong>。</li><li>对于一条增广路而言，如果将其中的匹配边与非匹配边身份互换，可得到一个更大的匹配。</li><li>由上述两条可知，找到最大匹配等价于此时二分图中不存在增广路。</li></ul><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>把二分图画成左边右边两个区域（黑点白点），两个区域中间有一些边，现在要在这些边里选择出一些，使形成一个最大匹配。</p><p>不妨以左边的点从上到下的顺序考虑</p><ul><li>对于左边的第<code>i</code>个点，遍历与之相邻的点<code>neighbor[i][j]</code>（一定在右侧）<ul><li>如果<code>neighbor[i][j]</code>还没有被匹配，那就把这两个点（暂时）匹配上，看左边的第<code>i+1</code>号点。</li><li>如果<code>neighbor[i][j]</code>已经被匹配过了，那就看看之前和<code>neighbor[i][j]</code>匹配的点还能不能匹配其他点（此时视角转换成<code>neighbor[i][j]</code>之前确定的那个匹配点（左边的点），递归进去）。<ul><li>如果<code>neighbor[i][j]</code>之前的匹配点可以换一个匹配对象，就换，把<code>neighbor[i][j]</code>留给现在考虑的<code>i</code>号点，不能换就算了，看<code>j+1</code>号点</li></ul></li><li>如果能找到一个合适的匹配点，就返回<code>true</code>，反之返回<code>false</code></li></ul></li></ul><p>这是一个类似于<code>dfs</code>的过程，被访问的点不应到再被访问一次，所以用一个<code>vis</code> 数组记录<code>dfs</code>过程中的访问情况，注意这里的<strong>访问情况</strong>和<strong>匹配情况</strong>的区别，代码中的<code>vis</code>是访问情况，<code>con_x</code> <code>con_y</code>是匹配情况。所以<code>vis</code>每看一个左边的点就要全部设置为未访问一次。</p><p>理解这个过程之后，发现真的很像相亲……</p><p>有点贪心的意思</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="HDU-2063-过山车"><a href="#HDU-2063-过山车" class="headerlink" title="HDU-2063 过山车"></a>HDU-2063 过山车</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> p[MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>], vis[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> con_x[MAXN * <span class="number">2</span>], con_y[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (con_y[i] == <span class="number">-1</span> || match(con_y[i])) &#123;</span><br><span class="line">                con_x[x] = i;</span><br><span class="line">                con_y[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;n, &amp;m) != EOF &amp;&amp; k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(con_x, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_x));</span><br><span class="line">        <span class="built_in">memset</span>(con_y, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_y));</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="literal">false</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> girl, boy;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girl, &amp;boy);</span><br><span class="line">            p[girl][boy + n] = p[boy + n][girl] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="http://ilern.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>manacher学习笔记</title>
    <link href="http://ilern.github.io/2019/11/04/manacher_learn/"/>
    <id>http://ilern.github.io/2019/11/04/manacher_learn/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2019-11-04T12:26:09.914Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="Manacher简介"><a href="#Manacher简介" class="headerlink" title="Manacher简介"></a>Manacher简介</h2><p>Manacher算法用于高效解决这样的问题：给定一个长度为 $n$ 的字符串，求其中以每个字符为中心的<strong>回文子串</strong>的长度。</p><h3 id="什么是回文串？"><a href="#什么是回文串？" class="headerlink" title="什么是回文串？"></a>什么是回文串？</h3><p>正着读和反着读都一样的字符串，例如<code>()()</code>不是一个回文串，而<code>())(</code>是一个回文串。</p><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><h3 id="最蠢的那种"><a href="#最蠢的那种" class="headerlink" title="最蠢的那种"></a>最蠢的那种</h3><p>$O(n^2)$ 枚举子串，$O(n)$ 判断是否为回文，总复杂度$O(n^3)$</p><h3 id="稍微好一点"><a href="#稍微好一点" class="headerlink" title="稍微好一点"></a>稍微好一点</h3><p>$O(n)$枚举中心，向两边尽量扩展，复杂度$O(n^2)$</p><h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher 利用了回文串具有的<strong>对称性</strong>来通过之前计算过的子串的信息优化对当前位置的计算。这一点和<a href="https://ilern.github.io/2019/09/26/KMP_learn/">KMP算法</a>可以说异曲同工。</p><p>首先明确最后要通过这个算法得到什么东西。一个数组<code>p</code>，其中<code>p[i]</code>表示以<code>i</code>为中心的最大回文半径。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>最后求出的<code>p</code>数组应当为</p><p><code>p = [1, 1, 2, 3, 4, 3, 2, 1, 1]</code></p><p>这样知道了最大回文半径，也就能求出以每个字符为中心的最长回文子串长度。</p><p>但是这样的做法不够完善，例如对于<code>baaaab</code>这个字符串，本身是一个回文串，那么最长回文子串自然是它本身，但是按照<code>p</code>数组的定义，这个字符串对应的<code>p</code>应该是<code>[1, 1, 2, 2, 1, 1]</code>，而仅仅通过这个数组是求不出最长回文子串的。</p><p>问题就出在这个串的长度是偶数，在这个串中不存在一个<strong>中心</strong>作为这个子串的中心。</p><p>所以需要进行预处理来使得这个算法支持偶数长的子串。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>个人感觉这一步相当巧妙。</p><p>对于原串，我们在开头插入一个<code>$</code>，在每个字符前后都插入一个<code>#</code>。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>预处理之后结果为</p><p><code>s1 = &quot;$#c#a#b#a#d#a#b#a#e#&quot;</code></p><p>这里的<code>$</code>和<code>#</code>并不是一定用这两个字符，只要是不在原串中出现的字符都可以。</p><p>经过这样的预处理我们发现之前不存在对称中心的问题解决了，偶数长度的子串在新字符串中以<code>#</code>为对称中心，奇数长度的子串在新字符串中还是以原来的对称中心为对称中心，且原字符串的回文子串长度等于新字符串回文半径长度减一。</p><p>添加开头的<code>$</code>是为了更好判断边界，不添加也可以，但是在边界处理上会麻烦一些。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在第二个暴力算法中，还是以<code>s = &quot;cabadabae&quot;</code>为例，假如我们已经知道了以第三位为中心的最大回文半径（相当于知道了以第三位为中心的最长回文子串）和以第五位为中心的最大回文半径，那么在求以第七位为中心的最大回文半径的时候，由于回文串具有<strong>对称</strong>的特性，并且三和七<del>恰好</del>关于五对称，所以可以直接得到（部分）结果。</p><ul><li>以第三位为中心的最长回文子串 <code>c[aba]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[aba]e</code></li></ul><p>所以可以直接从长度为3开始拓展（因为目前为止更后面的信息还不知道）。</p><p>如果换成计算第六位的时候又是怎样的情况呢？六关于五的对称点为四。</p><ul><li>以第二位为中心的最长回文子串 <code>cab[a]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[a]bae</code></li></ul><p>长度只能为1。</p><p>不难发现，在已知当前最长的回文串是以五位中心之后，再往后的位置都可以直接由对称性来得到至少一部分信息。我们利用这些信息，就能很快求出所有的回文子串。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设置两个状态 <code>maxR</code> 和 <code>id</code>，分别表示当前已知的回文子串的最右边界和这个边界所对应的中心。</p><p>设<code>p[i]</code>表示第<code>i</code>个字符为中心时最大回文子串的长度，按照<code>i</code>从大到小的顺序从左向右计算。</p><p>对于每一个即将计算到的<code>i</code>，先计算出关于<code>id</code>的对称点<code>j = id * 2 - i</code>，然后分以下三种情况进行。</p><ul><li>若 $i &gt; maxR$，即这个点不在之前计算过的回文串中，此时我们并不能从之前的计算中获取有用的信息，只能令<code>p[i] = 1</code>，然后从这个位置开始向两边扩展，顺便更新 <code>maxR</code> 和 <code>id</code></li><li>若 $i \leq maxR$ 且 $i + p[j] &lt; maxR$ ​，此时有 <code>p[i] = p[j]</code>，如同上面的第二个例子。</li><li>若 $i \leq maxR$ 且 $i + p[j] \geq maxR$，此时已知的最长回文串覆盖了<code>i</code>这个位置但是没有覆盖<code>j</code>为中心的回文串，此时有<code>p[i] = maxR - i</code>。</li></ul><p>这样确定<code>p[i]</code>最小可能的值然后再尝试向两边扩展即可，其中第二种情况应该是无法继续扩展的。</p><blockquote><p>1、先对字符串进行预处理，两个字符之间加上特殊符号#</p><p>2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）</p><p>3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度</p><p>4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界</p><p>5、最后得到最长回文之后，去掉其中的特殊符号即可</p></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">P3805 【模板】manacher算法</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">11000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[MAXN * <span class="number">2</span> + <span class="number">10</span>], maxR = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"$"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">        ret += <span class="string">"#"</span>;</span><br><span class="line">        ret += c;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sp = preProcess(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; maxR) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = id * <span class="number">2</span> - i;</span><br><span class="line">            p[i] = min(p[j], maxR - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = i - p[i];</span><br><span class="line">        <span class="keyword">int</span> r = i + p[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sp[l] == sp[r]) &#123;</span><br><span class="line">            l--; r++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; maxR) &#123;</span><br><span class="line">                maxR = r;</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p[i] = r - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        maxx = max(maxx, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxx - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTE1ODkyNQ==&amp;mid=2649410225&amp;idx=1&amp;sn=ed045e8edc3c49a436a328e5f0f37a55&amp;chksm=f0b60f53c7c18645b4c04a69ad314723cce94ed56994d6f963c2275a2db8d85f973f15f508e4&amp;mpshare=1&amp;scene=23&amp;srcid=1001JCsBlpxgUWjgixasChNQ#rd" target="_blank" rel="noopener">【面试现场】如何找到字符串中的最长回文子串？</a></p><p><a href="https://oi.men.ci/manacher-notes/" target="_blank" rel="noopener">Manacher 学习笔记 - Menci</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://ilern.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记 - 文件操作</title>
    <link href="http://ilern.github.io/2019/10/30/filepython/"/>
    <id>http://ilern.github.io/2019/10/30/filepython/</id>
    <published>2019-10-29T16:00:00.000Z</published>
    <updated>2019-11-03T06:48:24.982Z</updated>
    
    <content type="html"><![CDATA[<p>真是令人迷惑</p><a id="more"></a><h3 id="何为文件"><a href="#何为文件" class="headerlink" title="何为文件"></a>何为文件</h3><p>文件可以看作数据的抽象和集合。是数据存储的一种形式，由二进制存储。</p><p><code>Linux</code>认为一切都是文件， 在<code>UNIX</code>系统中，一切资源都被看作是文件，包括硬件设备。<code>UNIX</code>系统把每个硬件都看成是一个文件，称之为<strong>设备文件</strong>。</p><h3 id="文件的类型-展示方式"><a href="#文件的类型-展示方式" class="headerlink" title="文件的类型 / 展示方式"></a>文件的类型 / 展示方式</h3><ul><li><p>文本文件</p><ul><li><p><strong>单一而特定</strong>的编码组成的文件， 例如<code>UTF-8</code>编码。</p></li><li><p>可以看作一个长的字符串。</p></li></ul></li><li><p>二进制文件</p><ul><li><p>直接由<strong>0和1</strong>构成的文件，没有统一的编码格式。一般这样的文件中的0和1是由某种预定的格式组合成的，因此形成了一些特定的文件类型，例如图片的 <code>.png</code>，视频的<code>.avi</code>。</p></li><li><p>这类文件的0和1之上没有统一的编码。</p></li></ul></li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>文件的操作通常遵循 “打开，操作，关闭” 的步骤，关系如下图所示</p><div id="sequence-0"></div><ul><li><p>文件的打开</p><ul><li><p><code>f = open(&lt;file_name&gt;, &lt;open_mode&gt;)</code></p></li><li><p>文件名可以使用相对路径也可以使用绝对路径</p></li><li><p>Python提供七种文件打开模式，与C类似</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">打开模式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center"><strong>默认</strong>打开模式，只读，若文件不存在则抛出异常</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">覆盖写，若不存在则创建，若存在则完全覆盖</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">创建写，若不存在则创建，若存在则抛出异常</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">追加写，若不存在则创建，若存在则在文件后追加</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">二进制打开</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">文本打开，<strong>默认</strong>方式</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">与前四种模式一同使用，在原本的基础上增加读写功能</td></tr></tbody></table></div><ul><li><p>默认的文件编码格式为<code>UTF-8</code>，要打开其他编码格式的文件要在打开文件时为<code>read</code>添加参数<code>encoding</code>表示要使用的编码方式。</p></li><li><p>如果编码方式不规范，<code>open</code>会抛出异常，遇到这种情况可以添加<code>errors</code>参数表示如何处理，最简单的方式就是直接忽略<code>error = &#39;ignore&#39;</code>。</p></li></ul><ul><li><p>文件的关闭</p><ul><li><code>f.close()</code>用来关闭文件，使文件回到存储状态。</li></ul></li><li><p>处理异常</p><p>由于在每次打开文件的时候都可能会产生异常，所以应该对异常采取适当的处理方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>因为每次都要<code>try-finally</code>，过于繁琐，Python提供了<code>with</code>语句来简单处理（不局限但普遍应用于文件操作）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using with statement </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_path'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file: </span><br><span class="line">    file.write(<span class="string">'hello world !'</span>)</span><br></pre></td></tr></table></figure><p>这样的写法不需要自己手动关闭文件，也不需要手动捕获异常。</p></li></ul><h3 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h3><ul><li>python提供三种文件读取的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.read()</code></td><td style="text-align:center">直接读入整个文件，存到字符串当中，对于大文件慎用</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.read(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline()</code></td><td style="text-align:center">读一行</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readlines()</code></td><td style="text-align:center">读入所有行，组织成一个列表</td></tr><tr><td style="text-align:center"><code>&lt;dile_object&gt;.readlines(hint)</code></td><td style="text-align:center">读入前<code>hint</code> 行，组织成一个列表</td></tr></tbody></table></div><ul><li><p>逐行遍历文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h3><p>想要写入文件，在打开文件时应该用<code>w</code> / <code>wb</code>形式</p><ul><li>python提供两种写文件的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.write(str)</code></td><td style="text-align:center">写字符串或文件流到文件中</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.writelines(list)</code></td><td style="text-align:center">把一个全为字符串的列表写到文件里，实际上是把列表中的字符串续到一起</td></tr></tbody></table></div><ul><li><p>文件指针</p><ul><li><p>不是C语言里的那种文件指针。</p></li><li><p>就像文本编辑器里的光标一样，表示当前写入的位置。</p></li><li><p>使用<code>&lt;file_project&gt;.seek()</code>来调整文件指针</p><ul><li><p><code>seek()</code>接受两个参数，第一个参数表示偏移量，第二个参数表示起点（0-从开头开始，1-从当前位置开始，2-从末尾开始）</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'hihi '</span>, <span class="string">'haha '</span>, <span class="string">'hoho '</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br><span class="line">    <span class="comment"># f.seek(0, 0)  #hihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(1, 0)  #ihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(2, 0)  #hi haha hoho</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 1)  #None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 2)  #None</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li><li><p>如果写入之后接着读取是什么都读不到的，因为文件指针默认从当前位置开始读，而刚写入之后文件指针的后面什么都没有，需要移动之后再输出</p></li></ul></li></ul></li></ul><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant 存储状态 as ffparticipant 占用状态 as kkff-->kk: a = open(, )kk-->ff: a.close()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是令人迷惑&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ilern.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP学习笔记</title>
    <link href="http://ilern.github.io/2019/09/26/KMP_learn/"/>
    <id>http://ilern.github.io/2019/09/26/KMP_learn/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-11-04T08:08:43.998Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="KMP简介"><a href="#KMP简介" class="headerlink" title="KMP简介"></a>KMP简介</h2><p>KMP算法用于高效解决这样的问题：给定一个有 $n$ 个字符的字符串 <code>txt</code> 和一个有 $m$ 个字符的字符串 <code>pat</code> （$n &gt; m$），找出 <code>txt</code> 中 <code>pat</code> 每次出现的位置 。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input : txt[] = &quot;THIS IS A TEST TEXT&quot;</span><br><span class="line">        pat[] = &quot;TEST&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 10</span><br></pre></td></tr></table></figure><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:  txt[] = &quot;AABAACAADAABAABA&quot;</span><br><span class="line">        pat[] = &quot;AABA&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 0</span><br><span class="line">        Pattern found at index 9</span><br><span class="line">        Pattern found at index 12</span><br></pre></td></tr></table></figure><h2 id="暴力匹配法"><a href="#暴力匹配法" class="headerlink" title="暴力匹配法"></a>暴力匹配法</h2><p>对于这个问题，最容易想到的方法就是一个位置一个位置尝试匹配，每次将模式串 <code>pat</code> 向后移动一位，就像一个滑动的窗口一样，每次比较 $m$ 个位置。</p><p>但是这个方法在很多匹配的字符后面跟着一个不匹配的字符的情况下表现不够好，最坏的情况复杂度会达到 $O(m(n-m+1))$ 。</p><p>比如说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAAAAAAAAAAAAAAB&quot;</span><br><span class="line">pat[] = &quot;AAAAB&quot;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;ABABABCABABABCABABABC&quot;</span><br><span class="line">pat[] = &quot;ABABAC&quot;</span><br></pre></td></tr></table></figure></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法最基本的想法就是：不论我们在哪里失配了（在某些字符匹配成功之后），我们都知道了接下来要尝试匹配的 <code>txt</code> 的子串的一部分信息，因为每次 <code>pat</code> 都只向右移动一个字符，所以我们可以利用这一点来减少不必要的匹配。</p><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>第一次匹配是成功的，接下来 <code>pat</code> 串会向右移动一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>在暴力匹配算法中，我们会从 <code>txt</code> 的第二个位置，<code>pat</code>  的第一个位置开始尝试匹配，但是实际上我们只需要看<code>txt</code> 的第五个位置和 <code>pat</code> 的第四个位置是不是相同的就可以了，因为我们知道前三个字符一定会匹配。</p><p>为了做到这一点，我们需要进行一些预处理。</p><p>我们定义一个列表<code>lps[]</code>（<code>lps</code> 是 <strong>longest proper prefix which is also suffix</strong> 的缩写），<code>lps[i]</code>表示<code>pat</code> 中<code>[0, i]</code>这个子串中即是前缀又是后缀的最长的子串（不包括<code>[0, i]</code>这个子串本身）</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [0, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3]</span><br></pre></td></tr></table></figure><p>在有了<code>lps</code>数组之后，就可以进行我们的KMP算法了：</p><ul><li>我们用 <code>i</code> 来指示 <code>txt</code> 中当前考虑的元素的下标，<code>j</code>来指示 <code>pat</code> 中当前考虑元素的下标</li><li>匹配从<code>i = 0</code>，<code>j = 0</code> 开始，当 <code>txt[i] == pat[j]</code> 时，<code>i++; j++</code>，此时这个位置是匹配的</li><li>当<code>txt[i] != pat[j]</code>即这个位置不匹配的时候<ul><li>既然能进行到这一步，说明<code>pat</code>的<code>[0, j - 1]</code>中的每个位置和<code>txt</code>的<code>[i - j, i - 1]</code>中的每个位置都是匹配的</li><li>我们还知道<code>lps[j - 1]</code>表示<code>pat</code> 中<code>[0, j - 1]</code>这个子串中即是前缀又是后缀的最长的子串</li><li>基于以上两点，我们发现在<code>pat</code>向右移动一位准备开始下一次匹配的时候，<code>pat</code>的前<code>lps[j - 1]</code>个字符是不需要匹配的（一定可以匹配成功），<code>j</code>重置为<code>lps[j - 1]</code></li></ul></li></ul><p>简言之，以图中的例子来说，在 <code>i</code> 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串<code>i</code>之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p><img src="https://pic4.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg" alt="来自知乎">，</p><h3 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>直到<code>i = 4, j = 4</code>为止都是匹配的，此时一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code>，也就是说，在下一次匹配中，<code>pat</code> 的前三个字符都不必进行匹配（一定可以匹配成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 4, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>此时<code>i = 5, j = 4</code>，又一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =   &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[3 - 1] = lps[2] = 2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 2</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =    &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[2 - 1] = lps[1] = 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =     &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[1 - 1] = lps[0] = 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =      &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，但是此时<code>j = 0</code>，故<code>i++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 6, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =       &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>$\dots$</p><p>重复上述过程，直到<code>i = n</code>，算法结束。</p><h3 id="lps的计算"><a href="#lps的计算" class="headerlink" title="lps的计算"></a>lps的计算</h3><p>现在，问题只剩下如何求得<code>lps</code>这个列表了。</p><p>求解<code>lps</code>的过程可以看作模式串自己与自己匹配的过程，对于每个位置（除了0位置，0位置永远为0）都与自己从头开始匹配，能匹配的最大长度就是<code>lps</code>。</p><p>实现中用<code>len</code>记录当前匹配到的最大长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> txt[MAXN], pat[MAXN];</span><br><span class="line"><span class="keyword">int</span> lps[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> txt[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txt[i] == pat[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == lenB) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - j + <span class="number">1</span>);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcLps</span><span class="params">(<span class="keyword">int</span> lps[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenPat = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenPat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            lps[len] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[len] == pat[i]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                lps[i] = len;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    lps[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> len = lps[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, txt, pat);</span><br><span class="line">    calcLps(lps, pat);</span><br><span class="line">    KMP(txt, pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, lps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" target="_blank" rel="noopener">KMP Algorithm for Pattern Searching</a></p><p><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://ilern.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 3</title>
    <link href="http://ilern.github.io/2019/08/08/acmsummer_33/"/>
    <id>http://ilern.github.io/2019/08/08/acmsummer_33/</id>
    <published>2019-08-08T08:37:23.000Z</published>
    <updated>2019-08-08T12:46:02.633Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题限时训练一</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316474#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组限时训练1</a></p><a id="more"></a><h2 id="HDU-4217-Data-Structure-树状数组区间第k小-二分"><a href="#HDU-4217-Data-Structure-树状数组区间第k小-二分" class="headerlink" title="HDU 4217 Data Structure? - 树状数组区间第k小 + 二分"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4217" target="_blank" rel="noopener">HDU 4217 Data Structure? - 树状数组区间第k小 + 二分</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>在一个含有$1 \cdots n$的序列中，每次找到第 $k_i$ 小的数，并把它删除，每组数据，输出一个整数，表示删除元素的总和。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>发现一个数的排名只受它的位置之前被删除的数的个数影响，删除比它大的数不影响它的排名，这样问题就转化为了前缀和，可以用树状数组维护，对于要求排名 $k_i$ 的数，只会位于 $[k_i, n]$ 这个区间中，在这个区间二分找到将要被删除的那个数，计入答案即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">262144</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index]++;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf("[%d %d]", l, r);</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tmp = mid - bit.query(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> del = find(x, n, x);</span><br><span class="line"></span><br><span class="line">            ans += del;</span><br><span class="line">            bit.modify(del);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZOJ-1610-Count-the-Colors-区间染色"><a href="#ZOJ-1610-Count-the-Colors-区间染色" class="headerlink" title="ZOJ 1610 Count the Colors - 区间染色"></a><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1610" target="_blank" rel="noopener">ZOJ 1610 Count the Colors - 区间染色</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>对线段染色，后染上去的会覆盖前染上的，问完成染色后每种颜色各有多少段</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>线段树维护区间当前的颜色，对于每次修改，下放标记然后修改子树。</p><p>每组数据只有一次查询，在所有修改都结束之后记录下每个叶节点的颜色，把连续的相同颜色  都算成一段，统计即可</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        color = <span class="number">-1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) color = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color != <span class="number">-1</span>) &#123;</span><br><span class="line">            lc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line">            rc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;color = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), color);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, mid), r, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) v.push_back(<span class="keyword">this</span>-&gt;color);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;query(l, <span class="built_in">std</span>::min(r, mid), v);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegtree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegtree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegtree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, MAXN);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line"></span><br><span class="line">            root-&gt;modify(l, r, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        root-&gt;query(<span class="number">0</span>, MAXN, v);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt; v.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i + j] != v[i]) &#123;</span><br><span class="line">                    cnt[v[i]]++;</span><br><span class="line">                    i += j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, cnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        deleteSegtree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题限时训练一&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316474#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 1+2</title>
    <link href="http://ilern.github.io/2019/08/06/acmsummer_312/"/>
    <id>http://ilern.github.io/2019/08/06/acmsummer_312/</id>
    <published>2019-08-06T08:37:23.000Z</published>
    <updated>2019-08-08T13:22:59.897Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316346" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/316349" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练2</a></p><a id="more"></a><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Ultra-QuickSort-树状数组求逆序对-离散化"><a href="#C-Ultra-QuickSort-树状数组求逆序对-离散化" class="headerlink" title="C - Ultra-QuickSort - 树状数组求逆序对 + 离散化"></a><a href="https://cn.vjudge.net/contest/316346#problem/C" target="_blank" rel="noopener">C - Ultra-QuickSort - 树状数组求逆序对 + 离散化</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列，求对于升序排序的逆序对个数</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>树状数组求逆序对的模板题。</p><p>树状数组可以处理的问题是前缀和，对于某个元素来说，升序排序的逆序对的个数就是位置在它后面数值比他小的数的个数，这个就是一个前缀和的问题了。</p><p>对于每个元素，记录他的值和他的位置，按照从数值小到大的顺序排序去重完成离散化之后，把原数组从后往前的每个元素在排序好的数组中找到位置，用树状数组维护这个位置数组，这个位置的前缀和就是这个数逆序数，在找到的位置处加一。</p><p>例如 </p><script type="math/tex; mode=display">a = [9, 1, 0, 5, 4] \\a' = [0, 1, 5, 4, 9]\\</script><p>从后往前遍历 <code>a</code> 数组，</p><p>首先找到 $4$ ，在 <code>a&#39;</code> 数组中查找发现 $4$ 在第 $4$ 个位置，在树状数组中查询 $4$ 这个位置，发现前缀为 $0$ ，也就是 $4$ 后面数值比他小的数的个数为 $0$ ，也就是 $4$ 对于逆序数的贡献为 $0$，接下来在树状数组中把 $4$ 这个位置加一，</p><p>接下来找到 $5$ , 在 <code>a&#39;</code> 数组中查找发现 $5$ 在第 $3$ 个位置，在树状数组中查询 $3$ 这个位置，发现前缀为 $1$ ，也就是之前插入的 $4$，这说明 $5$ 后面数值比他小的数的个数为 $1$，也就是 $5$ 对于逆序数的贡献为 $1$，接下来在树状数组中把 $3$ 这个位置加一，</p><p>以此类推，最后的结果就是逆序对的总数。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    Bit(<span class="keyword">int</span> size) : size(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        bit.size = n;</span><br><span class="line">        <span class="built_in">memset</span>(bit.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit.a));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            v.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator newEnd = <span class="built_in">std</span>::unique(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">std</span>::lower_bound(v.begin(), newEnd, a[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">            ans += bit.query(index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            bit.modify(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理"><a href="#E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理" class="headerlink" title="E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3333" target="_blank" rel="noopener">E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列和若干询问，对于每个询问给出区间中不重复的元素的和</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>单独的一棵线段树/树状数组不能维护所有区间的不重复元素和，需要主席树等数据结构，这里的做法是离线处理每个查询。</p><p>把所有询问存下来，按照右端点从小到大排序，从小到大依次处理每个询问，对于一个新的询问，考察比上一个询问扩展出来的部分是否有之前出现过的元素，如果有就把之前的元素删除，把最近的加入，这样就保证了每个元素在每个询问中只出现一次，且是所有出现中最右边的那个。</p><p>更新完之后就可以用树状数组查询了。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        bit.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        bit.size = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            v.push_back(Query(l, r, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= it-&gt;r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.count(a[i])) bit.modify(mp[a[i]], -a[i]);</span><br><span class="line"></span><br><span class="line">                bit.modify(i, a[i]);</span><br><span class="line">                mp[a[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(<span class="built_in">std</span>::make_pair(it-&gt;id, bit.query(it-&gt;r) - bit.query(it-&gt;l - <span class="number">1</span>)));</span><br><span class="line">            l = it-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理"><a href="#F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理" class="headerlink" title="F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener">F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理</a></h2><h3 id="【题目大意】-2"><a href="#【题目大意】-2" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>马里奥吃金币，马里奥有在每个区间里有一个跳跃高度，只能吃到小于等于这个高度的硬币，给出若干组询问，问某个区间中能吃到多少金币。</p><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>离线处理所有询问，把每个点和每个询问都按照高度从小到大排序，排序后从小到大考察每个询问。</p><p>利用树状数组前缀求和的特点，只需要设置一个变量表示现在到了哪个金币，如果这个金币的高度小于当前询问的高度，就加入到树状数组当中，因为询问高度是单调增的，所以在前面的询问中加入的点仍然满足后面询问的条件，这样就只需要用树状数组维护一下区间和了。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; qs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i].h);</span><br><span class="line">            num[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;qs[i].l, &amp;qs[i].r, &amp;qs[i].h);</span><br><span class="line">            qs[i].l++;</span><br><span class="line">            qs[i].r++;</span><br><span class="line"></span><br><span class="line">            qs[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(qs, qs + m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt;= n &amp;&amp; num[cnt].h &lt;= qs[i].h) &#123;</span><br><span class="line">                bit.modify(num[cnt++].id, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[qs[i].id] = bit.query(qs[i].r) - bit.query(qs[i].l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="C-An-easy-problem-线段树维护区间乘积"><a href="#C-An-easy-problem-线段树维护区间乘积" class="headerlink" title="C - An easy problem - 线段树维护区间乘积"></a><a href="https://cn.vjudge.net/contest/316349#problem/C" target="_blank" rel="noopener">C - An easy problem - 线段树维护区间乘积</a></h2><h3 id="【题目大意】-3"><a href="#【题目大意】-3" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>令$x = 1$，给出两种操作</p><ul><li>操作<code>(1, a)</code>表示令 $x = a \cdot x$ </li><li>操作<code>(2, i)</code>表示令 $x = \frac{x}{a[i]}$，其中 $a[i]$ 表示第 $i$ 个一号操作中的<code>a</code>。</li></ul><p>问经过若干次操作之后 $x$ 的值是多少。</p><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>看上去维护一个数的更改，和线段树没有什么关系，其实把所有的一操作看作一个序列，问题就变成了维护区间乘积，二操作相当于把序列中的某个位置改成 $1$ ，这样就可以用线段树维护单点修改和区间乘积了。</p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> data;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="number">1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = (lc-&gt;data % mod * rc-&gt;data % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line">            <span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r)) % mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r) % mod) % mod;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;q, &amp;mod);</span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, q);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) root-&gt;modify(i, x);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) root-&gt;modify(x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;query(<span class="number">0</span>, q));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-HDU-2795-Billboard-线段树变形"><a href="#G-HDU-2795-Billboard-线段树变形" class="headerlink" title="G - HDU 2795 -Billboard - 线段树变形"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2795" target="_blank" rel="noopener">G - HDU 2795 -Billboard - 线段树变形</a></h2><h3 id="【题目大意】-4"><a href="#【题目大意】-4" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一个广告牌，有很多人往上贴广告，每个广告占一个单位高度，若干单位长度，广告优先往上边贴，同样高度情况下优先往左边贴，如果没有空间贴，就不贴。</p><p>对于每一张广告，询问它被贴在哪一行。</p><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题的修改的基本单位是行，以行为单位划分区间，想象把广告牌逆时针旋转九十度，建立线段树。</p><p>线段树维护每个区间中剩余空间的最大值，如果我们想贴一张新的海报上去，先与线段树的根节点值比较，如果大于根节点的值，说明所有行都没有空间贴这张新的海报；如果小于，就再与左右节点比较，以此类推，直到找到能贴的位置，注意要先和左子树比较再和右子树比较，因为要求尽量贴得高，旋转之后就是尽量贴得左。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = w;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="built_in">std</span>::max(lc-&gt;data, rc-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", this-&gt;l, this-&gt;r);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data = SegmentTree::w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int query(int l, int r) &#123;</span></span><br><span class="line">    <span class="comment">//     if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return this-&gt;data;</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         int ans = INT_MIN;</span></span><br><span class="line">    <span class="comment">//         if (l &lt; mid) ans = std::max(ans, query(l, std::min(r, mid)));</span></span><br><span class="line">    <span class="comment">//         if (r &gt; mid) ans = std::max(ans, query(std::max(l, mid), r));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         return ans;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data -= delta;</span><br><span class="line">            <span class="comment">// if (ans &lt;  this-&gt;id) ans = this-&gt;id;</span></span><br><span class="line">            ans = <span class="keyword">this</span>-&gt;id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lc-&gt;data &gt;= delta) lc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rc-&gt;data &gt;= delta) rc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d %d], data = %d\n"</span>, <span class="keyword">this</span>-&gt;l, <span class="keyword">this</span>-&gt;r, <span class="keyword">this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (lc) lc-&gt;print();</span><br><span class="line">        <span class="keyword">if</span> (rc) rc-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SegmentTree::w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree::w = w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int m = h;</span></span><br><span class="line">        <span class="comment">// if (h &gt; n) m = n;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">200000</span>) h = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("m = %d\n", m);</span></span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, h);</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", root-&gt;l, root-&gt;r);</span></span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("root-&gt;data = %d\n", root-&gt;data);</span></span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;modify(x) != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316346&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 4</title>
    <link href="http://ilern.github.io/2019/08/04/acmsummer_24/"/>
    <id>http://ilern.github.io/2019/08/04/acmsummer_24/</id>
    <published>2019-08-04T08:37:23.000Z</published>
    <updated>2019-08-02T11:11:40.382Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练二，题目多为思维题，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/314478#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练二，题目多为思维题，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/314478#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 3</title>
    <link href="http://ilern.github.io/2019/08/01/acmsummer_23/"/>
    <id>http://ilern.github.io/2019/08/01/acmsummer_23/</id>
    <published>2019-08-01T08:37:23.000Z</published>
    <updated>2019-08-02T08:53:43.242Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练一，题目简单且友好，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314466#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练1</a></p><a id="more"></a><h2 id="D-D1-Add-on-a-Tree"><a href="#D-D1-Add-on-a-Tree" class="headerlink" title="D - D1. Add on a Tree"></a><a href="https://cn.vjudge.net/contest/314466#problem/D" target="_blank" rel="noopener">D - D1. Add on a Tree</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一棵树，在这棵树上有这样的操作：选择两个叶节点，将连接他们的路径上的边全部加上某个<strong>实数</strong> 。</p><p>问是否任意的边权都能通过这种方法构造出来。</p><p><img src="https://vj.ti12z.cn/534562b9f71c214456d4ad6501057031?v=1564228755" alt="NO"></p><p>这棵树不满足条件</p><p><img src="https://vj.ti12z.cn/c3350c6775c16b2e8fc87ea1963db02a?v=1564228755" alt="YES"></p><p>这棵树满足条件</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始以为是 <code>LCA</code> 结果是普通的思维题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-B-Letters-Shop-二分查找"><a href="#G-B-Letters-Shop-二分查找" class="headerlink" title="G - B. Letters Shop - 二分查找"></a><a href="https://cn.vjudge.net/contest/314466#problem/G" target="_blank" rel="noopener">G - B. Letters Shop - 二分查找</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 $S$ ，从中取前缀组合成新的字符串，给出目标字符串，输出最小需要的前缀的长度，数据保证目标串一定可以由 $S$ 的前缀的字符重新组合而成。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不关心目标串中字符出现的顺序，只要前缀中相应字符的数目多于目标串中该字符数目即可，先预处理出每个前缀中的每个字母的个数，对于每个目标串，统计其中各个字母的个数，与每个前缀比较，满足条件即可。</p><p>朴素的线性比较会<code>TLE</code>，改成二分查找即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>][s[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">        a[i][s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line">        fill(b, b + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s1) &#123;</span><br><span class="line">            b[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[mid][k] &lt; b[k]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; l + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-B-Yet-Another-Crosses-Problem-模拟"><a href="#H-B-Yet-Another-Crosses-Problem-模拟" class="headerlink" title="H - B. Yet Another Crosses Problem - 模拟"></a><a href="https://cn.vjudge.net/contest/314466#problem/H" target="_blank" rel="noopener">H - B. Yet Another Crosses Problem - 模拟</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一些方格图，<br><img src="https://vj.ti12z.cn/b3bf19b1108c5f82bd973def2f3b1a20?v=1564477339" alt="pic1"></p><p><img src="https://vj.ti12z.cn/0f6acf44abaaaf4dade9e99d5c3067c9?v=1564477339" alt="pic2"></p><p>现在需要把一些白格子染成黑色，使得图里存在至少一个<code>cross</code>（如pic2）。</p><p>问最少染几个白格子。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>之前在cf上遇到了这题，当时没做出来。</p><p>其实很简单，要构成<code>cross</code>必须至少有一整行和一整列都是黑色的，那就把每行每列有多少黑色统计出来，枚举每种行列的组合，找出一个黑色数目最多的，把剩下的染上就行了。</p><p>但是有一个问题是，行数和列数的最大值都很大，开二维数组是开不下的。注意到虽然 $n, m$ 都很大，但是 $n \cdot m$ 是不大的，所以用 <code>std::string</code> 数组比较好</p><p>深夜果然容易神志不清。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row[MAXN], col[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'*'</span>) row[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'*'</span>) col[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, row[i] + col[j] - (s[i][j] == <span class="string">'*'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n + m - <span class="number">1</span> - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练一，题目简单且友好，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314466#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 1+2</title>
    <link href="http://ilern.github.io/2019/07/31/acmsummer_212/"/>
    <id>http://ilern.github.io/2019/07/31/acmsummer_212/</id>
    <published>2019-07-31T08:37:23.000Z</published>
    <updated>2019-08-03T13:51:31.826Z</updated>
    
    <content type="html"><![CDATA[<p>基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314459" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/314460" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练2</a></p><a id="more"></a><h1 id="新的邻接表写法"><a href="#新的邻接表写法" class="headerlink" title="新的邻接表写法"></a>新的邻接表写法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dfn, degree;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), degree(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v]));</span><br><span class="line">    nodes[v].edges.push_back(Edge(&amp;nodes[v], &amp;nodes[u]));</span><br><span class="line"></span><br><span class="line">    nodes[u].degree++;</span><br><span class="line">    nodes[v].degree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的好处是多组数据初始化的时候边的删除很方便，尤其相对于之前的版本来说。</p><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Skiing-最短路"><a href="#C-Skiing-最短路" class="headerlink" title="C - Skiing - 最短路"></a><a href="https://cn.vjudge.net/contest/314459#problem/C" target="_blank" rel="noopener">C - Skiing - 最短路</a></h2><h2 id="F-Sorting-It-All-Out-拓扑排序"><a href="#F-Sorting-It-All-Out-拓扑排序" class="headerlink" title="F - Sorting It All Out - 拓扑排序"></a><a href="https://cn.vjudge.net/contest/314459#problem/F" target="_blank" rel="noopener">F - Sorting It All Out - 拓扑排序</a></h2><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="D-Caterpillar-DFS"><a href="#D-Caterpillar-DFS" class="headerlink" title="D - Caterpillar - DFS"></a><a href="https://cn.vjudge.net/contest/314460#problem/D" target="_blank" rel="noopener">D - Caterpillar - DFS</a></h2><h2 id="E-昂贵的聘礼"><a href="#E-昂贵的聘礼" class="headerlink" title="E - 昂贵的聘礼 "></a><a href="https://cn.vjudge.net/contest/314460#problem/E" target="_blank" rel="noopener">E - 昂贵的聘礼 </a></h2><h2 id="F-最短路径问题-最短路"><a href="#F-最短路径问题-最短路" class="headerlink" title="F - 最短路径问题 - 最短路"></a><a href="https://cn.vjudge.net/contest/314460#problem/F" target="_blank" rel="noopener">F - 最短路径问题 - 最短路</a></h2><h2 id="K-Highways"><a href="#K-Highways" class="headerlink" title="K - Highways "></a><a href="https://cn.vjudge.net/contest/314460#problem/K" target="_blank" rel="noopener">K - Highways </a></h2><h2 id="L-Truck-History"><a href="#L-Truck-History" class="headerlink" title="L - Truck History "></a><a href="https://cn.vjudge.net/contest/314460#problem/L" target="_blank" rel="noopener">L - Truck History </a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>差分约束系统学习笔记</title>
    <link href="http://ilern.github.io/2019/07/30/difference_constraints/"/>
    <id>http://ilern.github.io/2019/07/30/difference_constraints/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:38:45.435Z</updated>
    
    <content type="html"><![CDATA[<p>数学问题转化到图论上解决，有点巧妙。</p><a id="more"></a><p>差分约束系统是一种特殊的 $N$ 元一次不等式组。包含 $N$ 个变量，$M$ 个约束条件，每个约束条件都是以差分的形式给出，形如 $X_i - X_j \leq c_k$。</p><p>现在要求 $X_i$ 的一组解，使得所有不等式成立。</p><p>对于这样的问题，有一个统一的转化方法：</p><ul><li>把不等式表示成 $X_i - X_j \leq c_k$ 的形式，</li><li>把每个变量 $X_i$ 看作 <strong>有向图</strong> 中的一个结点 $i$，把每个约束条件 $X_i - X_j \leq c_k$ 看作从 $i$ 到 $j$ 连一条长度为 $c_k$ 的有向边，</li><li>注意到此时建立的图不一定联通，需要添加一个超级源点，从 $0$ 号结点向每个点连一条边权为$0$ 的边。</li><li>用 <strong>spfa</strong> 求出 $0$ 号点到各个点的最短路，如果最短路存在，那么每个点的 <code>dis</code> 值就是原不等式组的一组解。</li><li>如果有负环，则解不存在，为了解决负环的问题，只能用 <strong>spfa</strong> 来求最短路。</li></ul><p>为什么这样是对的？看上去毫不相干的不等式怎么和最短路怎么联系起来的呢？<br><del>其实不知道也没关系</del></p><p><a href="https://blog.csdn.net/PleasantlY1/article/details/82775505" target="_blank" rel="noopener">有空就学</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数学问题转化到图论上解决，有点巧妙。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Poj 3169] Layout - 差分约束 + spfa</title>
    <link href="http://ilern.github.io/2019/07/30/poj_3169/"/>
    <id>http://ilern.github.io/2019/07/30/poj_3169/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:51:45.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>遇到这题才去学的<a href="https://ilern.github.io/2019/07/30/difference_constraints/">差分约束系统</a>。</p><p>明显题目中给出了关于两元素差的不等式，是差分约束的模型，转化成标准的模式 $a - b \leq c$，建图之后<code>SPFA</code>求出最短路即可，答案为<code>nodes[n].dis</code>。 </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dis, times;</span><br><span class="line">    <span class="keyword">bool</span> inQue;</span><br><span class="line"></span><br><span class="line">    Node() : dis(INT_MAX), times(<span class="number">0</span>), inQue(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;times++;</span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = v-&gt;edges.begin(); it != v-&gt;edges.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;to-&gt;dis &gt; v-&gt;dis + it-&gt;w) &#123;</span><br><span class="line">                it-&gt;to-&gt;dis = v-&gt;dis + it-&gt;w;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!it-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    it-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                    it-&gt;to-&gt;times++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;to-&gt;times &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    q.push(it-&gt;to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ml, md;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;ml, &amp;md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &lt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, -w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; n; i++) addEdge(i, i + 1, 0);</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) addEdge(0, i, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spfa(nodes + <span class="number">1</span>, n)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[n].dis == INT_MAX) <span class="built_in">printf</span>(<span class="string">"-2"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[n].dis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目大意】&quot;&gt;&lt;a href=&quot;#【题目大意】&quot; class=&quot;headerlink&quot; title=&quot;【题目大意】&quot;&gt;&lt;/a&gt;【题目大意】&lt;/h3&gt;&lt;p&gt;有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="差分约束" scheme="http://ilern.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-4</title>
    <link href="http://ilern.github.io/2019/07/27/acmsummer_14/"/>
    <id>http://ilern.github.io/2019/07/27/acmsummer_14/</id>
    <published>2019-07-27T15:37:23.000Z</published>
    <updated>2019-07-30T10:15:32.607Z</updated>
    
    <content type="html"><![CDATA[<p>第一周限时训练二</p><p><img src="https://s2.ax1x.com/2019/07/30/eJG8hT.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/312636" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周限时训练二&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/30/eJG8hT.png&quot; alt=&quot;rank&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/312636&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt;限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-3</title>
    <link href="http://ilern.github.io/2019/07/26/acmsummer_13/"/>
    <id>http://ilern.github.io/2019/07/26/acmsummer_13/</id>
    <published>2019-07-26T15:37:23.000Z</published>
    <updated>2019-07-30T10:07:52.832Z</updated>
    
    <content type="html"><![CDATA[<p>第一周限时训练一</p><p><img src="https://s2.ax1x.com/2019/07/27/euRsht.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312627#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练1</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周限时训练一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/27/euRsht.png&quot; alt=&quot;rank&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/312627#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt;限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-2</title>
    <link href="http://ilern.github.io/2019/07/25/acmsummer_12/"/>
    <id>http://ilern.github.io/2019/07/25/acmsummer_12/</id>
    <published>2019-07-25T08:37:23.000Z</published>
    <updated>2019-07-31T13:25:32.315Z</updated>
    
    <content type="html"><![CDATA[<p>数学与DP专题二，比较难，不怎么会</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312624" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em> 专题训练2</a></p><a id="more"></a><h2 id="A-Easy-Game-区间DP"><a href="#A-Easy-Game-区间DP" class="headerlink" title="A - Easy Game - 区间DP "></a><a href="https://cn.vjudge.net/contest/312624#problem/A" target="_blank" rel="noopener">A - Easy Game - 区间DP </a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组，$A，B$ 两人轮流从数组的开头或结尾取走一个或若干个连续的数，取走的数的和记为得分。现在 $A$ 先开始这个游戏，问在最优情况下 $A$ 比 $B$ 多得多少分</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看上去像博弈，其实是DP</p><p>设状态 $f(l, r)$ 表示在左闭右开区间（取决于具体实现） $[l, r)$ 中取数字，在最优情况下的得分。（不区分$A ,B$）<br>设函数 $sum(l, r)$ 表示开区间 $[l, r)$ 的所有数字的和，用前缀和数组实现。</p><p>则转移为:</p><script type="math/tex; mode=display">f(l, r) = sum(l ,r) - \min\{minR, minL\}</script><script type="math/tex; mode=display">minR = \min_{l \leq i \leq r} \{f(i ,r)\}</script><script type="math/tex; mode=display">minL = \min_{l \leq i \leq r} \{f(l, i)\}</script><p>由于 $A$ 先手，我们可以让 $B$ 的收益最小来使得 $A$ 的收益最大，$minL$ 和 $minR$ 分别表示从左边取和从右边取能留下来的最小 $f$ 值，区间和减去剩下的最小值，就是取走的最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], sum[MAXN], f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[r - <span class="number">1</span>] - sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            f[i][i + <span class="number">1</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[l, r)</span></span><br><span class="line">        <span class="comment">//[1, n + 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len &lt;= n + <span class="number">1</span>; l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minL = f[l + <span class="number">1</span>][r];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) minL = <span class="built_in">std</span>::min(minL, f[i][r]);</span><br><span class="line">                <span class="keyword">int</span> minR = f[l][r - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; i--) minR = <span class="built_in">std</span>::min(minR, f[l][i]);</span><br><span class="line"></span><br><span class="line">                f[l][r] = getSum(l, r) - <span class="built_in">std</span>::min(<span class="number">0</span>, <span class="built_in">std</span>::min(minL, minR));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cnt, f[<span class="number">1</span>][n + <span class="number">1</span>] - sum[n] + f[<span class="number">1</span>][n + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// printf("----------\n");</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 2; j &lt;= n + 1; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         printf("%5d ", f[i][j]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     printf("\n");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4 -10 -20 7</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure><h2 id="B-The-Fewest-Coins-混合背包"><a href="#B-The-Fewest-Coins-混合背包" class="headerlink" title="B - The Fewest Coins  - 混合背包"></a><a href="https://cn.vjudge.net/contest/312624#problem/B" target="_blank" rel="noopener">B - The Fewest Coins  - 混合背包</a></h2><h2 id="C-String-painter-区间DP"><a href="#C-String-painter-区间DP" class="headerlink" title="C - String painter - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/C" target="_blank" rel="noopener">C - String painter - 区间DP</a></h2><h2 id="D-Max-Sum-Plus-Plus-区间DP"><a href="#D-Max-Sum-Plus-Plus-区间DP" class="headerlink" title="D - Max Sum Plus Plus - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/D" target="_blank" rel="noopener">D - Max Sum Plus Plus - 区间DP</a></h2><h2 id="E-Constructing-Roads-In-JGShining’s-Kingdom-最长上升子序列"><a href="#E-Constructing-Roads-In-JGShining’s-Kingdom-最长上升子序列" class="headerlink" title="E - Constructing Roads In JGShining’s Kingdom - 最长上升子序列"></a><a href="https://cn.vjudge.net/contest/312624#problem/E" target="_blank" rel="noopener">E - Constructing Roads In JGShining’s Kingdom - 最长上升子序列</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一些穷国和一些富国分别排在两条直线上，每个穷国和一个富国之间可以建道路，但是路不能交叉，给出每个穷国和富国的联系，求最多能建多少条路</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>把富国编号从大到小排序，问题转化为求最长上升子序列。</p><p>朴素的$O(n^2)$的最长上升子序列求法会<code>TLE</code>，需要用优化后的$O(n\log n)$的算法。</p><p>简述如下：</p><p>舍弃之前的 <code>f</code> 数组，另设立一个数组 <code>d[len]</code> 记录长度为 <code>len</code> 的最长上升子序列的最小结尾。</p><p>每次读到一个新的数字，如果这个数字比 <code>d</code> 数组的最后一个元素还要大，说明这个数可以续在 <code>d</code> 数组最后一个元素的后面使最长上升子序变长，此时<code>d[++len] = a[i]</code>。</p><p>如果这个数字比<code>d</code>数组的最后一个元素要小，就在 <code>d</code> 数组中找到比这个数小的最大的数，用这个数去更新 <code>d</code> 数组，这一步可以用 <code>std::lower_bound()</code> 完成，这也是复杂度中<code>log</code>的来源。</p><p>为什么这这样是对的？</p><ul><li>由于<code>d</code>数组定义为长度为 <code>len</code> 的最长上升子序列的最小结尾，如果想让<code>d</code>数组长度增加，则新元素大小必定增加，所以<code>d</code>数组单调，可以二分。</li><li>关于<code>d</code>数组的更新，状态<code>i + 1</code>一定是从状态<code>i</code>转移过来的，此时我们选择一个更小的数作为状态<code>i</code>的值，一定不会比原先的选择更劣，所以这样的更新也是成立的。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a &lt; a.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].a, &amp;nodes[i].b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(nodes, nodes + n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = nodes[<span class="number">0</span>].b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i].b &gt; ans[len - <span class="number">1</span>]) ans[(++len) - <span class="number">1</span>] = nodes[i].b;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="built_in">std</span>::lower_bound(ans, ans + len, nodes[i].b) - ans;</span><br><span class="line">                ans[pos] = nodes[i].b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     printf("%d ", ans[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// printf("\n");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Case %d:\nMy king, at most %d road can be built.\n\n"</span>, ++cnt, len);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d:\nMy king, at most %d roads can be built.\n\n"</span>, ++cnt, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 7</span></span><br><span class="line"><span class="comment">// 3 1</span></span><br><span class="line"><span class="comment">// 4 5</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 7 3</span></span><br><span class="line"><span class="comment">// 8 8</span></span><br><span class="line"><span class="comment">// 10 9</span></span><br></pre></td></tr></table></figure><h2 id="F-Farey-Sequence-欧拉函数"><a href="#F-Farey-Sequence-欧拉函数" class="headerlink" title="F - Farey Sequence - 欧拉函数"></a><a href="https://cn.vjudge.net/contest/312624#problem/F" target="_blank" rel="noopener">F - Farey Sequence - 欧拉函数</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个数字 $n$ ，求有多少个有序对 $<a, b>$ 满足</a,></p><ul><li>$0  &lt; a &lt; b \leq n$</li><li>$ \gcd(a, b) = 1$ </li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><script type="math/tex; mode=display">ans = \sum_{i = 2}^n \varphi(i)</script><p>先处理出欧拉函数值的数组，直接求和即可</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phiTable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) phi[i] = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    phiTable(<span class="number">1000000</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += phi[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf("%d\n", 2 * sum + 1);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-The-Luckiest-number-欧拉定理-原根-数学技巧"><a href="#G-The-Luckiest-number-欧拉定理-原根-数学技巧" class="headerlink" title="G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧"></a><a href="https://cn.vjudge.net/contest/312624#problem/G" target="_blank" rel="noopener">G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧</a></h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数字 $L$ ，求一个最小的每一位都是 $8$ 的 $L$ 的倍数</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>对于一个 $n$ 位的全是 $8$ 的数字</p><script type="math/tex; mode=display">\begin{aligned}888 \dots 888 &= 8 \times 111 \dots 111 \\&= 8 \sum_{i = 0}^n 10^i \\&= 8 \times \frac{10^n - 1}{9}\end{aligned}</script><p>这个数是 $L$ 的倍数， 有</p><script type="math/tex; mode=display">8(10^n - 1) = k \cdot 9L</script><p>两边同除 $\gcd(8, L)$，记  $p = \frac{8}{\gcd(8, L)}, q = \frac{k \cdot 9L}{\gcd(8, L)}$，有</p><script type="math/tex; mode=display">p(10^n - 1) = q</script><p>$p, q$ 互质，两边同时对 $q$ 取模，得</p><script type="math/tex; mode=display">10^n \equiv 1 \pmod q</script><p>问题转化为求上面这个非线性同余方程的最小正整数解。</p><p>由欧拉定理知，当 $10$ 和 $q$ 互质的时候，有</p><script type="math/tex; mode=display">10^{\varphi(q)} \equiv 1 \pmod q</script><p>当 $10$ 和 $q$ 不互质的时候方程无解</p><p>$\varphi(q)$虽然是方程的一个解，但是不一定是最小正整数解，接下来枚举 $\varphi(q)$ 的因数，代入原方程检验是否成立</p><p>为什么$\varphi(q)$ 的因数是原方程的解？<br>涉及到<code>阶</code>的概念</p><ul><li>设 $m &gt; 1$ ，$\gcd(a, m) = 1$，则使得 $a^r \equiv 1 \pmod m$ 成立的最小正整数 $r_0$ 称为$a$ 对模 $m$ 的阶，记作 $\delta_m(a)$</li><li>若 $m &gt; 1$，$\gcd(a, m) = 1$，$a^n \equiv 1 \pmod m$，则 $\delta_m(a) | n$</li></ul><p>所以原方程就是求阶。</p><p>乘法会爆<code>long long</code> 所以使用所谓快速乘法</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long long fastPowMod(long long a, long long b, long long p) &#123;</span></span><br><span class="line"><span class="comment">//     long long ans = 1 % p;</span></span><br><span class="line"><span class="comment">//     for (; b; b &gt;&gt;= 1) &#123;</span></span><br><span class="line"><span class="comment">//         if (b &amp; 1) ans = (ans % p * a % p) % p;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         a = (a % p * a % p) % p;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return ans;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = (ans + a) % m;</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = (a + a) % m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">a %= m;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">ans = Mul(ans, a, m);</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = Mul(a, a, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x) != EOF &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">9</span> * x / gcd(<span class="number">8</span>, x);</span><br><span class="line">        <span class="keyword">if</span> (gcd(<span class="number">10</span>, p) != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> m = phi(p);</span><br><span class="line"></span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i * i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    v.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span> (i * i != m) v.push_back(m / i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fastPowMod(<span class="number">10</span>, v[i], p) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, v[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Best-Solver-矩阵快速幂-广义斐波那契循环节降幂"><a href="#H-Best-Solver-矩阵快速幂-广义斐波那契循环节降幂" class="headerlink" title="H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂"></a><a href="https://cn.vjudge.net/contest/312624#problem/H" target="_blank" rel="noopener">H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂</a></h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>设</p><script type="math/tex; mode=display">y = (5 + 2\sqrt6)^{1+2^x} , 0 \leq x \leq 2^{32}</script><p>给定 $x$ 和 $M$，求</p><script type="math/tex; mode=display">[y] \% m</script><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>看到这个式子，明显不能直接计算，先不管指数过大的问题，考虑如何求</p><script type="math/tex; mode=display">a_n = (5 + 2\sqrt6)^n</script><p>先写出前几项看一看</p><script type="math/tex; mode=display">a_1 = 5 + 2\sqrt6 \\a_2 = (5+2\sqrt6)^2 = 25 + 24 + 20\sqrt6 = 49 + 20\sqrt6 \\a_3 = (5+2\sqrt6)^2 = (49 + 20\sqrt6) \times (5 + 2\sqrt6) = 585 + 198\sqrt6</script><p>发现只是系数变了，不妨设 </p><script type="math/tex; mode=display">a_n =x_n + y_n \sqrt 6</script><p>则</p><script type="math/tex; mode=display">\begin{align}a_{n+1} &= (x_n + y_n \sqrt 6) \cdot (5 + 2\sqrt6) \\&= 5x_n + 12y_n + (2x_n + 5y_n)\sqrt6 \\&= x_{n+1} + y_{n+1}\sqrt6\end{align}</script><p>所以</p><script type="math/tex; mode=display">\begin{equation}\begin{cases}x_{n+1} = 5x_n + 12y_n \\[2ex]y_{n+1} = 2x_n + 5y_n\end{cases}\end{equation}</script><p>写成矩阵的形式</p><script type="math/tex; mode=display">\begin{bmatrix}     5 & 12 \\     2 & 5\end{bmatrix}\begin{bmatrix}    x_n\\    y_n\end{bmatrix}=\begin{bmatrix}    x_{n+1}\\    y_{n+1}\end{bmatrix}</script><p>现在我们就可以用矩阵快速幂快速计算系数了。</p><p>解决了底数计算，再来看指数上的$1 + 2^x$，这个东西非常大，所以需要用一些手段来降幂，对于整数的大幂计算，可以利用<a href="https://blog.csdn.net/ACdreamers/article/details/8236942" target="_blank" rel="noopener">指数循环节</a>用欧拉函数降幂，即</p><script type="math/tex; mode=display">A^B \mod C = A^{B \mod \varphi(C) + \varphi(C)} \mod C</script><p>但是对于矩阵是不能这样搞的，需要找到<a href="https://blog.csdn.net/ACdreamers/article/details/25616461" target="_blank" rel="noopener">矩阵的循环节(广义斐波那契数列循环节)</a>，对于寻找的方法，暂时超出了我的能力范围，暂记结论</p><p>广义斐波那契数列的循环节为 $p + 1$ 或 $(p+1) \cdot (p-1)$</p><p>这样就可以在用快速幂计算指数的时候把模数设为循环节达到降幂的目的。</p><p>这样底数和指数的问题就解决了，先降幂算出指数之后，矩阵快速幂算出底数两项的系数，带入公式计算然后取整即可。</p><p>注意降幂时的模数和矩阵快速幂的模数不是同一个。</p><p>这题比较难，但是也有套路的东西在里面。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> sizeX, sizeY;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> sizeX = <span class="number">0</span>, <span class="keyword">int</span> sizeY = <span class="number">0</span>) : sizeX(sizeX), sizeY(sizeY) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(sizeX, a.sizeY)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sizeY; k++) &#123;</span><br><span class="line">                    ans.a[i][j] += (<span class="keyword">this</span>-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD;</span><br><span class="line">                    ans.a[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;a[i][j] = a.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastPowMod</span><span class="params">(Matrix m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> fastPowMod(m, n - <span class="number">1</span>) * m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(m * m, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">for</span> ( ; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans % p * a % p) % p;</span><br><span class="line">        a = (a % p * a % p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MOD);</span><br><span class="line"></span><br><span class="line">        <span class="function">Matrix <span class="title">shift</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">        shift.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>; shift.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">12</span>;</span><br><span class="line">        shift.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>; shift.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">        ans.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int p = phi(MOD);</span></span><br><span class="line">        <span class="comment">// long long b = (fastPowMod(2, x, p) + 1 + p) % p;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b = fastPowMod(<span class="number">2</span>, x, MOD * MOD - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("p = %d, b = %lld\n", p, b);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Matrix tmp = fastPowMod(shift, b - 1);</span></span><br><span class="line">        <span class="comment">// ans = tmp * ans;</span></span><br><span class="line">        ans = fastPowMod(shift, b - <span class="number">1</span>) * ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("Case #%d: %d\n", ++cnt, (int)(ans.a[0][0] + ans.a[1][0] * sqrt(6)) % MOD);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++cnt, (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="number">2</span> * ans.a[<span class="number">0</span>][<span class="number">0</span>] % MOD - <span class="number">1</span>) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Queries-for-Number-of-Palindromes-区间DP"><a href="#K-Queries-for-Number-of-Palindromes-区间DP" class="headerlink" title="K - Queries for Number of Palindromes - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/K" target="_blank" rel="noopener">K - Queries for Number of Palindromes - 区间DP</a></h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串，求其回文子串的个数。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>比较典型的区间DP题目</p><p>设状态 $f(l, r)$ 表示左闭右开区间 $[l, r)$ 中的回文子串个数，<code>isP[l, r]</code>数组表示在区间$[l ,r)$中的字符串是否为回文串。</p><p>则转移为</p><script type="math/tex; mode=display">f(l, r) = f(l + 1, r) + f(l, r - 1) - f(l + 1, r - 1) + \text{isP}[l, r]</script><p>区间的计数问题常常这样解决。<br>好像有点容斥的感觉？<br>记得预处理<code>isP</code>数组。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> isP[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        isP[i][i + <span class="number">1</span>] = isP[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            isP[i][j] = (isP[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            f[i][j] = f[i][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j] - f[i + <span class="number">1</span>][j - <span class="number">1</span>] + isP[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[l][r + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Diophantus-of-Alexandria"><a href="#L-Diophantus-of-Alexandria" class="headerlink" title="L - Diophantus of Alexandria"></a><a href="https://cn.vjudge.net/contest/312624#problem/L" target="_blank" rel="noopener">L - Diophantus of Alexandria</a></h2><h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数学与DP专题二，比较难，不怎么会&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/312624&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt; 专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[HDU 1576] A/B - 乘法逆元+费马小定理/扩展欧几里得</title>
    <link href="http://ilern.github.io/2019/07/21/hdu_1576/"/>
    <id>http://ilern.github.io/2019/07/21/hdu_1576/</id>
    <published>2019-07-21T14:32:23.000Z</published>
    <updated>2019-07-21T10:15:51.468Z</updated>
    
    <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576" target="_blank" rel="noopener">HDU 1576 A/B</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>要求$(A / B)\%9973$，但由于$A$很大，我们只给出$n(n = A \% 9973)$(我们给定的$A$必能被$B$整除，且$\gcd(B, 9973) = 1)$。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>$(A / B)\%9973 = (AB^{-1}) \% 9973 = (A \% 9973 \cdot B^{-1} \%9973) \%9973 = (n \cdot B^{-1} \%9973) \%9973$</p><p>问题转化为求$B^{-1}$</p><p>可用费马小定理或者扩展欧几里得算法求解。</p><p>​    </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % MOD;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;b);</span><br><span class="line"></span><br><span class="line">        b = fastPowMod(b, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (n % MOD * b % MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDU2019暑期集训第一周数学部分&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得算法学习笔记</title>
    <link href="http://ilern.github.io/2019/07/21/exgcd_learn/"/>
    <id>http://ilern.github.io/2019/07/21/exgcd_learn/</id>
    <published>2019-07-21T14:32:23.000Z</published>
    <updated>2019-07-21T09:53:20.392Z</updated>
    
    <content type="html"><![CDATA[<p>扩展欧几里得算法能在计算$\gcd(a,b)$ 的同时求解方程$ax + by = \gcd(a, b)$的一组特解。</p><p>是为欧几里得算法之扩展。</p><a id="more"></a><h3 id="Bezout’s-identity（裴蜀定理）"><a href="#Bezout’s-identity（裴蜀定理）" class="headerlink" title="Bézout’s identity（裴蜀定理）"></a>Bézout’s identity（裴蜀定理）</h3><blockquote><p>对于任意整数$a, b$，存在一对整数 $x, y$ 满足$ax + by = \gcd(a, b)$</p></blockquote><p>使用（类似）数学归纳法证明：</p><ul><li><p>当 $b = 0$ 时，有$x = 1, y  = 0$ 使得等式成立，即有 $a \times 1 + b \times 0 = \gcd(a, 0) = a$</p></li><li><p>当 $b&gt;0$ 时，假设存在 $x, y$  使得等式成立，即</p><script type="math/tex; mode=display">ax + by = \gcd(a, b) = \gcd(b, a \% b) = bx + (a \% b)y</script><p> 又由取模运算的定义</p><script type="math/tex; mode=display">a \% b = a - b \lfloor \frac{a}{b} \rfloor</script><p>可知</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\gcd(a, b) &= bx + ay - b \lfloor \frac{a}{b} \rfloor y \\&= ay + b(x - b \lfloor \frac{a}{b} \rfloor y)\end{aligned}\end{equation}</script><p>令 $x’ = y, y’ = x - b \lfloor \frac{a}{b} \rfloor y$ 可得 $ax’ + by’ = gcd(a, b)$</p><p>即 $bx + (a \% b)y = \gcd(a, b)$ 有解</p></li><li><p>这里的 $a, b$ 在交换一次之后变小了，这样一直递归下去就会到达 $b = 0$ 的边界，所以解一定存在</p></li></ul><h3 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x; x = y; y = z - y * (a / b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码求出了$ax + by = \gcd(a, b)$，返回了$\gcd(a, b)$。</p><p>对于一般的线性方程$ax + by = c$，当且仅当$\gcd(a, b) | c$ 时存在非负整数解，此时先用扩展欧几里得算法求出$ax + by = \gcd(a, b)$ 的一组特解 $x_0, y_0$ 再等式两边同时乘以$\frac{c}{\gcd(a,b)}$ 即可求得原方程的一组特解 $x_0 \frac{c}{\gcd(a, b)}, y_0 \frac{c}{\gcd(a, b)}$</p><p>而原方程的通解表示为</p><script type="math/tex; mode=display">\begin{aligned}x &= x_0 \frac{c}{\gcd(a, b)} + k \frac{b}{\gcd(a, b)} \\y &= y_0 \frac{c}{\gcd(a, b)} + k \frac{a}{\gcd(a, b)}\end{aligned}</script><p>其中 $k$ 可以取遍全体整数</p><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>线性同余方程是指形如 $ax \equiv b \pmod m$ 的方程，因为未知数为的次数为一，故称之为<strong>线性</strong>同余方程。</p><p>扩展欧几里得算法的应用之一就是求解线性同余方程。</p><p>同余可以理解为<strong>模等于</strong>，也就是 $ax$ 模 $m$ 等于 $b$ ，所以原方程表示 $ax-b$ 是 $m$ 的倍数，不妨设为 $-y$ 倍，则原方程转化为 $ax - b = -ym$ 即 $ax + my = b$ 。</p><p>这样的方程我们可以用扩展欧几里得算法进行求解，当且仅当 $\gcd(a, m) | b$ 时，方程有解，易得原线性同余方程方程的特解为 $x = x_0 \frac{b}{\gcd(a, m)}$</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>特殊地，当 $ax \equiv 1 \pmod m$ 时， $x$ 被称为 $a$ 在模 $m$ 意义下的逆元，可以套用上面的方法求出，要求$\gcd(x, m) = 1$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;扩展欧几里得算法能在计算$\gcd(a,b)$ 的同时求解方程$ax + by = \gcd(a, b)$的一组特解。&lt;/p&gt;
&lt;p&gt;是为欧几里得算法之扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title> Leading and Trailing - 对数 + 快速幂</title>
    <link href="http://ilern.github.io/2019/07/21/Lat/"/>
    <id>http://ilern.github.io/2019/07/21/Lat/</id>
    <published>2019-07-21T14:32:23.000Z</published>
    <updated>2019-07-21T10:37:46.785Z</updated>
    
    <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p> <a href="https://vjudge.net/contest/312605#problem/B" target="_blank" rel="noopener">Leading and Trailing</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>You are given two integers: $n$ and $k$, your task is to find the most significant three digits, and least significant three digits of $n^k$.</p><p>给定$n$和$k$，求$n^k$的前三位数字和后三位数字。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>后三位数字直接用快速幂对$1000$取模即可。</p><p>前三位数字的做法比较巧妙。</p><p>设 $10^p = n^k$ ，两边同取对数 $p = k\lg n$ ，$p$ 是一个浮点数，整数部分为$[p]$, 记为 $x$ ; 小数部分为 $p - [p]$， 记为$y$ 。有$10^p = 10^{x + y} = 10^x \cdot 10^y = n^k$ 这样就把 $n^k$ 转化为了科学记数法表示，$10^y &lt; 1$ ，所以要求的前三位就是 $10^y \cdot 10^3 = 10^{y+3}$。</p><p>最后三位前面不足的位置补$0$。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % MOD;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">1</span>; cnt &lt;= t; cnt++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> p = k * <span class="built_in">log10</span>(n);</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>)p;</span><br><span class="line">        <span class="keyword">double</span> y = p - x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %03d\n"</span>, cnt, (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10.0</span>, y + <span class="number">2</span>), fastPowMod(n, k));</span><br><span class="line">        <span class="comment">//if (cnt &lt; t) printf("\n");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDU2019暑期集训第一周数学部分&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>[bzoj 1477] 青蛙的约会  - 扩展欧几里得</title>
    <link href="http://ilern.github.io/2019/07/21/bzoj_1477/"/>
    <id>http://ilern.github.io/2019/07/21/bzoj_1477/</id>
    <published>2019-07-21T13:00:00.000Z</published>
    <updated>2019-07-21T12:56:41.347Z</updated>
    
    <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1477" target="_blank" rel="noopener">bzoj 1477 青蛙的约会</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 $A$ 的出发点坐标是 $x$，青蛙 $B$ 的出发点坐标是 $y$。青蛙 $A$ 一次能跳 $m$ 米，青蛙 $B$ 一次能跳$n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>青蛙$A$: $(x + km) \% L$</p><p>青蛙$B$: $(y + kn)\%L$</p><p>问题转化为$(x + km) \% L = (y + kn)\%L$</p><p>展开得线性同余方程$k(m-n) \equiv y-x \pmod L$</p><p>其中 $m-n$ 和 $ y-x  $ 都是已知的常数，利用扩展欧几里得算法求出 $k$ 即可。</p><p>需要注意的是$(m-n)$一定要是正的，如果算出来是负的，等号两边同乘以负一。</p><p>最后 $k$ 也应该也是正的，如果算出来是负的，加上$\frac{b}{d}$就好。</p><p>记得用<code>long long</code></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x; x = y; y = z - y * (a / b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, m, n, l;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = m - n;</span><br><span class="line">    <span class="keyword">int</span> b = l;</span><br><span class="line">    <span class="keyword">int</span> c = y - x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        a = -a;</span><br><span class="line">        c = -c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("a = %d, b = %d, c = %d\n", a, b, c);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve ax + cy = b;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">    <span class="comment">//printf("d = %d\n", d);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x0 = <span class="number">0</span>, y0 = <span class="number">0</span>;</span><br><span class="line">        d = exgcd(a, b, x0, y0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = x0 * c / d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = b / d;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) x %= t;</span><br><span class="line">        <span class="keyword">else</span> x = x % t + t;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDU2019暑期集训第一周数学部分&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>[QDUoj 582] 嘉馨学姐吃包子 - 三分</title>
    <link href="http://ilern.github.io/2019/07/03/qduoj582/"/>
    <id>http://ilern.github.io/2019/07/03/qduoj582/</id>
    <published>2019-07-03T13:33:00.000Z</published>
    <updated>2019-07-03T03:06:27.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://qduoj.com/problem/582" target="_blank" rel="noopener">嘉馨学姐吃包子</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>嘉馨学姐非常爱吃包子，但是嘉馨学姐这个人很懒，她总是希望包子可以自己飞到她的嘴里，现在有 $n(n \leq 100000)$ 个包子，告诉你每个包子的位置 $p_i(|p_i| \leq 10^6)$ 和重量$w_i(1 &lt; w_i \leq 10)$。</p><p>已知包子飞行时，包子的口感度会降低，如果一个包子飞行了$x$，那这个包子的口感度会降低$x^3 \times w$。嘉馨学姐的初始位置由你来决定，要求尽量使所有包子降低的口感度总和$F$最小。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设起点为$x$，则每个包子移动的距离为$|p_i - x|$，那么降低的口感总和为</p><script type="math/tex; mode=display">f(x) = \sum_{i = 0}^n (|p_i - x|)^3 \times w_i</script><p>三分这个函数求出最值即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret += (<span class="built_in">pow</span>(<span class="built_in">fabs</span>(p[i] - x), <span class="number">3</span>) * w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e6</span>; <span class="keyword">double</span> r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt;= EPS) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> midL = mid - EPS;</span><br><span class="line">        <span class="keyword">double</span> midR = mid + EPS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (func(n, midL) &gt; func(n, midR)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>, func(n, l) / <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://qduoj.com/problem/582&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;嘉馨学姐吃包子&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;嘉馨学姐非常爱吃包子，但是嘉馨学姐这个人很懒，她总是希望包子可以自己飞到她的嘴里，现在有 $n(n \leq 100000)$ 个包子，告诉你每个包子的位置 $p_i(|p_i| \leq 10^6)$ 和重量$w_i(1 &amp;lt; w_i \leq 10)$。&lt;/p&gt;
&lt;p&gt;已知包子飞行时，包子的口感度会降低，如果一个包子飞行了$x$，那这个包子的口感度会降低$x^3 \times w$。嘉馨学姐的初始位置由你来决定，要求尽量使所有包子降低的口感度总和$F$最小。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="三分" scheme="http://ilern.github.io/tags/%E4%B8%89%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>三分法学习笔记</title>
    <link href="http://ilern.github.io/2019/07/03/divide3/"/>
    <id>http://ilern.github.io/2019/07/03/divide3/</id>
    <published>2019-07-03T13:33:00.000Z</published>
    <updated>2019-07-03T01:20:53.348Z</updated>
    
    <content type="html"><![CDATA[<p>三分法是一种求解单峰函数极值的算法</p><a id="more"></a><h3 id="【简介】"><a href="#【简介】" class="headerlink" title="【简介】"></a>【简介】</h3><p>所谓单峰函数，如图所示，三分法可以求出这样的函数的极值。</p><p><img src="https://s2.ax1x.com/2019/07/03/ZYK4FP.png" alt="pic1"></p><h3 id="【算法】"><a href="#【算法】" class="headerlink" title="【算法】"></a>【算法】</h3><ul><li>确定极值点所在的区间</li><li>取区间的中点 <code>mid</code></li><li>在中点左右各一个小距离中分别取<code>midL</code> <code>midR</code>，这两个点将整个区间三分</li><li><p>计算出<code>midL</code> <code>midR</code>的函数值</p><ul><li>若<code>f(midL)</code> 比较大，则舍弃右边的部分，将区间右端点设置为<code>mid</code></li><li>若<code>f(midR)</code>比较大，则舍弃左边的部分，将区间左端点设置为<code>mid</code></li></ul></li><li><p>重复上述过程直至区间大小小于某个设定好的<code>EPS</code></p></li></ul><h3 id="【模板】"><a href="#【模板】" class="headerlink" title="【模板】"></a>【模板】</h3><p><a href="https://www.luogu.org/problemnew/show/P3382" target="_blank" rel="noopener">洛谷P3382 【模板】三分法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// double func(double a[], int n, double x) &#123;</span></span><br><span class="line"><span class="comment">//     double ret = 0;</span></span><br><span class="line"><span class="comment">//     double b = 1;</span></span><br><span class="line"><span class="comment">//     for (int i = n; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//         ret += (b * a[i]);</span></span><br><span class="line"><span class="comment">//         b *= x;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return ret;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum = sum * x + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt;= EPS) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// double midL = (l + r) / 3;</span></span><br><span class="line">        <span class="comment">// double midR = midL * 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> midL = mid - EPS;</span><br><span class="line">        <span class="keyword">double</span> midR = mid + EPS;</span><br><span class="line">        <span class="keyword">if</span> (func(a, n, midL) &lt; func(a, n, midR)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三分法是一种求解单峰函数极值的算法&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
