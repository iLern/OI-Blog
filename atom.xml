<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iLern&#39;s Blog</title>
  
  <subtitle>Do what you love, love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ilern.github.io/"/>
  <updated>2021-03-05T12:27:36.580Z</updated>
  <id>http://ilern.github.io/</id>
  
  <author>
    <name>iLern</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基本初等函数的导数</title>
    <link href="http://ilern.github.io/2021/03/05/%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/"/>
    <id>http://ilern.github.io/2021/03/05/基本初等函数的导数/</id>
    <published>2021-03-05T11:36:58.000Z</published>
    <updated>2021-03-05T12:27:36.580Z</updated>
    
    <content type="html"><![CDATA[<p>基本初等函数导数的证明 / 推导</p><p>很大程度上是因为手痒想写 $\LaTeX$ 了</p><a id="more"></a><h1 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h1><script type="math/tex; mode=display">\begin{align}(a^x)’ &= \lim_{\Delta x \to 0} \frac{a^{x + \Delta x} - a^x}{\Delta x} \\[2ex]&= \lim_{\Delta x \to 0} \frac{a^x(a^{\Delta x} - 1)}{\Delta x} \label{con:2} \\[2ex]&= \lim_{\Delta x \to 0} \frac{a^x \cdot \Delta x \ln a}{\Delta x} \label{con:3} \\[2ex]&= a^x \ln a \\\end{align} \\</script><p>公式 $\ref{con:2}$ 到公式 $\ref{con:3} $ 使用了等价无穷小替换 $\lim_{x \to 0} a^x - 1 \sim a^x \ln a$</p><h1 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h1><h1 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h1><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本初等函数导数的证明 / 推导&lt;/p&gt;
&lt;p&gt;很大程度上是因为手痒想写 $\LaTeX$ 了&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>七和弦</title>
    <link href="http://ilern.github.io/2021/01/19/%E4%B8%83%E5%92%8C%E5%BC%A6/"/>
    <id>http://ilern.github.io/2021/01/19/七和弦/</id>
    <published>2021-01-19T05:43:29.000Z</published>
    <updated>2021-01-19T08:58:31.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七和弦"><a href="#七和弦" class="headerlink" title="七和弦"></a>七和弦</h1><p>关于七和弦自己的部分理解与总结</p><a id="more"></a><p>众所周知，构成三和弦的三个音依次成三度关系，以最简单的大三和弦和小三和弦为例：</p><ul><li><p>大三和弦根音和三音相距一个大三度，三音和五音相距一个小三度，根音和五音相距一个纯五度，</p></li><li><p>小三和弦根音和三音相距一个小三度，三音和五音相距一个大三度，根音和五音相距一个纯五度，</p></li></ul><p>也就是说仅仅是和弦的三音决定了和弦的色彩，五音是不变的</p><p>而七和弦，仅仅是在三和弦的<strong>基础上</strong>增加了七音，然后根据七音距离根音的不同音程关系具体分为很多种类</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;七和弦&quot;&gt;&lt;a href=&quot;#七和弦&quot; class=&quot;headerlink&quot; title=&quot;七和弦&quot;&gt;&lt;/a&gt;七和弦&lt;/h1&gt;&lt;p&gt;关于七和弦自己的部分理解与总结&lt;/p&gt;
    
    </summary>
    
      <category term="音乐" scheme="http://ilern.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="乐理" scheme="http://ilern.github.io/tags/%E4%B9%90%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NJU ics 2020 概要</title>
    <link href="http://ilern.github.io/2021/01/12/NJU-ics-2020-%E6%A6%82%E8%A6%81/"/>
    <id>http://ilern.github.io/2021/01/12/NJU-ics-2020-概要/</id>
    <published>2021-01-12T12:12:26.000Z</published>
    <updated>2021-02-05T14:12:26.784Z</updated>
    
    <content type="html"><![CDATA[<p>填坑</p><a id="more"></a><h1 id="PA1-开天辟地的篇章：最简单的计算机"><a href="#PA1-开天辟地的篇章：最简单的计算机" class="headerlink" title="PA1 - 开天辟地的篇章：最简单的计算机"></a>PA1 - 开天辟地的篇章：最简单的计算机</h1><h2 id="实现x86的寄存器"><a href="#实现x86的寄存器" class="headerlink" title="实现x86的寄存器"></a>实现x86的寄存器</h2><p>很关键的一张图</p><p><img src="1.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> _32;</span><br><span class="line">        <span class="keyword">uint16_t</span> _16;</span><br><span class="line">        <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">&#125; gpr[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//relreg_t === uint32_t</span></span><br><span class="line">    <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125; x86_CPU_state;</span><br></pre></td></tr></table></figure><p>希望下面的每一个寄存器（eax…）能和上面结构体中的结构进行对应</p><p>x86寄存器的这种结构很适合用<code>union</code>来表达</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> _32;</span><br><span class="line">                <span class="keyword">uint16_t</span> _16;</span><br><span class="line">                <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; gpr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//relreg_t === uint32_t</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125; x86_CPU_state;</span><br></pre></td></tr></table></figure><h3 id="reg-test-是如何测试你的实现的"><a href="#reg-test-是如何测试你的实现的" class="headerlink" title="reg_test()是如何测试你的实现的?"></a>reg_test()是如何测试你的实现的?</h3><p><img src="2.png" alt></p><p><code>reg_l</code>,<code>reg_w</code>,<code>reg_b</code>是<code>/nemu/src/isa/x86/local-include/reg.h</code>定义的三个宏，分别对应32位、16位、8位寄存器</p><p>给每一个32位寄存器赋一个随机值，然后依次检查其低16位低8位的值，最后检查pc</p><h3 id="在cmd-c-函数中-调用cpu-exec-的时候传入了参数-1-你知道这是什么意思吗"><a href="#在cmd-c-函数中-调用cpu-exec-的时候传入了参数-1-你知道这是什么意思吗" class="headerlink" title="在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?"></a>在<code>cmd_c()</code>函数中, 调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>, 你知道这是什么意思吗?</h3><p>循环<code>for (; n &gt; 0; n--)</code>，传入<code>-1</code>使得这个循环总是成立，所以会执行完全部的指令</p><h2 id="完善调试器"><a href="#完善调试器" class="headerlink" title="完善调试器"></a>完善调试器</h2><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_si</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">int</span> n = atoi(arg);</span><br><span class="line">    </span><br><span class="line">    cpu_exec(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_info</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(arg, <span class="string">"r"</span>)) &#123;</span><br><span class="line">        <span class="comment">//for registers</span></span><br><span class="line">        isa_reg_display();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(arg, <span class="string">"w"</span>)) &#123;</span><br><span class="line">        <span class="comment">//for watch point</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_reg_display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = R_EAX; i &lt;= R_EDI; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8s %-16x %-16d\n"</span>, regsl[i], reg_l(i), reg_l(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = R_AX; i &lt;= R_DI; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8s %-16x %-16d\n"</span>, regsw[i], reg_w(i), reg_w(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = R_AL; i &lt;= R_BH; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8s %-16x %-16d\n"</span>, regsb[i], reg_b(i), reg_b(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h3><p><img src="3.png" alt></p><p>注意要<code>#include &quot;../../../include/memory/vaddr.h&quot;</code></p><p>PA1第一阶段到此结束</p><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><h3 id="实现算术表达式的词法分析"><a href="#实现算术表达式的词法分析" class="headerlink" title="实现算术表达式的词法分析"></a>实现算术表达式的词法分析</h3><p>RTFC找到这部分的执行逻辑</p><p>表达式求值相关代码位于<code>/home/leyan/ics2020/nemu/src/monitor/debug/expr.c</code>，在<code>./ui.c</code>中<code>#include &quot;expr.h&quot;</code>，<code>./expr.h</code>中只有一个函数声明<code>word_t expr(char*, char*)</code>，也就是说在<code>./ui.c</code>中所有表达式求值的功能都由<code>expr()</code>这个函数来进行。</p><p>词法分析的任务相对简单，只需要把token类型写进枚举中，rule数组中存放由正则表达式和类型组成的规则</p><p>对表达式进行匹配的部分框架已经写好了，只需要对于识别出的token一次扔到<code>tokens</code>数组中即可，有些特殊的token需要特殊处理，例如<code>TK_NOTYPE</code>，表示空格，空格在词法解析中会被忽略，因此直接break就行。</p><p><img src="4.png" alt></p><p>这里有一个小坑就是<code>strncpy</code>不会包含最后的<code>\0</code>，需要手动加上。</p><h3 id="实现算术表达式的递归求值"><a href="#实现算术表达式的递归求值" class="headerlink" title="实现算术表达式的递归求值"></a>实现算术表达式的递归求值</h3><p>递归求值的部分文档里写的很清晰，只要填框架就行了，目前没有发现坑。</p><h2 id="实现表达式生成器"><a href="#实现表达式生成器" class="headerlink" title="实现表达式生成器"></a>实现表达式生成器</h2><p>这一部分的代码在<code>/nemu/tools/gen-expr.c</code>中，大体的思路就是先生成表达式字符串，在把它塞进这样一个C语言代码字符串里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;#include &lt;stdio.h&gt;\n&quot;</span><br><span class="line">&quot;int main() &#123; &quot;</span><br><span class="line">&quot;  unsigned result = %s; &quot;</span><br><span class="line">&quot;  printf(\&quot;%%u\&quot;, result); &quot;</span><br><span class="line">&quot;  return 0; &quot;</span><br><span class="line">&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><p>然后输出到文件里，调用gcc编译运行并获得输出结果。</p><p>一些细节：</p><ul><li>如何保证表达式进行无符号运算?<ul><li>先进行有符号运算最后转成无符号数</li></ul></li><li>如何生成长表达式, 同时不会使<code>buf</code>溢出?<ul><li>设定一个上限，超过了就返回</li></ul></li><li>如何过滤求值过程中有除0行为的表达式?<ul><li>调用gcc的时候把所有警告视为错误，这样<code>system</code>的返回值不为零，就不会写进文件里</li></ul></li></ul><p>有了表达式生成器就可以测试之前的递归求值了</p><p>PA1阶段2到此结束</p><h2 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h2><p>监视点的功能是监视一个表达式的值何时发生变化。</p><h3 id="扩展算数表达式求值功能"><a href="#扩展算数表达式求值功能" class="headerlink" title="扩展算数表达式求值功能"></a>扩展算数表达式求值功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;decimal-number&gt;</span><br><span class="line">  | &lt;hexadecimal-number&gt;    # 以&quot;0x&quot;开头</span><br><span class="line">  | &lt;reg_name&gt;              # 以&quot;$&quot;开头</span><br><span class="line">  | &quot;(&quot; &lt;expr&gt; &quot;)&quot;</span><br><span class="line">  | &lt;expr&gt; &quot;+&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;-&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;*&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;/&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;==&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;</span><br><span class="line">  | &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;</span><br><span class="line">  | &quot;*&quot; &lt;expr&gt;              # 指针解引用</span><br></pre></td></tr></table></figure><p>这个部分硬写就行，重点是单目运算符的实现，框架中给出了思路，在正则匹配的阶段是无法区分乘号<code>*</code>和解引用<code>*</code>的，需要在识别出token之后，求值之前，把解引用标识出来</p><p>解引用是单目运算，因此左边不能是数字或右括号</p><p>在寻找主运算符的过程中，要注意单目运算符的优先级高，找主运算符时应该跳过</p><p>负数的处理也类似</p><p><img src="5.png" alt></p><h3 id="实现监视点"><a href="#实现监视点" class="headerlink" title="实现监视点"></a>实现监视点</h3><p>监视点池就是一个链表，注意删除的时候判断空，否则会触发段错误</p><p>没什么好说的，就是一些链表操作、</p><h3 id="调试的建议"><a href="#调试的建议" class="headerlink" title="调试的建议"></a>调试的建议</h3><ul><li>总是使用<code>-Wall</code>和<code>-Werror</code></li><li>尽可能多地在代码中插入<code>assert()</code></li><li><code>assert()</code>无法捕捉到error时, 通过<code>printf()</code>输出可疑的变量, 期望能观测到error</li><li><code>printf()</code>不易观测error时, 通过GDB理解程序的精确行为</li></ul><h3 id="断点的工作原理"><a href="#断点的工作原理" class="headerlink" title="断点的工作原理"></a>断点的工作原理</h3><p>在PA中可以用<code>w pc == ADDR</code>来模拟断点，但是这样会影响效率</p><p><a href="https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints" target="_blank" rel="noopener">How debuggers work: Part 2 - Breakpoints</a></p><p>这篇文章介绍了GDB打断点的原理，简要概括如下：</p><ul><li>断点通过软中断（trap / software interrupts）实现<ul><li>发生中断时，CPU会保存当前的状态，跳转到一个事先确定的处理相应中断的程序的位置</li><li>硬件中断和软件中断都是如此</li></ul></li><li>断点通过一种特殊的trap——<code>int3</code>来实现<ul><li>这里的<code>int</code>不是类型，而是x86对于trap指令的一种术语，指的是对预先定义的处理程序的调用，<code>interrupt</code></li><li><code>int</code>指令可以跟一个8位的操作数，这个操作数表明了中断的编号，理论上可以有$2^8 = 256$种中断，我们关心的中断是三号中断<code>int3</code></li><li><code>int3</code>称为<code>trap to debugger</code></li></ul></li><li>当进程执行<code>int3</code>指令时，OS会停止当前的进程，并向他发送一个<code>SIGTRAP</code>信号</li></ul><p>思考题：</p><ul><li>x86的<code>int3</code>指令不带任何操作数, 操作码为1个字节, 因此指令的长度是1个字节. 这是必须的吗? 假设有一种x86体系结构的变种my-x86, 除了<code>int3</code>指令的长度变成了2个字节之外, 其余指令和x86相同. 在my-x86中, 上述文章中的断点机制还可以正常工作吗? 为什么?</li></ul><h2 id="如何阅读手册"><a href="#如何阅读手册" class="headerlink" title="如何阅读手册"></a>如何阅读手册</h2><h3 id="查阅手册回答"><a href="#查阅手册回答" class="headerlink" title="查阅手册回答"></a>查阅手册回答</h3><ul><li><p>EFLAGS寄存器中的CF位是什么意思?</p><p><a href="https://nju-projectn.github.io/i386-manual/s02_03.htm#fig2-8" target="_blank" rel="noopener">Figure 2-8.  EFLAGS Register  </a></p><p>CF：Carry Flag 进位标志</p><p><img src="8.png" alt></p></li><li><p>ModR/M字节是什么?</p><p>ModR/M是x86指令中的一个字节</p><p>x86指令的一般格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+-----------+--------+------+------+------+------------+-----------+</span><br><span class="line">|instruction| address-  |  operand- |segment |opcode|ModR/M| SIB  |displacement| immediate |</span><br><span class="line">|  prefix   |size prefix|size prefix|override|      |      |      |            |           |</span><br><span class="line">|-----------+-----------+-----------+--------+------+------+------+------------+-----------|</span><br><span class="line">|   0 OR 1  |  0 OR 1   |   0 OR 1  | 0 OR 1 |1 OR 2|0 OR 1|0 OR 1| 0,1,2 OR 4 |0,1,2 OR 4 |</span><br><span class="line">| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|</span><br><span class="line">|                                     number of bytes                                      |</span><br><span class="line">+------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>除了opcode(操作码)必定出现之外, 其余组成部分可能不出现, 而对于某些组成部分, 其长度并不是固定的. 但给定一条具体指令的二进制形式, 其组成部分的划分是有办法确定的, 不会产生歧义(即把一串比特串看成指令的时候, 不会出现两种不同的解释). </p><p>去手册中查询指令的一般格式 <code>17.2 Instruction Format</code></p><ul><li>ModR/M 和 SIB 字节跟在 opcode 后面， 包括以下信息<ul><li>指令中要使用的索引类型或者寄存器号</li><li>要使用的寄存器或者用来选择指令的更多信息</li><li>base, index, 和 scale 的相关信息</li></ul></li><li>ModR/M 字节包括三部分信息:<ul><li>mod field, 占用字节的两个最高位, 和 r/m field 结合表示32个可能的值: 8个寄存器和和24个 index mode。</li><li>The reg field, 占用 mod field 接下来的三位，决定是寄存器号还是 opdode 的额外3位，取决于 opcode 的第一个字节。</li><li>The r/m field, 占用三个最低位, 决定寄存器是操作数的位置或者可以与上述字段结合形成寻址模式编码的一部分。</li></ul></li></ul></li><li><p>mov指令的具体格式是怎么样的?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Opcode   Instruction       Clocks        Description</span><br><span class="line"></span><br><span class="line">88  /r   MOV r/m8,r8       2/2           Move byte register to r/m byte</span><br><span class="line">89  /r   MOV r/m16,r16     2/2           Move word register to r/m word</span><br><span class="line">89  /r   MOV r/m32,r32     2/2           Move dword register to r/m dword</span><br><span class="line">8A  /r   MOV r8,r/m8       2/4           Move r/m byte to byte register</span><br><span class="line">8B  /r   MOV r16,r/m16     2/4           Move r/m word to word register</span><br><span class="line">8B  /r   MOV r32,r/m32     2/4           Move r/m dword to dword register</span><br><span class="line">8C  /r   MOV r/m16,Sreg    2/2           Move segment register to r/m word</span><br><span class="line">8E  /r   MOV Sreg,r/m16    2/5,pm=18/19  Move r/m word to segment register</span><br><span class="line">A0       MOV AL,moffs8     4             Move byte at (seg:offset) to AL</span><br><span class="line">A1       MOV AX,moffs16    4             Move word at (seg:offset) to AX</span><br><span class="line">A1       MOV EAX,moffs32   4             Move dword at (seg:offset) to EAX</span><br><span class="line">A2       MOV moffs8,AL     2             Move AL to (seg:offset)</span><br><span class="line">A3       MOV moffs16,AX    2             Move AX to (seg:offset)</span><br><span class="line">A3       MOV moffs32,EAX   2             Move EAX to (seg:offset)</span><br><span class="line">B0 + rb ib  MOV reg8,imm8     2          Move immediate byte to register</span><br><span class="line">B8 + rw iw  MOV reg16,imm16   2          Move immediate word to register</span><br><span class="line">B8 + rd id  MOV reg32,imm32   2          Move immediate dword to register</span><br><span class="line">C6 ib    MOV r/m8,imm8     2/2           Move immediate byte to r/m byte</span><br><span class="line">C7 iw    MOV r/m16,imm16   2/2           Move immediate word to r/m word</span><br><span class="line">C7 id    MOV r/m32,imm32   2/2           Move immediate dword to r/m dword</span><br></pre></td></tr></table></figure></li></ul><h3 id="统计代码行数"><a href="#统计代码行数" class="headerlink" title="统计代码行数"></a>统计代码行数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name "*.[ch]" | xargs wc -l &gt; statistic</span><br></pre></td></tr></table></figure><p><img src="6.png" alt></p><p>PA0 时的代码行数:</p><p><img src="7.png" alt></p><font color="blue"><strong>PA1到此结束</strong></font><h1 id="PA2-简单复杂的机器-冯诺依曼计算机系统"><a href="#PA2-简单复杂的机器-冯诺依曼计算机系统" class="headerlink" title="PA2 - 简单复杂的机器: 冯诺依曼计算机系统"></a>PA2 - 简单复杂的机器: 冯诺依曼计算机系统</h1><p>先给出了一段YEMU的代码，其中模拟了最简单的计算机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义指令格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">uint8_t</span> rs : <span class="number">2</span>, rt : <span class="number">2</span>, op : <span class="number">4</span>; &#125; rtype;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">uint8_t</span> addr : <span class="number">4</span>      , op : <span class="number">4</span>; &#125; mtype;</span><br><span class="line">  <span class="keyword">uint8_t</span> inst;</span><br><span class="line">&#125; <span class="keyword">inst_t</span>;</span><br></pre></td></tr></table></figure><p>这部分定义了指令格式，其中用到了<strong>位域（Bit field）</strong>的结构</p><h2 id="RTFC"><a href="#RTFC" class="headerlink" title="RTFC"></a>RTFC</h2><p><code>isa-cpu-exec()</code>中，代码首先定义了一个<code>DecodeExecState</code>类型的结构体变量<code>s</code>, 它用于存放在执行一条指令过程中的译码和执行信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> opcode;</span><br><span class="line">  <span class="keyword">vaddr_t</span> seq_pc;  <span class="comment">// sequential pc</span></span><br><span class="line">  <span class="keyword">uint32_t</span> is_jmp;</span><br><span class="line">  <span class="keyword">vaddr_t</span> jmp_pc;</span><br><span class="line">  Operand src1, dest, src2;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">  <span class="keyword">rtlreg_t</span> tmp_reg[<span class="number">4</span>];</span><br><span class="line">  ISADecodeInfo isa;</span><br><span class="line">&#125; DecodeExecState;</span><br></pre></td></tr></table></figure><p>部分isa相关信息存放在<code>ISADecodeInfo</code>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">bool</span> is_operand_size_16;</span><br><span class="line">  <span class="keyword">uint8_t</span> ext_opcode;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *mbase;</span><br><span class="line">  <span class="keyword">rtlreg_t</span> mbr;</span><br><span class="line">  <span class="keyword">word_t</span> moff;</span><br><span class="line">&#125; x86_ISADecodeInfo;</span><br></pre></td></tr></table></figure></p><p>这里定义的是<code>x86_ISADecodeInfo</code>，但是在代码中直接用的是<code>ISADecodeInfo</code>，是因为</p><p><code>include/isa.h:13:typedef concat(__ISA__, _ISADecodeInfo) ISADecodeInfo;</code></p><p>这样可以让框架代码不随ISA而改变</p><p><code>concat(x, y)</code>同样是一个宏，作用是把两个字符串<code>x,y</code>拼在一起，也就是说<code>concat(x86, _ISADecodeInfo) == x86_ISADecodeInfo</code></p><h3 id="取指"><a href="#取指" class="headerlink" title="取指"></a>取指</h3><p>取指实质上就是读内存，在<code>pc</code>指向的位置读一条长度为<code>len</code>的指令，返回读到的指令</p><p>Debug状态下会把指令的每一个字节放到一个外部数组<code>log_bytebuf[]</code>中。</p><p>这里读内存使用的是<code>vaddr_ifetch()</code>，看上去是读虚拟内存，实际上现阶段都是直接访问物理内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//read address</span></span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_ifetch(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">"%02x "</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h3><p>译码实质上就是查表，把取出的指令的<code>opcode</code>提取出来，然后根据<code>opcode</code>去查表确定指令类型，这里用一个很大的<code>switch-case</code>来进行，其中用到了一些宏。</p><p>这些宏先设置操作数的宽度，再进行操作数译码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty decode helper</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> decode_empty(s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(idx, id, ex, w) CASE_ENTRY(idx, concat(decode_, id), concat(exec_, ex), w)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(idx, id, ex)     IDEXW(idx, id, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXW(idx, ex, w)       IDEXW(idx, empty, ex, w)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX(idx, ex)           EXW(idx, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY(idx)            EX(idx, inv)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE_ENTRY(idx, id, ex, w) case idx: set_width(s, w), id(s), ex(s); break;</span></span><br></pre></td></tr></table></figure><p>这些宏一个套一个，最终都是来自<code>CASE_ENTRY</code>，其中的<code>s</code>是<code>DecodeExecState *s</code>，他被用作这些函数的参数，且总叫做<code>s</code>。</p><p>例如：</p><p><code>IDEXW(0x80, I2E, gp1, 1) == CASE_ENTRY(0x80, decode_I2E, exec_gp1, 1)</code></p><p><code>IDEX(0x81, I2E, gp1) == IDEXW(0x80, I2E, gp1, 0) == CASE_ENTRY(0x81, decode_I2E, exec_gp1, 0)</code></p><p><code>EX(0x0f, 2byte_esc) == EXW(0x0f, 2byte_esc, 0) == IDEXW(0x0f, empty, 2byte_esc, 0) == CASE_ENTRY(0x0f, decode_empty, exec_2byte_esc, 0)</code></p><p>其中的<code>decode_</code>开头的函数都是译码辅助函数</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><code>#define def_EHelper(name) void concat(exec_, name) (DecodeExecState *s)</code>，用于执行，<code>exec_</code>开头的都是执行辅助函数。</p><h3 id="更新PC"><a href="#更新PC" class="headerlink" title="更新PC"></a>更新PC</h3><p>下一条指令有静态动态两种，默认情况下取指结束后<code>s-&gt;seq_pc</code>会指向下一条静态地址，如果有跳转指令，<code>s-&gt;jmp_pc</code>会指向下一条动态指令，真正修改的时候调用<code>update_pc()</code>即可。</p><h2 id="使用RTL表示指令行为"><a href="#使用RTL表示指令行为" class="headerlink" title="使用RTL表示指令行为"></a>使用RTL表示指令行为</h2><ul><li>RTL寄存器<ul><li>PA1中已经实现</li></ul></li><li></li></ul><h2 id="请整理一条指令在NEMU中的执行过程"><a href="#请整理一条指令在NEMU中的执行过程" class="headerlink" title="请整理一条指令在NEMU中的执行过程"></a>请整理一条指令在NEMU中的执行过程</h2><ul><li><code>si 1</code></li><li><code>cpu_exec(n=1) at src/monitor/cpu_exec.c</code></li><li><code>isa_exec_once() at src/isa/x86/exec/exec.c</code></li><li><code>fetch_decode_exec (s=0x7ffffffed860) at src/isa/x86/exec/exec.c:144</code><ul><li><code>instr_fetch (len=1, pc=0x7ffffffed864) at src/isa/x86/exec/exec.c:144</code> 取指</li><li><code>IDEX(0xb8, mov_I2r, mov)</code> 指令是移动立即数到寄存器<ul><li><code>set_width (width=0, s=0x7ffffffed860) at src/isa/x86/exec/exec.c:108</code></li><li><code>s-&gt;src1.width = s-&gt;dest.width = s-&gt;src2.width = width; //width = 4</code> 设置操作数宽度</li><li><code>decode_mov_I2r (s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:166</code> 开始译码操作数</li><li><code>decode_op_r (load_val=0 &#39;\000&#39;, op=0x7ffffffed8b8, s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:167</code> load_val = 0表示这个操作数不需要存储到<code>s</code>中供后续使用</li><li><code>operand_reg (s=0x7ffffffed860, width=4, r=0, load_val=0 &#39;\000&#39;, op=0x7ffffffed8b8) at src/isa/x86/exec/../local-include/decode.h:8</code> 找出要用到的寄存器</li><li><code>decode_op_I (load_val=1 &#39;\001&#39;, op=0x7ffffffed870, s=0x7ffffffed860) at src/isa/x86/exec/../local-include/decode.h:168</code></li><li><code>operand_imm (width=&lt;optimized out&gt;, imm=&lt;optimized out&gt;, load_val=&lt;optimized out&gt;,op=&lt;optimized out&gt;, s=&lt;optimized out&gt;) at src/isa/x86/exec/../local-include/decode.h:40</code> 找出立即数，用到一条<code>rtl_li</code></li><li></li></ul></li></ul></li></ul><h2 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h2><h2 id="运行第一个C程序"><a href="#运行第一个C程序" class="headerlink" title="运行第一个C程序"></a>运行第一个C程序</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;填坑&lt;/p&gt;
    
    </summary>
    
      <category term="计算机系统基础" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机系统基础" scheme="http://ilern.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机组成原理" scheme="http://ilern.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="操作系统" scheme="http://ilern.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记 物理层</title>
    <link href="http://ilern.github.io/2020/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/12/30/计算机网络复习笔记-物理层/</id>
    <published>2020-12-30T13:41:06.000Z</published>
    <updated>2021-01-04T11:31:18.122Z</updated>
    
    <content type="html"><![CDATA[<p>复习笔记，学的时候没整理，欠的还是要还</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="物理层的四个特性"><a href="#物理层的四个特性" class="headerlink" title="物理层的四个特性"></a>物理层的四个特性</h2><ol><li><p>机械特性</p><ol><li>接口的形状尺寸、引线数目、排列方式</li></ol></li><li><p>电气特性</p><ol><li>各条线上电压的范围</li></ol></li><li><p>功能特性</p><ol><li>某个电压代表的具体含义</li></ol></li><li>过程特性<ol><li>对于不同功能的各种事件出现的顺序</li></ol></li></ol><h2 id="两种信号"><a href="#两种信号" class="headerlink" title="两种信号"></a>两种信号</h2><ol><li>数字信号<ol><li>不连续变化的信号，是离散的</li></ol></li><li>模拟信号<ol><li>连续变化的信号</li></ol></li></ol><ol><li>基带信号<ol><li>基本频带信号，包含较多的低频分量 / 直流分量，不易在信道中传输</li></ol></li><li>带通信号<ol><li>基带信号经过调制后把低频转化为高频</li></ol></li></ol><h2 id="两种调制方法"><a href="#两种调制方法" class="headerlink" title="两种调制方法"></a>两种调制方法</h2><ol><li>基带调制<ol><li>编码，把数字信号转换为另一种形式的数字信号</li></ol></li><li>带通调制<ol><li>利用载波进行调制，把基带信号移动到较高频段，转换为模拟信号</li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><h1 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h1><h2 id="不归零制-NRZ"><a href="#不归零制-NRZ" class="headerlink" title="　不归零制 NRZ"></a>　不归零制 NRZ</h2><p>有电压表示1，无电压表示0</p><p>效率高，但是接收方不易同步</p><h2 id="归零制-RZ"><a href="#归零制-RZ" class="headerlink" title="归零制 RZ"></a>归零制 RZ</h2><p>发送窄脉冲，发送完归零</p><p>把时钟信号包含在内，但是大部分的数据带宽被浪费了</p><h2 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h2><p>每一位的中间进行一次跳变，向上向下分别代表0和1</p><h2 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h2><p>每一位的中间进行一次跳变，这次跳变用来时钟同步</p><p>每一位开始进行一次跳变，这次有无跳变表示0和1</p><h2 id="非归零反相编码-NRZI"><a href="#非归零反相编码-NRZI" class="headerlink" title="　非归零反相编码 NRZI"></a>　非归零反相编码 NRZI</h2><p>信号反转与否代表0和1</p><p>USB使用NRZI编码进行传输</p><p>不具有自同步特性，但可以使用前同步码的方式进行同步</p><p>对于连续的多个1，需要进行比特填充，每7个连续的1之后插一个0</p><h1 id="带通调制方法"><a href="#带通调制方法" class="headerlink" title="带通调制方法"></a>带通调制方法</h1><p>调幅</p><p>调频</p><p>调相</p><p><img src="IMG_1616.PNG" alt></p><p>正交振幅调制</p><h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><h2 id="极限传输速率"><a href="#极限传输速率" class="headerlink" title="极限传输速率"></a>极限传输速率</h2><p>信道极限传输速率：</p><script type="math/tex; mode=display">C = W \log_2(1 + \frac{S}{N})</script><p>$W$ 为带宽，单位是Hz</p><p>$S$ 为信号的平均功率</p><p>$N$ 为信道内部高斯噪声功率</p><h2 id="信噪比"><a href="#信噪比" class="headerlink" title="　信噪比"></a>　信噪比</h2><p>信号的平均功率比上噪声的平均功率</p><script type="math/tex; mode=display">\frac{S}{N}</script><p>以分贝为单位的信噪比</p><script type="math/tex; mode=display"> 10 \log_{10} (\frac{S}{N})</script><p>给出分贝计算出比值，进而计算出极限传输速率</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p>理论上讲，只要信道传输速率低于信道极限传输速率，就一定能实现无差错传输</p><p>在存在高斯白噪声的信道中，最大传输速率为</p><script type="math/tex; mode=display">\begin{align}C &= B \times \log_2(1 + \frac{S}{N}) \\&= B \times \log_2(1 + \frac{S}{n_0 B})\end{align}</script><p>也就是说噪声功率是受带宽影响的，当带宽增大时，噪声也会随之增大，因此无法无限制提高带宽</p><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><ul><li><p>双绞线 </p><ul><li><p>有屏蔽的双绞线  STP</p></li><li><p>无屏蔽的双绞线  UTP</p></li><li><p>光纤</p><ul><li>单模光纤<ul><li>高能量、长距离，需要激光源，成本高</li><li>1310nm 1510nm</li></ul></li><li>多模光纤<ul><li>传输速度低、距离短、整体性能差，但成本低</li><li>850nm</li></ul></li></ul></li></ul></li><li><p>地面微波接力</p></li><li><p>卫星通信</p></li></ul><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>每个用户被分配一个频带,不同的用户在相同时间内使用不同的频带</p><h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>把时间划分为若干时分复用帧,每一个用户所占用的时隙周期性出现\</p><p>又分同步时分复用和异步时分复用</p><p>时分复用中时隙预先分配且保持不变,可能会造成时隙浪费</p><h2 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h2><p>又叫异步时分复用</p><p>能够动态按需分配时隙</p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="　波分复用"></a>　波分复用</h2><p>一根光纤上同时传送多个不同的光载波</p><p>波分复用就是光的频分复用</p><p>使用掺铒光纤放大器</p><h2 id="码分复用-码分多址"><a href="#码分复用-码分多址" class="headerlink" title="码分复用 / 码分多址"></a>码分复用 / 码分多址</h2><p>CDMA 码分多址</p><p>每个站有自己的码片序列,对于1,发送自己码片的源码,对于0,发送自己码片的二进制反码(按位取反)</p><p>码片序列中用-1表示0</p><p>各个站点之间的码片相互正交</p><script type="math/tex; mode=display">S \cdot T = \frac{1}{m} \sum_{i=1}^m S_iT_i = 0</script><p>任何一个码片向量和该码片向量自己的规格化内积都是1</p><script type="math/tex; mode=display">S \cdot S = \frac{1}{m}\sum_{i=1}^mS_iS_i = \frac{1}{m}\sum_{i=1}^m S_i^2 = 1</script><p>任何一个码片向量和该码片反码的向量的规格化内积值为-1</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>共有四个站进行码分多址CDMA通信.四个站的码片序列为：<br>A.(-1 -1 -1 +1 +1 -1 +1 +1) B.(-1 -1 +1 -1 +1 +1 +1 -1)<br>C.(-1 +1 -1 +1 +1 +1 -1 -1) D.(-1 +1 -1 -1 -1 -1 +1 -1)<br>现收到这样的码片序列：（-1 +1 -3 +1 -1 -3 +1 +1）.问哪个站发送了数据?发送数据的站发送的是1,还是0?</p><p>分别计算正交和,结果是1说明发了1,结果是-1说明发了0,结果是0说明没发</p><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="数字传输系统-PCM-方法"><a href="#数字传输系统-PCM-方法" class="headerlink" title="数字传输系统 PCM 方法"></a>数字传输系统 PCM 方法</h2><p>取样量化编码</p><h2 id="SONET-同步光纤网"><a href="#SONET-同步光纤网" class="headerlink" title="SONET 同步光纤网"></a>SONET 同步光纤网</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习笔记，学的时候没整理，欠的还是要还&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习指北</title>
    <link href="http://ilern.github.io/2020/12/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8C%97/"/>
    <id>http://ilern.github.io/2020/12/27/操作系统复习指北/</id>
    <published>2020-12-27T02:44:25.000Z</published>
    <updated>2020-12-27T09:59:28.554Z</updated>
    
    <content type="html"><![CDATA[<p>期末复习用，主要是上课画的重点</p><a id="more"></a><h1 id="Chapter-1-导论"><a href="#Chapter-1-导论" class="headerlink" title="Chapter 1 导论"></a>Chapter 1 导论</h1><p>buffer 和 Cache 的区别与联系</p><ul><li><strong>Buffer</strong>是系统两端处理<strong>速度平衡</strong>（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到<strong>流量整形</strong>的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。</li><li><strong>Cache</strong>则是系统两端处理<strong>速度不匹配</strong>时的一种<strong>折衷策略</strong>。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。</li></ul><p>软中断</p><h1 id="Chapter-2-操作系统结构"><a href="#Chapter-2-操作系统结构" class="headerlink" title="Chapter 2 操作系统结构"></a>Chapter 2 操作系统结构</h1><h1 id="Chapter3-进程"><a href="#Chapter3-进程" class="headerlink" title="Chapter3 进程"></a>Chapter3 进程</h1><h1 id="Chapter-4-线程"><a href="#Chapter-4-线程" class="headerlink" title="Chapter 4 线程"></a>Chapter 4 线程</h1><h1 id="Chapter-5-同步"><a href="#Chapter-5-同步" class="headerlink" title="Chapter 5 同步"></a>Chapter 5 同步</h1><h1 id="Chapter-6-进程调度"><a href="#Chapter-6-进程调度" class="headerlink" title="Chapter 6 进程调度"></a>Chapter 6 进程调度</h1><h1 id="Chapter-7-死锁"><a href="#Chapter-7-死锁" class="headerlink" title="Chapter 7 死锁"></a>Chapter 7 死锁</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;期末复习用，主要是上课画的重点&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://ilern.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-运输层</title>
    <link href="http://ilern.github.io/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/12/21/计算机网络复习笔记-运输层/</id>
    <published>2020-12-21T06:38:14.000Z</published>
    <updated>2021-01-03T09:01:29.724Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络中最难/复杂的部分</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层考虑的是两个应用进程间的逻辑通信，端到端的通信，端口到端口的通信</p><p>运输层支持复用和分用，不同进程向下提供给网络层，使用一样的服务，由网络层传上来的内容经过运输层的分用发给不同进程</p><p>TCP提供一条全双工的可靠信道</p><p>UDP提供不可靠信道，但是胜在快</p><p>DCCP提供双向单播拥塞控制连接但不可靠的协议，无连接不可靠但仍有拥塞控制</p><p>SCTP</p><ol><li>是面向消息的，</li><li>在socket种TCP只能绑定一个IP，但SCTP可以绑定多个IP，只要其中由一对IP能通， 这条SCTP连接就还可用</li><li>多流独立有序、无序传输</li><li>需要四次握手</li><li>使用心跳机制来管理路径的可用性，如果一条连接上的连续传输失败次数大于连接最大重传次数，就会通知应用程序并关闭连接</li></ol><h1 id="UDP-User-Datagram-Protocol"><a href="#UDP-User-Datagram-Protocol" class="headerlink" title="UDP User Datagram Protocol"></a>UDP User Datagram Protocol</h1><p>只在IP之上增加了 <em>复用分用</em>、<em>差错检测</em> 的功能</p><p>不提供 <em>确认</em> 和 <em>重传</em> 的功能，这两个功能需要序号，然而UDP不带序号</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>无连接</p><p>使用尽最大努力交付，不可靠</p><p>面向<strong>报文</strong></p><p>没有拥塞控制，<font color="red">UDP无连接且不带拥塞控制不代表只要无连接就不带拥塞控制</font></p><p>UDP支持一对一、一对多、多对一、多对多的交互通信</p><p>UDP的首部开销小，只有8字节，而TCP有20字节</p><h2 id="如何理解UDP是面向报文的"><a href="#如何理解UDP是面向报文的" class="headerlink" title="如何理解UDP是面向报文的"></a>如何理解UDP是面向报文的</h2><p>UDP把应用层交下来的报文添加头部后就交给网络层，应用层交给UDP多长的报文UDP就发送多长的报文，<strong>既不合并，也不拆分</strong></p><p>接收方接收到UDP报文后去掉头部后一次交付给上层，一次交付一个完整的报文</p><p>因此应用层应当选择恰当的报文长度，若太长则会引发IP分片，若太短则使IP首部相对过大，传输效率低</p><h2 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h2><p><img src="IMG_5691.PNG" alt></p><p>计算检验和时需要把伪首部和UDP数据报连接在一起，检验和是为了检测<strong>整个UDP报文</strong>是否出错</p><p>伪首部是为了二次验证</p><p>计算检验和时先填充、然后以两个字节为单位对整个UDP报文进行二进制反码求和</p><h1 id="TCP-Transport-Control-Protocol"><a href="#TCP-Transport-Control-Protocol" class="headerlink" title="TCP Transport Control Protocol"></a>TCP Transport Control Protocol</h1><p>面向连接，提供<strong>点对点</strong>的全双工服务</p><p>使用socket连接，socket包括IP地址和端口号</p><p>TCP提供可靠交付的服务，有顺序控制、重发机制、端到端校验和、拥塞控制的功能</p><font color="red"> <strong> TCP面向字节流  </strong> </font> <h2 id="报文段格式"><a href="#报文段格式" class="headerlink" title="报文段格式"></a>报文段格式</h2><p><img src="IMG_1597.PNG" alt="IMG_1597.PNG"></p><p>序号</p><ul><li>TCP的每一个字节都有一个序号，首部中的序号字段是本报文段发送的数据的第一个字节的序号</li></ul><p>确认号</p><ul><li>期望收到对方的下一个报文段的数据的第一个字节的序号</li></ul><p>数据偏移（首部长度）</p><ul><li>以四字节为计算单位</li></ul><p>保留</p><ul><li>目前全为0</li></ul><p>六个标志位</p><ul><li>URG 紧急标志，表明高优先级的数据，不排队、不进缓存、直接提交</li><li>ACK 确认标志，当ACK为1时确认号才有效</li><li>PSH 推送标志，用不到</li><li>RST 复位标志，出现重大差错，需要重新建立连接</li><li>SYN 同步标志， 表示是一个连接请求或连接接受报文</li><li>FIN  终止标志，用于释放连接</li></ul><p>窗口</p><ul><li>以字节为单位，告知对方自己的接受能力，从而使对方设置发送窗口的大小</li><li>16位，两个字节，因此窗口最大为$2^{16} - 1$</li></ul><p>检验和</p><ul><li>检验首部和数据部分，计算时要在报文段的前面加上12字节的伪首部</li></ul><p>紧急指针</p><ul><li>配合URG使用，指出紧急数据共有多少字节</li></ul><p>选项</p><ul><li>选项的一般格式为类型一字节、长度一字节、信息若干字节，总和最长40字节</li></ul><p><img src="https://img-blog.csdnimg.cn/20190304204418902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwOTY5MDA=,size_16,color_FFFFFF,t_70" alt></p><ul><li>MSS Maximum Segment Size TCP报文中数据字段的最大长度，可以限制分片的产生，两个方向的MSS可以不同</li><li>窗口扩大选项，窗口最大$2^{16} - 1$，有些长肥管道的时延带宽积非常大，即使窗口到达最大也无法填满信道，此时可以使用窗口扩大因子进行扩大。<ul><li>窗口扩大因子实际是移位数，假设TCP头部中的通告窗口大小为$N$，窗口扩大因子（位移数）是$M$，那么TCP报文段的实际接收通告窗口大小为：$N \times 2 ^ M$。M的取值范围为0 ～ 14</li><li>这样能把窗口最大 扩大到$2^{16 + 14} = 2^{30} = 1G$</li><li>没有那么细致，毕竟只是移位</li></ul></li><li>时间戳，防止序列号回绕，乱序时间判断的依据，计算RTT</li><li>SACK，4号表示支持SACK，5号是SACK的内容，最多三个SACK块</li></ul><p>填充</p><ul><li>整个首部长度需要是4字节的整数倍</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="停止等待协议-（自动重传请求-ARQ协议-Automatic-Repeat-Request）"><a href="#停止等待协议-（自动重传请求-ARQ协议-Automatic-Repeat-Request）" class="headerlink" title="停止等待协议 （自动重传请求 ARQ协议 Automatic Repeat Request）"></a>停止等待协议 （自动重传请求 ARQ协议 Automatic Repeat Request）</h3><p>A向B发送一个分组，B收到后向A进行确认，A收到确认后发送下一个分组</p><p>A发送结束后设置一个超时重传计时器<font color="blue"> &lt;第一个计时器&gt; </font>, 超过等待时间没有收到确认就认为分组丢失，重新发送</p><p>A发送后需要保存一个刚刚发送的报文的副本，收到B的确认后再撤销计时器和副本</p><p>分组和确认分组都需要编号，从而明确收到的确认分组对应于发出去的哪个分组</p><p>分组正确到达B但是没有收到确认，存在两种可能</p><ul><li>确认丢失，重传之后B丢弃重复分组，再次发送确认；</li><li>确认迟到，B收到重传的重复分组，丢弃，A收到迟到的确认报文，什么也不做</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="　缺点"></a>　缺点</h4><p>信道利用率很低，利用率为Ｕ，则</p><script type="math/tex; mode=display">U = \frac{T_D}{T_D + RTT + T_A}</script><p>其中$T_D$是发送时间，$T_A$是发送ACK的时间</p><p>可以使用流水线传输的方式提高效率、</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>只对按序到达的最后一个分组发送确认</p><p>优点是及时确认丢失也不必重传，前面的ACK丢失，后续的ACK可能足以确认前面的报文段了</p><p>缺点是不能向发送方反映出接受方已经城阙收到的所有分组的信息</p><h4 id="Go-back-N"><a href="#Go-back-N" class="headerlink" title="Go back N"></a>Go back N</h4><p>部分分组丢失后发送方只收到一个靠前的ACK，此时需要退回来重传已经发送过的N个分组</p><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>最大为$2^{16}-1$</p><p>发送方和接收方各有一个缓冲（Buffer）</p><p>对于发送方而言，其缓冲数据内的数据可以分为四类</p><p><img src="https://pic1.zhimg.com/80/a1d5c050ad957880094a5f003b1ccd24_720w.png" alt></p><p>其中第二类和第三类在一个发送窗口中</p><p>收到累计确认后，窗口右移 </p><p>对于接收方而言，他的缓冲数据中存在三类，已接收，未接受准备接收，未接受未准备接收</p><p>所谓已接收实际意味着已发送确认，ACK由TCP协议栈回复，不需要等进程回复，因此不存在已接收未回复</p><p>其中<strong>未接受准备接收</strong>就是接收窗口，似乎说成未确认准备确认更合适一些？</p><h4 id="发送窗口和接收窗口的关系"><a href="#发送窗口和接收窗口的关系" class="headerlink" title="发送窗口和接收窗口的关系"></a>发送窗口和接收窗口的关系</h4><p><img src="https://pic4.zhimg.com/80/c798dd393fcf7c03b1db78f5bcf0304b_720w.png" alt></p><h4 id="利用滑动窗口实现可靠传输"><a href="#利用滑动窗口实现可靠传输" class="headerlink" title="利用滑动窗口实现可靠传输"></a>利用滑动窗口实现可靠传输</h4><p>最基本的传输可靠性来自于<strong>确认重传</strong>机制，滑动窗口是实现确认重传的一种方式</p><p>发送端只有在收到对端发送的对于己方发送窗口内的字节的ACK且前面全都完成确认的情况下窗口的左边界才会移动（绕）</p><p>对于已有的确认不能撤销，因此左边沿不能左移</p><p>右边沿通常是不动和右移，在收到缩小窗口大小的信号后可能左移，但是非常不推荐</p><p>举个例子</p><p><img src="IMG_1599.PNG" alt></p><h4 id="Buffer-和窗口的关系"><a href="#Buffer-和窗口的关系" class="headerlink" title="Buffer 和窗口的关系"></a>Buffer 和窗口的关系</h4><p><img src="IMG_1600.PNG" alt></p><p><img src="IMG_1601.PNG" alt></p><h4 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h4><ul><li>发送窗口根据对方的接收窗口进行设置， 但是两者并不总是相等，因为网络传送窗口值是有延迟的</li><li>对于不按序到达的数据，TCP通常是临时存放在接收窗口中，在字节流中缺少的字节收到后再交付给上层（SACK？）</li><li>接收方必须支持累计确认，可以适当推迟确认，也可以捎带确认、</li></ul><h3 id="超时重传时间-RTO-的选择"><a href="#超时重传时间-RTO-的选择" class="headerlink" title="超时重传时间 RTO 的选择"></a>超时重传时间 RTO 的选择</h3><p>为什么需要考虑超时重传时间？</p><p>重传时间过短会引起不必要的重传，占用资源；重传时间过长会导致空闲，降低传输效率</p><p>TCP通过RTT来计算RTO</p><script type="math/tex; mode=display">\begin{align}newRTO &= newRTT_S + 4 \times newRTT_D \\newRTT_S & = (1 - \alpha)RTT_S + \alpha RTT \\newRTT_D & = (1 - \beta)RTT_D + \beta |RTT_ S - RTT|\\end{align}</script><p>第一次测量到$RTT$时，$RTT_S = RTT$，$RTT_D = \frac{RTT}{2}$</p><p>因此第一次测量到$RTT$时，$RTO = RTT + 4 \times \frac{RTT}{2} = 3RTT$</p><p>因为$newRTT_D$需要用到$RTT_S$，所以应该先算，如果先算$RTT_S$，旧的值就被覆盖了</p><p>$\alpha = \frac{1}{8}, \beta = \frac{1}{4}$</p><h4 id="一个题目"><a href="#一个题目" class="headerlink" title=" 一个题目 "></a><font color="red"> 一个题目 </font></h4><blockquote><p>假定TCP在开始建立连接时，发送方设定的超时重传时间$RTO = 6s$</p><p>（1）当发送方收到对方的连接确认报文段时，测量出$RTT$样本值为$1.5s$，计算现在的$RTO$值</p><p>（2）当发送方发送数据报文段并收到确认时，测量出$RTT$样本值为$2.5s$，计算现在的$RTO$值</p></blockquote><p>首先要明确$RTO$的计算和初始值没有任何关系，$6s$ 是一个干扰数据</p><p>第一问：</p><p>第一次测得 $RTT$ 时 $RTO  = 3RTT = 4.5s$</p><p>此时$RTT_S = 1.5, RTT_D = 0.75$</p><p>第二问：</p><p>$newRTT_D = \frac{3}{4} \times 0.75 + \frac{1}{4}|1.5 - 2.5| = \frac{13}{16}$</p><p>$newRTT_S = \frac{7}{8} \times 1.5 + \frac{1}{8} \times 2.5 = \frac{26}{16}$</p><p>$newRTO = newRTT_S + 4RTT_D = \frac{78}{16} = 4.875$    </p><h4 id="Karn-算法"><a href="#Karn-算法" class="headerlink" title="Karn 算法"></a>Karn 算法</h4><p>计算RTT时，如果报文段重传了就不计入往返时间样本</p><p>存在一个问题，如果由于某种神秘力量，时延突然增加，在原本的时间内就收不到确认，发起重传，但是重传的RTT又不被采用，就会导致一直无法更新重传时间</p><h4 id="修正的-Karn-算法"><a href="#修正的-Karn-算法" class="headerlink" title="修正的 Karn 算法"></a>修正的 Karn 算法</h4><p>每重传一次，RTO就增大一些</p><script type="math/tex; mode=display">newRTO = \gamma RTO, \gamma = 2</script><h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>双方必须事先商定好</p><p>在选项部分中指明收到的 <strong>不连续字节块</strong> 的边界</p><p>一个SACK报文最多只能指明三个字节块的边界信息</p><ul><li>首部选项部分长度最多四十字节，一个边界用掉四字节，去掉类型和长度</li></ul><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>控制发送方不要发得太快</p><h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><p>对于接收方发出的每一个ACK，都包含自己的接收窗口大小，表示自己还能接受多少数据，发送方收到之后调整自己的发送窗口</p><p>会带来死锁的局面，当接收窗口为0时发送端便不再发送数据，但是如果接收方之后发送的非零窗口大小的报文丢失了，发送端就永远无法得知接收端已经准备好接收数据，从而产生死锁的情况</p><h3 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h3><p>为了解决死锁的情况，TCP为每一个连接设置了一个持续计时器<font color="blue"> &lt;第二个计时器&gt; </font></p><p>如果持续计时器到时，发送方就向接收方发送一个零窗口探测报文段，若不是零，则在AC中告知，如果仍然是零，发送方就重设计时器</p><h3 id="流量控制下的传输效率-发送时机"><a href="#流量控制下的传输效率-发送时机" class="headerlink" title="流量控制下的传输效率 / 发送时机"></a>流量控制下的传输效率 / 发送时机</h3><ol><li><p>维护一个MSS Max Segment Size，缓冲中存放的数据大于MSS时组装成一个TCP报文发出去</p></li><li><p>发送方的进程显式push</p></li><li>发送方设置一个发送计时器，把缓冲中的数据装入报文段（长度不超过MSS）</li></ol><h4 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h4><p>对于小数据量的传送，Nagle算法会将他们写入缓冲区，累计到一定数目后再一起发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if有新資料要傳送</span><br><span class="line">  if訊窗大小&gt;= MSS and可傳送的資料&gt;= MSS</span><br><span class="line">    立刻傳送完整MSS大小的segment</span><br><span class="line">  else</span><br><span class="line">   if管線中有尚未確認的資料</span><br><span class="line">     在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列</span><br><span class="line">   else</span><br><span class="line">     立即傳送資料</span><br></pre></td></tr></table></figure><p>在任意时刻，网络中最多只能有一个未被确认的小段，在收到确认后才会发送，也就是说发送的频率取决于RTT，是一种自时钟，ACK返回越快，数据传输也就越快。</p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>由于发送方发送能力差（产生数据慢）或者接收方处理能力差（消耗数据慢）导致了发送窗口越来越小，以至于一次只能发送一个字节，造成巨大的浪费</p><p>发送端采用Nagle算法进行问题避免，发送端累计数据到MSS之后进行发送</p><p>接收端采用<code>David D Clark&#39;s solution</code>进行问题避免，暂时关闭接收窗口直到有能容纳MSS的空间；或者使用延迟确认的方法，不立即发送ACK，发送端会一直等待，直到接收方空间够了再发送ACK</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞是一个系统性的问题，仅仅优化局部往往难以解决问题</p><p>流量控制是局部，拥塞控制是全局</p><p>拥塞控制并不能真正控制拥塞，只是让拥塞晚一点来</p><p>拥塞控制是动态的问题</p><h3 id="慢开始-amp-拥塞避免"><a href="#慢开始-amp-拥塞避免" class="headerlink" title="慢开始 &amp; 拥塞避免"></a>慢开始 &amp; 拥塞避免</h3><p>基于窗口的拥塞控制</p><p>发送方维护一个拥塞窗口cwnd，其随着网络状态动态变化，发送方的窗口为对方的接收窗口和拥塞窗口的较小值</p><p>只要没有出现拥塞，拥塞窗口就再增大一点，以便发送更多的分组，一旦出现拥塞，拥塞窗口就减小一点</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol><li><p>初始情况下设置拥塞窗口大小为1 MSS</p></li><li><p>每收到一个新的报文段的确认，窗口大小加一（以MSS为单位）</p><ol><li>是一个一个增加的，但是在一个传输轮次中的表现是经过一个轮次窗口大小加倍</li><li>一个传输轮次就是一个RTT</li><li>这段时间cwnd以指数规律增长</li></ol><p><img src="IMG_1607.PNG" alt></p></li><li><p>随着cwnd不断增加，会到达一个阈值，之后每一轮cwnd只增加一</p><ol><li>这个部分为拥塞避免，方法为加法增大</li></ol></li><li><p>当网络拥塞发生后，cwnd回到初始值，阈值被重新设定为网络拥塞发生时cwnd大小的一般，重新进行慢开始</p><ol><li>减小阈值的操作被称为乘法减小</li></ol></li></ol><p><img src="IMG_1608.PNG" alt></p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>接收方每收到一个失序报文段后就立即发送重复确认，这样可以让发送方尽早直到有报文段没有到达接收方</p><p>发送方只要连续三次收到重复确认，就重发</p><p><strong>没有取消超时重传计时器</strong>，但是在部分情况下可以更快重发</p><p><img src="IMG_1609.PNG" alt></p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>发送方收到三个重复确认后立即执行乘法减小，修改阈值，但是此时并不从一开始，而是直接从新的阈值开始进行加法增大</p><p>超时执行慢开始，三个重复确认执行快恢复</p><p><img src="IMG_1610.PNG" alt></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="Tahoe"><a href="#Tahoe" class="headerlink" title="Tahoe"></a>Tahoe</h4><p>旧的算法，没有快恢复，在恢复丢失数据报期间不能发送新的数据包，因为此时的已发送未确认大于窗口值</p><h4 id="Reno"><a href="#Reno" class="headerlink" title="Reno"></a>Reno</h4><p>相比Tahoe增加了快恢复</p><h4 id="NewReno"><a href="#NewReno" class="headerlink" title="　NewReno"></a>　NewReno</h4><p><strong>Reno</strong>提出的快速恢复算法提高了包丢失后的吞吐量和健壮性，但缺陷是它只考虑了只丢失一个包的情形，只要丢失了一个包，就被认为是发生了一次拥塞。</p><p>在实际的网络中，一旦发生拥塞，会丢弃大量的包。如果采用<strong>Reno</strong>算法，它会认为网络中发生了多次拥塞，则会多次将<code>cwnd</code>和<code>ssthresh</code>减半，造成吞吐量极具下降，当发送窗口小于3时，将无法产生足够的ACK来触发快重传而导致超时重传，超时是很严重的事情。</p><p>在只丢失一个数据包的情况下，<strong>NewReno</strong>和<strong>Reno</strong>的处理方法是一致的，而在同一个时间段丢失了多个包时，<strong>NewReno</strong>做出了改进。<br><strong>Reno</strong>快速恢复算法中，发送方只要收到一个新的ACK就会退出快速恢复状态而进入拥塞避免阶段，<strong>NewReno</strong>算法中，只有当所有丢失的包都重传并收到确认后才退出。</p><p>NewReno提出了PACK和RACK，在重传完成之前的ACK都是PACK，只有收到RACK之后才会结束快恢复</p><h4 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h4><p>Reno的衍生版本，允许使用SACK来告知接收端自己收到了哪些部分</p><p>但是对于肠肥管道而言，每次告知对方自己收到了哪些部分的代价是很大的，此时的SACK会消耗大量的资源</p><p><img src="IMG_1611.PNG" alt></p><h4 id="随机早期检测-RED-Random-Early-Detection"><a href="#随机早期检测-RED-Random-Early-Detection" class="headerlink" title="随机早期检测 RED Random Early Detection"></a>随机早期检测 RED Random Early Detection</h4><p>网络的主体部分是通信子网，上述算法都是从端系统的角度来考虑的，其实对拥塞影响最大的是路由器的丢弃算法。</p><p>RED将路由器的到达队列划分为了三个部分</p><p><img src="IMG_1612.PNG" alt></p><p>通常而言最大阈值是最小阈值的两倍，如果阈值设置不合适，RED也会引起类似于尾部丢弃导致的全局震荡</p><p>对于P丢弃，P并不是一个确定的值，而是会随着当前的<strong>平均队列长度</strong>不断变化</p><p>平均队列长度的计算</p><script type="math/tex; mode=display">newL_{AV} = (1 - \delta)  L_{AV} + \delta L</script><p>$L$表示当前队列长度的样本，$L_{AV}$是旧的平均队列长度，计算方式和RTO的计算很像，$\delta$ 是零到一之间的数。</p><h2 id="TCP的建立与释放"><a href="#TCP的建立与释放" class="headerlink" title="TCP的建立与释放"></a>TCP的建立与释放</h2><p>大名鼎鼎的三次握手</p><p><img src="IMG_1613.PNG" alt></p><p>TCP的连接实际上是一种<strong>虚连接</strong>，只是维护一些状态值而已</p><p>SYN=1的报文段不携带数据，但是要消耗掉一个序号，因为SYN报文段需要确认，而确认是需要序号的</p><p>ACK报文段可以携带数据（捎带确认），但是如果不携带数据，则不消耗序号，因为不需要对ACK进行确认</p><p>说白了序号就是为了确认，不需要确认就不用序号</p><p><img src="IMG_1617.PNG" alt></p><p>主动关闭一方发送的序号不是随机值,而是发送到这个值了</p><p>被动关闭放的ACK不消耗序号</p><p>此时TCP连接处于半关闭状态</p><p>在左侧发送完最后的确认之后进行一个$2 \times MSL$的计时,使用时间等待计时器 <font color="blue"> &lt;第三个计时器&gt; </font></p><p>MSL为最长报文段寿命</p><p>这个计时器是为了保证A发送的最后一个ACK能到达B,且这个连接持续时间中的所有报文段在网络中失效</p><p>为了防止TCP出现长时间的空闲,通常还有一个保活计时器 <font color="blue"> &lt;第四个计时器&gt;</font></p><p>超时之后每隔一段时间发送一个探测报文段,发送十个探测报文段还没有收到响应就假定客户除了故障,主动终止TCP连接</p><h2 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a>TCP 有限状态机</h2><p><img src="https://upload-images.jianshu.io/upload_images/2846604-6a8557619966204d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络中最难/复杂的部分&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（五）</title>
    <link href="http://ilern.github.io/2020/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/12/17/操作系统实验笔记（五）/</id>
    <published>2020-12-17T02:12:21.000Z</published>
    <updated>2020-12-30T08:52:16.374Z</updated>
    
    <content type="html"><![CDATA[<p>调了很久之后发现是<code>shmget()</code>写成了<code>semget()</code>导致共享内存段attach失败，但是Shell没给提示，一开始以为是死锁了各种检查信号量，最后gdb跑了一下发现是段错误了，顺便学习了怎样用gdb调试多进程并发的程序</p><a id="more"></a><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>用于同步和互斥</p><p>当信号量用于表示资源数量协助我们进行资源分配与回收时，不一定只在零一之间变动</p><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><p>创建信号量集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span></span><br></pre></td></tr></table></figure><p><code>semnum</code>是信号量的下标，<code>cmd</code>是操作的动作</p><p><code>cmd</code>使用<code>SETVALUE</code>设置某个信号量的值</p><p><code>cmd</code>使用<code>SETALL</code>设定一组信号量的值</p><p><code>NOWAIT</code>进行一个尝试，不阻塞</p><p><code>UNDO</code>意外退出没有V的时候会自动V，推荐使用</p><h2 id="并发时进程映像的替换"><a href="#并发时进程映像的替换" class="headerlink" title="并发时进程映像的替换"></a>并发时进程映像的替换</h2><p>exec函数族</p><p><code>execl(const char *path, const char *arg, ...)</code> 参数数量不确定</p><p><code>execv(const char *path, char *const argv[])</code></p><p>拿指定的静态的可执行文件，覆盖当前进程的进程映像中的代码和数据，除了PID以外全都换了</p><p>不创建新的进程</p><p>fork之前，父子进程需要共享的内存、信号量、管道，要打开</p><p><img src="IMG_5788.png" alt></p><h2 id="信号量与共享内存共用并使用信号量同步"><a href="#信号量与共享内存共用并使用信号量同步" class="headerlink" title="信号量与共享内存共用并使用信号量同步"></a>信号量与共享内存共用并使用信号量同步</h2><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>以随机间隔生成随机字母并完成大小写转换</p><p>三进程并发，进程1生成字母，进程2大小写转换，进程3输出转换结果，每生成一个随机字母流水线就动一圈</p><p>进程1和进程2之间用共享内存段<code>shm_1</code>通信，进程2和进程3之间用共享内存段<code>shm_2</code>通信</p><p>使用四个信号量分别实现两个共享内存段的互斥访问与访问同步</p><p><img src="IMG_5766.PNG" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem30.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semid, shm1_id, shm2_id, semkey, shm1_key, shm2_key;</span><br><span class="line">  <span class="keyword">int</span> p1, p2, p3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> semun arg;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm1_key = ftok(PATH_FOR_FTOK, <span class="string">'Y'</span>);</span><br><span class="line">  shm2_key = ftok(PATH_FOR_FTOK, <span class="string">'Z'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">4</span> ,IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">  shm1_id = shmget(shm1_key, SHM_SIZE, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">  shm2_id = shmget(shm2_key, SHM_SIZE, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  arg.<span class="built_in">array</span> = (<span class="keyword">unsigned</span> <span class="keyword">short</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span>) * <span class="number">4</span>);</span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//mutex</span></span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  arg.<span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//the second arg is ignored</span></span><br><span class="line">  semctl(semid, <span class="number">0</span>, SETALL, arg);</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      p3 = fork();</span><br><span class="line">      <span class="keyword">if</span> (p3) &#123;</span><br><span class="line">        waitpid(p1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        waitpid(p2, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        waitpid(p3, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        semctl(semid, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">        shmctl(shm1_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">        shmctl(shm2_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(arg.<span class="built_in">array</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//chlid3</span></span><br><span class="line">        execl(<span class="string">"./sem33"</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      execl(<span class="string">"./sem32"</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    execl(<span class="string">"./sem31"</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem31.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semkey, shm1_key, semid, shm1_id;</span><br><span class="line">  <span class="keyword">int</span> seed;</span><br><span class="line">  <span class="keyword">char</span> c, *shm1_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm1_key = ftok(PATH_FOR_FTOK, <span class="string">'Y'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm1_id = shmget(shm1_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line"></span><br><span class="line">  seed = getpid();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= atoi(argv[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      c = (<span class="keyword">char</span>)(rand_r(&amp;seed) % <span class="number">128</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">isalpha</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Random letter %c\n"</span>, c);</span><br><span class="line">  </span><br><span class="line">    P(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("sem31: P(sem0)\n");</span></span><br><span class="line">    shm1_addr = (<span class="keyword">char</span>*)shmat(shm1_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("%p\n", shm1_addr);</span></span><br><span class="line">    <span class="comment">// printf("sem31: ated\n");</span></span><br><span class="line">    <span class="comment">// printf("c = %c\n", c);</span></span><br><span class="line">    shm1_addr[<span class="number">0</span>] = c;</span><br><span class="line">    <span class="comment">// printf("sem31: done\n");</span></span><br><span class="line">    shmdt(shm1_addr);</span><br><span class="line">    <span class="comment">// printf("sem31: deted\n");</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// printf("sem31: try to V(sem0)\n");</span></span><br><span class="line">    V(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("sem31: V(sem0) try to V(sem1)\n");</span></span><br><span class="line">    V(semid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf("sem31: I will sleep\n");</span></span><br><span class="line">    sleep(rand_r(&amp;seed) % <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem32.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semkey, shm1_key, shm2_key, semid, shm1_id, shm2_id;</span><br><span class="line">  <span class="keyword">char</span> c, *shm1_addr = <span class="literal">NULL</span>, *shm2_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm1_key = ftok(PATH_FOR_FTOK, <span class="string">'Y'</span>);</span><br><span class="line">  shm2_key = ftok(PATH_FOR_FTOK, <span class="string">'Z'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm1_id = shmget(shm1_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm2_id = shmget(shm2_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= atoi(argv[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    <span class="comment">// printf("sem2: try to P(sem1)\n\twaiting\n");</span></span><br><span class="line">    P(semid, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf("sem2: try to P(sem0)\n");</span></span><br><span class="line">    P(semid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    shm1_addr = (<span class="keyword">char</span>*)shmat(shm1_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    c = shm1_addr[<span class="number">0</span>];</span><br><span class="line">    shmdt(shm1_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read c = %c\n"</span>, c);</span><br><span class="line">    V(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf("sem2: V(sem0)\n");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    <span class="keyword">else</span> c = <span class="built_in">tolower</span>(c);</span><br><span class="line"></span><br><span class="line">    P(semid, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    shm2_addr = (<span class="keyword">char</span>*)shmat(shm2_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    shm2_addr[<span class="number">0</span>] = c;</span><br><span class="line">    shmdt(shm2_addr);</span><br><span class="line"></span><br><span class="line">    V(semid, <span class="number">2</span>);</span><br><span class="line">    V(semid, <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem33.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> semkey, shm2_key, semid, shm2_id;</span><br><span class="line">  <span class="keyword">char</span> c, *shm2_addr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  semkey = ftok(PATH_FOR_FTOK, <span class="string">'X'</span>);</span><br><span class="line">  shm2_key = ftok(PATH_FOR_FTOK, <span class="string">'Z'</span>);</span><br><span class="line"></span><br><span class="line">  semid = semget(semkey, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line">  shm2_id = shmget(shm2_key, <span class="number">0</span>, IPC_EXCL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= atoi(argv[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    P(semid, <span class="number">3</span>);</span><br><span class="line">    P(semid, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    shm2_addr = (<span class="keyword">char</span>*)shmat(shm2_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    c = shm2_addr[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After transform %c\n"</span>, c);</span><br><span class="line">    shmdt(shm2_addr);</span><br><span class="line"></span><br><span class="line">    V(semid, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是信号量的使用，四个信号量分别为</p><div class="table-container"><table><thead><tr><th>信号量</th><th>初始值</th><th>用途</th></tr></thead><tbody><tr><td>sem0</td><td>1</td><td>互斥 shm_1</td></tr><tr><td>sem1</td><td>0</td><td>同步进程1进程2</td></tr><tr><td>sem2</td><td>1</td><td>互斥 shm_2</td></tr><tr><td>sem3</td><td>0</td><td>同步进程2进程3</td></tr></tbody></table></div><p>进程1需要先获得<code>shm_1</code>的互斥访问权，等待信号量<code>sem0</code>，将生成的随机字母写入<code>shm_1</code>，然后释放信号量<code>sem0</code></p><p>进程2必须在进程1之后进行，因此进程2应当先等待信号量<code>sem1</code>，进程1在结束后会<code>signal(sem1)</code>唤醒进程2；被唤醒之后进程2取得对<code>shm_1</code>的互斥访问权，读取字母并进行大小写转换，然后释放<code>sem0</code>；接下来进程2取得对<code>shm_2</code>的互斥访问权，把转换后的结果写入<code>shm_2</code>，释放信号量<code>sem1</code></p><p>进程3必须在进程2之后进行，因此进程2应当先等待信号量<code>sem3</code>，进程2在结束后会<code>signal(sem3)</code>唤醒进程3；被唤醒之后进程3取得对<code>shm_2</code>的互斥访问权，读取字母并进行大小写转换，然后释放<code>sem2</code>；</p><p>P操作为wait，V操作为signal，两个操作写在单独的文件里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sem3pv.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sops</span> = &#123;</span>semnum, <span class="number">-1</span>, SEM_UNDO&#125;;</span><br><span class="line">  <span class="keyword">return</span> semop(semid, &amp;sops, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sops</span> = &#123;</span>semnum, +<span class="number">1</span>, SEM_UNDO&#125;;</span><br><span class="line">  <span class="keyword">return</span> semop(semid, &amp;sops, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个作业分为五个c文件和一个头文件</p><p><img src="IMG_5777.png" alt></p><p>使用makefile进行自动化编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: sem31 sem32 sem33 sem30</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"></span><br><span class="line"><span class="section">sem31: sem31.c sem3pv.o sem3.h</span></span><br><span class="line">gcc -c sem31.c</span><br><span class="line">gcc -o sem31 sem31.o sem3pv.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem32: sem32.c sem3pv.o sem3.h</span></span><br><span class="line">gcc -c sem32.c</span><br><span class="line">gcc -o sem32 sem32.o sem3pv.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem33: sem33.c sem3pv.o sem3.h</span></span><br><span class="line">gcc -c sem33.c</span><br><span class="line">gcc -o sem33 sem33.o sem3pv.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem30: sem30.c sem3.h</span></span><br><span class="line">gcc -c sem30.c</span><br><span class="line">gcc -o sem30 sem30.o -g</span><br><span class="line"></span><br><span class="line"><span class="section">sem3pv.o: sem3pv.c</span></span><br><span class="line">gcc -c sem3pv.c -g</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调了很久之后发现是&lt;code&gt;shmget()&lt;/code&gt;写成了&lt;code&gt;semget()&lt;/code&gt;导致共享内存段attach失败，但是Shell没给提示，一开始以为是死锁了各种检查信号量，最后gdb跑了一下发现是段错误了，顺便学习了怎样用gdb调试多进程并发的程序&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（四）</title>
    <link href="http://ilern.github.io/2020/12/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/12/10/操作系统实验笔记（四）/</id>
    <published>2020-12-10T02:10:48.000Z</published>
    <updated>2020-12-30T08:53:27.427Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列通信。消息队列还是经常能听到的一个东西，比如弹幕系统实际上就是一个MQ</p><a id="more"></a><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>本质是一个128个元素的指针数组</p><p>同一条消息只能被摘一次</p><p>挂 消息块</p><p>摘 消息块</p><p>摘没有的消息块会阻塞</p><p>当有期待的消息块被挂上去，被唤醒，摘下来</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg_c.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">  msgget(key, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和共享内存块相似，需要先获取一个<code>key</code>，使用一个系统文件和一个字符进行拼接</p><p><code>IPC_CREAT | 0600</code> 表示创建的消息队列拥有者可读写，其他人不可读写执行</p><p><code>IPC_CREAR | 0666</code> 表示创建的消息队列所有人均可读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg_s.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100 <span class="comment">//size of msg</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype; <span class="comment">//消息编号 &gt; 0</span></span><br><span class="line">  <span class="keyword">char</span> text[SIZE]; <span class="comment">//消息内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key, msqid, i;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line">  </span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line">  msqid = msgget(key, IPC_EXCL);</span><br><span class="line">  </span><br><span class="line">  msg.mtype = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(msg.text, argv[<span class="number">2</span>]);</span><br><span class="line">  msgsnd(msqid, &amp;msg, SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂消息到消息队列需要把消息进行封装，就是代码中的<code>msgbuf</code></p><p>先获取消息队列，<code>msgget(key_t key, int msgflg)</code>，<code>IPC_EXCL</code>表示获取一个已经存在的消息队列</p><p>挂消息到消息队列，<code>msgsnd(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)</code>，把<code>msg</code>的地址传进去，本质是往指针数组中增加一个元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg_r.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype;</span><br><span class="line">  <span class="keyword">char</span> text[SIZE]; <span class="comment">//size of msg</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p, key, msqid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line">  msqid = msgget(key, IPC_EXCL);</span><br><span class="line"></span><br><span class="line">  msgrcv(msqid, &amp;msg, SIZE, atoi(argv[<span class="number">1</span>]), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg.text);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> msqid, key;</span><br><span class="line">  </span><br><span class="line">  key = ftok(<span class="string">"/boot"</span>, <span class="string">'a'</span>);</span><br><span class="line">  msqid = msgget(key, IPC_EXCL);</span><br><span class="line">  msgctl(msqid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除消息队列，先获取然后调用<code>msgctl(int msqid, int cmd, msqid_ds *buf)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列通信。消息队列还是经常能听到的一个东西，比如弹幕系统实际上就是一个MQ&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（三）</title>
    <link href="http://ilern.github.io/2020/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/12/03/操作系统实验笔记（三）/</id>
    <published>2020-12-03T02:45:26.000Z</published>
    <updated>2020-12-30T09:04:56.661Z</updated>
    
    <content type="html"><![CDATA[<p>管道通信是有局限的，共享内存段和消息队列提供了更灵活的进程间通信方式<br>不过非要说最灵活可能还是用socket</p><a id="more"></a><h1 id="共享内存通信与消息队列通信"><a href="#共享内存通信与消息队列通信" class="headerlink" title="共享内存通信与消息队列通信"></a>共享内存通信与消息队列通信</h1><h2 id="使用管道进行通信的局限"><a href="#使用管道进行通信的局限" class="headerlink" title="使用管道进行通信的局限"></a>使用管道进行通信的局限</h2><p>只能在有家族关系的进程间进行通信</p><p>大小只有4K，不好传输过大的</p><p>Socket一般用于用户进程间的通信</p><p>IP+端口可以唯一定位一台主机上的一个进程，把IP设定为127.0.0.1，可以实现本机间的两个进程通信</p><p>IPC一般用于系统间的通信</p><p>信号量使用集合的方式进行管理，Semaphores Set</p><p>共享内存 Shared Memory Segment</p><p>消息队列 Message Queue</p><p>管道由操作系统进行管理</p><p>IPC需要自己手工管理</p><h2 id="用到的函数"><a href="#用到的函数" class="headerlink" title="用到的函数"></a>用到的函数</h2><p><code>int shmget(key_t key, size_t size, int shmflg);</code></p><p>创建一个新的共享内存段 / 关联已有的共享内存段，返回一个共享内存段的ID</p><p><code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></p><p>获得共享内存段的地址，通常和脱离配合使用。</p><p><code>int shmdt(const void *shmaddr);</code> </p><p>脱离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。</p><p><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</code> </p><p>操作共享内存段，如果要进行更细致的操作需要用到，在实验中用来删除共享内存段，<code>cmd</code>设定为<code>IPC_RMID</code></p><p>写是覆盖写，读是多次读。</p><p>读多少次都不会影响数据的存在，用于进程间的一对多通信，多个进程先后去读结果是一样的。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>在创建共享内存段时，可以指明共享内存段的权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shmget(shm_key, SHM_SIZE, IPC_CREAT | <span class="number">0600</span>)</span><br></pre></td></tr></table></figure><p>在<code>flag</code>后面或上一个八进制数，这里的数字含义和<code>chomd</code>的数字含义相同，例如<code>0600</code>代表创建者可读可写</p><h2 id="生成Key"><a href="#生成Key" class="headerlink" title="生成Key"></a>生成Key</h2><p>操作系统中唯一标识共享内存段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br></pre></td></tr></table></figure><p><code>ftok()</code>使用一个路径和一个项目编号来生成一个唯一的 system V 进程间通信的 key</p><p>通常情况下<code>pathname</code>选择一个所有Linux都有的路径，比如<code>/boot</code>，<code>proj_id</code>因为只会用到低8位，通常选择一个字符常量</p><p>对于同样的参数会得到同样的key</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY 3456</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *shm_addr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//0600 only for this user's process</span></span><br><span class="line">  <span class="comment">//0666 for all process</span></span><br><span class="line">  <span class="keyword">int</span> shm_id;</span><br><span class="line">  shm_id = shmget(KEY, SIZE, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> p;</span><br><span class="line">  p = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    shm_addr = (<span class="keyword">char</span>*)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, shm_addr);</span><br><span class="line">    shmdt(shm_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//control</span></span><br><span class="line">    <span class="comment">//destroy the shared memory segment</span></span><br><span class="line">    shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//chlid</span></span><br><span class="line">    <span class="comment">//get the address of shared memory segment</span></span><br><span class="line">    <span class="comment">//shmat()</span></span><br><span class="line">    shm_addr = (<span class="keyword">char</span>*)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(shm_addr, <span class="string">"This is a message"</span>);</span><br><span class="line">    shmdt(shm_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建一个多进程并发的环境，实现共享内存段通信</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管道通信是有局限的，共享内存段和消息队列提供了更灵活的进程间通信方式&lt;br&gt;不过非要说最灵活可能还是用socket&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（二）</title>
    <link href="http://ilern.github.io/2020/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/11/26/操作系统实验笔记（二）/</id>
    <published>2020-11-26T02:24:17.000Z</published>
    <updated>2020-12-13T15:20:34.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>中断被封装成信号，多个不同的中断被封装成一个信号。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">层次</th><th style="text-align:center">称呼</th></tr></thead><tbody><tr><td style="text-align:center">硬件层次</td><td style="text-align:center">中断</td></tr><tr><td style="text-align:center">操作系统层次</td><td style="text-align:center">信号</td></tr><tr><td style="text-align:center">应用程序层次</td><td style="text-align:center">事件</td></tr></tbody></table></div><p>信号可以用编号、名称表示，名称是编号的宏。</p><p><img src="1.png" alt></p><h2 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h2><p>过滤信号，每个进程都有对signal的mask，滤掉的就忽略，没有滤掉的就响应</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h2><p><img src="2.png" alt></p><p>返回信号处理程序的入口指针，<code>signal()</code>根据编号设置信号处理程序</p><p><img src="3.JPG" alt></p><p>实际是修改进程PCB中的信号表中的函数指针</p><p><img src="3.png" alt></p><p>注意唤醒的时刻，4和alarm有一秒停顿，alarm和5没有间隔，说明收到信号之后进程被立即唤醒</p><p>信号什么时候到来和<code>signal()</code>没有关系</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h2><p>给某个进程发信号</p><p><img src="4.png" alt></p><p><img src="5.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure><p>发9号信号给进程，表示终止进程，不能被拦截或忽略</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><p>杀死自己，返回0</p><h2 id="进程软中断通信"><a href="#进程软中断通信" class="headerlink" title="进程软中断通信"></a>进程软中断通信</h2><p>信号是传送给进程的一种事件通知，Linux 系统中所有信号均定义在头文件 中。 </p><p>信号发生时，Linux 内核可以采取下面 3 种动作之一：</p><ul><li><p>忽略信号 大部分信号可以被忽略，除 SIGSTOP 信号和 SIGKILL 例外； </p></li><li><p>捕获信号 指定动作；</p></li><li><p>信号默认动作起作用。</p></li></ul><p>编写程序，使用系统调用 <code>fork()</code>创建两个子进程，再用系统调用 <code>signal()</code>让父进程捕捉键盘上发出的中断信号(即按 ctrl+c 或是 ctrl+\键)，5 秒钟内若父进程未接收到这两个软中断的某一个，则父进程用系统调用 <code>kill()</code>向两个子进程分别发送软中断信号 <code>SIGUSR1</code> 和 <code>SIGUSR2</code>，子进程获得对应的软中断信号，然后分别输出下列信息后终止： <code>Child process (pid=?) be killed</code>！ 21<code>Child process (pid=?) be killed！</code> 父进程调用<code>wait()</code>等待两个子进程终止后，输出以下信息，结束进程执行： <code>Parent process (pid=?) finished！</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent_stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Parent process (pid = %d) be killed (get SIGINT / SIGQUIT)\n"</span>, getpid());</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Chlid process (pid = %d) be killed\n"</span>, getpid());</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">      signal(SIGINT, parent_stop);</span><br><span class="line">      signal(SIGQUIT, parent_stop);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is Parent process, pid = %d\n"</span>, getpid());</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"parent sleep\n"</span>);</span><br><span class="line">      sleep(<span class="number">3</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"parent get up\n"</span>);</span><br><span class="line"></span><br><span class="line">      kill(p1, SIGUSR1);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"kill p1\n"</span>);</span><br><span class="line">      kill(p2, SIGUSR2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"kill p2\n"</span>);</span><br><span class="line"></span><br><span class="line">      waitpid(p1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      waitpid(p2, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Parent process %d terminated\n"</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is chlid process 2, pid = %d\n"</span>, getpid());</span><br><span class="line">      </span><br><span class="line">      signal(SIGUSR1, child_stop);</span><br><span class="line">      signal(SIGUSR2, child_stop);</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child2 sleep\n"</span>);</span><br><span class="line">      sleep(<span class="number">6</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child2 get up\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is child process 1, pid = %d\n"</span>, getpid());</span><br><span class="line">    </span><br><span class="line">    signal(SIGUSR1, child_stop);</span><br><span class="line">    signal(SIGUSR2, child_stop); </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1 sleep\n"</span>);</span><br><span class="line">    sleep(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child1 get up\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h1&gt;&lt;p&gt;中断被封装成信号，多个不同的中断被封装成一个信号。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据清洗中空格的处理</title>
    <link href="http://ilern.github.io/2020/11/18/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%AD%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://ilern.github.io/2020/11/18/数据清洗中空格的处理/</id>
    <published>2020-11-18T03:26:32.000Z</published>
    <updated>2020-11-18T03:53:46.779Z</updated>
    
    <content type="html"><![CDATA[<p><code>pandas</code>中使用<code>fillna()</code>或者<code>drop()</code>来填充或丢弃包含空值的行和列，但是<code>pandas</code>只认为<code>numpy.nan</code>是空值，实际情况里可能使用空格等空字符来代表空值，这时需要一些特殊处理</p><a id="more"></a><p>原始数据中存在空格</p><p><img src="1.png" alt="1"></p><p><code>df</code>是一个<code>DataFrame</code>，以<code>DataFrame</code>中的列名为索引可以得到一个<code>Series</code>，其中有一个<code>apply</code>方法可以修改其中的值</p><p><code>apply</code>方法为一个高阶函数，接受一个函数<code>func</code>为参数，对<code>Series</code>中的每个元素调用<code>func</code></p><blockquote><p>“””<br>Invoke function on values of Series.</p><p>Can be ufunc (a NumPy function that applies to the entire Series)<br>or a Python function that only works on single values.</p><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>func : function<br>   Python function or NumPy ufunc to apply.<br>convert_dtype : bool, default True<br>   Try to find better dtype for elementwise function results. If<br>   False, leave as dtype=object.<br>args : tuple<br>   Positional arguments passed to func after the series value.<br>**kwds<br>   Additional keyword arguments passed to func.</p><h2 id="Returns"><a href="#Returns" class="headerlink" title="Returns"></a>Returns</h2><p>Series or DataFrame<br>   If func returns a Series object the result will be a DataFrame.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><p>Series.map: For element-wise operations.<br>Series.agg: Only perform aggregating type operations.<br>Series.transform: Only perform transforming type operations.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Create a series with typical summer temperatures for each city.</p><blockquote><blockquote><blockquote><p>s = pd.Series([20, 21, 12],<br>…               index=[‘London’, ‘New York’, ‘Helsinki’])<br>s<br>London      20<br>New York    21<br>Helsinki    12<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Square the values by defining a function and passing it as an<br>argument to <code>apply()</code>.</p><blockquote><blockquote><blockquote><p>def square(x):<br>…     return x ** 2<br>s.apply(square)<br>London      400<br>New York    441<br>Helsinki    144<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Square the values by passing an anonymous function as an<br>argument to <code>apply()</code>.</p><blockquote><blockquote><blockquote><p>s.apply(lambda x: x ** 2)<br>London      400<br>New York    441<br>Helsinki    144<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Define a custom function that needs additional positional<br>arguments and pass these additional arguments using the<br><code>args</code> keyword.</p><blockquote><blockquote><blockquote><p>def subtract_custom_value(x, custom_value):<br>…     return x - custom_value</p><p>s.apply(subtract_custom_value, args=(5,))<br>London      15<br>New York    16<br>Helsinki     7<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Define a custom function that takes keyword arguments<br>and pass these arguments to <code>apply</code>.</p><blockquote><blockquote><blockquote><p>def add_custom_values(x, **kwargs):<br>…     for month in kwargs:<br>…         x += kwargs[month]<br>…     return x</p><p>s.apply(add_custom_values, june=30, july=20, august=25)<br>London      95<br>New York    96<br>Helsinki    87<br>dtype: int64</p></blockquote></blockquote></blockquote><p>Use a function from the Numpy library.</p><blockquote><blockquote><blockquote><p>s.apply(np.log)<br>London      2.995732<br>New York    3.044522<br>Helsinki    2.484907<br>dtype: float64<br>“””</p></blockquote></blockquote></blockquote></blockquote><p>了解了<code>apply()</code>函数之后，就可以替换原先的空格为<code>np.nan</code>了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'./newFile.csv'</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># none_score = (df['成绩'].isnull()) | (df['成绩'].apply(lambda x: str(x).isspace()))</span></span><br><span class="line"><span class="comment"># df_null = df[none_score]</span></span><br><span class="line"><span class="comment"># print(df_null)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># df_not_null = df[~none_score]</span></span><br><span class="line"><span class="comment"># data1 = df_not_null</span></span><br><span class="line"><span class="comment"># data1.to_csv('./cleaned_newFile.csv', encoding='utf-8_sig', index=None)</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">'成绩'</span>] = df[<span class="string">'成绩'</span>].apply(<span class="keyword">lambda</span> x: np.nan <span class="keyword">if</span> str(x).isspace() <span class="keyword">else</span> x)</span><br><span class="line">df = df.fillna(<span class="number">0</span>)</span><br><span class="line">df.to_csv(<span class="string">'./cleaned_newFile.csv'</span>, encoding=<span class="string">'utf-8_sig'</span>, index=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure></p><p>清洗之后，原本的空值被替换成了0</p><p><img src="2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;pandas&lt;/code&gt;中使用&lt;code&gt;fillna()&lt;/code&gt;或者&lt;code&gt;drop()&lt;/code&gt;来填充或丢弃包含空值的行和列，但是&lt;code&gt;pandas&lt;/code&gt;只认为&lt;code&gt;numpy.nan&lt;/code&gt;是空值，实际情况里可能使用空格等空字符来代表空值，这时需要一些特殊处理&lt;/p&gt;
    
    </summary>
    
      <category term="数据挖掘" scheme="http://ilern.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="数据清洗" scheme="http://ilern.github.io/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验笔记（一）</title>
    <link href="http://ilern.github.io/2020/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/11/12/操作系统实验笔记（一）/</id>
    <published>2020-11-12T02:07:47.000Z</published>
    <updated>2020-11-26T02:17:50.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h2><p>创建子进程，继承父进程<code>fork()</code>之后的的指令序列，复制父进程的数据部分</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p, x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">      x = <span class="number">200</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is parent, x = %d\n"</span>, x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = <span class="number">300</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is child, x = %d\n"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过汇编语言可以很容易理解<code>fork()</code>具有两个返回值的事情，<code>p = fork()</code>是两条指令，而子进程会执行函数调用<code>call fork</code>之后的所有指令，这样子进程和父进程的<code>p</code>就是不一样的。</p><p>当创建失败时<code>fork()</code>会返回<code>-1</code>，为了鲁棒性应该判断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span><span class="string">"test1.c"</span></span><br><span class="line"><span class="meta">.section</span>.rodata</span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"Hello world"</span></span><br><span class="line"><span class="symbol">.LC1:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is parent, x = %d\n"</span></span><br><span class="line"><span class="symbol">.LC2:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is child, x = %d\n"</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span>main</span><br><span class="line"><span class="meta">.type</span>main, @function</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line">leal<span class="number">4</span>(%esp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">andl$-<span class="number">16</span>, %esp</span><br><span class="line">pushl-<span class="number">4</span>(%ecx)</span><br><span class="line">pushl%ebp</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0x10</span>,<span class="number">0x5</span>,<span class="number">0x2</span>,<span class="number">0x75</span>,<span class="number">0</span></span><br><span class="line">movl%esp, %ebp</span><br><span class="line">pushl%ecx</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0xf</span>,<span class="number">0x3</span>,<span class="number">0x75</span>,<span class="number">0x7c</span>,<span class="number">0x6</span></span><br><span class="line">subl<span class="number">$20</span>, %esp</span><br><span class="line">movl<span class="number">$100</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$12</span>, %esp</span><br><span class="line">pushl$.LC0</span><br><span class="line"><span class="keyword">call</span>puts</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span>fork</span><br><span class="line"></span><br><span class="line"><span class="comment">;子进程会执行的部分</span></span><br><span class="line">movl%eax, -<span class="number">12</span>(%ebp)</span><br><span class="line">cmpl<span class="number">$0</span>, -<span class="number">12</span>(%ebp)</span><br><span class="line"><span class="keyword">je</span>.L2</span><br><span class="line">movl<span class="number">$200</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC1</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="keyword">jmp</span>.L3</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">movl<span class="number">$300</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC2</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">movl<span class="number">$0</span>, %eax</span><br><span class="line">movl-<span class="number">4</span>(%ebp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="meta">.cfi_restore</span> <span class="number">5</span></span><br><span class="line">leal-<span class="number">4</span>(%ecx), %esp</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">.size</span>main, .-main</span><br><span class="line"><span class="meta">.ident</span><span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line"><span class="meta">.section</span>.note.GNU-stack,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>下面的代码会构成怎样的进程树？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br></pre></td></tr></table></figure><h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid()"></a>getpid()</h2><p>获得当前进程的进程号</p><p><code>getppid()</code>获得父进程的进程号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//running to blocked</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is parent, my pid = %d, my child = %d\n"</span>, getpid(), p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is child, my pid = %d, my parent = %d\n"</span>, getpid(), getppid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>发现子进程的父进程编号不对，这是因为在执行子进程之前父进程已经执行结束，此时子进程称为孤儿进程<strong>Orphan Process</strong>，父进程被设置成了1305号进程</p><p><img src="4.png" alt="4"></p><p>查看所有进程发现1305号为upstart进程，用于接管孤儿进程</p><p>但是维基百科上说孤儿进程会被<code>init</code>进程或者<code>systemd</code>进程接管</p><p>想要父进程不那么快结束，可以使用<code>sleep(1)</code>让父进程进入阻塞状态一秒钟</p><p><img src="5.png" alt="5"></p><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><ul><li><p>框架的搭建</p></li><li><p>分别完成两个进程的功能</p></li><li><p>互斥和同步</p></li></ul><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line">  p1 = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print from parent process: %d\n"</span>, i);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line">      <span class="keyword">char</span> ch2 = <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">while</span> (ch2 &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"print from Child process 2: %c\n"</span>, ch2);</span><br><span class="line">        ch2++;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    <span class="keyword">char</span> ch1 = <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch1 &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print from Child process 1: %c\n"</span>, ch1);</span><br><span class="line">      ch1++;</span><br><span class="line"></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲区长度为一行，\n表示一行结束，会刷新缓冲区</p><p><code>fflush()</code> 刷新缓冲区</p><p>普通进程只往缓冲区写数据，往屏幕写数据是操作系统的事情</p><p>多个进程的缓冲区共用</p><h3 id="两个进程并发的执行情况"><a href="#两个进程并发的执行情况" class="headerlink" title="两个进程并发的执行情况"></a>两个进程并发的执行情况</h3><p><img src="6.png" alt="6"></p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br></pre></td></tr></table></figure><p>父进程一旦调用了<code>wait()</code>就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，<code>wait()</code>就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，<code>wait()</code>就会一直阻塞在这里，直到有一个出现为止。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>对于一个进程，当其进行结束时，进入<strong>终止状态</strong>，此时操作系统的进程表中还留有子进程的PCB。</p><p><img src="7.PNG" alt></p><p>如果此时父进程没有<code>wait()</code>，PCB将会保留，会导致资源泄露。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_pair</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> fd[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct fd_pair <span class="title">pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//on other architectures</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span> <span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><code>fd</code>参数会被设置成两个文件描述符，<code>f[0]</code>表示读，<code>f[1]</code>表示写</p><p><code>pipe</code>会自动保持同步</p><p>管道面向字节流</p><p>管道只允许单向通信（单工？</p><h3 id="使用管道进行进程间通信"><a href="#使用管道进行进程间通信" class="headerlink" title="使用管道进行进程间通信"></a>使用管道进行进程间通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> p1, p2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">  pipe(fd1);</span><br><span class="line"></span><br><span class="line">  p1 = fork();</span><br><span class="line">  <span class="keyword">if</span> (p1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"fork Error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2[<span class="number">2</span>];</span><br><span class="line">    pipe(fd2);</span><br><span class="line"></span><br><span class="line">    p2 = fork();</span><br><span class="line">    <span class="keyword">if</span> (p2) &#123;</span><br><span class="line">      <span class="comment">//parent</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      <span class="keyword">while</span> (read(fd1[<span class="number">0</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent: got data from child1\n"</span>);</span><br><span class="line">        write(fd2[<span class="number">1</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent: sent data to child2\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//child2</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      <span class="keyword">while</span> (read(fd2[<span class="number">0</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child2: Got the char, print to the screen\n"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch)) ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">        <span class="keyword">else</span> ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//putchar(ch);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child2: Done\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf("child1: Waiting for input: \n");</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> ch = getchar();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child1: Got the char '%c', sent to the parent process\n"</span>, ch);</span><br><span class="line">        write(fd1[<span class="number">1</span>], &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isspace</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"char %c, ascii code %d is invaild\n"</span>, ch, ch);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//printf("child1: Waiting for input: \n");</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三进程并发，父进程拥有两个管道，子进程一负责从键盘读取输入，通过管道1发送给父进程，父进程通过管道2把输入发送给子进程2，子进程2进行大小写转换并输出。</p><p>子进程一进行输入过滤，不符合条件的输入会被忽略。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;h2 id=&quot;fork（）&quot;&gt;&lt;a href=&quot;#fork（）&quot; class=&quot;headerlink&quot; title=&quot;fork（）&quot;&gt;&lt;/a&gt;fork（）&lt;/h2&gt;&lt;p&gt;创建子进程，继承父进程&lt;code&gt;fork()&lt;/code&gt;之后的的指令序列，复制父进程的数据部分&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-内存管理</title>
    <link href="http://ilern.github.io/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"/>
    <id>http://ilern.github.io/2020/11/11/操作系统学习笔记-内存管理策略/</id>
    <published>2020-11-11T13:28:50.000Z</published>
    <updated>2020-12-27T02:46:10.970Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://ilern.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-网络层</title>
    <link href="http://ilern.github.io/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/11/08/计算机网络复习笔记-网络层/</id>
    <published>2020-11-08T08:52:16.000Z</published>
    <updated>2020-12-21T06:44:40.400Z</updated>
    
    <content type="html"><![CDATA[<p>内容贼多</p><a id="more"></a><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>网络层向运输层提供服务</li><li>网络保证可靠 or 端系统保证可靠</li></ul><h3 id="网络负责可靠交互"><a href="#网络负责可靠交互" class="headerlink" title="网络负责可靠交互"></a>网络负责可靠交互</h3><ul><li>虚电路<ul><li>和电路交换类似，都需要建立连接，有电路交换的特点</li><li>但是电路交换具有排他性，虚电路没有，所以称为<strong>虚</strong>电路</li></ul></li><li>虚电路建立<strong>逻辑上</strong>的连接，分组沿着逻辑上的连接进行分组转发</li></ul><h3 id="网络负责最大努力交互"><a href="#网络负责最大努力交互" class="headerlink" title="网络负责最大努力交互"></a>网络负责最大努力交互</h3><ul><li><p>因特网真正的设计思路</p></li><li><p>不提供服务质量的承诺，只进行最大努力、无连接的<strong>数据报服务</strong></p><ul><li><p>可能出错、丢失、重复、失序</p></li><li><p>出错由ICMP解决</p></li></ul></li></ul><h4 id="尽最大努力交付的好处"><a href="#尽最大努力交付的好处" class="headerlink" title="尽最大努力交付的好处"></a>尽最大努力交付的好处</h4><ul><li>路由器可以比较简单，价格低廉</li><li>运输层负责差错处理、流量控制</li><li>网络的造假大大降低，运行方式灵活，能适用多种应用</li></ul><h3 id="虚电路与数据报的对比"><a href="#虚电路与数据报的对比" class="headerlink" title="虚电路与数据报的对比"></a>虚电路与数据报的对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚电路</th><th style="text-align:center">数据报</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">网络保证可靠通信</td><td style="text-align:center">端系统保证可靠通信</td></tr><tr><td style="text-align:center">连接</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">只有建立连接时使用</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发</td><td style="text-align:center">同一条虚电路的分组按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当节点故障时</td><td style="text-align:center">所有通过故障接待您的虚电路均不能工作</td><td style="text-align:center">出故障的节点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按照顺序到达终点</td><td style="text-align:center">到达顺序不一定按照发送顺序</td></tr><tr><td style="text-align:center">差错处理 / 流量控制</td><td style="text-align:center">可以由网络负责， 也可以由主机负责</td><td style="text-align:center">主机负责</td></tr></tbody></table></div><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="配套使用的三个协议"><a href="#配套使用的三个协议" class="headerlink" title="配套使用的三个协议"></a>配套使用的三个协议</h3><ul><li>地址解析协议 ARP<ul><li>Address Reesolution Protocol</li><li>IP地址转换为MAC地址</li><li>IP协议族的较下层</li></ul></li><li>网际控制报文协议 ICMP<ul><li>Internet Control Message Protocol</li><li>控制信息</li><li>IP协议族的较上层</li></ul></li><li>忘记组管理协议 IGMP<ul><li>Internet Group Management Protocol</li><li>实现多播/组播</li><li>IP协议族的较上层</li></ul></li></ul><h3 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h3><ul><li>扩展<ul><li>转发器 物理层</li><li>网桥 数据链路层</li></ul></li><li>互联<ul><li>路由器 网络层</li><li>桥路器 网桥+ 路由器</li><li>网关 网络层以上</li></ul></li></ul><h3 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h3><p>又称逻辑互联网络，当互联网上的主机进行通信时，好像在一个网络上通信一样，虽然不同物理网络的异构性客观存在，但是被屏蔽掉了，对于用户而言，只能看到像在同一个网络上通信而看不到异构细节。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>32位二进制，四个点分十进制数，每个数取值在0 - 255</li><li>定义为 网络号+主机号</li><li>8位一组</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>A类<ul><li>第一位一定是0，前8位（一个字节）表示网络号，后24位表示主机号（三个字节）</li><li>一个网络中主机数最多有$2^{24} - 2 = 16777214$</li><li>最大网络数$2^7 - 2 = 126$<ul><li>全零作为保留地址，意为本网络，不能指派</li><li>全一作为环回测试地址，不能指派</li></ul></li><li>前8位 1 - 127</li></ul></li><li>B类<ul><li>前两位一定是10，前16位（两个字节）表示网络号，后16位表示主机号（两个字节）</li><li>一个网络中主机数最多有$2^{16} - 2 = 65534$</li><li>最大网络数$2 ^ {14} = 16384$<ul><li>最小网络号为 128.0</li><li>二进制为 1000 0000 . 0000 0000</li></ul></li><li>前8位 128 - 191</li></ul></li><li>C类<ul><li>前三位一定是110，前24位（三个字节）表示网络号，后8位表示主机号（一个字节)</li><li>一个网络中主机数最多有$2^{8} - 2= 254$</li><li>最大网络数$2 ^ {21} = 2097152$<ul><li>最小网络号为 192.0.0</li><li>二进制为 1100 0000 . 0000 0000 . 0000 0000</li></ul></li><li>前8位 192 - 223</li></ul></li><li>D类<ul><li>前四位一定是1110，用于多播地址</li><li>前8位 224 - 239</li></ul></li><li>E类<ul><li>前四位为1111，留作以后使用</li><li>前8位 240 - 255</li></ul></li></ul><p><img src="IMG_1551.PNG" alt="IMG-1551"></p><h4 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h4><p><img src="IMG_1552.PNG" alt="IMG-1552"></p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">用作源地址</th><th style="text-align:center">用作目的地址</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">可</td><td style="text-align:center">不n可</td><td style="text-align:center">本网络的本主机，相当于临时牌照，申请IP地址时使用</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">host-id</td><td style="text-align:center">可</td><td style="text-align:center">不可</td><td style="text-align:center">本网络的某台主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">只在本网络进行广播，所有路由器不进行转发</td></tr><tr><td style="text-align:center">net-id</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">网络外成员对net-id中的的所有成员进行广播</td></tr><tr><td style="text-align:center">127（0111 1111）</td><td style="text-align:center">非全零全一</td><td style="text-align:center">可</td><td style="text-align:center">可</td><td style="text-align:center">本地软件环回测试</td></tr></tbody></table></div><h4 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h4><p>10.0.0.0 ———— 10.255.255.255</p><p>(0000 1010 . 0000 0000 . 0000 0000 . 0000 0000 —— 0000 1010 . 1111 1111 . 1111 1111 . 1111 1111)</p><p>172.16.0.0 ———— 172.131.255.255</p><p>(1010 1100 . 0001 0000 . 0000 0000 . 0000 0000 —— 1010 1100 . 1000 0011 . 1111 1111 . 1111 1111)</p><p>192.168.0.0 ———— 192.168.255.255</p><p>(1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 —— 1100 0000 . 1010 1000 . 1111 1111 . 1111 1111)</p><h4 id="重要特点"><a href="#重要特点" class="headerlink" title="重要特点"></a>重要特点</h4><ul><li>分等级<ul><li>IP地址管理机构分配IP只分配网络号，主机号由网络号管理单位自行分配</li><li>路由器仅仅根据目的主机所连接的网络号来转发分组</li><li>这样就可以大大减少路由表的大小</li><li>找到了网络，再找主机就很容易了</li></ul></li><li>IP地址标志一个主机 / 路由器 / 链路的接口<ul><li>路由器属于不同网络的接口有不同的IP地址</li><li>至少有两个不同的IP地址</li></ul></li><li>网桥连接的若干局域网仍拥有相同的网络号，仍属于同一个网络<ul><li>网桥 / 转发器仅仅是扩展网络</li></ul></li><li>只包含一段线路的网络不指明IP地址</li></ul><h2 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h2><p>这里说硬件地址而不是MAC地址，因为链路层及以下使用的的硬件地址有很多种，其中以太网使用MAC地址</p><p>MAC地址 $\in$ 硬件地址</p><ul><li>路由器转发不改变IP源和目的，但是改变MAC源和目的<ul><li>网桥转发不改变MAC源和目的</li><li>路由器转发改变了链路</li></ul></li><li>数据包中间经过的路由器的IP不会出现在IP数据报的首部中</li><li>虽然首部有源站，但是路由器<strong>仅根据</strong>目的站的IP的网络号进行转发<ul><li>只找到网络就行</li></ul></li></ul><h3 id="地址解析协议-ARP-Address-Resolution-Protocal"><a href="#地址解析协议-ARP-Address-Resolution-Protocal" class="headerlink" title="地址解析协议 ARP Address Resolution Protocal"></a>地址解析协议 ARP Address Resolution Protocal</h3><ul><li>从网络层使用的IP地址解析出链路层使用的硬件地址</li><li>每个主机都有一个ARP Cache，里面有所在<strong>局域网</strong>上的各个主机和路由器的IP地址到硬件地址的映射表<ul><li>IP Address；MAC Address；TTL (Time to live) 使用老化策略，过久不使用的地址会被删除</li><li>能够减少ARP广播的数量</li></ul></li><li>发送过程<ul><li>向本局域网中的主机发送</li><li>有就把目的MAC地址写入MAC帧</li><li>没有就<strong>本地广播</strong>发送一个<strong>ARP请求分组</strong>，目的主机<strong>响应</strong>，把目的主机的MAC地址加入ARP Cache<ul><li><strong>本地广播</strong>：路由器不转发；链路层广播，MAC地址全1</li><li><strong>ARP请求分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 <strong>未知时填零</strong>/ 目标方IP地址；所有主机都会记录下发送方的硬件地址</li><li><strong>ARP响应分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 / 目标方IP地址；是广播实现的一对一通信</li></ul></li><li>如果目的主机和源主机不在同一个局域网，发送主机获得的就不是真正目的主机的MAC地址，而是能通往目的主机的路由器的IP地址。此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或<strong>ARP代理（ARP Proxy）</strong>。</li></ul></li><li>为什么不使用硬件地址进行通信<ul><li>异构网络很多，互相通信需要进行复杂的地址转换</li><li>IP使得所有网络像连接在同一个网络一样，把脏活累活交给ARP去做</li></ul></li></ul><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p><img src="IMG_1554.PNG" alt="ip"></p><p>首部、数据</p><p>首部包括固定部分20字节，可选部分长度不定，总共不超过60字节</p><ul><li>版本 4位<ul><li>0100 IPv4   0110 IPv6</li></ul></li><li>首部长度 4位<ul><li>最大表示15个单位，一个单位4字节，所以首部最长60字节</li></ul></li><li>区分服务 8位</li><li>总长度 16位<ul><li>首部长度 + 数据长度</li><li>单位为字节，因此数据报最大长度为$2^{16} - 1 = 65535$字节</li><li>总长度不能超过MTU</li></ul></li><li>标识 16位<ul><li>长度超过MTU则需要分片</li><li>分片后标识来自同一个数据报</li></ul></li><li>标志 3位<ul><li>目前只有前两位有意义</li><li>最低位是MF（More Fragment），中间一位是DF（Don’t Fragment）<ul><li>MF=0 没有分片了</li><li>DF=0 允许分片</li></ul></li></ul></li><li>片偏移 13位<ul><li>表示某片在原分组中的相对位置</li><li>以8字节为偏移单位，需要乘八，也就是左移三位，正好补上标志部分三位的空缺</li></ul></li><li>生存事件TTL 8位<ul><li>每经过一次路由转发，减少一，变成零了还没到目的就丢弃</li></ul></li><li>协议<ul><li>指出为谁服务，上层协议是什么</li></ul></li><li>首部检验和  16位<ul><li>验证首部在传输中有没有出现差错</li><li>二进制反码求和</li><li>IP不检验数据部分，扔给链路层做</li></ul></li><li>源地址、目的地址 各32位</li><li>可变部分<ul><li>最大40字节，需要使长度为4的整数倍，不足则用零填充</li><li>其实很少用</li></ul></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><p>IP分片不是一件好事情，应该能不分就不分</p><ul><li><p>分片之后有哪些字段会变</p><ul><li>总长度</li><li>报头检验和</li><li>MF位</li><li>片偏移</li></ul></li><li><p>分片的坏处</p><ul><li>效率低</li><li>需要缓存</li><li>防火墙可能会拦截</li></ul></li></ul><h2 id="二进制反码求和"><a href="#二进制反码求和" class="headerlink" title="二进制反码求和"></a>二进制反码求和</h2><ul><li>此反码非计组之反码 （ones’ complement）<ul><li>计组中的反码 正数的反码是本身 负数的反码是符号位不变，其余位取反</li></ul></li><li>逐位取反之后再相加（再取反）</li><li>最高位的进位加在最后一位上 (回卷)<ul><li>这样可以使得先加后取反和先取反后加的结果一样</li></ul></li><li>不依赖大端表示 / 小端表示<ul><li>交换十六位数的字节顺序，得到的结果相同，只是字节顺序也相应发生变化</li></ul></li></ul><h2 id="转发分组的流程"><a href="#转发分组的流程" class="headerlink" title="转发分组的流程"></a>转发分组的流程</h2><h3 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a>特定主机路由</h3><p>将IP数据报发送到特定的某个主机上，而不是发送到网络上就结束了</p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>路由表中的Default项，不在匹配其他任何项时按照默认路由进行转发</p><p>可以减少路由表中的条目数</p><h2 id="划分子网与构造超网"><a href="#划分子网与构造超网" class="headerlink" title="划分子网与构造超网"></a>划分子网与构造超网</h2><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><ul><li>网络号、主机号的两级IP 变为网络号、子网号、主机号的三级IP</li><li>网络号侵占主机号</li><li>因为全零全一不允许使用，每划分一个子网就会废掉两个IP</li><li>子网号的位数不能为0、1、15、16<ul><li>为0则没有划分子网</li><li>为16则没有主机</li><li>为1则网络号要么0要么1，不允许使用</li><li>为15则主机号要么0要么1，不允许使用</li></ul></li><li>定长子网划分、变长子网划分</li></ul><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a><font color="red">一个问题</font></h4><p>一个C类IP，划分为四个子网，分别在全零全一可用 / 不可用的时候损失了多少IP？</p><p>四个子网需要两个位的子网号，剩余六个位的主机号</p><p>网络号为00， 01， 10， 11，全零全一不可用，只剩下01， 10两个网络</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>用于找出IP地址中的子网部分</li><li>前面为1， 主机号部分为0，与IP做按位与运算，可以去掉主机号</li><li>最小IP网络的子网掩码是多少<ul><li>255.255.255.252</li><li>留出两位作为主机号，00， 01， 10， 11个主机，全零全一不让用，只有两台主机，其中一台是路由器</li></ul></li></ul><h3 id="构造超网-无分类编址CIDR-路由聚合"><a href="#构造超网-无分类编址CIDR-路由聚合" class="headerlink" title="构造超网 无分类编址CIDR 路由聚合"></a>构造超网 无分类编址CIDR 路由聚合</h3><p>无分类域间路由选择 Classless Inter-Domain Routing</p><ul><li>取消了传统ABC类网络，改用网络前缀来代替网络号与子网号<ul><li>主机号侵占网络号</li></ul></li><li>又变成两级编址</li><li>可以把多个C类网络合并，相当于侵占网络号</li><li>使用斜线记法，斜线后面表示网络前缀所占的位数<ul><li>数值上对应三级编址中子网掩码的1的位数</li></ul></li><li>仍然使用掩码</li><li>路由表中的一个项目可以表示很多传统分类的路由</li></ul><h4 id="构造超网的规则"><a href="#构造超网的规则" class="headerlink" title="构造超网的规则"></a>构造超网的规则</h4><ul><li>构成超网的地址块数必须是$2^n$</li><li>构成超网的地址快必须连续</li><li>第一个地址的第三字节必须能被块数整除</li></ul><h4 id="一些问题"><a href="#一些问题" class="headerlink" title=" 一些问题"></a><font color="red"> 一些问题</font></h4><ul><li>超网的网络地址能不能是X.Y.33.0？<ul><li>X.Y.00100001.0，发现主机号只有最后一个字节，相当于C类网络，没有聚合，也就不能叫超网</li></ul></li><li>X.Y.32.0 能不能确定网络<ul><li>X.Y.00100000.0，不能确定主机号的零从哪里开始</li><li>必须加上掩码/斜线才能确定网络号</li></ul></li></ul><h2 id="查找路由表"><a href="#查找路由表" class="headerlink" title="查找路由表"></a>查找路由表</h2><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>匹配路由表中最长的那个，因为越长越具体，有特定主机路由就不用网络前缀路由，有网络前缀路由就不用默认路由</p><p>路由器取出IP分组中的目的地址，与前缀对应的掩码进行按位与运算提取到网络号，进行匹配</p><h3 id="二叉线索"><a href="#二叉线索" class="headerlink" title="二叉线索"></a>二叉线索</h3><p>是一棵Trie</p><p>Trie上的前缀是唯一的，进行<strong>唯一前缀匹配</strong></p><p>唯一前缀匹配不等价于网络前缀匹配</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP在IP之上，ICMP报文作为IP报文的数据部分，也要被封装成IP数据报</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>1字节类型，1字节代码，2字节检验和</p><p>4字节ICMP数据部分，长度可变</p><h3 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h3><p>长度为<strong>36字节</strong></p><p>在收到错误的IP数据报后发送，也要封装为IP数据报</p><p>（封装后的IP数据报）数据部分是ICMP的前8字节 + 收到的IP数据报的首部 + 8字节，为TCP / UDP的端口号</p><p>因为要判定端口不可达</p><h4 id="不需要发送ICMP差错报文的几种情况"><a href="#不需要发送ICMP差错报文的几种情况" class="headerlink" title="不需要发送ICMP差错报文的几种情况"></a>不需要发送ICMP差错报文的几种情况</h4><ul><li>不再为ICMP差错报文发送ICMP差错报文 / 禁止套娃</li><li>只对分片中的第一片发送 / 一个错各个错</li><li>多播地址的数据报不发送</li><li>特殊地址（127.0.0.0 / 0.0.0.0）不发送</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>终点不可达<ul><li>某一环无法继续传递，向发送方发送终点不可达</li><li>报文中的数据表示失败的原因</li><li>不可达有五种情况<ul><li>网络不可达</li><li>主机不可达</li><li>协议不可达 //无法向上提交</li><li>端口不可达</li><li>需要分片但DF位为1</li><li>源路由失败</li></ul></li></ul></li><li>时间超过<ul><li>TTL减到0</li><li>某些分片迟迟不来，组装出问题</li></ul></li><li>参数问题<ul><li>头部参数出错，Pointer部分会指出错误的字节位置</li></ul></li><li>源点抑制<ul><li>流量过大，缓存队列溢出，只能丢弃报文，此时发送一个ICMP源点抑制，告知发送方晚点再来</li></ul></li><li>改变路由 / 重定向<ul><li>找不到目的地址</li></ul></li></ul><h3 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h3><p>长度为<strong>40字节</strong></p><h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ul><li>回送请求和回答<ul><li>ping</li></ul></li><li>时间戳请求和回答<ul><li>查询当前时间，提供毫秒级的分辨率</li><li>包含三个时间戳 ：Origin时间、Receive时间、transmit时间 （接收方发送回应的时间）</li><li>即使不同步也能计算正确的往返时间</li></ul></li></ul><h3 id="源路由"><a href="#源路由" class="headerlink" title="源路由"></a>源路由</h3><p>从源路由网桥中提到过，指从源点就确定的路由</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><ul><li><strong>ping非常特殊，应用层直接使用网络层，不经过运输层</strong></li></ul><h4 id="trace-route"><a href="#trace-route" class="headerlink" title="trace route"></a>trace route</h4><ul><li><p>发很多次，第一次发TTL是1，第二次发TTL是2，以此类推，每一次路由器都会给出一个超时</p></li><li><p>当到达目的主机时没法发送超时了，此时设置的一个不可达的UDP端口使得目的主机发送终点不可达</p></li><li><p>因此<strong>trace route 用到了运输层</strong></p></li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><ul><li>正确、完整</li><li>计算上简单</li><li>能适应通信量和网络拓扑的变化</li><li>稳定性，路由不应该不停变化</li><li>公平，除了少数优先级高的用户 / 区分服务</li><li>算法应该是最佳的 / 相对概念，特定约束下的较为合理的选择</li></ul><h3 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h3><p>静态路由 简单开销小，但是不能及时适应网络状态变化</p><p>动态路由 复杂开销大，但是能较好适应网络状态的变化</p><p>内部网关协议 IGP AS内部使用</p><p>外部网关协议 EGP AS之间使用</p><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>Autonomous System 自治系统</p><p>把AS内的网络看作一个整体，屏蔽内部细节和采用的路由协议</p><p>一个AS对其他AS表现出一个单一的一致的路由选择策略</p><h3 id="RIP-Route-information-protocol"><a href="#RIP-Route-information-protocol" class="headerlink" title="RIP Route information protocol"></a>RIP Route information protocol</h3><p>是一种内部网关协议</p><p><strong>分布式</strong>的基于<strong>距离向量</strong>的路由选择协议</p><p>每经过一个路由器距离加一，距离向量的距离指的是最短距离 / 经过路由器的数目最少</p><p>RIP简单粗暴的把距离短的路由认为是好的路由，允许一条路径最多包含15个路由器，距离超过15就标记为不可达</p><p><strong>不存在</strong>负载均衡，有两条长度一样的路径也只会走其中一条</p><p>工作方式为每隔固定的一段时间和相邻路由器交换自己的路由表</p><ul><li>三分钟没收到消息就认为不可达，距离设置为16</li><li>收到之后总总是要更新，距离可能增大也可能减小，应该以最新的更新</li></ul><p>能很快收敛 / 所有路由器达到一致</p><ul><li>路由表一致性不等于路由表表项相同</li></ul><p>路由表包括目的网络（大方向） 距离 下一跳路由器（小方向）</p><h4 id="RIP2报文格式"><a href="#RIP2报文格式" class="headerlink" title="RIP2报文格式"></a>RIP2报文格式</h4><p><img src="IMG_1576.PNG" alt></p><p>RIP2要封装到UDP中再封装到IP中，RIP是应用层协议</p><p>四字节首部，路由信息20字节，最多25个，总长度最大4 + 20 * 25 = 504字节，超过则启用新的RIP2报文</p><p>RIP2和RIP1（最大的）的区别是RIP2支持子网</p><p>路由标记表示是否再同一个自治系统中，填写的是自治系统的编码</p><h4 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h4><ul><li>水平分割<ul><li>从某个接口学到的路由不会再发回去，防止了路由环路</li></ul></li><li>毒性逆转<ul><li>当路由信息变成无效后不是直接删除而是设置为不可达并广播出去，可以清楚路由表中无用的路由</li></ul></li><li>触发更新<ul><li>路由信息改变后立即更新并发送给相邻路由器</li></ul></li><li>抑制计时<ul><li>如果一条路由更新的跳数大于路由表已记录的该路由的跳数，那么将会引起该路由进入长达180秒（即6个路由更新周期）的抑制状态阶段。在抑制计时器超时前，路由器不再接收关于这条路由的更新信息。可以用来防止路由环路。</li></ul></li></ul><h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF Open Shortest Path First"></a>OSPF Open Shortest Path First</h3><p>是一种内部网关协议</p><p><strong>分布式</strong>的，基于<strong>链路状态</strong>的路由选择协议</p><p>工作在网络层，在IP之上，直接使用IP数据报进行传送</p><p>使用Djijkstra算法</p><p>需要一张完整的网络图，来跑Dijkstra算法</p><p>所有的路由器都维护一个完整的链路状态数据库 / 全网的拓扑结构图</p><p>所有路由器的数据库都是完全一致的，和RIP中的一致不同</p><p>OSPF收敛很快</p><h4 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h4><ul><li>使用泛洪法向自治系统内的所有路由器发送信息</li><li>发送与本路由器相邻的所有路由器的链路状态<ul><li>与谁相邻，代价是多少</li></ul></li><li>只有链路状态发生变化时，路由器才使用泛洪法向所有路由器发送信息</li></ul><h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><p>自治系统通常贼大，需要维护的数据库也就会变大，因此在自治系统的基础上进一步划分区域（Area），这样就只需要在区域内泛洪、维护区域的拓扑结构图</p><p>每个区域用一个32位的区域标识符来表示，和IP一样使用点分十进制</p><p>使用层次结构的区域划分，上层的区域叫做主干区域，标识符为 0.0.0.0，主干区域联通下层区域</p><p>位于主干区域中的路由器称为主干路由器（BR）</p><p>位于区域边缘，与其他区域通信的路由器称为区域边界路由器（Area Border Router)</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>数据报很短<ul><li>减少路由信息的通信量，网络最主要的功能还是处理端系统的消息</li><li>不必将长的数据报分片传送，有效减少重传</li></ul></li><li>具有多路径负载均衡</li><li>具有鉴别功能<ul><li>保证了仅在可信的路由器之间交换链路状态信息</li></ul></li><li>支持变长子网划分和CIDR</li><li>每一个链路状态都有一个32位的序号，序号增长不超过五秒钟一次</li><li>每隔一段时间刷新数据库中的链路状态</li><li>互联网规模很大时，OSPF要比RIP好很多，对网络变化的响应很快不存在坏消息传得慢的情况</li></ul><h4 id="指定路由器"><a href="#指定路由器" class="headerlink" title="指定路由器"></a>指定路由器</h4><p>在一个广播性、多路访问的网络中，如果每个路由器都独立进行链路状态更新包的交换，就会产生巨大流量，不好，因此选举出一个村长来进行链路状态信息的交换。</p><p>有DR（Designated Router)）和BDR（Backup Designated Router）</p><h4 id="分组格式"><a href="#分组格式" class="headerlink" title="分组格式"></a>分组格式</h4><p><img src="IMG_1577.PNG" alt></p><ul><li>版本<ul><li>当前版本为2，版本一版本二不兼容</li></ul></li><li>类型<ul><li>Hello<ul><li>每隔十秒交换一次问候分组，从而得知有哪些路由器是可达的</li></ul></li><li>Database Description</li><li>Link State Request</li><li>Link State Update<ul><li>收到更新报文后需要恢复ACK</li></ul></li><li>Link State Acknowledgment</li></ul></li><li>分组长度<ul><li>包括OFSF头部的分组长度</li></ul></li><li>路由器ID<ul><li>在AS中可以唯一表示路由器</li></ul></li><li>区域ID<ul><li>指定分组所属的区域号</li></ul></li><li>校验和<ul><li>用于分组所有内容的校验和</li></ul></li><li>鉴别1<ul><li>0或1，表示不鉴别和使用口令鉴别</li></ul></li><li>鉴别2<ul><li>鉴别1为0时为0，鉴别1为1时为口令</li></ul></li></ul><h3 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP Border Gateway Protocol"></a>BGP Border Gateway Protocol</h3><p>外部网关协议</p><p>目前版本为4</p><p>难以寻找最佳路由，只在AS之间交换可达性信息，找到一条不兜圈子的<strong>比较好</strong>的路由</p><p>基于<strong>路径向量</strong>的路由选择协议</p><p>每个AS至少要有一个BGP发言人，每个发言人都要属于一个AS</p><p>作用于不同AS，但同一个AS中的不同边界路由器也需要建立BGP连接</p><p>BGP支持CIDR</p><p>是应用层协议，使用TCP进行传输</p><ul><li>对于远距离的传输，需要使用TCP保证可靠性</li></ul><h4 id="BGP热土豆路由选择协议"><a href="#BGP热土豆路由选择协议" class="headerlink" title="BGP热土豆路由选择协议"></a>BGP热土豆路由选择协议</h4><p>热马铃薯路由选择（Hot-potato routing）是在当前AS接收到一个数据包后，使其停留在该AS中的时间尽可能短。它尝试减少当前AS的开销，而忽略了网络中其他组成成分的开销。</p><p>将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS。</p><h4 id="AS的分类"><a href="#AS的分类" class="headerlink" title="AS的分类"></a>AS的分类</h4><p>单口AS，只有一个连接可以到达另一个AS，只能是信源或信宿</p><p>多归路过渡AS，有多个连接到达多个AS，但是拒绝传送流量，只能是信源或信宿 / 拒绝通信量穿越的多归属AS</p><p>过渡AS，不允许通信量穿越的多归属AS</p><h4 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h4><p>OPEN 与相邻的另一个BGP发言人建立关系 / 打招呼</p><p>UPDATE 发送某一路由的信息，列出要撤销的多条路由 / 有新闻</p><p>KEEPALIVE  确认打开报文与周期性证实临站关系 / 表明自己还活着 / 只有报文头</p><p>NOTIFICATION 发送检测到的差错 / 不跟你玩了</p><p><img src="IMG_1579.PNG" alt></p><p>标记部分用于鉴别，但是现在没有鉴别方案，全部置为1</p><p>长度为包括首部在内的总长度</p><p>类型为1-4，上述的四种类型</p><h4 id="一个问题-1"><a href="#一个问题-1" class="headerlink" title=" 一个问题 "></a><font color="red"> 一个问题 </font></h4><p><strong>KeepAlive报文在链路层是否需要进行填充？</strong></p><p>KeepAlive只有报文头，16 + 2 + 1 = 19 字节</p><p>作为TCP的数据部分，需要加上TCP的首部 19 + 20 = 39 字节</p><p>作为IP的数据部分，需要加上IP的首部 39 + 20 = 59 字节</p><p>MAC帧在长度小于46字节时才进行填充，因此不需要进行填充</p><p>以太网最短帧长为64字节，减去16字节头部，4字节FCS，数据部分最短46字节</p><h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>多输入端口，多输出端口</p><p>作用是转发分组</p><p>路由选择协议生成路由表，路由表生成转发表</p><h3 id="多播特点"><a href="#多播特点" class="headerlink" title="多播特点"></a>多播特点</h3><p>使用组地址，D类地址</p><p>永久组地址</p><p>动态组成员</p><p>使用硬件进行多播</p><h3 id="IP多播地址与以太网多播地址的转换"><a href="#IP多播地址与以太网多播地址的转换" class="headerlink" title="IP多播地址与以太网多播地址的转换"></a>IP多播地址与以太网多播地址的转换</h3><p>01 + 00 + 5e + 0 + 组播IP低23位</p><h4 id="一个例子"><a href="#一个例子" class="headerlink" title=" 一个例子 "></a><font color="red"> 一个例子 </font></h4><p>226.150.47.33</p><p>首先确定D类IP，D类IP从224到239</p><p>写出后三个字节的二进制</p><p>150 = 128 + 16 + 4 + 2 = 1001 0110</p><p>47 = 32 + 16 - 1 = 0011 0000 - 1 = 0010 1111</p><p>33 = 32 + 1 = 0010 0001</p><p>把正数第二字节第一位换成0，因为只要后23位</p><p>0001 0110 = 16</p><p>0010 1111 = 2F</p><p>0010 0001 = 21</p><p>最终结果为 01 00 5e 16 2F 21</p><h3 id="IGMP-Internet-Group-Management-Protocal"><a href="#IGMP-Internet-Group-Management-Protocal" class="headerlink" title="IGMP Internet Group Management Protocal"></a>IGMP Internet Group Management Protocal</h3><p>使路由器知道多播组成员的信息</p><p>看作IP的一个组成部分</p><h4 id="IGMP的本地使用范围"><a href="#IGMP的本地使用范围" class="headerlink" title="IGMP的本地使用范围"></a>IGMP的本地使用范围</h4><p><strong>并非</strong> 在因特网范围内对所有多播组成员进行管理的协议</p><p>IGMP 不知道IP多播组包含的成员数，也不知道这些成员分布在哪些网络上</p><p>IGMP是让连接在本地局域网的多播路由器知道本剧于网上是否有主机参加或退出了多播组</p><h3 id="为什么多播路由选择协议比单播路由选择协议复杂得多"><a href="#为什么多播路由选择协议比单播路由选择协议复杂得多" class="headerlink" title="为什么多播路由选择协议比单播路由选择协议复杂得多"></a>为什么多播路由选择协议比单播路由选择协议复杂得多</h3><p>多播转发必须动态适应多播组成员的变化，而单播通常是在网络拓扑发生变化时才需要更新路由</p><p>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，还要考虑这个多播数据报从哪里来到哪里去</p><p>多播数据报可以从没有加入多播组的主机发出，也可以通过没有组成员接入的网络</p><h3 id="IGMP两个阶段及具体措施"><a href="#IGMP两个阶段及具体措施" class="headerlink" title="IGMP两个阶段及具体措施"></a>IGMP两个阶段及具体措施</h3><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>新主机加入多播组，先向该组的多播地址发送IGMP报文，表明自己要加入，多播路由器收到之后将组成员关系转发到因特网上其他多播路由器，以完善多播路径</p><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>周期性探询本地局域网的主机，确认是否是该组的成员，只要有一个响应认为是活跃的，多次没有响应就不再将组成员关系转发给其他路由器</p><h4 id="具体措施"><a href="#具体措施" class="headerlink" title="具体措施"></a>具体措施</h4><p>使用IP多播</p><p>探寻组成员关系时对所有组发送一个请求信息的询问报文（而不是每个组一个）</p><p>主机收到询问后随机选择一个时延进行发送</p><p>如果组内有其他主机发送了，自己就可以不发送了</p><h3 id="多播路由选择的三种方法"><a href="#多播路由选择的三种方法" class="headerlink" title="多播路由选择的三种方法"></a>多播路由选择的三种方法</h3><p>多播路由选择实际上是要构建以源主机为根节点的多播转发树</p><h4 id="洪泛与剪除"><a href="#洪泛与剪除" class="headerlink" title="洪泛与剪除"></a>洪泛与剪除</h4><p>RBP Reverse Path Broadcasting</p><p>洪泛适用于较小的多播组，为了避免兜圈子，使用了反向路径广播Reverse Path Broadcasting的策略</p><p>剪除指发现下游树枝上没有多播组成员时，把它和下游树枝一起在转发树上剪除</p><h4 id="隧道-lt-第一个隧道-gt"><a href="#隧道-lt-第一个隧道-gt" class="headerlink" title="隧道  &lt;第一个隧道&gt; "></a>隧道 <font color="blue"> &lt;第一个隧道&gt; </font></h4><p>把多播报文封装为单播，使用单播通过不支持多播的网络，出来之后再恢复成多播</p><h4 id="基于核心的发现技术"><a href="#基于核心的发现技术" class="headerlink" title="　基于核心的发现技术"></a>　基于核心的发现技术</h4><p>对每一个多播组指定一个核心，核心路由器构建转发树</p><h3 id="RPB特点"><a href="#RPB特点" class="headerlink" title="RPB特点"></a>RPB特点</h3><p>路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的：</p><p>若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外 ）</p><p>否 则 ， 就 丢 弃 而 不 转 发。</p><p>如果 存 在 几 条 同 样 长 度 的 最 短 路 径 ， 那 么 只 能 选 择 一 条 最 短 路 径 ， 选 择 的 准 则 就 是 看 这 几 条 最 短 路 径中的相邻路由器谁的 IP 地址最小。 </p><p>最终得出多播转发树，以后就按其转发多播数据报</p><h2 id="VPN-Virtaul-Private-Network"><a href="#VPN-Virtaul-Private-Network" class="headerlink" title="VPN Virtaul Private Network"></a>VPN Virtaul Private Network</h2><p>利用公用的互联网作为本机构各专用网之间的通信载体</p><p>所有通过互联网传送的数据都必须加密</p><p>使用 <strong>隧道技术</strong> 来实现 <font color="blue"> &lt;第二个隧道&gt; </font></p><p><img src="IMG_1580.PNG" alt="IMG_1580"></p><p>机构内部的VPN为内联网（intranet），不同机构共同建立的VPN为外联网（exrtanet）</p><h2 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT Network Address Translation"></a>NAT Network Address Translation</h2><p>专用网中的主机需要与外部进行通信，需要通过NAT路由器将私有地址转换为全球地址</p><p>转换结果需要记录在NAT地址转换表中</p><p>每次通信需要进行两次转换，离开时一次，进入时一次</p><p>对于有$n$个全球IP地址的NAT路由器，最多可以同时有$n$台主机接入到互联网</p><p>专用网内部的主机不能作为服务器</p><p><img src="IMG_1583.PNG" alt="ING_1583"></p><h3 id="NAPT-Network-Address-and-Port-Translation"><a href="#NAPT-Network-Address-and-Port-Translation" class="headerlink" title="NAPT Network Address and Port Translation"></a>NAPT Network Address and Port Translation</h3><p>多个主机公用一个NAT路由器上的全球IP地址</p><p>把专用网内部的不同IP地址转换为相同的全球IP地址，源主机采用的TCP端口号不管相不相同都转换为不同的新的端口号</p><h2 id="MPLS-Multi-Protocol-Label-Switching"><a href="#MPLS-Multi-Protocol-Label-Switching" class="headerlink" title="MPLS Multi Protocol Label Switching"></a>MPLS Multi Protocol Label Switching</h2><p>属于2.5层协议，是IP的一种增强</p><p><strong>多协议</strong> 表示MPLS的上层可以采用多种网络协议、下层可以采用多种链路层协议</p><p><strong>标记</strong> 表示每<strong>类</strong>分组被打上一个标记，根据标记对分组进行转发</p><font color="red"> **面向连接**</font><blockquote><p>传统的路由决策，路由器需要对网络数据包进行解包，再根据目的IP地址计算归属的FEC。</p><p>而MPLS提出，当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。</p><p>当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。</p></blockquote><p>每类分组会有一个特定的编号</p><h3 id="MPLS特点"><a href="#MPLS特点" class="headerlink" title="MPLS特点"></a>MPLS特点</h3><ul><li>分类意味着面向连接，标记一旦确定，连接的路径就确定了</li><li>支持流量工程，平衡网络负载</li><li>有效支持VPN</li><li>在转发是不上升到第三层查找转发表，而是直接在第二能用硬件进行转发</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>使用LDP label distribution protocol交换报文，找到标记交换路径LSP</li><li>分组进入MPLS域时，在入口打上标记，按照转发表将分组发给下一个LSR</li><li><font color="red">标记具有强烈的本地意义</font>，仅在两个LSR之间才有意义</li><li>分组经过LSR要做两件事情，一是转发，二是标记对换</li><li>离开MPLS域时，MPLS出口节点把标记去除</li><li>这样的转发方式被称为<strong>显式路由选择</strong></li></ul><h4 id="MPLS域"><a href="#MPLS域" class="headerlink" title="MPLS域"></a>MPLS域</h4><p>这个区域中所有路由器都支持MPLS技术，都是LSR Label Switching router</p><p>LSR既可以标记交换也可以路由选择，转发表被用来构造标记交换表</p><h3 id="转发等价类FEC"><a href="#转发等价类FEC" class="headerlink" title="转发等价类FEC"></a>转发等价类FEC</h3><p>如何划分转发等价类是MPLS的核心</p><p>转发等价类是LSR按照同样的方式对待的分组的集合</p><p>划分方式很灵活，通常由网络管理员来控制</p><p>通过设置不同的FEC可以实现负载均衡，也称为流量工程</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>特定前缀进行匹配</p><p>源地址目的地址都相同</p><p>某种服务质量需求的（区分服务）</p><h3 id="MPLS格式"><a href="#MPLS格式" class="headerlink" title="MPLS格式"></a>MPLS格式</h3><p>在IP数据报被封装成以太网帧之前，先插入一个MPLS首部</p><p><img src="IMG_1592.PNG" alt></p><p>生存时间用于防止兜圈子</p><h3 id="LSP隧道-lt-第三个隧道-gt"><a href="#LSP隧道-lt-第三个隧道-gt" class="headerlink" title="LSP隧道  &lt;第三个隧道&gt; "></a>LSP隧道 <font color="blue"> &lt;第三个隧道&gt; </font></h3><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h3><p>允许协议继续扩充</p><p>支持即插即用自动配置</p><p>支持资源预分配</p><p>首部由四字节对齐改为八字节对齐</p><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p><img src="IMG_1593.PNG" alt></p><ul><li>版本<ul><li>4位，目前版本6</li></ul></li><li>通信量类<ul><li>8位，相当于区分服务</li></ul></li><li>流标号</li><li>有效载荷长度</li><li>下一个首部<ul><li>8位，指向扩展首部，串出一个列表</li></ul></li><li>跳数限制<ul><li>8位</li></ul></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>128位</p><p>除Unicast、Multicast外支持Anycast</p><ul><li>对于一组主机，只要找到最近的一个即可</li><li>发向一组，其中只要有一个接收到即可</li></ul><p>使用冒号十六进制记法</p><p>允许把数字前面的0省略</p><p>一串零可以使用零压缩压缩成一对冒号，地址中只能压缩一次</p><p>CIDR斜线表示法仍然适用</p><h4 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h4><p><code>::/128</code> 未指明</p><p><code>::1/128</code> 环回</p><p><code>FF00::/8</code> 多播</p><p><code>FE80::/10</code> 本地链路单播</p><h3 id="v4-to-v6"><a href="#v4-to-v6" class="headerlink" title="v4 to v6"></a>v4 to v6</h3><ul><li>双协议栈</li><li>隧道技术 <font color="blue"> &lt;第四种隧道&gt; </font><ul><li>把v6数据报封装进v4数据报</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容贼多&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-进程同步</title>
    <link href="http://ilern.github.io/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://ilern.github.io/2020/10/15/操作系统学习笔记-进程同步/</id>
    <published>2020-10-15T07:08:38.000Z</published>
    <updated>2020-12-27T02:45:36.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h2><h3 id="About-Critical-Section"><a href="#About-Critical-Section" class="headerlink" title="About Critical Section"></a>About Critical Section</h3><ul><li><p>An atomic action is required in a critical section.</p></li><li><p>When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</p></li><li><p>The critical section is <strong>not</strong> a public section. Each process has its own critical section.</p></li><li>Each process must request permission to enter its critical section. The section of code implementing this request is the <strong>entry section</strong>, the critical section may be followed by an <strong>exit section</strong></li></ul><p><img src="https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG" alt></p><a id="more"></a><h3 id="Solution-of-the-critical-section-problem"><a href="#Solution-of-the-critical-section-problem" class="headerlink" title="Solution of the critical-section problem"></a>Solution of the critical-section problem</h3><ul><li><p>Mutual exclusion 互斥</p><ul><li>If  process $p_i$ is executing its critical section, then no other process can be executing in their critical sections</li></ul></li><li><p>progress 进步？</p><ul><li>If no process is executing in its critical section and some processes with to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which  will enter its critical section next, and this selection cannot be postponed <strong>indefinitely</strong>.</li><li>如果没有进程在执行临界区并且某些进程想要执行他们的临界区，那么只有那些不在他们剩余区的进程可以参与决定谁来执行临界区的筛选，这个选择过程不会无限期推迟。</li></ul></li><li><p>Bounded waiting 有界等待</p><ul><li><p>There exists a bound on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.</p></li><li><pre class="mermaid">    gantt                section Figure1       请求进入临界区            :des1, 1d       等待          :des2, after des1, 3d       被授权进入临界区            :des3, after des2, 5d</pre></li><li><p>如上图，在等待的过程中其他进程被允许进入临界区的次数是有限的</p></li></ul></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p><strong>两个进程</strong>的同步算法，软件实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initicall turn = 0</span></span><br><span class="line"><span class="comment">// turn is a shared variable</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (turn != i); <span class="comment">// only turn == i can this process execute it's critical section</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">//reminder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Satisfies mutual exclusion, but not progress</p><p>机械的规定零号进程一号进程交替进行。</p><p>进程是否有进入临界区的 <strong>意愿</strong> ？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initial flag[0] = flag[1] = false;</span></span><br><span class="line"><span class="comment">//flag[i] == true -&gt; process i ready to enter critical section</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]); <span class="comment">// mutual exclusion</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>不满足 progress ，在<code>flag[i] = true</code>之后，切换到另一个进程<code>flag[j] = true</code>，此时两个进程都想进临界区，但是都在看对方，都不能进入临界区</p><h3 id="Peterson‘s-Solution"><a href="#Peterson‘s-Solution" class="headerlink" title="Peterson‘s Solution"></a>Peterson‘s Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share turn flag[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>最后执行turn等于谁，谁就进入临界区</p><h2 id="Synchronization-Hardware"><a href="#Synchronization-Hardware" class="headerlink" title="Synchronization Hardware"></a>Synchronization Hardware</h2><p>Based on <strong>locking</strong></p><ul><li>Uniprocessors<ul><li>同一时刻指运行一个进程</li><li>disable interrupts 把中断屏蔽即可</li></ul></li><li>special atomic hardware instructions 硬件提供特殊的原子指令<ul><li>原子指令执行期间不允许切换</li><li><code>test memory</code> 查看某内存单元的值</li><li><code>set value</code> 对某内存单元设置为1</li><li><code>swap</code> 交换两个内存单元的值</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    acquire lock</span><br><span class="line">        <span class="comment">//criticla section</span></span><br><span class="line">    release lock</span><br><span class="line">        <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="test-and-set-Instruction"><a href="#test-and-set-Instruction" class="headerlink" title="test_and_set Instruction"></a>test_and_set Instruction</h3><p>做成<strong>一条</strong>机器指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tar 看作一个锁，一堆人去抢这把锁</span></span><br><span class="line"><span class="function">boolean <span class="title">test_and_set</span><span class="params">(boolean *tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> rv = *tar;</span><br><span class="line">    *tar = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">//got the lock or not;</span></span><br><span class="line">    <span class="comment">//flase -&gt; 锁没被锁，自己锁了</span></span><br><span class="line">    <span class="comment">//true -&gt; 已经被锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这条指令加锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutux lock</span></span><br><span class="line"><span class="comment">//锁只是一个普通变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(test_and_set(&amp;lock));</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较倒霉的情况可能不满足有界等待</span></span><br><span class="line"><span class="comment">//几率小，当倒霉处理</span></span><br></pre></td></tr></table></figure></p><h3 id="compare-and-swap-Instruction"><a href="#compare-and-swap-Instruction" class="headerlink" title="compare_and_swap Instruction"></a>compare_and_swap Instruction</h3><p>和<code>test_and_set Instruction</code>做一样的事情，但是实际功能更强。</p><p>用牛刀杀鸡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *value;</span><br><span class="line">    <span class="keyword">if</span> (*value == expected) </span><br><span class="line">        *value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旧值和新值比较</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">//是0就设置为1</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h2><p>Software Tool</p><p>使用原子的<code>acquire()</code>和<code>release()</code>来申请、释放锁，不需要在意底层具体实现方式。</p><ul><li><p>CPU busy waiting 问题</p><ul><li>循环查看锁开没开</li><li>Spinlock 自旋锁</li><li>会浪费CPU的时间</li></ul></li><li><p>更好的办法</p><ul><li>锁可用获得锁</li><li>锁不可用进程挂起</li><li>释放锁时有进程挂起则挑一个唤醒</li><li>没有进程挂起直接释放</li></ul></li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p><p>Synchronization Tool that does not require busy waiting</p><ul><li><p>is an integer</p></li><li><p><code>wait()</code> P 减信号量 请求执行</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//busy wait</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>signal()</code> V 加信号量</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>某个资源的只能被有限的人使用，例如为了保证网络通畅，只允许五个人连接。</p><p>不局限于加锁解锁，可以有一定范围。</p><p>当信号量被限制到二元，则退化（？）为互斥锁。</p><p>生产者 / 消费者问题？</p><p>有界缓冲区问题？</p><p>哲学家就餐问题？如何把这些搞哲学的饿死。</p><p><strong>一个使用信号量解决问题的例子</strong></p><p><img src="1.JPG" alt="figure1"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-Critical-Section-Problem&quot;&gt;&lt;a href=&quot;#The-Critical-Section-Problem&quot; class=&quot;headerlink&quot; title=&quot;The Critical-Section Problem&quot;&gt;&lt;/a&gt;The Critical-Section Problem&lt;/h2&gt;&lt;h3 id=&quot;About-Critical-Section&quot;&gt;&lt;a href=&quot;#About-Critical-Section&quot; class=&quot;headerlink&quot; title=&quot;About Critical Section&quot;&gt;&lt;/a&gt;About Critical Section&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;An atomic action is required in a critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The critical section is &lt;strong&gt;not&lt;/strong&gt; a public section. Each process has its own critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Each process must request permission to enter its critical section. The section of code implementing this request is the &lt;strong&gt;entry section&lt;/strong&gt;, the critical section may be followed by an &lt;strong&gt;exit section&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="OS" scheme="http://ilern.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-数据链路层</title>
    <link href="http://ilern.github.io/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/10/15/计算机网络复习笔记-数据链路层/</id>
    <published>2020-10-15T06:55:25.000Z</published>
    <updated>2020-11-08T13:44:20.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>数据链路层的信道种类</p><ul><li>点对点信道<ul><li>一对一通信</li></ul></li><li>广播信道<ul><li>一对多</li><li>需要专门的协议</li></ul></li></ul></li><li><p>链路与数据链路</p><ul><li>链路指一条无源的点到点的线路</li><li>物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路</li></ul></li><li><p>数据链路层的传输单位是帧 Frame</p></li><li><p>数据链路层解决的三个基本问题</p><ul><li>封装成帧</li><li>透明传输</li><li>差错控制</li></ul></li></ul><a id="more"></a><h2 id="链路层的基本功能"><a href="#链路层的基本功能" class="headerlink" title="链路层的基本功能"></a>链路层的基本功能</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul><li>添加首部尾部进行帧定界 <code>SOH</code> Start_of_header <code>EOT</code> End_of_transmission</li><li>帧定界符是特殊的控制字符</li></ul><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul><li>透明就是不透明</li><li>透明传输使得不用关心下层的传输，所采用的设备只是一个通道的作用</li><li>当传输二进制文件中出现定界符序列时，在这个序列之前添加<code>ESC</code>进行转义</li><li>称为 字节填充 / 字符填充<ul><li>在前面的非归零反相编码 NRZI 中有提到比特位填充 <code>bit_stuffing</code></li></ul></li><li>先转义还是先封装?</li></ul><h3 id="差错控制-差错检测"><a href="#差错控制-差错检测" class="headerlink" title="差错控制 / 差错检测"></a>差错控制 / 差错检测</h3><ul><li>误码率 BER<ul><li>$P_e = \frac{N_e}{N}$</li><li>传错的除以总的</li></ul></li><li>噪声的类型<ul><li>热噪声<ul><li>时刻存在、强度低</li><li>高斯白噪声</li><li>引起随机差错</li></ul></li><li>冲击噪声<ul><li>外界电磁干扰引起、强度高</li><li>闪电</li><li>引起突发错</li></ul></li></ul></li><li>纠错码与检错码<ul><li>纠错码适用于错误出现多的情况，可以由接收方发现错误并纠正</li><li>检错码适用于错误出现较少的地方，例如有线网络，发现出错后不进行纠正，直接抛弃</li></ul></li><li>常用检错码<ul><li>奇偶校验<ul><li>最后添加一个校验位</li><li>统计数据码中1的个数</li></ul></li><li>循环冗余编码CRC<ul><li>有纠错能力，但是数据链路层只用它来检错</li></ul></li></ul></li></ul><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><ul><li>生成多项式<ul><li>除数，长度为生成多项式最高项的次数，翻译为二进制为多项式每一项的系数</li></ul></li><li>FCS<ul><li>帧检验序列</li><li>CRC是生成FCS的一种方法但不是唯一方法</li></ul></li><li>无差错接受<ul><li>凡是接受的帧，都可以以非常接近于1的概率认为它正确的</li><li>也有可能因为噪声，所有的位变成了0，但是概率非常小</li></ul></li></ul><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><ul><li>PPP 既能面向Bit也能面向字节 / 字符</li><li>点对点通信</li><li>只支持全双工</li><li>使用广域网进行串行通信</li></ul><h3 id="需要满足的要求"><a href="#需要满足的要求" class="headerlink" title="需要满足的要求"></a>需要满足的要求</h3><ul><li>简单</li><li>链路层功能<ul><li>封装成帧</li><li>透明性</li><li>差错检测</li></ul></li><li>对上与对下<ul><li>多种网络层协议</li><li>多种类型链路</li></ul></li><li>检测连接状态</li><li>最大传送单元<ul><li>MTU</li><li>不包含帧头帧尾</li><li>发送过程中逐步进行调整</li><li>高层协议根据链路层的MTU进行分片</li></ul></li><li>网络层地址协商</li><li>数据压缩协商</li></ul><h3 id="不需要的功能"><a href="#不需要的功能" class="headerlink" title="不需要的功能"></a>不需要的功能</h3><ul><li><p>纠错</p><ul><li>链路层不要求可靠性</li></ul></li><li><p>流量控制</p><ul><li>流量来自于端系统的进程，进程间通信由TCP协议负责</li></ul></li><li><p>序号</p><ul><li>PPP不保证可靠性</li><li>实际上链路层的传输本就很可靠</li></ul></li><li><p>多点链路</p><ul><li>PPP只支持点对点</li></ul></li><li><p>半双工 / 单工链路</p><p>PPP只支持全双工链路</p></li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>一个将IP数据报封装到串行链路的方法<ul><li>面向字符的异步链路</li><li>面向比特的同步链路</li></ul></li><li>链路控制协议 <code>LCP</code> Link Control Protocol<ul><li>与物理层交互</li></ul></li><li><strong>一套</strong>网络控制协议 <code>NCP</code> Network Control Protocol<ul><li>与网络层交互</li><li>每个协议支持一种不同的网络层协议</li></ul></li></ul><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><ul><li>首部<ul><li>定界符 / 定界字节序列　　0x7E</li><li>AC 固定的两个部分，但是说不准以后会有用</li><li>协议<ul><li>0x0021 信息部分为IP数据报</li><li>0xC021 信息部分位PPP链路控制数据</li><li>0x8021 信息部分位网络控制数据</li></ul></li></ul></li><li>信息部分<ul><li>IP数据报</li></ul></li><li>尾部<ul><li>CRC检验序列<ul><li>从AC开始到信息部分结束</li><li>万一以后AC部分有用呢</li></ul></li><li>定界符 / 定界字节序列        0x7E</li></ul></li></ul><h4 id="字节填充"><a href="#字节填充" class="headerlink" title="　字节填充"></a>　字节填充</h4><ul><li>出现控制字符时，前面添加转义字符0x7D，同时第六个bit取反</li></ul><h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><ul><li>SONET / SDH使用同步传输，同步传输中没有 <strong>字符</strong> 的概念</li><li>0x7E = 0111 1110</li><li>5个连续1之后插一个0，保证不出现连续6个1，就不会出现定界符</li></ul><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><ul><li>使用时钟信号线或前同步序列保证发送端与接收端的时钟保持同步</li><li>以数据帧位单位传输</li></ul><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><ul><li>以字符为单位传输</li><li>每个字符前添加起始位0，后面加停止位1，表示数据的开始和结束</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>连接从下往上建立，从上往下释放</p><ul><li>调制解调器建立物理连接</li><li>PC向路由器发送一系列的LCP分组 （0xC021）建立LCP连接</li><li>NCP给新接入的PC分配一个临时的IP地址</li><li>通信</li><li>NCP释放网络层链接，收回临时IP</li><li>LCP释放数据链路层连接</li><li>释放物理层链接</li></ul><h3 id="挑战握手认证协议-CHAP"><a href="#挑战握手认证协议-CHAP" class="headerlink" title="挑战握手认证协议 CHAP"></a>挑战握手认证协议 CHAP</h3><p>在初始链路建立时完成，也可以在链路建立后的任何时刻进行</p><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ul><li><p>IEEE 局域网标准</p><ul><li>IEEE 802.3     CSMA/CD</li><li>IEEE 802.4     令牌总线</li><li>IEEE 802.5     令牌环</li></ul></li><li><p>局域网的特点</p><ul><li>网络为一个单位所拥有，地理范围和站点数目均有限</li></ul></li><li>局域网的拓扑结构<ul><li>环形    环形令牌网</li><li>总线 <ul><li>两端带有匹配电阻吸收电磁波信号的能量</li><li>CSMA/CD</li></ul></li><li>星形</li><li>树形</li></ul></li><li>共享信道<ul><li>静态划分   不能适用于网络的突发性</li><li>动态接入<ul><li>随机接入    需要解决冲突</li><li>受控接入</li></ul></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>使用<strong>曼彻斯特编码</strong>进行数据传输</p><ul><li>不需要尾部的定界符</li><li>可以在$1 \over 2$处不跳变</li></ul></li><li><p>数据链路层的子层</p><ul><li>LLC Logical Link Control<ul><li>面向上层，与传输媒体无关</li></ul></li><li>MAC Medium Access Control<ul><li>面向下层</li><li>数据帧真正完成封装的位置</li></ul></li><li>MAC 子层的功能<ul><li>数据真的封装/卸装</li><li>帧的寻址和识别</li><li>帧的接受和发送</li><li>链路的管理</li><li>帧的差错控制</li><li>仲裁介质的使用权</li></ul></li></ul></li><li>LLC 子层的功能<ul><li>识别网络层协议，进行封装，加上一个LLC报头</li><li>接收方可识别使用了何种局域网</li><li>以太网一统天下，LLC实际作用不大</li></ul></li></ul><h4 id="为什么说以太网很简便"><a href="#为什么说以太网很简便" class="headerlink" title="为什么说以太网很简便"></a>为什么说以太网很简便</h4><ul><li>无连接</li><li>不编号，不要求对方发回确认</li><li>提供不可靠的最大努力交付，高层发现丢失了一些数据帧并进行重传，但是以太网并不知道这是一个重传的帧，而是完全当作一个新的数据帧来发送</li></ul><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器既有链路层的功能，也有物理层的功能</p><ul><li>适配器的主要功能<ul><li>串行/并行转换</li><li>数据缓存</li><li>安装设备驱动程序（设备与CPU通信的媒介）</li><li>实现以太网协议</li></ul></li></ul><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><ul><li><p>CSMA/CD 是<strong>随机征用型</strong>的介质访问控制方法</p></li><li><p>载波监听 多点接入 with 冲突检测</p><ul><li>载波监听  每个站在发送数据前都要检测总线上是否有其他站在发信息</li><li>多点接入  多个站点连接在一根总线上</li><li>冲突检测  边发送数据边检测信道上的信号电压大小，当发现冲突时做出相应处理</li></ul></li><li><p>Carrier Sense Multiple Access with Collision Detection</p></li><li><p>以帧为单位传输</p><ul><li>存在 IFG Interframe Gap 帧间距</li><li>网络设备和组件在接受一个帧后，需要一段时间恢复为接受下一帧做准备</li><li>IFG 最小为96比特时间</li></ul></li></ul><h3 id="站模型"><a href="#站模型" class="headerlink" title="　站模型"></a>　站模型</h3><p>各个站点相互独立，以固定速率产生数据帧。某个站点一旦产生新帧，即使被阻塞，也不会有新的帧产生，直到发送完毕</p><h3 id="单信道假设"><a href="#单信道假设" class="headerlink" title="单信道假设"></a>单信道假设</h3><p>所有通信都是通过单信道进行，任何时刻仅允许一个站点发送，需要争用发送权</p><h3 id="冲突假设"><a href="#冲突假设" class="headerlink" title="冲突假设"></a>冲突假设</h3><p>若两帧同时发送，则产生冲突，所有站点都能检测冲突，冲突的帧必须重发</p><h3 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h3><p>帧可以在任意时刻发送</p><h3 id="侦听假设"><a href="#侦听假设" class="headerlink" title="　侦听假设"></a>　侦听假设</h3><p>所有站点都可以侦听到当前信道的状态，若忙则等待</p><p>但是当某个站监听到总线是空闲时，可能总线并不是真正空闲，因为信号的传播需要时间，也就是之前提到过的<strong>传播时延</strong></p><p>策略：</p><ul><li>非坚持     忙则不等，过会再来看</li><li>１坚持    一直等待，直到空闲</li><li>Ｐ坚持    以概率为P进行等待</li></ul><h3 id="传播时延对载波侦听的影响"><a href="#传播时延对载波侦听的影响" class="headerlink" title="传播时延对载波侦听的影响"></a>传播时延对载波侦听的影响</h3><p>A在 $t=0$ 时刻发送信号，B在$t = \tau - \delta$ 发送信号，两者信号在 $t = \tau - \frac{\delta}{2}$ 时刻碰撞，B在$t = \tau$时刻检测到碰撞，A在$t=2\tau-\delta$ 时刻检测到碰撞，$\tau$指传播时间。</p><p><img src="IMG_4731.PNG" alt="IMG_4731"></p><p>先发送的一方较后检测到冲突。</p><h3 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h3><ul><li>CSMA/CD不能进行全双工通信，只能进行半双工通信 （而PPP只支持全双工通信）</li><li>每个站在发送数据之后的一段时间内，存在着遭遇碰撞的可能性<ul><li>时间的从长短取决于发送方到接收方的距离</li></ul></li><li>发送的不确定性使得整个以太网的平均通信两远小于以太网的最高数据率<ul><li>以太网不能保证某一时间内一定能把自己的数据帧成功发出去</li></ul></li><li>因此以太网必须轻负载，百分之三十左右</li></ul><h3 id="关于碰撞"><a href="#关于碰撞" class="headerlink" title="关于碰撞"></a>关于碰撞</h3><h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><p>在发送数据后至多 $2\tau$ 时间可以知道是否发生冲突，这段时间称为<strong>争用期</strong>或<strong>碰撞窗口</strong>，经过这段时间后还没有检测到碰撞，则说明本次传输不会发生碰撞</p><ul><li>所有以太网取 $51.2 \mu s$ 作为争用期长度<ul><li>以太网的设计决定了最长的2RTT不会超过 $51.2 \mu s$ </li></ul></li><li>对于 10Mb/s 的以太网，争用期内可以发送 512bit 即 64 字节<ul><li>发生冲突一定是在前64字节以内</li><li>最短的有效帧长为64字节</li></ul></li><li>或者说争用期的长度是512比特时间</li></ul><h4 id="截断二进制指数类型退避算法"><a href="#截断二进制指数类型退避算法" class="headerlink" title="截断二进制指数类型退避算法"></a>截断二进制指数类型退避算法</h4><ul><li>碰撞之后退避一段时间再发送</li><li>基本退避时间是$ 2\tau $ （512比特时间），在此基础上乘以$[0, 1, \dots, (2^k - 1)]$中随机一个数，$k$是重传次数，最大为$10$</li><li>争用期的若干倍数</li><li>重传$16$次还是失败，直接丢弃</li><li>会出现<strong>捕获效应</strong>，越退越倒霉</li></ul><h4 id="碰撞发生后"><a href="#碰撞发生后" class="headerlink" title="碰撞发生后"></a>碰撞发生后</h4><ul><li>检测到碰撞立即停止发送数据，并发送干扰信号，让其他主机知道发生了碰撞</li></ul><p><img src="IMG_4734.PNG" alt="image-4734"></p><ul><li>时间的浪费</li></ul><p><img src="IMG_4735.PNG" alt="image-4735"></p><h3 id="整个发送过程"><a href="#整个发送过程" class="headerlink" title="整个发送过程"></a>整个发送过程</h3><p>准备发送</p><p>​    适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中，准备发送</p><p>检测信道</p><p>​    在96比特时间内（IFG 帧间距）没有检测到信道上有信号，就发送</p><p>发送</p><p>​    发送过程中持续检测信道，若检测到碰撞，就终止发送，并发送干扰信号</p><p>终止发送后</p><p>​    执行指数退避算法，等待$r$ 倍的512比特时间，继续检测信道</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>先听后说，边听边说</p><p>一旦冲突，立即停说</p><p>等待时机，然后再说</p><h2 id="使用广播信道的以太网"><a href="#使用广播信道的以太网" class="headerlink" title="使用广播信道的以太网"></a>使用广播信道的以太网</h2><h3 id="以太网物理设备的演进"><a href="#以太网物理设备的演进" class="headerlink" title="以太网物理设备的演进"></a>以太网物理设备的演进</h3><ul><li>粗同轴电缆       10BASE5<ul><li>10Mbit/s，基带信号，最大段长度500m</li><li>站与站之间大于等于2.5m，网络最大跨度2.5km</li><li>中继器：信号的整形与放大</li><li>收发器：发送、接收、冲突检测、电气隔离</li><li>粗缆以太网的冲突检测不靠网卡进行</li></ul></li><li><p>细同轴电缆       10BASE2</p><ul><li>10Mbit/s，基带信号，最大段长度约等于200m</li><li>没有外置收发器</li><li>冲突检测由网卡完成</li></ul></li><li><p>双绞线              10BASE-T</p><ul><li>使用RJ45连接器</li><li>所有站点与集线器相连接</li><li>集线器：信号放大与整形，是物理层设备</li><li>两个集线器连接时要使用交叉链接法</li><li>帧长度可变，最大1518个字节，其中18个字节的MAC头尾，1500个字节的IP数据报</li></ul></li><li>光纤                 10BASE-F</li></ul><h3 id="RJ45连接头"><a href="#RJ45连接头" class="headerlink" title="RJ45连接头"></a>RJ45连接头</h3><p>锁扣朝上，从左到右编号1-8</p><p><img src="IMG_4796.JPEG" alt="IMG-4976"></p><ul><li>为什么要两发两收<ul><li>传送的是差分信号，用两个信号的差值作为传输的信号，相当于放大，更容易识别</li></ul></li></ul><h3 id="集线器的特点"><a href="#集线器的特点" class="headerlink" title="集线器的特点"></a>集线器的特点</h3><ul><li>逻辑总线</li><li>多借口转发器</li><li>转发比特，不进行碰撞检测<ul><li>工作在物理层</li></ul></li></ul><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><ul><li><p>一些时间</p><ul><li>争用期长度为$2 \tau$，是RTT的两倍</li><li>帧长为$L$</li><li>数据发送率为$C$</li><li>帧的发送时间 / 发送时延 / 传输时延 为$\frac{L}{C} = T_0$</li></ul></li><li><p>发送一帧需要经过若干个争用期，然后经过发送时延和传输时延</p><p><img src="IMG_4795.PNG" alt="IMG-4795"></p></li><li><p>$a = \frac{\tau}{T_0}$，$a$小则说明信道利用率高，$a$大则说明每碰撞一次都会浪费许多信道资源</p></li><li><p>减小连线长度 / 增加帧长</p></li><li><p>理想情况下，极限信道利用率为，此时不发生碰撞</p><script type="math/tex; mode=display">S_{\text{max}} = \frac{T_0}{T_0 + \tau} = \frac{1}{1 + a}</script></li></ul><h2 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h2><ul><li>硬件地址 / 物理地址 / MAC地址</li><li>一个主机多个网卡的话就有多个MAC地址</li><li>MAC地址应当理解为某个接口的标识符</li><li>网卡使用MAC地址检查某个帧是不是发给自己</li></ul><h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><p>最常用的是以太网V2标准的格式，IEEE802.3的格式和V2相差无几，我们研究的重点是以太网的V2协议。</p><p><img src="IMG_4834.PNG" alt="img4834"></p><ul><li><p>类型字段用来表示上一层使用的是什么协议</p><ul><li>不一定是<strong>网络层</strong>，比如PPP协议，PPPoE</li></ul></li><li><p>为什么先是目的地址再是源地址</p><ul><li>方便解析，能快速判断是不是发给自己的</li></ul></li><li><p>在使用VLAN虚拟局域网的时候MAC帧的长度可能会超过1518</p><ul><li>1500字节的数据部分</li><li>目的地址6，源地址6，类型2，FCS 4</li></ul></li><li><p><code>0x0800</code>表示IP，<code>0x0806</code>表示ARP</p></li><li><p>最后的FCS校验全部的内容</p><ul><li>不包含帧定界符，因为使用曼彻斯特编码，时钟周期中间不跳变即标明发送结束，不需要帧定界符</li><li>不需要帧定界符也就不需要使用字节插入来实现透明传输</li></ul></li><li><p>当数据字段的长度小于46字节时，再数据字段后面加入整数字节的填充字段</p><ul><li>MAC层因为没有长度计数，所以MAC层并不知道有填充，填充也不发生在MAC层</li><li>填充发生在网络层或者有长度指征的层</li><li>例如IP协议有一个总长度字段，表示MAC层的真实数据字段</li></ul></li><li><p>如何计算传输效率</p><ul><li>$ \frac{X}{X + 18 + 8 + 12}$</li><li>18字节的控制信息，8字节的前同步码，12字节的帧间隔IFG<ul><li>前同步码是一串规律的01序列，用于告知接收方发送方的时钟序列，最后两个11表示准备发送</li><li>同步传输，所以需要前同步码</li></ul></li></ul></li><li><p>无效的MAC帧</p><ul><li>数据字段长度不在46 ~ 1500字节之间<ul><li>46 + 18 = 64，恰好是可以接受的最短帧长</li><li>参看 CSMA/CD  /  关于碰撞 / 争用期</li></ul></li><li>以太网对于无效的MAC帧直接丢弃，不负责重传，由更高层负责</li><li>无效帧的出现不一定因为发生了碰撞。例如断电。</li></ul></li></ul><h3 id="IEEE-802-3的MAC协议"><a href="#IEEE-802-3的MAC协议" class="headerlink" title="IEEE 802.3的MAC协议"></a>IEEE 802.3的MAC协议</h3><ul><li>区别仅在于，第三个字段是长度<strong>或</strong>类型。长度和类型只能有一个，大于<code>0x6000</code>时表示类型， 小于<code>0x6000</code>时表示长度</li><li>因为长度最大不会超过<code>0x6000</code></li><li>当实际长度与长度字段不同时被视为无效帧</li><li>强行让LLC发挥作用</li></ul><h3 id="无效的MAC帧"><a href="#无效的MAC帧" class="headerlink" title="无效的MAC帧"></a>无效的MAC帧</h3><ul><li>802.3协议中数据字段的长度与长度字段不一致</li><li>帧的长度不是整数个字节</li><li>FCS检测出错</li><li>数据字段的长度不在46 ~ 1500字节之间</li></ul><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><ul><li>使用多个集线器级联</li><li>把多个碰撞域合并成一个碰撞域<ul><li>Collision Domain</li><li>所有可能发生冲突的站点的集合</li><li>冲突域被看作物理层的感念</li></ul></li><li>缺点<ul><li>通信效率会下降，但是使得不同局域网可以通信，扩大了以太网覆盖的地理范围</li><li>总的吞吐量没有提高</li><li>数据率不同的碰撞域连接起来会使得较快的无法发挥出自己的吞吐量</li></ul></li></ul><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><ul><li><p>使用网桥 / 转发器</p><ul><li>根据MAC地址进行转发和过滤</li></ul></li><li><p>过滤通信量、增大吞吐量、划分冲突域 / 碰撞域</p></li><li><p>缺点</p><ul><li>需要存储转发，增加了时延</li><li>转发前执行CSMA/CD算法</li><li>没有流量控制，帧多的时候会导致缓存空间不够，发生帧丢失</li><li>不同MAC子层的网段桥接在一起时延更大</li><li>只适合用户数不太多，通信量不太大的局域网</li></ul></li></ul><h4 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h4><ul><li>广播域<ul><li>数据能广播到的范围，能收到同样广播的设备的集合</li><li>是链路层的概念（冲突域是物理层的概念）</li></ul></li><li>产生于网络拓扑的设计和连接问题</li></ul><h3 id="使用交换机扩展以太网"><a href="#使用交换机扩展以太网" class="headerlink" title="使用交换机扩展以太网"></a>使用交换机扩展以太网</h3><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>目前所有的标准网桥都必须支持透明网桥，源路由网桥为可选配置</p><h3 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h3><p><strong>透明网桥的特点</strong></p><ul><li>使用最多</li><li>“透明”，网桥对于站点来说是看不见的</li><li>即插即用，不需要人工配置转发表<ul><li>需要配置转发表的为静态网桥</li></ul></li><li>网桥的转发表不宜过大，有些旧的地址应该淘汰<ul><li>网络拓扑可能变化</li><li>可能由于更换网卡导致MAC地址变化</li><li>不是所有的站点总是接通电源</li><li>有的站点从不发送数据或者长时间不发送数据</li></ul></li></ul><p><strong>透明网桥的缺点</strong></p><ul><li>不能充分利用网络资源，尤其不能保证最佳路由（由于生成树算法导致相距很近的节点可能需要绕圈子）</li><li>为了防止广播风暴的产生，透明网桥只能使用生成树，不能保证每条路由最佳，也不能进行负载均衡</li></ul><h4 id="网桥自学习算法"><a href="#网桥自学习算法" class="headerlink" title="网桥自学习算法"></a>网桥自学习算法</h4><p>分为自学习和转发两个过程</p><ul><li>每一次转发都可以得知发送站相对于自己的<strong>方向</strong>（源地址、进入的接口、时间）<ul><li>如果之前没有与源地址匹配的项目就插入转发表，若有则更新转发表</li><li>但是帧从接口X进入网桥不代表帧发送站在X的网段上</li></ul></li><li>当转发表中无目的地址时无条件进行转发到所有其他接口，记录下发送站相对于自己的方向</li><li>当目的地址和源地址在网桥的同一方向时不需要转发，直接丢弃，转发表不变<ul><li>一个网桥丢弃帧不代表所有的网桥都会丢弃帧</li></ul></li><li>网桥的转发需要拆帧成帧，集线器转发只是整型、放大</li></ul><h4 id="透明网桥的生成树算法"><a href="#透明网桥的生成树算法" class="headerlink" title="透明网桥的生成树算法"></a>透明网桥的生成树算法</h4><ul><li>为了解决广播风暴的问题</li><li>当拓扑结构中存在环的时候求其中的生成树,消除图中的环路，从而保证两个站点之间只有一条路径。</li><li>最小序号网桥作为生成树的根</li><li>网桥为边，网段为节点</li></ul><h3 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h3><ul><li>发送帧时，详细路由信息放在帧的首部</li><li>发送数据帧之前，先发送<strong>发现帧</strong>，发现帧记录经过的路由，到达目的之后按照记住的路由返回</li><li>源站根据这些路由得到一个最佳路由进行发送</li><li>不再透明</li><li>发现帧还能够帮助源点确定整个网络可以通过的帧的最大长度</li><li>可以实现负载均衡</li><li>可以使用最佳路由</li></ul><h3 id="多接口网桥-以太网交换机"><a href="#多接口网桥-以太网交换机" class="headerlink" title="多接口网桥 / 以太网交换机"></a>多接口网桥 / 以太网交换机</h3><ul><li><p>以太网交换机实质上是一个多接口的网桥，交换机出现之后网桥很快被淘汰了</p><ul><li>Multiport Repeater = Hub</li><li>Multiport Bridge = Switch</li></ul></li><li><p>通常工作在链路层，常被称为第二层交换机</p></li><li><p>交换机本质上和网桥一样</p><ul><li>网桥传统上基于软件，交换机基于硬件<ul><li>由数据转发的逻辑部分和输入输出端口组成（input / output port）</li></ul></li><li>两者<strong>等效</strong>而非<strong>等价</strong></li><li>交换机的和网桥一样缩小了网络的冲突域，一个端口就是一个冲突域<ul><li>一个端口连接一个计算机时，仍采用CSMA/CD的控制方法</li><li>只要网络上的用户不同时访问一个接口，而且是全双工通信，就不会发生冲突</li></ul></li></ul></li><li><p>有的交换机还具有差错控制的功能</p></li><li><p>能够提高带宽</p><p><img src="daikuan.png" alt></p></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>收到一个包时可以知道源MAC的机器连在哪个端口的方向上<ul><li>之前有过这一项就更新，没有就添加</li></ul></li><li>转发包时在转发表中查找目的MAC地址<ul><li>如果有则直接复制到目的端口上</li><li>没有则泛洪到所有端口</li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>以太网交换机的每个接口都直接与主机或者另一个集线器相连</li><li>一般使用全双工的工作方式<ul><li>此时CSMA/CD的单信道假设不再成立</li></ul></li><li>能同时联通多对接口，每一对相互通信的主机都可以无碰撞的传输数据</li><li>和透明网桥一样，即插即用，使用自学习法逐步建立转发表</li><li>因为用硬件实现，转发速度较快</li></ul><h4 id="交换技术的种类"><a href="#交换技术的种类" class="headerlink" title="交换技术的种类"></a>交换技术的种类</h4><ul><li>直通方式<ul><li>只检查包头，把数据包转发到输出端口</li><li>转发速率高，但是会转发错误帧</li></ul></li><li>存储转发方式<ul><li>缓存数据包，进行CRC检验，过滤掉不正确的包</li><li>可以让错误包提前过滤掉，但是牺牲效率</li></ul></li><li>无碎片直通方式<ul><li>只检查数据包的长度够不够64字节，只去除无效帧</li><li>介于以上两者之间，比较平衡的方式</li></ul></li></ul><h2 id="虚拟局域网-VLAN"><a href="#虚拟局域网-VLAN" class="headerlink" title="虚拟局域网 VLAN"></a>虚拟局域网 VLAN</h2><p>由<code>IEEE 802.1Q</code>定义</p><ul><li>一些局域网网段构成的与物理位置无关的逻辑组，这些网段有某些共同的需求</li><li>每个VLAN的帧都有明确的标识符，标明这个帧属于哪个VLAN<ul><li>所以帧长会超过1518</li><li><img src="IMG_1543.PNG" alt="IMG_1543"></li></ul></li><li>虚拟局域网是局域网的一种服务，而非另一种新型的局域网</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>安全性</li><li>降低负载的相互影响</li><li>防止广播风暴</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>VLAN中的每一个站点都可以听到同一个VLAN上的其他站点发出的广播</li><li>不会产生广播风暴</li><li>需要路由器或者第三层交换机</li><li>VLAN的工作站可以在不同的局域网（网段）中，也可以不在同一楼中（地理位置）</li></ul><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><h4 id="根据端口来划分"><a href="#根据端口来划分" class="headerlink" title="根据端口来划分"></a>根据端口来划分</h4><ul><li>物理层</li><li>一个或多个交换机上的几个端口划分为一个逻辑组</li><li>一个集线器上的站点只能属于同一个VLAN</li></ul><h4 id="根据MAC地址来划分"><a href="#根据MAC地址来划分" class="headerlink" title="根据MAC地址来划分"></a>根据MAC地址来划分</h4><ul><li>数据链路层</li><li>可以实现同一广播域内站点的自由移动</li><li>但是需要对大量毫无规律的MAC地址进行操作</li></ul><h4 id="根据网路层来划分"><a href="#根据网路层来划分" class="headerlink" title="根据网路层来划分"></a>根据网路层来划分</h4><ul><li>网络层</li><li>按照站点的IP地址来定义广播域，形成虚拟IP子网</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据链路层的信道种类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点信道&lt;ul&gt;
&lt;li&gt;一对一通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广播信道&lt;ul&gt;
&lt;li&gt;一对多&lt;/li&gt;
&lt;li&gt;需要专门的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链路与数据链路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链路指一条无源的点到点的线路&lt;/li&gt;
&lt;li&gt;物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层的传输单位是帧 Frame&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层解决的三个基本问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装成帧&lt;/li&gt;
&lt;li&gt;透明传输&lt;/li&gt;
&lt;li&gt;差错控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习笔记</title>
    <link href="http://ilern.github.io/2020/02/22/learn_SQL/"/>
    <id>http://ilern.github.io/2020/02/22/learn_SQL/</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2020-02-22T14:14:41.501Z</updated>
    
    <content type="html"><![CDATA[<p>非常粗浅的SQL学习笔记，关于如何<strong>使用</strong>SQL。</p><p>笔记中使用开源的MySQL作为数据管理软件。</p><a id="more"></a><h2 id="MySQL-Client"><a href="#MySQL-Client" class="headerlink" title="MySQL Client"></a>MySQL Client</h2><p>安装好MySQL之后，除了服务器以外，还装上了一个客户端，对于数据库的操作都是由这个客户端提供的。客户端通过TCP连接服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接本地服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h &lt;IP&gt; -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接远程SQL服务器。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">-- 显示全部数据库</span><br><span class="line">CREATE DATABASES test;</span><br><span class="line">-- 创建数据库</span><br><span class="line">DROP DATABASES test;</span><br><span class="line">-- 删除数据库</span><br><span class="line">USE test;</span><br><span class="line">-- 切换到某个数据库</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">-- 显示表</span><br><span class="line">CREATE TABLE students</span><br><span class="line">-- 创建表</span><br><span class="line">DROP TABLE students</span><br><span class="line">-- 删除表</span><br><span class="line"></span><br><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br><span class="line">-- 修改列</span><br><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br><span class="line">-- 删除列</span><br></pre></td></tr></table></figure><p><code>ALTER</code>似乎是Alternate的意思，和键盘上的Alt键一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXIT</span><br><span class="line">-- 退出</span><br></pre></td></tr></table></figure><p>这些都是MySQL的操作，对于不同的数据库系统可能有不同的指令。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt;;</span><br><span class="line"><span class="comment">-- 列出某个表的所有行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出符合条件的所有行</span></span><br><span class="line"><span class="comment">-- 条件运算包括 &gt;= / &lt;= / = / &lt;&gt; / AND / OR / NOT 等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_columns&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出想要的列</span></span><br><span class="line"><span class="comment">-- 可以对列起一个别名方便表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt; </span><br><span class="line"><span class="keyword">WHERE</span> &lt;confition&gt; </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt; &lt;<span class="keyword">DESC</span>&gt;;</span><br><span class="line"><span class="comment">-- DESC可以降序排序，默认是升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;conition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_size_of_page&gt;</span><br><span class="line"><span class="keyword">OFFSET</span> &lt;number_of_offset&gt;;</span><br><span class="line"><span class="comment">-- 从&lt;number_of_offset&gt;开始分页显示，每页最多显示&lt;limit_size_of_page&gt;个</span></span><br><span class="line"><span class="comment">-- 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL内置聚合函数</span></span><br><span class="line">COUNT()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">SUM()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">MAX()</span><br><span class="line"><span class="comment">-- 计算某一列的最大值</span></span><br><span class="line">MIN()</span><br><span class="line"><span class="comment">-- 计算某一列的最小值</span></span><br><span class="line">AVG()</span><br><span class="line"><span class="comment">-- 计算某一列的平均值，该列必须为数值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;num_of_colmns&gt;;</span><br><span class="line"><span class="comment">-- 按照列中的值自动分别计算&lt;function&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接查询</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常粗浅的SQL学习笔记，关于如何&lt;strong&gt;使用&lt;/strong&gt;SQL。&lt;/p&gt;
&lt;p&gt;笔记中使用开源的MySQL作为数据管理软件。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://ilern.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://ilern.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>如何实现减法</title>
    <link href="http://ilern.github.io/2020/01/22/how_to_diff/"/>
    <id>http://ilern.github.io/2020/01/22/how_to_diff/</id>
    <published>2020-01-22T13:33:00.000Z</published>
    <updated>2020-03-11T00:08:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。</p><p>将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。</p><p>至此就实现了二进制加法。</p><p>每一个全加器只能计算<strong>一位</strong>二进制数，要进行多位二进制数的加法就需要串联多个全加器。</p><a id="more"></a><h2 id="大数减小数"><a href="#大数减小数" class="headerlink" title="大数减小数"></a>大数减小数</h2><p>对于减法而言，不存在进位，但是有借位。</p><p>为了避免借位，提出<strong>补数</strong>的概念</p><blockquote><p>对于一个 $k$ 进制数 $a$ ，从一串 $k$ 中（个数等于 $k$ 进制下 $a$ 的位数）减去 $a$ 得到的数，称为 $a$ 对 $k$ 的补数</p></blockquote><p>提出补数的好处是计算补数的过程不需要借位</p><p>当计算出补数之后，将补数与被减数<strong>相加</strong>，把结果加一，再减去$10^n$，$n$为$a$的位数。</p><p>为什么这样可行？举个例子</p><script type="math/tex; mode=display">\begin{align}   253 - 176 &= 253 - 176 + 1000 - 1000 \\   &= 253 - 176 + 999 + 1 - 1000  \\   &= 253 + (999 - 176) + 1 - 1000\\\end{align}</script><p>二进制的减法与之类似。</p><p>注意到现在式子中唯一的减法其实就是求这个数的补数。</p><p>对于一个二进制数，计算它的补数只需要对其按位取反，也就是它的<strong>反码</strong>(inverse)。</p><p>并且，对于最后一步减法，也是不必真的做的，最高位会自然溢出，作为进位被丢掉。</p><p>至此，大数减小数的减法就实现了。</p><h2 id="表示负数"><a href="#表示负数" class="headerlink" title="表示负数"></a>表示负数</h2><p>首先明确一点，计算机处理的位数是有限的，超过最高位的数将会溢出。</p><h2 id="小数减大数"><a href="#小数减大数" class="headerlink" title="小数减大数"></a>小数减大数</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。&lt;/p&gt;
&lt;p&gt;将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。&lt;/p&gt;
&lt;p&gt;至此就实现了二进制加法。&lt;/p&gt;
&lt;p&gt;每一个全加器只能计算&lt;strong&gt;一位&lt;/strong&gt;二进制数，要进行多位二进制数的加法就需要串联多个全加器。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="《编码》笔记" scheme="http://ilern.github.io/tags/%E3%80%8A%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业三 邮件服务器</title>
    <link href="http://ilern.github.io/2019/11/27/Computer-Networking-Lab-3/"/>
    <id>http://ilern.github.io/2019/11/27/Computer-Networking-Lab-3/</id>
    <published>2019-11-26T16:00:00.000Z</published>
    <updated>2019-11-27T14:52:36.345Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业三</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>通过完成本实验，您将更加了解SMTP协议。您还将学到使用Python实现标准协议的经验。</p><p>您的任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。您的客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>在某些情况下，接收邮件服务器可能会将您的电子邮件分类为垃圾邮件。当您查找从客户端发送的电子邮件时，请检查垃圾邮件文件夹。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于某些众所周知的原因，本实验不使用Google邮箱，而是使用QQ邮箱。</p><p>基本流程如下</p><ul><li>与QQ邮箱服务器（smtp.qq.com）建立TCP连接，这里为了简单起见，使用非SSL协议的25端口。其他邮件服务器见这篇文章：<a href="https://blog.csdn.net/qq_25046261/article/details/78982080" target="_blank" rel="noopener">常用的邮件服务器名称、地址及SSL/非SSL协议端口号</a>。成功建立连接之后，服务器会返回状态码220表示已就绪。</li><li>发送 HELO 命令，输入自己的账户，开始试图与服务器交互。</li><li>发送 AUTH LOGIN 命令，输入密码。这里的密码指的是<strong>邮件服务器提供的授权码</strong>，而不是平时在web端登录的密码。</li><li>上面提到的用户名和密码都是<strong>经过Base64加密后的结果</strong>。我在这一步卡了很久，最后发现原因是在网上找的Base64加密工具给出的结果是错的，换一个工具就好了。</li><li>登录成功后，服务器会返回状态码235表示成功。</li><li>发送 MAIL FROM 命令，表明发信人，应当与 HELO-AUTH 命令中验证的邮箱保持一致。成功后会收到 <code>250 OK</code>的回复。</li><li>发送 RCPT TO 命令，表明收信人。成功后会收到 <code>250 OK</code> 的回复。</li><li>发送 DATA 命令，表明自己要开始发送信息了。 服务器将返回状态码354 。</li><li>发送邮件内容，最开头要有<code>\r\n</code>，每条信息结尾也要有<code>\r\n</code>，最后要发送一个<code>\r\n.\r\n</code>表明邮件内容的结束。</li><li>发送 QUIT 命令，结束与邮件服务器的连接。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="https://s2.ax1x.com/2019/11/27/QC5J3R.png" alt="yh"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业三&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业二 UDP ping 程序</title>
    <link href="http://ilern.github.io/2019/11/16/Computer-Networking-Lab-2/"/>
    <id>http://ilern.github.io/2019/11/16/Computer-Networking-Lab-2/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2019-11-17T02:44:16.302Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业二</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>在这个编程作业中，你将用Python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序，然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第4章中学习ICMP）。此时我们将创建一个非标准（但简单）的基于UDP的ping程序。</p><p>你的ping程序经UDP向目标服务器发送10个ping报文，对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为1秒；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。</p><p>在此作业中，我们给出服务器的完整代码（在配套网站中可以找到。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以不受限制地从服务器代码中剪贴代码行。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>在服务端与客户端建立UDP连接</li><li>循环发送十条信息，在发出和接收的位置分别计时</li><li>每接收到一条回复，把两个时间相减得到RTT</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>在判断超时的时候，<code>socket</code>自带了一个时长限定，当超出这个时间之后会抛出<code>timeout</code>异常。</li><li><code>time.perf_counter()</code>是以秒为单位的计时。</li><li>服务端模拟丢包率为 $30 \%$ ，实际结果与其格外吻合。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>【客户端】<br><img src="https://s2.ax1x.com/2019/11/16/MBnItH.png" alt="cilent"></p><p>【服务端】<br><img src="https://s2.ax1x.com/2019/11/16/MBuShj.md.png" alt="server"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业二&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
