<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iLern&#39;s Blog</title>
  
  <subtitle>Do what you love, love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ilern.github.io/"/>
  <updated>2019-08-08T05:14:45.806Z</updated>
  <id>http://ilern.github.io/</id>
  
  <author>
    <name>iLern</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 1+2</title>
    <link href="http://ilern.github.io/2019/08/06/acmsummer_312/"/>
    <id>http://ilern.github.io/2019/08/06/acmsummer_312/</id>
    <published>2019-08-06T08:37:23.000Z</published>
    <updated>2019-08-08T05:14:45.806Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316346" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/316349" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练2</a></p><a id="more"></a><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Ultra-QuickSort-树状数组求逆序对-离散化"><a href="#C-Ultra-QuickSort-树状数组求逆序对-离散化" class="headerlink" title="C - Ultra-QuickSort - 树状数组求逆序对 + 离散化"></a><a href="https://cn.vjudge.net/contest/316346#problem/C" target="_blank" rel="noopener">C - Ultra-QuickSort - 树状数组求逆序对 + 离散化</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列，求对于升序排序的逆序对个数</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>树状数组求逆序对的模板题。</p><p>树状数组可以处理的问题是前缀和，对于某个元素来说，升序排序的逆序对的个数就是位置在它后面数值比他小的数的个数，这个就是一个前缀和的问题了。</p><p>对于每个元素，记录他的值和他的位置，按照从数值小到大的顺序排序去重完成离散化之后，把原数组从后往前的每个元素在排序好的数组中找到位置，用树状数组维护这个位置数组，这个位置的前缀和就是这个数逆序数，在找到的位置处加一。</p><p>例如 </p><script type="math/tex; mode=display">a = [9, 1, 0, 5, 4] \\a' = [0, 1, 5, 4, 9]\\</script><p>从后往前遍历 <code>a</code> 数组，</p><p>首先找到 $4$ ，在 <code>a&#39;</code> 数组中查找发现 $4$ 在第 $4$ 个位置，在树状数组中查询 $4$ 这个位置，发现前缀为 $0$ ，也就是 $4$ 后面数值比他小的数的个数为 $0$ ，也就是 $4$ 对于逆序数的贡献为 $0$，接下来在树状数组中把 $4$ 这个位置加一，</p><p>接下来找到 $5$ , 在 <code>a&#39;</code> 数组中查找发现 $5$ 在第 $3$ 个位置，在树状数组中查询 $3$ 这个位置，发现前缀为 $1$ ，也就是之前插入的 $4$，这说明 $5$ 后面数值比他小的数的个数为 $1$，也就是 $5$ 对于逆序数的贡献为 $1$，接下来在树状数组中把 $3$ 这个位置加一，</p><p>以此类推，最后的结果就是逆序对的总数。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    Bit(<span class="keyword">int</span> size) : size(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        bit.size = n;</span><br><span class="line">        <span class="built_in">memset</span>(bit.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit.a));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            v.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator newEnd = <span class="built_in">std</span>::unique(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">std</span>::lower_bound(v.begin(), newEnd, a[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">            ans += bit.query(index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            bit.modify(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理"><a href="#E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理" class="headerlink" title="E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3333" target="_blank" rel="noopener">E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列和若干询问，对于每个询问给出区间中不重复的元素的和</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>单独的一棵线段树/树状数组不能维护所有区间的不重复元素和，需要主席树等数据结构，这里的做法是离线处理每个查询。</p><p>把所有询问存下来，按照右端点从小到大排序，从小到大依次处理每个询问，对于一个新的询问，考察比上一个询问扩展出来的部分是否有之前出现过的元素，如果有就把之前的元素删除，把最近的加入，这样就保证了每个元素在每个询问中只出现一次，且是所有出现中最右边的那个。</p><p>更新完之后就可以用树状数组查询了。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        bit.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        bit.size = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            v.push_back(Query(l, r, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= it-&gt;r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.count(a[i])) bit.modify(mp[a[i]], -a[i]);</span><br><span class="line"></span><br><span class="line">                bit.modify(i, a[i]);</span><br><span class="line">                mp[a[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(<span class="built_in">std</span>::make_pair(it-&gt;id, bit.query(it-&gt;r) - bit.query(it-&gt;l - <span class="number">1</span>)));</span><br><span class="line">            l = it-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理"><a href="#F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理" class="headerlink" title="F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener">F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理</a></h2><h3 id="【题目大意】-2"><a href="#【题目大意】-2" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>马里奥吃金币，马里奥有在每个区间里有一个跳跃高度，只能吃到小于等于这个高度的硬币，给出若干组询问，问某个区间中能吃到多少金币。</p><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>离线处理所有询问，把每个点和每个询问都按照高度从小到大排序，排序后从小到大考察每个询问。</p><p>利用树状数组前缀求和的特点，只需要设置一个变量表示现在到了哪个金币，如果这个金币的高度小于当前询问的高度，就加入到树状数组当中，因为询问高度是单调增的，所以在前面的询问中加入的点仍然满足后面询问的条件，这样就只需要用树状数组维护一下区间和了。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; qs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i].h);</span><br><span class="line">            num[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;qs[i].l, &amp;qs[i].r, &amp;qs[i].h);</span><br><span class="line">            qs[i].l++;</span><br><span class="line">            qs[i].r++;</span><br><span class="line"></span><br><span class="line">            qs[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(qs, qs + m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt;= n &amp;&amp; num[cnt].h &lt;= qs[i].h) &#123;</span><br><span class="line">                bit.modify(num[cnt++].id, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[qs[i].id] = bit.query(qs[i].r) - bit.query(qs[i].l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="C-An-easy-problem-线段树维护区间乘积"><a href="#C-An-easy-problem-线段树维护区间乘积" class="headerlink" title="C - An easy problem - 线段树维护区间乘积"></a><a href="https://cn.vjudge.net/contest/316349#problem/C" target="_blank" rel="noopener">C - An easy problem - 线段树维护区间乘积</a></h2><h3 id="【题目大意】-3"><a href="#【题目大意】-3" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>令$x = 1$，给出两种操作</p><ul><li>操作<code>(1, a)</code>表示令 $x = a \cdot x$ </li><li>操作<code>(2, i)</code>表示令 $x = \frac{x}{a[i]}$，其中 $a[i]$ 表示第 $i$ 个一号操作中的<code>a</code>。</li></ul><p>问经过若干次操作之后 $x$ 的值是多少。</p><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>看上去维护一个数的更改，和线段树没有什么关系，其实把所有的一操作看作一个序列，问题就变成了维护区间乘积，二操作相当于把序列中的某个位置改成 $1$ ，这样就可以用线段树维护单点修改和区间乘积了。</p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> data;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="number">1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = (lc-&gt;data % mod * rc-&gt;data % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line">            <span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r)) % mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r) % mod) % mod;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;q, &amp;mod);</span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, q);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) root-&gt;modify(i, x);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) root-&gt;modify(x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;query(<span class="number">0</span>, q));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-HDU-2795-Billboard-线段树变形"><a href="#G-HDU-2795-Billboard-线段树变形" class="headerlink" title="G - HDU 2795 -Billboard - 线段树变形"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2795" target="_blank" rel="noopener">G - HDU 2795 -Billboard - 线段树变形</a></h2><h3 id="【题目大意】-4"><a href="#【题目大意】-4" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一个广告牌，有很多人往上贴广告，每个广告占一个单位高度，若干单位长度，广告优先往上边贴，同样高度情况下优先往左边贴，如果没有空间贴，就不贴。</p><p>对于每一张广告，询问它被贴在哪一行。</p><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题的修改的基本单位是行，以行为单位划分区间，想象把广告牌逆时针旋转九十度，建立线段树。</p><p>线段树维护每个区间中剩余空间的最大值，如果我们想贴一张新的海报上去，先与线段树的根节点值比较，如果大于根节点的值，说明所有行都没有空间贴这张新的海报；如果小于，就再与左右节点比较，以此类推，直到找到能贴的位置，注意要先和左子树比较再和右子树比较，因为要求尽量贴得高，旋转之后就是尽量贴得左。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = w;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="built_in">std</span>::max(lc-&gt;data, rc-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", this-&gt;l, this-&gt;r);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data = SegmentTree::w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int query(int l, int r) &#123;</span></span><br><span class="line">    <span class="comment">//     if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return this-&gt;data;</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         int ans = INT_MIN;</span></span><br><span class="line">    <span class="comment">//         if (l &lt; mid) ans = std::max(ans, query(l, std::min(r, mid)));</span></span><br><span class="line">    <span class="comment">//         if (r &gt; mid) ans = std::max(ans, query(std::max(l, mid), r));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         return ans;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data -= delta;</span><br><span class="line">            <span class="comment">// if (ans &lt;  this-&gt;id) ans = this-&gt;id;</span></span><br><span class="line">            ans = <span class="keyword">this</span>-&gt;id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lc-&gt;data &gt;= delta) lc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rc-&gt;data &gt;= delta) rc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d %d], data = %d\n"</span>, <span class="keyword">this</span>-&gt;l, <span class="keyword">this</span>-&gt;r, <span class="keyword">this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (lc) lc-&gt;print();</span><br><span class="line">        <span class="keyword">if</span> (rc) rc-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SegmentTree::w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree::w = w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int m = h;</span></span><br><span class="line">        <span class="comment">// if (h &gt; n) m = n;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">200000</span>) h = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("m = %d\n", m);</span></span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, h);</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", root-&gt;l, root-&gt;r);</span></span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("root-&gt;data = %d\n", root-&gt;data);</span></span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;modify(x) != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316346&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 4</title>
    <link href="http://ilern.github.io/2019/08/04/acmsummer_24/"/>
    <id>http://ilern.github.io/2019/08/04/acmsummer_24/</id>
    <published>2019-08-04T08:37:23.000Z</published>
    <updated>2019-08-02T11:11:40.382Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练二，题目多为思维题，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/314478#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练二，题目多为思维题，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/314478#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 3</title>
    <link href="http://ilern.github.io/2019/08/01/acmsummer_23/"/>
    <id>http://ilern.github.io/2019/08/01/acmsummer_23/</id>
    <published>2019-08-01T08:37:23.000Z</published>
    <updated>2019-08-02T08:53:43.242Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练一，题目简单且友好，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314466#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练1</a></p><a id="more"></a><h2 id="D-D1-Add-on-a-Tree"><a href="#D-D1-Add-on-a-Tree" class="headerlink" title="D - D1. Add on a Tree"></a><a href="https://cn.vjudge.net/contest/314466#problem/D" target="_blank" rel="noopener">D - D1. Add on a Tree</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一棵树，在这棵树上有这样的操作：选择两个叶节点，将连接他们的路径上的边全部加上某个<strong>实数</strong> 。</p><p>问是否任意的边权都能通过这种方法构造出来。</p><p><img src="https://vj.ti12z.cn/534562b9f71c214456d4ad6501057031?v=1564228755" alt="NO"></p><p>这棵树不满足条件</p><p><img src="https://vj.ti12z.cn/c3350c6775c16b2e8fc87ea1963db02a?v=1564228755" alt="YES"></p><p>这棵树满足条件</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始以为是 <code>LCA</code> 结果是普通的思维题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-B-Letters-Shop-二分查找"><a href="#G-B-Letters-Shop-二分查找" class="headerlink" title="G - B. Letters Shop - 二分查找"></a><a href="https://cn.vjudge.net/contest/314466#problem/G" target="_blank" rel="noopener">G - B. Letters Shop - 二分查找</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 $S$ ，从中取前缀组合成新的字符串，给出目标字符串，输出最小需要的前缀的长度，数据保证目标串一定可以由 $S$ 的前缀的字符重新组合而成。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不关心目标串中字符出现的顺序，只要前缀中相应字符的数目多于目标串中该字符数目即可，先预处理出每个前缀中的每个字母的个数，对于每个目标串，统计其中各个字母的个数，与每个前缀比较，满足条件即可。</p><p>朴素的线性比较会<code>TLE</code>，改成二分查找即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>][s[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">        a[i][s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line">        fill(b, b + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s1) &#123;</span><br><span class="line">            b[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[mid][k] &lt; b[k]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; l + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-B-Yet-Another-Crosses-Problem-模拟"><a href="#H-B-Yet-Another-Crosses-Problem-模拟" class="headerlink" title="H - B. Yet Another Crosses Problem - 模拟"></a><a href="https://cn.vjudge.net/contest/314466#problem/H" target="_blank" rel="noopener">H - B. Yet Another Crosses Problem - 模拟</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一些方格图，<br><img src="https://vj.ti12z.cn/b3bf19b1108c5f82bd973def2f3b1a20?v=1564477339" alt="pic1"></p><p><img src="https://vj.ti12z.cn/0f6acf44abaaaf4dade9e99d5c3067c9?v=1564477339" alt="pic2"></p><p>现在需要把一些白格子染成黑色，使得图里存在至少一个<code>cross</code>（如pic2）。</p><p>问最少染几个白格子。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>之前在cf上遇到了这题，当时没做出来。</p><p>其实很简单，要构成<code>cross</code>必须至少有一整行和一整列都是黑色的，那就把每行每列有多少黑色统计出来，枚举每种行列的组合，找出一个黑色数目最多的，把剩下的染上就行了。</p><p>但是有一个问题是，行数和列数的最大值都很大，开二维数组是开不下的。注意到虽然 $n, m$ 都很大，但是 $n \cdot m$ 是不大的，所以用 <code>std::string</code> 数组比较好</p><p>深夜果然容易神志不清。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row[MAXN], col[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'*'</span>) row[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'*'</span>) col[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, row[i] + col[j] - (s[i][j] == <span class="string">'*'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n + m - <span class="number">1</span> - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练一，题目简单且友好，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314466#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 1+2</title>
    <link href="http://ilern.github.io/2019/07/31/acmsummer_212/"/>
    <id>http://ilern.github.io/2019/07/31/acmsummer_212/</id>
    <published>2019-07-31T08:37:23.000Z</published>
    <updated>2019-08-03T13:51:31.826Z</updated>
    
    <content type="html"><![CDATA[<p>基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314459" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/314460" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练2</a></p><a id="more"></a><h1 id="新的邻接表写法"><a href="#新的邻接表写法" class="headerlink" title="新的邻接表写法"></a>新的邻接表写法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dfn, degree;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), degree(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v]));</span><br><span class="line">    nodes[v].edges.push_back(Edge(&amp;nodes[v], &amp;nodes[u]));</span><br><span class="line"></span><br><span class="line">    nodes[u].degree++;</span><br><span class="line">    nodes[v].degree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的好处是多组数据初始化的时候边的删除很方便，尤其相对于之前的版本来说。</p><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Skiing-最短路"><a href="#C-Skiing-最短路" class="headerlink" title="C - Skiing - 最短路"></a><a href="https://cn.vjudge.net/contest/314459#problem/C" target="_blank" rel="noopener">C - Skiing - 最短路</a></h2><h2 id="F-Sorting-It-All-Out-拓扑排序"><a href="#F-Sorting-It-All-Out-拓扑排序" class="headerlink" title="F - Sorting It All Out - 拓扑排序"></a><a href="https://cn.vjudge.net/contest/314459#problem/F" target="_blank" rel="noopener">F - Sorting It All Out - 拓扑排序</a></h2><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="D-Caterpillar-DFS"><a href="#D-Caterpillar-DFS" class="headerlink" title="D - Caterpillar - DFS"></a><a href="https://cn.vjudge.net/contest/314460#problem/D" target="_blank" rel="noopener">D - Caterpillar - DFS</a></h2><h2 id="E-昂贵的聘礼"><a href="#E-昂贵的聘礼" class="headerlink" title="E - 昂贵的聘礼 "></a><a href="https://cn.vjudge.net/contest/314460#problem/E" target="_blank" rel="noopener">E - 昂贵的聘礼 </a></h2><h2 id="F-最短路径问题-最短路"><a href="#F-最短路径问题-最短路" class="headerlink" title="F - 最短路径问题 - 最短路"></a><a href="https://cn.vjudge.net/contest/314460#problem/F" target="_blank" rel="noopener">F - 最短路径问题 - 最短路</a></h2><h2 id="K-Highways"><a href="#K-Highways" class="headerlink" title="K - Highways "></a><a href="https://cn.vjudge.net/contest/314460#problem/K" target="_blank" rel="noopener">K - Highways </a></h2><h2 id="L-Truck-History"><a href="#L-Truck-History" class="headerlink" title="L - Truck History "></a><a href="https://cn.vjudge.net/contest/314460#problem/L" target="_blank" rel="noopener">L - Truck History </a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>差分约束系统学习笔记</title>
    <link href="http://ilern.github.io/2019/07/30/difference_constraints/"/>
    <id>http://ilern.github.io/2019/07/30/difference_constraints/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:38:45.435Z</updated>
    
    <content type="html"><![CDATA[<p>数学问题转化到图论上解决，有点巧妙。</p><a id="more"></a><p>差分约束系统是一种特殊的 $N$ 元一次不等式组。包含 $N$ 个变量，$M$ 个约束条件，每个约束条件都是以差分的形式给出，形如 $X_i - X_j \leq c_k$。</p><p>现在要求 $X_i$ 的一组解，使得所有不等式成立。</p><p>对于这样的问题，有一个统一的转化方法：</p><ul><li>把不等式表示成 $X_i - X_j \leq c_k$ 的形式，</li><li>把每个变量 $X_i$ 看作 <strong>有向图</strong> 中的一个结点 $i$，把每个约束条件 $X_i - X_j \leq c_k$ 看作从 $i$ 到 $j$ 连一条长度为 $c_k$ 的有向边，</li><li>注意到此时建立的图不一定联通，需要添加一个超级源点，从 $0$ 号结点向每个点连一条边权为$0$ 的边。</li><li>用 <strong>spfa</strong> 求出 $0$ 号点到各个点的最短路，如果最短路存在，那么每个点的 <code>dis</code> 值就是原不等式组的一组解。</li><li>如果有负环，则解不存在，为了解决负环的问题，只能用 <strong>spfa</strong> 来求最短路。</li></ul><p>为什么这样是对的？看上去毫不相干的不等式怎么和最短路怎么联系起来的呢？<br><del>其实不知道也没关系</del></p><p><a href="https://blog.csdn.net/PleasantlY1/article/details/82775505" target="_blank" rel="noopener">有空就学</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数学问题转化到图论上解决，有点巧妙。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[Poj 3169] Layout - 差分约束 + spfa</title>
    <link href="http://ilern.github.io/2019/07/30/poj_3169/"/>
    <id>http://ilern.github.io/2019/07/30/poj_3169/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:51:45.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>遇到这题才去学的<a href="https://ilern.github.io/2019/07/30/difference_constraints/">差分约束系统</a>。</p><p>明显题目中给出了关于两元素差的不等式，是差分约束的模型，转化成标准的模式 $a - b \leq c$，建图之后<code>SPFA</code>求出最短路即可，答案为<code>nodes[n].dis</code>。 </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dis, times;</span><br><span class="line">    <span class="keyword">bool</span> inQue;</span><br><span class="line"></span><br><span class="line">    Node() : dis(INT_MAX), times(<span class="number">0</span>), inQue(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;times++;</span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = v-&gt;edges.begin(); it != v-&gt;edges.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;to-&gt;dis &gt; v-&gt;dis + it-&gt;w) &#123;</span><br><span class="line">                it-&gt;to-&gt;dis = v-&gt;dis + it-&gt;w;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!it-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    it-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                    it-&gt;to-&gt;times++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;to-&gt;times &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    q.push(it-&gt;to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ml, md;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;ml, &amp;md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &lt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, -w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; n; i++) addEdge(i, i + 1, 0);</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) addEdge(0, i, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spfa(nodes + <span class="number">1</span>, n)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[n].dis == INT_MAX) <span class="built_in">printf</span>(<span class="string">"-2"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[n].dis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目大意】&quot;&gt;&lt;a href=&quot;#【题目大意】&quot; class=&quot;headerlink&quot; title=&quot;【题目大意】&quot;&gt;&lt;/a&gt;【题目大意】&lt;/h3&gt;&lt;p&gt;有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="差分约束" scheme="http://ilern.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-4</title>
    <link href="http://ilern.github.io/2019/07/27/acmsummer_14/"/>
    <id>http://ilern.github.io/2019/07/27/acmsummer_14/</id>
    <published>2019-07-27T15:37:23.000Z</published>
    <updated>2019-07-30T10:15:32.607Z</updated>
    
    <content type="html"><![CDATA[<p>第一周限时训练二</p><p><img src="https://s2.ax1x.com/2019/07/30/eJG8hT.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/312636" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周限时训练二&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/30/eJG8hT.png&quot; alt=&quot;rank&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/312636&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt;限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-3</title>
    <link href="http://ilern.github.io/2019/07/26/acmsummer_13/"/>
    <id>http://ilern.github.io/2019/07/26/acmsummer_13/</id>
    <published>2019-07-26T15:37:23.000Z</published>
    <updated>2019-07-30T10:07:52.832Z</updated>
    
    <content type="html"><![CDATA[<p>第一周限时训练一</p><p><img src="https://s2.ax1x.com/2019/07/27/euRsht.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312627#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练1</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周限时训练一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/27/euRsht.png&quot; alt=&quot;rank&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/312627#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt;限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-2</title>
    <link href="http://ilern.github.io/2019/07/25/acmsummer_12/"/>
    <id>http://ilern.github.io/2019/07/25/acmsummer_12/</id>
    <published>2019-07-25T08:37:23.000Z</published>
    <updated>2019-07-27T09:03:22.611Z</updated>
    
    <content type="html"><![CDATA[<p>数学与DP专题二，比较难，不怎么会</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312624" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em> 专题训练2</a></p><a id="more"></a><h2 id="A-Easy-Game-区间DP"><a href="#A-Easy-Game-区间DP" class="headerlink" title="A - Easy Game - 区间DP "></a><a href="https://cn.vjudge.net/contest/312624#problem/A" target="_blank" rel="noopener">A - Easy Game - 区间DP </a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组，$A，B$ 两人轮流从数组的开头或结尾取走一个或若干个连续的数，取走的数的和记为得分。现在 $A$ 先开始这个游戏，问在最优情况下 $A$ 比 $B$ 多得多少分</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看上去像博弈，其实是DP</p><p>设状态 $f(l, r)$ 表示在左闭右开区间（取决于具体实现） $[l, r)$ 中取数字，在最优情况下的得分。（不区分$A ,B$）<br>设函数 $sum(l, r)$ 表示开区间 $[l, r)$ 的所有数字的和，用前缀和数组实现。</p><p>则转移为:</p><script type="math/tex; mode=display">f(l, r) = sum(l ,r) - \min\{minR, minL\}</script><script type="math/tex; mode=display">minR = \min_{l \leq i \leq r} \{f(i ,r)\}</script><script type="math/tex; mode=display">minL = \min_{l \leq i \leq r} \{f(l, i)\}</script><p>由于 $A$ 先手，我们可以让 $B$ 的收益最小来使得 $A$ 的收益最大，$minL$ 和 $minR$ 分别表示从左边取和从右边取能留下来的最小 $f$ 值，区间和减去剩下的最小值，就是取走的最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], sum[MAXN], f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[r - <span class="number">1</span>] - sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            f[i][i + <span class="number">1</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[l, r)</span></span><br><span class="line">        <span class="comment">//[1, n + 1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len &lt;= n + <span class="number">1</span>; l++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + len;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> minL = f[l + <span class="number">1</span>][r];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) minL = <span class="built_in">std</span>::min(minL, f[i][r]);</span><br><span class="line">                <span class="keyword">int</span> minR = f[l][r - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; i--) minR = <span class="built_in">std</span>::min(minR, f[l][i]);</span><br><span class="line"></span><br><span class="line">                f[l][r] = getSum(l, r) - <span class="built_in">std</span>::min(<span class="number">0</span>, <span class="built_in">std</span>::min(minL, minR));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cnt, f[<span class="number">1</span>][n + <span class="number">1</span>] - sum[n] + f[<span class="number">1</span>][n + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// printf("----------\n");</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 2; j &lt;= n + 1; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         printf("%5d ", f[i][j]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     printf("\n");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4 -10 -20 7</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure><h2 id="B-The-Fewest-Coins-混合背包"><a href="#B-The-Fewest-Coins-混合背包" class="headerlink" title="B - The Fewest Coins  - 混合背包"></a><a href="https://cn.vjudge.net/contest/312624#problem/B" target="_blank" rel="noopener">B - The Fewest Coins  - 混合背包</a></h2><h2 id="C-String-painter-区间DP"><a href="#C-String-painter-区间DP" class="headerlink" title="C - String painter - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/C" target="_blank" rel="noopener">C - String painter - 区间DP</a></h2><h2 id="D-Max-Sum-Plus-Plus-区间DP"><a href="#D-Max-Sum-Plus-Plus-区间DP" class="headerlink" title="D - Max Sum Plus Plus - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/D" target="_blank" rel="noopener">D - Max Sum Plus Plus - 区间DP</a></h2><h2 id="E-Constructing-Roads-In-JGShining’s-Kingdom-最长上升子序列"><a href="#E-Constructing-Roads-In-JGShining’s-Kingdom-最长上升子序列" class="headerlink" title="E - Constructing Roads In JGShining’s Kingdom - 最长上升子序列"></a><a href="https://cn.vjudge.net/contest/312624#problem/E" target="_blank" rel="noopener">E - Constructing Roads In JGShining’s Kingdom - 最长上升子序列</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一些穷国和一些富国分别排在两条直线上，每个穷国和一个富国之间可以建道路，但是路不能交叉，给出每个穷国和富国的联系，求最多能建多少条路</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>把富国编号从大到小排序，问题转化为求最长上升子序列。</p><p>朴素的$O(n^2)$的最长上升子序列求法会<code>TLE</code>，需要用优化后的$O(n\log n)$的算法。</p><p>简述如下：</p><p>舍弃之前的 <code>f</code> 数组，另设立一个数组 <code>d[len]</code> 记录长度为 <code>len</code> 的最长上升子序列的最小结尾。</p><p>每次读到一个新的数字，如果这个数字比 <code>d</code> 数组的最后一个元素还要大，说明这个数可以续在 <code>d</code> 数组最后一个元素的后面使最长上升子序变长，此时<code>d[++len] = a[i]</code>。</p><p>如果这个数字比<code>d</code>数组的最后一个元素要小，就在 <code>d</code> 数组中找到比这个数小的最大的数，用这个数去更新 <code>d</code> 数组，这一步可以用 <code>std::lower_bound()</code> 完成，这也是复杂度中<code>log</code>的来源。</p><p>为什么这这样是对的？</p><ul><li>由于<code>d</code>数组定义为长度为 <code>len</code> 的最长上升子序列的最小结尾，如果想让<code>d</code>数组长度增加，则新元素大小必定增加，所以<code>d</code>数组单调，可以二分。</li><li>关于<code>d</code>数组的更新，状态<code>i + 1</code>一定是从状态<code>i</code>转移过来的，此时我们选择一个更小的数作为状态<code>i</code>的值，一定不会比原先的选择更劣，所以这样的更新也是成立的。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a &lt; a.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].a, &amp;nodes[i].b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(nodes, nodes + n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = nodes[<span class="number">0</span>].b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i].b &gt; ans[len - <span class="number">1</span>]) ans[(++len) - <span class="number">1</span>] = nodes[i].b;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="built_in">std</span>::lower_bound(ans, ans + len, nodes[i].b) - ans;</span><br><span class="line">                ans[pos] = nodes[i].b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     printf("%d ", ans[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// printf("\n");</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Case %d:\nMy king, at most %d road can be built.\n\n"</span>, ++cnt, len);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d:\nMy king, at most %d roads can be built.\n\n"</span>, ++cnt, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 7</span></span><br><span class="line"><span class="comment">// 3 1</span></span><br><span class="line"><span class="comment">// 4 5</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 7 3</span></span><br><span class="line"><span class="comment">// 8 8</span></span><br><span class="line"><span class="comment">// 10 9</span></span><br></pre></td></tr></table></figure><h2 id="F-Farey-Sequence-欧拉函数"><a href="#F-Farey-Sequence-欧拉函数" class="headerlink" title="F - Farey Sequence - 欧拉函数"></a><a href="https://cn.vjudge.net/contest/312624#problem/F" target="_blank" rel="noopener">F - Farey Sequence - 欧拉函数</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个数字 $n$ ，求有多少个有序对 $<a, b>$ 满足</a,></p><ul><li>$0  &lt; a &lt; b \leq n$</li><li>$ \gcd(a, b) = 1$ </li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><script type="math/tex; mode=display">ans = \sum_{i = 2}^n \varphi(i)</script><p>先处理出欧拉函数值的数组，直接求和即可</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phiTable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) phi[i] = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    phiTable(<span class="number">1000000</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += phi[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf("%d\n", 2 * sum + 1);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-The-Luckiest-number-欧拉定理-原根-数学技巧"><a href="#G-The-Luckiest-number-欧拉定理-原根-数学技巧" class="headerlink" title="G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧"></a><a href="https://cn.vjudge.net/contest/312624#problem/G" target="_blank" rel="noopener">G - The Luckiest number - 欧拉定理 + 原根 + 数学技巧</a></h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数字 $L$ ，求一个最小的每一位都是 $8$ 的 $L$ 的倍数</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>对于一个 $n$ 位的全是 $8$ 的数字</p><script type="math/tex; mode=display">\begin{aligned}888 \dots 888 &= 8 \times 111 \dots 111 \\&= 8 \sum_{i = 0}^n 10^i \\&= 8 \times \frac{10^n - 1}{9}\end{aligned}</script><p>这个数是 $L$ 的倍数， 有</p><script type="math/tex; mode=display">8(10^n - 1) = k \cdot 9L</script><p>两边同除 $\gcd(8, L)$，记  $p = \frac{8}{\gcd(8, L)}, q = \frac{k \cdot 9L}{\gcd(8, L)}$，有</p><script type="math/tex; mode=display">p(10^n - 1) = q</script><p>$p, q$ 互质，两边同时对 $q$ 取模，得</p><script type="math/tex; mode=display">10^n \equiv 1 \pmod q</script><p>问题转化为求上面这个非线性同余方程的最小正整数解。</p><p>由欧拉定理知，当 $10$ 和 $q$ 互质的时候，有</p><script type="math/tex; mode=display">10^{\varphi(q)} \equiv 1 \pmod q</script><p>当 $10$ 和 $q$ 不互质的时候方程无解</p><p>$\varphi(q)$虽然是方程的一个解，但是不一定是最小正整数解，接下来枚举 $\varphi(q)$ 的因数，代入原方程检验是否成立</p><p>为什么$\varphi(q)$ 的因数是原方程的解？<br>涉及到<code>阶</code>的概念</p><ul><li>设 $m &gt; 1$ ，$\gcd(a, m) = 1$，则使得 $a^r \equiv 1 \pmod m$ 成立的最小正整数 $r_0$ 称为$a$ 对模 $m$ 的阶，记作 $\delta_m(a)$</li><li>若 $m &gt; 1$，$\gcd(a, m) = 1$，$a^n \equiv 1 \pmod m$，则 $\delta_m(a) | n$</li></ul><p>所以原方程就是求阶。</p><p>乘法会爆<code>long long</code> 所以使用所谓快速乘法</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long long fastPowMod(long long a, long long b, long long p) &#123;</span></span><br><span class="line"><span class="comment">//     long long ans = 1 % p;</span></span><br><span class="line"><span class="comment">//     for (; b; b &gt;&gt;= 1) &#123;</span></span><br><span class="line"><span class="comment">//         if (b &amp; 1) ans = (ans % p * a % p) % p;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         a = (a % p * a % p) % p;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return ans;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">ans = (ans + a) % m;</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = (a + a) % m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">a %= m;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">ans = Mul(ans, a, m);</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = Mul(a, a, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x) != EOF &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">9</span> * x / gcd(<span class="number">8</span>, x);</span><br><span class="line">        <span class="keyword">if</span> (gcd(<span class="number">10</span>, p) != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> m = phi(p);</span><br><span class="line"></span><br><span class="line">            v.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i * i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    v.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span> (i * i != m) v.push_back(m / i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fastPowMod(<span class="number">10</span>, v[i], p) == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, v[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-Best-Solver-矩阵快速幂-广义斐波那契循环节降幂"><a href="#H-Best-Solver-矩阵快速幂-广义斐波那契循环节降幂" class="headerlink" title="H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂"></a><a href="https://cn.vjudge.net/contest/312624#problem/H" target="_blank" rel="noopener">H - Best Solver - 矩阵快速幂 + 广义斐波那契循环节降幂</a></h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>设</p><script type="math/tex; mode=display">y = (5 + 2\sqrt6)^{1+2^x} , 0 \leq x \leq 2^{32}</script><p>给定 $x$ 和 $M$，求</p><script type="math/tex; mode=display">[y] \% m</script><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>看到这个式子，明显不能直接计算，先不管指数过大的问题，考虑如何求</p><script type="math/tex; mode=display">a_n = (5 + 2\sqrt6)^n</script><p>先写出前几项看一看</p><script type="math/tex; mode=display">a_1 = 5 + 2\sqrt6 \\a_2 = (5+2\sqrt6)^2 = 25 + 24 + 20\sqrt6 = 49 + 20\sqrt6 \\a_3 = (5+2\sqrt6)^2 = (49 + 20\sqrt6) \times (5 + 2\sqrt6) = 585 + 198\sqrt6</script><p>发现只是系数变了，不妨设 </p><script type="math/tex; mode=display">a_n =x_n + y_n \sqrt 6</script><p>则</p><script type="math/tex; mode=display">\begin{align}a_{n+1} &= (x_n + y_n \sqrt 6) \cdot (5 + 2\sqrt6) \\&= 5x_n + 12y_n + (2x_n + 5y_n)\sqrt6 \\&= x_{n+1} + y_{n+1}\sqrt6\end{align}</script><p>所以</p><script type="math/tex; mode=display">\begin{equation}\begin{cases}x_{n+1} = 5x_n + 12y_n \\[2ex]y_{n+1} = 2x_n + 5y_n\end{cases}\end{equation}</script><p>写成矩阵的形式</p><script type="math/tex; mode=display">\begin{bmatrix}     5 & 12 \\     2 & 5\end{bmatrix}\begin{bmatrix}    x_n\\    y_n\end{bmatrix}=\begin{bmatrix}    x_{n+1}\\    y_{n+1}\end{bmatrix}</script><p>现在我们就可以用矩阵快速幂快速计算系数了。</p><p>解决了底数计算，再来看指数上的$1 + 2^x$，这个东西非常大，所以需要用一些手段来降幂，对于整数的大幂计算，可以利用<a href="https://blog.csdn.net/ACdreamers/article/details/8236942" target="_blank" rel="noopener">指数循环节</a>用欧拉函数降幂，即</p><script type="math/tex; mode=display">A^B \mod C = A^{B \mod \varphi(C) + \varphi(C)} \mod C</script><p>但是对于矩阵是不能这样搞的，需要找到<a href="https://blog.csdn.net/ACdreamers/article/details/25616461" target="_blank" rel="noopener">矩阵的循环节(广义斐波那契数列循环节)</a>，对于寻找的方法，暂时超出了我的能力范围，暂记结论</p><p>广义斐波那契数列的循环节为 $p + 1$ 或 $(p+1) \cdot (p-1)$</p><p>这样就可以在用快速幂计算指数的时候把模数设为循环节达到降幂的目的。</p><p>这样底数和指数的问题就解决了，先降幂算出指数之后，矩阵快速幂算出底数两项的系数，带入公式计算然后取整即可。</p><p>注意降幂时的模数和矩阵快速幂的模数不是同一个。</p><p>这题比较难，但是也有套路的东西在里面。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> sizeX, sizeY;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> sizeX = <span class="number">0</span>, <span class="keyword">int</span> sizeY = <span class="number">0</span>) : sizeX(sizeX), sizeY(sizeY) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(sizeX, a.sizeY)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sizeY; k++) &#123;</span><br><span class="line">                    ans.a[i][j] += (<span class="keyword">this</span>-&gt;a[i][k] % MOD * a.a[k][j] % MOD) % MOD;</span><br><span class="line">                    ans.a[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;a[i][j] = a.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sizeX; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sizeY; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastPowMod</span><span class="params">(Matrix m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> fastPowMod(m, n - <span class="number">1</span>) * m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fastPowMod(m * m, n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">for</span> ( ; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans % p * a % p) % p;</span><br><span class="line">        a = (a % p * a % p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MOD);</span><br><span class="line"></span><br><span class="line">        <span class="function">Matrix <span class="title">shift</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">        shift.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>; shift.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">12</span>;</span><br><span class="line">        shift.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>; shift.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Matrix <span class="title">ans</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">        ans.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int p = phi(MOD);</span></span><br><span class="line">        <span class="comment">// long long b = (fastPowMod(2, x, p) + 1 + p) % p;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b = fastPowMod(<span class="number">2</span>, x, MOD * MOD - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf("p = %d, b = %lld\n", p, b);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Matrix tmp = fastPowMod(shift, b - 1);</span></span><br><span class="line">        <span class="comment">// ans = tmp * ans;</span></span><br><span class="line">        ans = fastPowMod(shift, b - <span class="number">1</span>) * ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("Case #%d: %d\n", ++cnt, (int)(ans.a[0][0] + ans.a[1][0] * sqrt(6)) % MOD);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>, ++cnt, (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="number">2</span> * ans.a[<span class="number">0</span>][<span class="number">0</span>] % MOD - <span class="number">1</span>) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Queries-for-Number-of-Palindromes-区间DP"><a href="#K-Queries-for-Number-of-Palindromes-区间DP" class="headerlink" title="K - Queries for Number of Palindromes - 区间DP"></a><a href="https://cn.vjudge.net/contest/312624#problem/K" target="_blank" rel="noopener">K - Queries for Number of Palindromes - 区间DP</a></h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串，求其回文子串的个数。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>比较典型的区间DP题目</p><p>设状态 $f(l, r)$ 表示左闭右开区间 $[l, r)$ 中的回文子串个数，<code>isP[l, r]</code>数组表示在区间$[l ,r)$中的字符串是否为回文串。</p><p>则转移为</p><script type="math/tex; mode=display">f(l, r) = f(l + 1, r) + f(l, r - 1) - f(l + 1, r - 1) + \text{isP}[l, r]</script><p>区间的计数问题常常这样解决。<br>好像有点容斥的感觉？<br>记得预处理<code>isP</code>数组。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> isP[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        f[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        isP[i][i + <span class="number">1</span>] = isP[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            isP[i][j] = (isP[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + l &lt;= len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l;</span><br><span class="line">            f[i][j] = f[i][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j] - f[i + <span class="number">1</span>][j - <span class="number">1</span>] + isP[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[l][r + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Diophantus-of-Alexandria"><a href="#L-Diophantus-of-Alexandria" class="headerlink" title="L - Diophantus of Alexandria"></a><a href="https://cn.vjudge.net/contest/312624#problem/L" target="_blank" rel="noopener">L - Diophantus of Alexandria</a></h2><h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数学与DP专题二，比较难，不怎么会&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/312624&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt; 专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[HDU 1576] A/B - 乘法逆元+费马小定理/扩展欧几里得</title>
    <link href="http://ilern.github.io/2019/07/21/hdu_1576/"/>
    <id>http://ilern.github.io/2019/07/21/hdu_1576/</id>
    <published>2019-07-21T14:32:23.000Z</published>
    <updated>2019-07-21T10:15:51.468Z</updated>
    
    <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576" target="_blank" rel="noopener">HDU 1576 A/B</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>要求$(A / B)\%9973$，但由于$A$很大，我们只给出$n(n = A \% 9973)$(我们给定的$A$必能被$B$整除，且$\gcd(B, 9973) = 1)$。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>$(A / B)\%9973 = (AB^{-1}) \% 9973 = (A \% 9973 \cdot B^{-1} \%9973) \%9973 = (n \cdot B^{-1} \%9973) \%9973$</p><p>问题转化为求$B^{-1}$</p><p>可用费马小定理或者扩展欧几里得算法求解。</p><p>​    </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % MOD;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;b);</span><br><span class="line"></span><br><span class="line">        b = fastPowMod(b, MOD - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (n % MOD * b % MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDU2019暑期集训第一周数学部分&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得算法学习笔记</title>
    <link href="http://ilern.github.io/2019/07/21/exgcd_learn/"/>
    <id>http://ilern.github.io/2019/07/21/exgcd_learn/</id>
    <published>2019-07-21T14:32:23.000Z</published>
    <updated>2019-07-21T09:53:20.392Z</updated>
    
    <content type="html"><![CDATA[<p>扩展欧几里得算法能在计算$\gcd(a,b)$ 的同时求解方程$ax + by = \gcd(a, b)$的一组特解。</p><p>是为欧几里得算法之扩展。</p><a id="more"></a><h3 id="Bezout’s-identity（裴蜀定理）"><a href="#Bezout’s-identity（裴蜀定理）" class="headerlink" title="Bézout’s identity（裴蜀定理）"></a>Bézout’s identity（裴蜀定理）</h3><blockquote><p>对于任意整数$a, b$，存在一对整数 $x, y$ 满足$ax + by = \gcd(a, b)$</p></blockquote><p>使用（类似）数学归纳法证明：</p><ul><li><p>当 $b = 0$ 时，有$x = 1, y  = 0$ 使得等式成立，即有 $a \times 1 + b \times 0 = \gcd(a, 0) = a$</p></li><li><p>当 $b&gt;0$ 时，假设存在 $x, y$  使得等式成立，即</p><script type="math/tex; mode=display">ax + by = \gcd(a, b) = \gcd(b, a \% b) = bx + (a \% b)y</script><p> 又由取模运算的定义</p><script type="math/tex; mode=display">a \% b = a - b \lfloor \frac{a}{b} \rfloor</script><p>可知</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\gcd(a, b) &= bx + ay - b \lfloor \frac{a}{b} \rfloor y \\&= ay + b(x - b \lfloor \frac{a}{b} \rfloor y)\end{aligned}\end{equation}</script><p>令 $x’ = y, y’ = x - b \lfloor \frac{a}{b} \rfloor y$ 可得 $ax’ + by’ = gcd(a, b)$</p><p>即 $bx + (a \% b)y = \gcd(a, b)$ 有解</p></li><li><p>这里的 $a, b$ 在交换一次之后变小了，这样一直递归下去就会到达 $b = 0$ 的边界，所以解一定存在</p></li></ul><h3 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x; x = y; y = z - y * (a / b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码求出了$ax + by = \gcd(a, b)$，返回了$\gcd(a, b)$。</p><p>对于一般的线性方程$ax + by = c$，当且仅当$\gcd(a, b) | c$ 时存在非负整数解，此时先用扩展欧几里得算法求出$ax + by = \gcd(a, b)$ 的一组特解 $x_0, y_0$ 再等式两边同时乘以$\frac{c}{\gcd(a,b)}$ 即可求得原方程的一组特解 $x_0 \frac{c}{\gcd(a, b)}, y_0 \frac{c}{\gcd(a, b)}$</p><p>而原方程的通解表示为</p><script type="math/tex; mode=display">\begin{aligned}x &= x_0 \frac{c}{\gcd(a, b)} + k \frac{b}{\gcd(a, b)} \\y &= y_0 \frac{c}{\gcd(a, b)} + k \frac{a}{\gcd(a, b)}\end{aligned}</script><p>其中 $k$ 可以取遍全体整数</p><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>线性同余方程是指形如 $ax \equiv b \pmod m$ 的方程，因为未知数为的次数为一，故称之为<strong>线性</strong>同余方程。</p><p>扩展欧几里得算法的应用之一就是求解线性同余方程。</p><p>同余可以理解为<strong>模等于</strong>，也就是 $ax$ 模 $m$ 等于 $b$ ，所以原方程表示 $ax-b$ 是 $m$ 的倍数，不妨设为 $-y$ 倍，则原方程转化为 $ax - b = -ym$ 即 $ax + my = b$ 。</p><p>这样的方程我们可以用扩展欧几里得算法进行求解，当且仅当 $\gcd(a, m) | b$ 时，方程有解，易得原线性同余方程方程的特解为 $x = x_0 \frac{b}{\gcd(a, m)}$</p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>特殊地，当 $ax \equiv 1 \pmod m$ 时， $x$ 被称为 $a$ 在模 $m$ 意义下的逆元，可以套用上面的方法求出，要求$\gcd(x, m) = 1$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;扩展欧几里得算法能在计算$\gcd(a,b)$ 的同时求解方程$ax + by = \gcd(a, b)$的一组特解。&lt;/p&gt;
&lt;p&gt;是为欧几里得算法之扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title> Leading and Trailing - 对数 + 快速幂</title>
    <link href="http://ilern.github.io/2019/07/21/Lat/"/>
    <id>http://ilern.github.io/2019/07/21/Lat/</id>
    <published>2019-07-21T14:32:23.000Z</published>
    <updated>2019-07-21T10:37:46.785Z</updated>
    
    <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p> <a href="https://vjudge.net/contest/312605#problem/B" target="_blank" rel="noopener">Leading and Trailing</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>You are given two integers: $n$ and $k$, your task is to find the most significant three digits, and least significant three digits of $n^k$.</p><p>给定$n$和$k$，求$n^k$的前三位数字和后三位数字。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>后三位数字直接用快速幂对$1000$取模即可。</p><p>前三位数字的做法比较巧妙。</p><p>设 $10^p = n^k$ ，两边同取对数 $p = k\lg n$ ，$p$ 是一个浮点数，整数部分为$[p]$, 记为 $x$ ; 小数部分为 $p - [p]$， 记为$y$ 。有$10^p = 10^{x + y} = 10^x \cdot 10^y = n^k$ 这样就把 $n^k$ 转化为了科学记数法表示，$10^y &lt; 1$ ，所以要求的前三位就是 $10^y \cdot 10^3 = 10^{y+3}$。</p><p>最后三位前面不足的位置补$0$。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPowMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % MOD;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">1</span>; cnt &lt;= t; cnt++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> p = k * <span class="built_in">log10</span>(n);</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>)p;</span><br><span class="line">        <span class="keyword">double</span> y = p - x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %03d\n"</span>, cnt, (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10.0</span>, y + <span class="number">2</span>), fastPowMod(n, k));</span><br><span class="line">        <span class="comment">//if (cnt &lt; t) printf("\n");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDU2019暑期集训第一周数学部分&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>[bzoj 1477] 青蛙的约会  - 扩展欧几里得</title>
    <link href="http://ilern.github.io/2019/07/21/bzoj_1477/"/>
    <id>http://ilern.github.io/2019/07/21/bzoj_1477/</id>
    <published>2019-07-21T13:00:00.000Z</published>
    <updated>2019-07-21T12:56:41.347Z</updated>
    
    <content type="html"><![CDATA[<p>QDU2019暑期集训第一周数学部分</p><a id="more"></a><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1477" target="_blank" rel="noopener">bzoj 1477 青蛙的约会</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 $A$ 的出发点坐标是 $x$，青蛙 $B$ 的出发点坐标是 $y$。青蛙 $A$ 一次能跳 $m$ 米，青蛙 $B$ 一次能跳$n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>青蛙$A$: $(x + km) \% L$</p><p>青蛙$B$: $(y + kn)\%L$</p><p>问题转化为$(x + km) \% L = (y + kn)\%L$</p><p>展开得线性同余方程$k(m-n) \equiv y-x \pmod L$</p><p>其中 $m-n$ 和 $ y-x  $ 都是已知的常数，利用扩展欧几里得算法求出 $k$ 即可。</p><p>需要注意的是$(m-n)$一定要是正的，如果算出来是负的，等号两边同乘以负一。</p><p>最后 $k$ 也应该也是正的，如果算出来是负的，加上$\frac{b}{d}$就好。</p><p>记得用<code>long long</code></p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">long</span> <span class="keyword">long</span> &amp;x, <span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> z = x; x = y; y = z - y * (a / b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, m, n, l;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = m - n;</span><br><span class="line">    <span class="keyword">int</span> b = l;</span><br><span class="line">    <span class="keyword">int</span> c = y - x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        a = -a;</span><br><span class="line">        c = -c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("a = %d, b = %d, c = %d\n", a, b, c);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//solve ax + cy = b;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">    <span class="comment">//printf("d = %d\n", d);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c % d != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x0 = <span class="number">0</span>, y0 = <span class="number">0</span>;</span><br><span class="line">        d = exgcd(a, b, x0, y0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = x0 * c / d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = b / d;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) x %= t;</span><br><span class="line">        <span class="keyword">else</span> x = x % t + t;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDU2019暑期集训第一周数学部分&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://ilern.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>三分法学习笔记</title>
    <link href="http://ilern.github.io/2019/07/03/divide3/"/>
    <id>http://ilern.github.io/2019/07/03/divide3/</id>
    <published>2019-07-03T13:33:00.000Z</published>
    <updated>2019-07-03T01:20:53.348Z</updated>
    
    <content type="html"><![CDATA[<p>三分法是一种求解单峰函数极值的算法</p><a id="more"></a><h3 id="【简介】"><a href="#【简介】" class="headerlink" title="【简介】"></a>【简介】</h3><p>所谓单峰函数，如图所示，三分法可以求出这样的函数的极值。</p><p><img src="https://s2.ax1x.com/2019/07/03/ZYK4FP.png" alt="pic1"></p><h3 id="【算法】"><a href="#【算法】" class="headerlink" title="【算法】"></a>【算法】</h3><ul><li>确定极值点所在的区间</li><li>取区间的中点 <code>mid</code></li><li>在中点左右各一个小距离中分别取<code>midL</code> <code>midR</code>，这两个点将整个区间三分</li><li><p>计算出<code>midL</code> <code>midR</code>的函数值</p><ul><li>若<code>f(midL)</code> 比较大，则舍弃右边的部分，将区间右端点设置为<code>mid</code></li><li>若<code>f(midR)</code>比较大，则舍弃左边的部分，将区间左端点设置为<code>mid</code></li></ul></li><li><p>重复上述过程直至区间大小小于某个设定好的<code>EPS</code></p></li></ul><h3 id="【模板】"><a href="#【模板】" class="headerlink" title="【模板】"></a>【模板】</h3><p><a href="https://www.luogu.org/problemnew/show/P3382" target="_blank" rel="noopener">洛谷P3382 【模板】三分法</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// double func(double a[], int n, double x) &#123;</span></span><br><span class="line"><span class="comment">//     double ret = 0;</span></span><br><span class="line"><span class="comment">//     double b = 1;</span></span><br><span class="line"><span class="comment">//     for (int i = n; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//         ret += (b * a[i]);</span></span><br><span class="line"><span class="comment">//         b *= x;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return ret;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum = sum * x + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt;= EPS) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// double midL = (l + r) / 3;</span></span><br><span class="line">        <span class="comment">// double midR = midL * 2;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> midL = mid - EPS;</span><br><span class="line">        <span class="keyword">double</span> midR = mid + EPS;</span><br><span class="line">        <span class="keyword">if</span> (func(a, n, midL) &lt; func(a, n, midR)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三分法是一种求解单峰函数极值的算法&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[QDUoj 582] 嘉馨学姐吃包子 - 三分</title>
    <link href="http://ilern.github.io/2019/07/03/qduoj582/"/>
    <id>http://ilern.github.io/2019/07/03/qduoj582/</id>
    <published>2019-07-03T13:33:00.000Z</published>
    <updated>2019-07-03T03:06:27.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://qduoj.com/problem/582" target="_blank" rel="noopener">嘉馨学姐吃包子</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>嘉馨学姐非常爱吃包子，但是嘉馨学姐这个人很懒，她总是希望包子可以自己飞到她的嘴里，现在有 $n(n \leq 100000)$ 个包子，告诉你每个包子的位置 $p_i(|p_i| \leq 10^6)$ 和重量$w_i(1 &lt; w_i \leq 10)$。</p><p>已知包子飞行时，包子的口感度会降低，如果一个包子飞行了$x$，那这个包子的口感度会降低$x^3 \times w$。嘉馨学姐的初始位置由你来决定，要求尽量使所有包子降低的口感度总和$F$最小。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>设起点为$x$，则每个包子移动的距离为$|p_i - x|$，那么降低的口感总和为</p><script type="math/tex; mode=display">f(x) = \sum_{i = 0}^n (|p_i - x|)^3 \times w_i</script><p>三分这个函数求出最值即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret += (<span class="built_in">pow</span>(<span class="built_in">fabs</span>(p[i] - x), <span class="number">3</span>) * w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e6</span>; <span class="keyword">double</span> r = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt;= EPS) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> midL = mid - EPS;</span><br><span class="line">        <span class="keyword">double</span> midR = mid + EPS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (func(n, midL) &gt; func(n, midR)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>, func(n, l) / <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://qduoj.com/problem/582&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;嘉馨学姐吃包子&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;嘉馨学姐非常爱吃包子，但是嘉馨学姐这个人很懒，她总是希望包子可以自己飞到她的嘴里，现在有 $n(n \leq 100000)$ 个包子，告诉你每个包子的位置 $p_i(|p_i| \leq 10^6)$ 和重量$w_i(1 &amp;lt; w_i \leq 10)$。&lt;/p&gt;
&lt;p&gt;已知包子飞行时，包子的口感度会降低，如果一个包子飞行了$x$，那这个包子的口感度会降低$x^3 \times w$。嘉馨学姐的初始位置由你来决定，要求尽量使所有包子降低的口感度总和$F$最小。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="三分" scheme="http://ilern.github.io/tags/%E4%B8%89%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[蓝桥杯 2013] 幸运数 - 构造</title>
    <link href="http://ilern.github.io/2019/05/21/lq2013_1/"/>
    <id>http://ilern.github.io/2019/05/21/lq2013_1/</id>
    <published>2019-05-21T13:33:00.000Z</published>
    <updated>2019-07-02T16:36:03.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="http://lx.lanqiao.cn/problem.page?gpid=T33" target="_blank" rel="noopener">历届试题 幸运数</a></p><h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成</p><p>首先从1开始写出自然数 $1,2,3,4,5,6, \dots$</p><p>$1$ 就是第一个幸运数。</p><p>我们从2这个数开始。把所有序号能被2整除的项删除，变为：</p><script type="math/tex; mode=display">1, 3, 5, 7, 9 \dots</script><p>这时，$3$ 为第 $2$ 个幸运数，然后把所有能被 $3$ 整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被$3$ 整除!! 删除的应该是 $5, 11, 17,\dots$</p><p>此时$7$为第$3$个幸运数，然后再删去序号位置能被$7$整除的$(19, 39, …)$</p><p>最后剩下的序列类似：</p><script type="math/tex; mode=display">1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, \dots</script><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>关键点在于如何构造出题目中要求的数列。</p><p>没有必要每次删除再移位再删除，发现前面没有被删除的数在后续的操作中也不会被删除</p><p>所以只需要找出当前这轮不会被删除的数填到数组中，下一轮参考的元素变成下一个，重复这样的过程。</p><p>只需要生成到$m$为止即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % a[x] != <span class="number">0</span>) a[cnt++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        a[i] = (i * <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; n) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://lx.lanqiao.cn/problem.page?gpid=T33&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;历届试题 幸运数&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;【题目描述】&quot;&gt;&lt;a href=&quot;#【题目描述】&quot; class=&quot;headerlink&quot; title=&quot;【题目描述】&quot;&gt;&lt;/a&gt;【题目描述】&lt;/h3&gt;&lt;p&gt;幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成&lt;/p&gt;
&lt;p&gt;首先从1开始写出自然数 $1,2,3,4,5,6, \dots$&lt;/p&gt;
&lt;p&gt;$1$ 就是第一个幸运数。&lt;/p&gt;
&lt;p&gt;我们从2这个数开始。把所有序号能被2整除的项删除，变为：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;1, 3, 5, 7, 9 \dots&lt;/script&gt;&lt;p&gt;这时，$3$ 为第 $2$ 个幸运数，然后把所有能被 $3$ 整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被$3$ 整除!! 删除的应该是 $5, 11, 17,\dots$&lt;/p&gt;
&lt;p&gt;此时$7$为第$3$个幸运数，然后再删去序号位置能被$7$整除的$(19, 39, …)$&lt;/p&gt;
&lt;p&gt;最后剩下的序列类似：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, \dots&lt;/script&gt;
    
    </summary>
    
      <category term="蓝桥" scheme="http://ilern.github.io/categories/%E8%93%9D%E6%A1%A5/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【5.13】2019一起开心蓝桥国赛训练</title>
    <link href="http://ilern.github.io/2019/05/14/5132109/"/>
    <id>http://ilern.github.io/2019/05/14/5132109/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-07-21T08:42:28.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h2><p><a href="http://fastvj.rainng.com/contest/301445#overview" target="_blank" rel="noopener">【5.13】2019一起开心蓝桥国赛训练</a></p><ul><li>树状数组</li><li>线段树</li><li>SPFA</li><li>桥</li><li>欧拉回路/函数</li><li>数学</li><li>SG博弈</li></ul><a id="more"></a><p>密码：bullet</p><h2 id="A-hdu4738-Caocao’s-Bridges-Tajan求桥"><a href="#A-hdu4738-Caocao’s-Bridges-Tajan求桥" class="headerlink" title="A - hdu4738 - Caocao’s Bridges - Tajan求桥"></a>A - hdu4738 - Caocao’s Bridges - Tajan求桥</h2><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>双联通分量的模板题。</p><p>求出所有桥中边权最小的那个。</p><p>Tarjan算法求桥和求割点/强连通分量的算法类似，都用到了<code>low</code>和<code>dfn</code>两个标记。</p><p>由于一个环中的点<code>dfn</code>值都是相同的，如果有一个点的<code>dfn</code>大于它的父亲节点，那连接这两个点的边一定是一个桥。</p><p>参看<a href="https://ilern.github.io/2018/06/28/tarjan_note/">Tarjan强连通分量学习笔记</a></p><p>这题有几个坑:</p><ul><li>图可能不连通</li><li>图里可能有重边</li><li>如果边权最小的为$0$，答案应该是$1$，因为总要派一个人去爆破（题意）。</li></ul><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> haveEdge[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dfn, low;</span><br><span class="line">    <span class="keyword">bool</span> vis;</span><br><span class="line"></span><br><span class="line">    Node *fa;</span><br><span class="line"></span><br><span class="line">    Edge *edges;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), low(<span class="number">0</span>), vis(<span class="literal">false</span>), fa(<span class="literal">NULL</span>), edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">    v-&gt;edges = <span class="keyword">new</span> Edge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(haveEdge, <span class="number">0</span>, <span class="keyword">sizeof</span>(haveEdge));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nodes[i].dfn = <span class="number">0</span>;</span><br><span class="line">        nodes[i].low = <span class="number">0</span>;</span><br><span class="line">        nodes[i].vis = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> nodes[i].edges;</span><br><span class="line">        nodes[i].edges = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        nodes[i].fa = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;to == x-&gt;fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;to-&gt;fa) &#123;</span><br><span class="line">            e-&gt;to-&gt;fa = x;</span><br><span class="line">            tarjan(e-&gt;to);</span><br><span class="line">            x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x-&gt;low = <span class="built_in">std</span>::min(x-&gt;low, e-&gt;to-&gt;low);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x-&gt;vis) num++;</span><br><span class="line">    x-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;fa &amp;&amp; e-&gt;to == x-&gt;fa || e-&gt;to-&gt;vis) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (haveEdge[e-&gt;fr - nodes][e-&gt;to - nodes] == <span class="number">1</span> &amp;&amp; e-&gt;to-&gt;low &gt; x-&gt;low) min = <span class="built_in">std</span>::min(min, e-&gt;w);</span><br><span class="line">            dfs(e-&gt;to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF &amp;&amp; n != <span class="number">0</span> &amp;&amp; m != <span class="number">0</span>) &#123;</span><br><span class="line">        init(n);</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        min = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            addEdge(nodes + u, nodes + v, w);</span><br><span class="line">            haveEdge[u][v]++;</span><br><span class="line">            haveEdge[v][u]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tarjan(nodes + <span class="number">1</span>);</span><br><span class="line">        dfs(nodes + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num != n) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (min == INT_MAX) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-POJ-3245-Wormholes-SPFA判负环"><a href="#B-POJ-3245-Wormholes-SPFA判负环" class="headerlink" title="B - POJ 3245 - Wormholes - SPFA判负环"></a>B - POJ 3245 - Wormholes - SPFA判负环</h2><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>裸的SPFA判负环，条件是存在某一个节点入队次数大于$n$(节点总数)。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPFA判负环</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">bool</span> inQue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    Node() : edges(<span class="literal">NULL</span>), dis(INT_MAX), inQue(<span class="literal">false</span>), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"></span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;cnt++;</span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge *e = v-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;to-&gt;dis &gt; v-&gt;dis + e-&gt;w) &#123;</span><br><span class="line">                e-&gt;to-&gt;dis = v-&gt;dis + e-&gt;w;</span><br><span class="line">                <span class="keyword">if</span> (!e-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    e-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                    e-&gt;to-&gt;cnt++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (e-&gt;to-&gt;cnt &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    q.push(e-&gt;to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes[i].dis = INT_MAX;</span><br><span class="line">        nodes[i].inQue = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">delete</span> nodes[i].edges;</span><br><span class="line">        nodes[i].edges = <span class="literal">NULL</span>;</span><br><span class="line">        nodes[i].cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;w);</span><br><span class="line"></span><br><span class="line">        init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + w; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s, e, t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;e, &amp;t);</span><br><span class="line">            s--; e--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m) &#123;</span><br><span class="line">                addEdge(nodes + s, nodes + e, t);</span><br><span class="line">                addEdge(nodes + e, nodes + s, t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addEdge(nodes + s, nodes + e, -t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (spfa(nodes, n)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-POJ-3468-A-Simple-Problem-with-Integers-线段树"><a href="#C-POJ-3468-A-Simple-Problem-with-Integers-线段树" class="headerlink" title="C - POJ 3468 - A Simple Problem with Integers - 线段树"></a>C - POJ 3468 - A Simple Problem with Integers - 线段树</h2><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>用线段树维护区间和，支持区间修改和区间查询。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树区间加 区间和</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lazy;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        sum = lazy = <span class="number">0</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;sum = lc-&gt;sum + rc-&gt;sum;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) sum = a[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTag</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">        lazy += tag;</span><br><span class="line">        sum += (r - l) * tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy) &#123;</span><br><span class="line">            lc-&gt;addTag(lazy);</span><br><span class="line">            rc-&gt;addTag(lazy);</span><br><span class="line">            lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans += lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r));</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans += rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == l &amp;&amp; <span class="keyword">this</span>-&gt;r == r) addTag(delta);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r), delta);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, <span class="keyword">this</span>-&gt;mid), r, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, n);</span><br><span class="line">    root-&gt;build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        l--; r--;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'Q'</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; root-&gt;query(l, r + <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'C'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> del;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; del;</span><br><span class="line">            root-&gt;modify(l, r + <span class="number">1</span>, del);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-HDU-1166-敌兵布阵-树状数组-线段树"><a href="#D-HDU-1166-敌兵布阵-树状数组-线段树" class="headerlink" title="D - HDU 1166 - 敌兵布阵 - 树状数组/线段树"></a>D - HDU 1166 - 敌兵布阵 - 树状数组/线段树</h2><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>用线段树/树状数组维护区间和，支持单点修改区间查询，树状数组代码量相对较少。</p><p>注意用树状数组查询区间$[l, r]$的区间和要写成<code>query(r) - query(l - 1)</code></p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线段树（树状数组）单点修改前缀求和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= n) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowbit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            bit.modify(i, x);   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++cnt &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">"End"</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> a, b;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">"Add"</span>) &#123;</span><br><span class="line">                    bit.modify(a, b);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">"Query"</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bit.query(b) - bit.query(a - <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">"Sub"</span>) &#123;</span><br><span class="line">                    bit.modify(a, -b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-POJ-2230-Watchcow-欧拉回路"><a href="#E-POJ-2230-Watchcow-欧拉回路" class="headerlink" title="E - POJ 2230 - Watchcow - 欧拉回路"></a>E - POJ 2230 - Watchcow - 欧拉回路</h2><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>欧拉回路模板题，用<code>dfs</code>求欧拉回路。其中不允许同向走两次的要求用对边打标记实现，由于加边时加的是两条方向相反的边，走的时候给其中一条标记上之后，相反方向的那条还是可以走的。</p><p>由于不确定的原因，<code>TLE</code>，大概是指针邻接表的锅。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Edge *edges;</span><br><span class="line"></span><br><span class="line">    Node() : edges(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to), vis(<span class="literal">false</span>) &#123;</span><br><span class="line">        next = fr-&gt;edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;edges = <span class="keyword">new</span> Edge(u, v); </span><br><span class="line">    v-&gt;edges = <span class="keyword">new</span> Edge(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span> * MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = x-&gt;edges; e; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(e-&gt;vis)) &#123;</span><br><span class="line">            e-&gt;vis = <span class="literal">true</span>;</span><br><span class="line">            dfs(e-&gt;to);</span><br><span class="line">            ans[cnt++] = (e-&gt;to) - nodes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addEdge(nodes + u, nodes + v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nodes + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-POJ-3090-Visible-Lattice-Points-欧拉函数"><a href="#F-POJ-3090-Visible-Lattice-Points-欧拉函数" class="headerlink" title="F - POJ 3090 - Visible Lattice Points - 欧拉函数"></a>F - POJ 3090 - Visible Lattice Points - 欧拉函数</h2><h3 id="【题解】-5"><a href="#【题解】-5" class="headerlink" title="【题解】"></a>【题解】</h3><p>知道欧拉函数的提示就好做了，画图找规律可以得到</p><script type="math/tex; mode=display">ans = 2 \sum_{i = 2}^n \varphi(i) + 3</script><p>$\varphi(x)$是欧拉函数，表示小于等于$x$的与$x$互质的数的个数。</p><p>关于欧拉函数可以看<a href="https://ilern.github.io/2019/03/02/rcyl/">【数学】- 容斥原理学习笔记</a></p><p>可是为什么是欧拉函数？</p><p>首先发现上三角和下三角是对称的，所以只需要考虑一半。</p><p>易知$(1, 0), (0, 1), (1, 1)$是一定可见的，所以只需要考虑剩下的点。</p><p>如果某个点被挡住了，那在它之前一定有一个点和它共线，这里有点相似三角形的感觉，相当于两个直角边同时放大若干倍，也就是说，如果这个点的横纵坐标有公共因子，那么一定可以同时除以这个因子使得沿着这条线向$(0, 0)$方向移动，移动到不能动之后横纵坐标就互质了，所以对于每一个$x$只要求出小于等于它的（只考虑下三角）与它互质的数的个数即可。也就是$\varphi(x)$。</p><h3 id="【代码】-5"><a href="#【代码】-5" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">int</span> tmp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= tmp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) tmp /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &gt; <span class="number">1</span>) ans = ans / tmp * (tmp - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = phi(i);</span><br><span class="line">            <span class="comment">// printf("phi(%d) = %d\n", i, a);</span></span><br><span class="line">            tmp += a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, cnt, n, tmp * <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-POJ-1845-Sumdiv-数学"><a href="#G-POJ-1845-Sumdiv-数学" class="headerlink" title="G - POJ 1845 - Sumdiv - 数学"></a>G - POJ 1845 - Sumdiv - 数学</h2><h2 id="H-POJ-2311-Cutting-Game-博弈-SG函数"><a href="#H-POJ-2311-Cutting-Game-博弈-SG函数" class="headerlink" title="H - POJ 2311 - Cutting Game - 博弈 + SG函数"></a>H - POJ 2311 - Cutting Game - 博弈 + SG函数</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://fastvj.rainng.com/contest/301445#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【5.13】2019一起开心蓝桥国赛训练&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树状数组&lt;/li&gt;
&lt;li&gt;线段树&lt;/li&gt;
&lt;li&gt;SPFA&lt;/li&gt;
&lt;li&gt;桥&lt;/li&gt;
&lt;li&gt;欧拉回路/函数&lt;/li&gt;
&lt;li&gt;数学&lt;/li&gt;
&lt;li&gt;SG博弈&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="蓝桥" scheme="http://ilern.github.io/categories/%E8%93%9D%E6%A1%A5/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记（三）- 内联函数 / Lambda表达式</title>
    <link href="http://ilern.github.io/2019/04/15/cpp3/"/>
    <id>http://ilern.github.io/2019/04/15/cpp3/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-22T05:30:45.378Z</updated>
    
    <content type="html"><![CDATA[<p>上课时的随手笔记，供期末复习用。</p><a id="more"></a><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="普通的函数"><a href="#普通的函数" class="headerlink" title="普通的函数"></a>普通的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用这个函数的时候，不是简单的跳转，要先把<code>main()</code>函数里面的变量”保护起来”，再跳到<code>add()</code>函数的位置，重新分配变量，进行运算（此时<code>main()</code>里面的变量不能被修改），然后返回值。</p><p>这样的过程虽然不慢，但也要花时间，如果函数比较短小，同一个函数的多次调用在跳转上花费的时间可能会比执行花费的还要长。</p><p>所以我们有了<strong>内联函数</strong></p><h3 id="内联函数-1"><a href="#内联函数-1" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的函数会由编译器直接原地展开，例如上面的函数<code>int x = add(a, b)</code>就相当于<code>int x = a + b</code>，这样就有了更好的执行效率。</p><p>好处显而易见，不用手动复制代码，也提升了执行效率。</p><p>同样也存在缺点，代码被多次复制，增加了代码量，占用更多的内存空间。</p><p>有些函数即使声明为内联的也不一定会被编译器内联, 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数)</p><h2 id="Lambda-表达式-C-11"><a href="#Lambda-表达式-C-11" class="headerlink" title="Lambda 表达式(C++11)"></a>Lambda 表达式(C++11)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;<span class="keyword">return</span> x + y;&#125; (<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>Lambda表达式可以看作是一个匿名函数（但是实际上是个表达式）</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>语法定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) mutable -&gt;return_type &#123;statement&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>[capture]</code>是捕捉列表，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用，如果不需要可以只写中括号(捕捉列表为空)</p></li><li><p><code>(parameters)</code>是参数列表，就像普通函数一样，如果不需要传参数，则可以省略</p></li><li><p><code>mutable</code>是一个修饰符。默认情况下，Lambda函数总是一个<code>const</code>函数，<code>mutable</code>可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）</p></li><li><p><code>-&gt;return-type</code>表明了Lambda表达式的返回类型</p></li><li><p><code>{statement}</code>：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量</p></li></ul><p>捕捉列表中可以指定捕捉何种类型的变量</p><ul><li><p><code>[&amp;var_name]</code> 以传引用的方式捕获<code>var_name</code>这个变量（需要修改外部变量时）</p></li><li><p><code>[var_name]</code> 以传值的方式捕获<code>var_name</code>这个变量</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [sum](<span class="keyword">int</span> x, <span class="keyword">int</span> y) <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before adding, sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sum = x + y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"After adding, sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(<span class="number">13</span>, <span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">2333</span>;</span><br><span class="line">    f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>[=]</code>以传值方式捕获所有变量</li><li><code>[&amp;]</code>以传引用方式捕获所有变量</li></ul><p>也可以同时混合多种使用，比如</p><ul><li><code>[=, &amp;sum]</code> 以传引用方式捕获<code>sum</code>这个变量，以传值方式捕获其他变量</li><li><code>[&amp;, sum]</code> 以传值方式捕获<code>sum</code>这个变量，以引用方式捕获其他变量</li></ul><p>但是<strong>不要</strong>重复使用，比如不能</p><ul><li><code>[=, sum]</code></li><li><code>[&amp;, &amp;sum]</code></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="自定义排序顺序"><a href="#自定义排序顺序" class="headerlink" title="自定义排序顺序"></a>自定义排序顺序</h4><p>在排序的时候，通常需要传入一个自定义的比较函数，这时就可以用一个匿名函数作为比较函数，而不是额外定义一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a是一个存了int的vector</span></span><br><span class="line">sort(a.begin(), a.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;))</span><br></pre></td></tr></table></figure><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>检索数组（vector）里有多少个偶数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    generate(a.begin(), a.end(), rand);</span><br><span class="line"></span><br><span class="line">    for_each(a.begin(), a.end(), [](<span class="keyword">int</span> x)&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    for_each(a.begin(), a.end(), [&amp;cnt](<span class="keyword">int</span> x)&#123;cnt += (x % <span class="number">2</span> == <span class="number">0</span>);&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h4><p><code>algorithm</code> 里提供的函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    generate(a.begin(), a.end(), rand);</span><br><span class="line"></span><br><span class="line">    for_each(a.begin(), a.end(), [](<span class="keyword">int</span> x)&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count = count_if(a.begin(), a.end(), [](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上课时的随手笔记，供期末复习用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://ilern.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>【数学】- 微分方程学习笔记（二）</title>
    <link href="http://ilern.github.io/2019/04/11/diff_equation_2/"/>
    <id>http://ilern.github.io/2019/04/11/diff_equation_2/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-04-11T16:05:24.009Z</updated>
    
    <content type="html"><![CDATA[<p>我们称表示<strong>未知函数</strong>、<strong>未知函数的导数</strong>、<strong>自变量</strong>之间的关系的方程叫做微分方程，微分方程的解是一个<strong>函数</strong>。下面我们讨论各种不同的微分方程的解法。</p><a id="more"></a><h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><h3 id="一阶线性齐次微分方程"><a href="#一阶线性齐次微分方程" class="headerlink" title="一阶线性齐次微分方程"></a>一阶线性齐次微分方程</h3><p>形如</p><script type="math/tex; mode=display">\frac{dy}{dx} + P(x)y = 0</script><p>的方程为一阶线性齐次微分方程。</p><p>通解公式为</p><script type="math/tex; mode=display">y = Ce^{-\int P(x) {\rm d}x}</script><h3 id="一阶线性非齐次微分方程"><a href="#一阶线性非齐次微分方程" class="headerlink" title="一阶线性非齐次微分方程"></a>一阶线性非齐次微分方程</h3><p>形如</p><script type="math/tex; mode=display">\frac{dy}{dx} + P(x)y = Q(x)</script><p>的方程为一阶线性非齐次微分方程。<br>通解公式为</p><script type="math/tex; mode=display">\begin{align}y &= Ce^{-\int P(x) {\rm d}x} \left( \int Q(x)e^{\int P(x) {\rm d}x} + C\right) \\&= Ce^{-\int P(x){\rm d}x} + e^{-\int P(x) {\rm d}x} \int Q(x)e^{\int P(x) {\rm d}x} {\rm d}x\end{align}</script><p>可以发现非齐次方程的通解是对应齐次方程的通解加上一个特解。</p><h2 id="可降阶的高阶微分方程"><a href="#可降阶的高阶微分方程" class="headerlink" title="可降阶的高阶微分方程"></a>可降阶的高阶微分方程</h2><h3 id="y-n-f-x-型"><a href="#y-n-f-x-型" class="headerlink" title="$y^{(n)} = f(x)$ 型"></a>$y^{(n)} = f(x)$ 型</h3><p>两边连续进行$n$次积分即可</p><h3 id="y’’-f-x-y’-型"><a href="#y’’-f-x-y’-型" class="headerlink" title="$y’’ = f(x, y’)$ 型"></a>$y’’ = f(x, y’)$ 型</h3><p>令$p = y’$，则原式转换为$p’ = f(x, p)$</p><h3 id="y’’-f-y-y’-型"><a href="#y’’-f-y-y’-型" class="headerlink" title="$y’’ = f(y, y’)$ 型"></a>$y’’ = f(y, y’)$ 型</h3><h2 id="线性微分方程解的结构"><a href="#线性微分方程解的结构" class="headerlink" title="线性微分方程解的结构"></a>线性微分方程解的结构</h2><p>对于二阶齐次线性方程</p><script type="math/tex; mode=display"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们称表示&lt;strong&gt;未知函数&lt;/strong&gt;、&lt;strong&gt;未知函数的导数&lt;/strong&gt;、&lt;strong&gt;自变量&lt;/strong&gt;之间的关系的方程叫做微分方程，微分方程的解是一个&lt;strong&gt;函数&lt;/strong&gt;。下面我们讨论各种不同的微分方程的解法。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://ilern.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="微分方程" scheme="http://ilern.github.io/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记（二） - C++11/STL</title>
    <link href="http://ilern.github.io/2019/04/09/cpp2/"/>
    <id>http://ilern.github.io/2019/04/09/cpp2/</id>
    <published>2019-04-08T16:00:00.000Z</published>
    <updated>2019-04-15T05:30:59.793Z</updated>
    
    <content type="html"><![CDATA[<p>上课时的随手笔记，供期末复习用。</p><a id="more"></a><h2 id="C-11的部分新特性"><a href="#C-11的部分新特性" class="headerlink" title="C++11的部分新特性"></a>C++11的部分新特性</h2><h3 id="使用auto进行自动的类型推断"><a href="#使用auto进行自动的类型推断" class="headerlink" title="使用auto进行自动的类型推断"></a>使用auto进行自动的类型推断</h3><h4 id="旧的用法"><a href="#旧的用法" class="headerlink" title="旧的用法"></a>旧的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//写和不写auto效果相同</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="新的用法"><a href="#新的用法" class="headerlink" title="新的用法"></a>新的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">6</span>; <span class="comment">//自动进行类型推断</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><code>auto</code>类型的变量声明时<strong>必须</strong>初始化。</li><li>并不会牺牲运行效率和编译效率。</li><li><code>auto</code>并不能用于函数的参数，如果不想进行函数重载请使用函数模板。</li></ul><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><h4 id="旧的用法-1"><a href="#旧的用法-1" class="headerlink" title="旧的用法"></a>旧的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新的用法-1"><a href="#新的用法-1" class="headerlink" title="新的用法"></a>新的用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span> ,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : arr) &#123; <span class="comment">// 冒号后面应当是一个容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (auto k : arr) cout &lt;&lt; k &lt;&lt; " "; // 可以应用于各种类型的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>不止普通数组，其他的容器也可以进行类似的遍历操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s) <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向量（动态数组）</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// only for c++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure></p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><p>为了形式的<strong>通用</strong>与<strong>统一</strong>，可以看作是一种<strong>广义的</strong>指针。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it; <span class="comment">//指向存储int的vector的迭代器</span></span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(), it != v.end(); it++) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v.begin()返回指向v的第一个元素的迭代器</span></span><br><span class="line"><span class="comment">//v.end()返回指向v的最后一个元素后面的位置的迭代器</span></span><br><span class="line"><span class="comment">//vector的随机存取迭代器的行为类似指针，允许++操作（前置后置均可）</span></span><br></pre></td></tr></table></figure><p>在C++11中，有更方便的写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only for c++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有更更方便的写法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//only for c++11</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li>迭代器并不<strong>等同于</strong>指针，迭代器表示<strong>逻辑上的</strong>前后关系，而指针表示的是<strong>物理上的</strong>前后关系。</li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="vector（动态数组）"><a href="#vector（动态数组）" class="headerlink" title="vector（动态数组）"></a>vector（动态数组）</h4><p><a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector" target="_blank" rel="noopener">靠谱的参考</a></p><p>可以通过重载 <code>&lt;&lt;</code> 来实现直接用 <code>cout</code> 来输出<code>vector</code>，可以写成模板函数的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) out &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><h4 id="sort（排序）"><a href="#sort（排序）" class="headerlink" title="sort（排序）"></a>sort（排序）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要#include &lt;algorithm&gt;</span></span><br><span class="line">sort(v.begin(), v.end(), cmp); <span class="comment">//默认升序排序</span></span><br></pre></td></tr></table></figure><p><code>sort()</code>可以排序任何支持<strong>比较大小</strong>的对象，比如整数，字符串，甚至是自己定义的类（需要重载小于号，相当于给<code>sort()</code>一个比较的规则）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) out &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    out &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Stu() &#123;</span><br><span class="line">        score = <span class="number">-1</span>;</span><br><span class="line">        name = <span class="string">"Anonymous"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stu(<span class="keyword">int</span> sc, <span class="built_in">std</span>::<span class="built_in">string</span> nm) &#123;</span><br><span class="line">        score = sc;</span><br><span class="line">        name = nm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Stu &amp;a) &#123;</span><br><span class="line">    out &lt;&lt; a.score &lt;&lt; <span class="string">" "</span> &lt;&lt; a.name;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stu &amp;a, <span class="keyword">const</span> Stu &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score &lt; b.score) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; aa = &#123;<span class="string">"ZhangSans"</span>, <span class="string">"LiSi"</span>, <span class="string">"WangWu"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bb = &#123;<span class="number">11</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">4444</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Stu&gt; cc = &#123;&#123;<span class="number">99</span>, <span class="string">"ZhangSan"</span>&#125;, &#123;<span class="number">90</span>, <span class="string">"LiSi"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    cc.push_back(&#123;<span class="number">91</span>, <span class="string">"WangWu"</span>&#125;);</span><br><span class="line">    cc.push_back(Stu(<span class="number">95</span>, <span class="string">"ZhaoLiu"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cc;</span><br><span class="line">    <span class="built_in">std</span>::sort(cc.begin(), cc.end());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想倒序排序怎么办？</p><ul><li>不怎么靠谱的方法<ul><li>把小于号重载成大于号 【<strong>不推荐</strong>】</li></ul></li><li>靠谱的方法：<ul><li>写一个<strong>比较规则函数</strong>放在<code>cmp</code>的位置上，调用的时候用<code>sort(v.begin(), v.end(), cmp);</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Stu&amp; a, <span class="keyword">const</span> Stu&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score &gt; b.score) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="random-shuffle（打乱）"><a href="#random-shuffle（打乱）" class="headerlink" title="random_shuffle（打乱）"></a>random_shuffle（打乱）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要#include &lt;algorithm&gt;</span></span><br><span class="line">random_shuffle(v.begin(), v.end()); <span class="comment">//随机打乱</span></span><br></pre></td></tr></table></figure><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>用于遍历某容器的指定区间并执行某个操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for_each(v.begin(), v.end(), print);</span><br><span class="line"><span class="comment">//print 是一个函数指针</span></span><br><span class="line"><span class="comment">//这句话的意思是对从v.begin()到v.end()这个左闭右开区间中的每一个元素应用print这个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//print如果是一个函数模板，请指明其类型</span></span><br><span class="line">for_each(v.begin(), v.end(), print&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上课时的随手笔记，供期末复习用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://ilern.github.io/categories/C/"/>
    
    
  </entry>
  
</feed>
