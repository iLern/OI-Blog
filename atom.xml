<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iLern&#39;s Blog</title>
  
  <subtitle>Do what you love, love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ilern.github.io/"/>
  <updated>2020-11-12T06:37:33.905Z</updated>
  <id>http://ilern.github.io/</id>
  
  <author>
    <name>iLern</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统实验笔记（一）</title>
    <link href="http://ilern.github.io/2020/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/11/12/操作系统实验笔记（一）/</id>
    <published>2020-11-12T02:07:47.000Z</published>
    <updated>2020-11-12T06:37:33.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h2><p>创建子进程，继承父进程<code>fork()</code>之后的的指令序列，复制父进程的数据部分</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p, x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">      x = <span class="number">200</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is parent, x = %d\n"</span>, x);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = <span class="number">300</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is child, x = %d\n"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过汇编语言可以很容易理解<code>fork()</code>具有两个返回值的事情，<code>p = fork()</code>是两条指令，而子进程会执行函数调用<code>call fork</code>之后的所有指令，这样子进程和父进程的<code>p</code>就是不一样的。</p><p>当创建失败时<code>fork()</code>会返回<code>-1</code>，为了鲁棒性应该判断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span><span class="string">"test1.c"</span></span><br><span class="line"><span class="meta">.section</span>.rodata</span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"Hello world"</span></span><br><span class="line"><span class="symbol">.LC1:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is parent, x = %d\n"</span></span><br><span class="line"><span class="symbol">.LC2:</span></span><br><span class="line"><span class="meta">.string</span><span class="string">"This is child, x = %d\n"</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span>main</span><br><span class="line"><span class="meta">.type</span>main, @function</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">.cfi_startproc</span></span><br><span class="line">leal<span class="number">4</span>(%esp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">andl$-<span class="number">16</span>, %esp</span><br><span class="line">pushl-<span class="number">4</span>(%ecx)</span><br><span class="line">pushl%ebp</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0x10</span>,<span class="number">0x5</span>,<span class="number">0x2</span>,<span class="number">0x75</span>,<span class="number">0</span></span><br><span class="line">movl%esp, %ebp</span><br><span class="line">pushl%ecx</span><br><span class="line"><span class="meta">.cfi_escape</span> <span class="number">0xf</span>,<span class="number">0x3</span>,<span class="number">0x75</span>,<span class="number">0x7c</span>,<span class="number">0x6</span></span><br><span class="line">subl<span class="number">$20</span>, %esp</span><br><span class="line">movl<span class="number">$100</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$12</span>, %esp</span><br><span class="line">pushl$.LC0</span><br><span class="line"><span class="keyword">call</span>puts</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span>fork</span><br><span class="line"></span><br><span class="line"><span class="comment">;子进程会执行的部分</span></span><br><span class="line">movl%eax, -<span class="number">12</span>(%ebp)</span><br><span class="line">cmpl<span class="number">$0</span>, -<span class="number">12</span>(%ebp)</span><br><span class="line"><span class="keyword">je</span>.L2</span><br><span class="line">movl<span class="number">$200</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC1</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="keyword">jmp</span>.L3</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">movl<span class="number">$300</span>, -<span class="number">16</span>(%ebp)</span><br><span class="line">subl<span class="number">$8</span>, %esp</span><br><span class="line">pushl-<span class="number">16</span>(%ebp)</span><br><span class="line">pushl$.LC2</span><br><span class="line"><span class="keyword">call</span>printf</span><br><span class="line">addl<span class="number">$16</span>, %esp</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">movl<span class="number">$0</span>, %eax</span><br><span class="line">movl-<span class="number">4</span>(%ebp), %ecx</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="meta">.cfi_restore</span> <span class="number">5</span></span><br><span class="line">leal-<span class="number">4</span>(%ecx), %esp</span><br><span class="line"><span class="meta">.cfi_def_cfa</span> <span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="meta">.cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">.size</span>main, .-main</span><br><span class="line"><span class="meta">.ident</span><span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line"><span class="meta">.section</span>.note.GNU-stack,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>下面的代码会构成怎样的进程树？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br><span class="line">fork();</span><br></pre></td></tr></table></figure><h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid()"></a>getpid()</h2><p>获得当前进程的进程号</p><p><code>getppid()</code>获得父进程的进程号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">  p = fork();</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//running to blocked</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is parent, my pid = %d, my child = %d\n"</span>, getpid(), p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is child, my pid = %d, my parent = %d\n"</span>, getpid(), getppid());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.c" alt="3"></p><p>发现子进程的父进程编号不对，这是因为在执行子进程之前父进程已经执行结束，此时子进程称为孤儿进程<strong>Orphan Process</strong>，父进程被设置成了1305号进程</p><p><img src="4.c" alt="4"></p><p>查看所有进程发现1305号为upstart进程，用于接管孤儿进程</p><p>但是维基百科上说孤儿进程会被<code>init</code>进程或者<code>systemd</code>进程接管</p><p>想要父进程不那么快结束，可以使用<code>sleep(1)</code>让父进程进入阻塞状态一秒钟</p><p><img src="5.PNG" alt="5"></p><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><p><img src="1.PNG" alt="1"></p><p><img src="2.PNG" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;h2 id=&quot;fork（）&quot;&gt;&lt;a href=&quot;#fork（）&quot; class=&quot;headerlink&quot; title=&quot;fork（）&quot;&gt;&lt;/a&gt;fork（）&lt;/h2&gt;&lt;p&gt;创建子进程，继承父进程&lt;code&gt;fork()&lt;/code&gt;之后的的指令序列，复制父进程的数据部分&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统#" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="实验" scheme="http://ilern.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-内存管理</title>
    <link href="http://ilern.github.io/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"/>
    <id>http://ilern.github.io/2020/11/11/操作系统学习笔记-内存管理策略/</id>
    <published>2020-11-11T13:28:50.000Z</published>
    <updated>2020-11-12T02:06:57.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="http://ilern.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-网络层（一）</title>
    <link href="http://ilern.github.io/2020/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://ilern.github.io/2020/11/08/计算机网络复习笔记-网络层（一）/</id>
    <published>2020-11-08T08:52:16.000Z</published>
    <updated>2020-11-11T13:32:06.839Z</updated>
    
    <content type="html"><![CDATA[<p>Page 0 to Page （）</p><a id="more"></a><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>网络层向运输层提供服务</li><li>网络保证可靠 or 端系统保证可靠</li></ul><h3 id="网络负责可靠交互"><a href="#网络负责可靠交互" class="headerlink" title="网络负责可靠交互"></a>网络负责可靠交互</h3><ul><li>虚电路<ul><li>和电路交换类似，都需要建立连接，有电路交换的特点</li><li>但是电路交换具有排他性，虚电路没有，所以称为<strong>虚</strong>电路</li></ul></li><li>虚电路建立<strong>逻辑上</strong>的连接，分组沿着逻辑上的连接进行分组转发</li></ul><h3 id="网络负责最大努力交互"><a href="#网络负责最大努力交互" class="headerlink" title="网络负责最大努力交互"></a>网络负责最大努力交互</h3><ul><li><p>因特网真正的设计思路</p></li><li><p>不提供服务质量的承诺，只进行最大努力、无连接的<strong>数据报服务</strong></p><ul><li><p>可能出错、丢失、重复、失序</p></li><li><p>出错由ICMP解决</p></li></ul></li></ul><h4 id="尽最大努力交付的好处"><a href="#尽最大努力交付的好处" class="headerlink" title="尽最大努力交付的好处"></a>尽最大努力交付的好处</h4><ul><li>路由器可以比较简单，价格低廉</li><li>运输层负责差错处理、流量控制</li><li>网络的造假大大降低，运行方式灵活，能适用多种应用</li></ul><h3 id="虚电路与数据报的对比"><a href="#虚电路与数据报的对比" class="headerlink" title="虚电路与数据报的对比"></a>虚电路与数据报的对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">虚电路</th><th style="text-align:center">数据报</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">网络保证可靠通信</td><td style="text-align:center">端系统保证可靠通信</td></tr><tr><td style="text-align:center">连接</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">只有建立连接时使用</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发</td><td style="text-align:center">同一条虚电路的分组按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当节点故障时</td><td style="text-align:center">所有通过故障接待您的虚电路均不能工作</td><td style="text-align:center">出故障的节点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按照顺序到达终点</td><td style="text-align:center">到达顺序不一定按照发送顺序</td></tr><tr><td style="text-align:center">差错处理 / 流量控制</td><td style="text-align:center">可以由网络负责， 也可以由主机负责</td><td style="text-align:center">主机负责</td></tr></tbody></table></div><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="配套使用的三个协议"><a href="#配套使用的三个协议" class="headerlink" title="配套使用的三个协议"></a>配套使用的三个协议</h3><ul><li>地址解析协议 ARP<ul><li>Address Reesolution Protocol</li><li>IP地址转换为MAC地址</li><li>IP协议族的较下层</li></ul></li><li>网际控制报文协议 ICMP<ul><li>Internet Control Message Protocol</li><li>控制信息</li><li>IP协议族的较上层</li></ul></li><li>忘记组管理协议 IGMP<ul><li>Internet Group Management Protocol</li><li>实现多播/组播</li><li>IP协议族的较上层</li></ul></li></ul><h3 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h3><ul><li>扩展<ul><li>转发器 物理层</li><li>网桥 数据链路层</li></ul></li><li>互联<ul><li>路由器 网络层</li><li>桥路器 网桥+ 路由器</li><li>网关 网络层以上</li></ul></li></ul><h3 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h3><p>又称逻辑互联网络，当互联网上的主机进行通信时，好像在一个网络上通信一样，虽然不同物理网络的异构性客观存在，但是被屏蔽掉了，对于用户而言，只能看到像在同一个网络上通信而看不到异构细节。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>32位二进制，四个点分十进制数，每个数取值在0 - 255</li><li>定义为 网络号+主机号</li><li>8位一组</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>A类<ul><li>第一位一定是0，前8位（一个字节）表示网络号，后24位表示主机号（三个字节）</li><li>一个网络中主机数最多有$2^{24} - 2 = 16777214$</li><li>最大网络数$2^7 - 2 = 126$<ul><li>全零作为保留地址，意为本网络，不能指派</li><li>全一作为环回测试地址，不能指派</li></ul></li><li>前8位 1 - 127</li></ul></li><li>B类<ul><li>前两位一定是10，前16位（两个字节）表示网络号，后16位表示主机号（两个字节）</li><li>一个网络中主机数最多有$2^{16} - 2 = 65534$</li><li>最大网络数$2 ^ {14} = 16384$<ul><li>最小网络号为 128.0</li><li>二进制为 1000 0000 . 0000 0000</li></ul></li><li>前8位 128 - 191</li></ul></li><li>C类<ul><li>前三位一定是110，前24位（三个字节）表示网络号，后8位表示主机号（一个字节)</li><li>一个网络中主机数最多有$2^{8} - 2= 254$</li><li>最大网络数$2 ^ {21} = 2097152$<ul><li>最小网络号为 192.0.0</li><li>二进制为 1100 0000 . 0000 0000 . 0000 0000</li></ul></li><li>前8位 192 - 223</li></ul></li><li>D类<ul><li>前四位一定是1110，用于多播地址</li><li>前8位 224 - 239</li></ul></li><li>E类<ul><li>前四位为1111，留作以后使用</li><li>前8位 240 - 255</li></ul></li></ul><p><img src="IMG_1551.PNG" alt="IMG-1551"></p><h4 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h4><p><img src="IMG_1552.PNG" alt="IMG-1552"></p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">用作源地址</th><th style="text-align:center">用作目的地址</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">可</td><td style="text-align:center">不n可</td><td style="text-align:center">本网络的本主机，相当于临时牌照，申请IP地址时使用</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">host-id</td><td style="text-align:center">可</td><td style="text-align:center">不可</td><td style="text-align:center">本网络的某台主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">只在本网络进行广播，所有路由器不进行转发</td></tr><tr><td style="text-align:center">net-id</td><td style="text-align:center">全1</td><td style="text-align:center">不可</td><td style="text-align:center">可</td><td style="text-align:center">网络外成员对net-id中的的所有成员进行广播</td></tr><tr><td style="text-align:center">127（0111 1111）</td><td style="text-align:center">非全零全一</td><td style="text-align:center">可</td><td style="text-align:center">可</td><td style="text-align:center">本地软件环回测试</td></tr></tbody></table></div><h4 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h4><p>10.0.0.0 ———— 10.255.255.255</p><p>(0000 1010 . 0000 0000 . 0000 0000 . 0000 0000 —— 0000 1010 . 1111 1111 . 1111 1111 . 1111 1111)</p><p>172.16.0.0 ———— 172.131.255.255</p><p>(1010 1100 . 0001 0000 . 0000 0000 . 0000 0000 —— 1010 1100 . 1000 0011 . 1111 1111 . 1111 1111)</p><p>192.168.0.0 ———— 192.168.255.255</p><p>(1100 0000 . 1010 1000 . 0000 0000 . 0000 0000 —— 1100 0000 . 1010 1000 . 1111 1111 . 1111 1111)</p><h4 id="重要特点"><a href="#重要特点" class="headerlink" title="重要特点"></a>重要特点</h4><ul><li>分等级<ul><li>IP地址管理机构分配IP只分配网络号，主机号由网络号管理单位自行分配</li><li>路由器仅仅根据目的主机所连接的网络号来转发分组</li><li>这样就可以大大减少路由表的大小</li><li>找到了网络，再找主机就很容易了</li></ul></li><li>IP地址标志一个主机 / 路由器 / 链路的接口<ul><li>路由器属于不同网络的接口有不同的IP地址</li><li>至少有两个不同的IP地址</li></ul></li><li>网桥连接的若干局域网仍拥有相同的网络号，仍属于同一个网络<ul><li>网桥 / 转发器仅仅是扩展网络</li></ul></li><li>只包含一段线路的网络不指明IP地址</li></ul><h2 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h2><p>这里说硬件地址而不是MAC地址，因为链路层及以下使用的的硬件地址有很多种，其中以太网使用MAC地址</p><p>MAC地址 $\in$ 硬件地址</p><ul><li>路由器转发不改变IP源和目的，但是改变MAC源和目的<ul><li>网桥转发不改变MAC源和目的</li><li>路由器转发改变了链路</li></ul></li><li>数据包中间经过的路由器的IP不会出现在IP数据报的首部中</li><li>虽然首部有源站，但是路由器<strong>仅根据</strong>目的站的IP的网络号进行转发<ul><li>只找到网络就行</li></ul></li></ul><h3 id="地址解析协议-ARP-Address-Resolution-Protocal"><a href="#地址解析协议-ARP-Address-Resolution-Protocal" class="headerlink" title="地址解析协议 ARP Address Resolution Protocal"></a>地址解析协议 ARP Address Resolution Protocal</h3><ul><li>从网络层使用的IP地址解析出链路层使用的硬件地址</li><li>每个主机都有一个ARP Cache，里面有所在<strong>局域网</strong>上的各个主机和路由器的IP地址到硬件地址的映射表<ul><li>IP Address；MAC Address；TTL (Time to live) 使用老化策略，过久不使用的地址会被删除</li><li>能够减少ARP广播的数量</li></ul></li><li>发送过程<ul><li>向本局域网中的主机发送</li><li>有就把目的MAC地址写入MAC帧</li><li>没有就<strong>本地广播</strong>发送一个<strong>ARP请求分组</strong>，目的主机<strong>响应</strong>，把目的主机的MAC地址加入ARP Cache<ul><li><strong>本地广播</strong>：路由器不转发；链路层广播，MAC地址全1</li><li><strong>ARP请求分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 <strong>未知时填零</strong>/ 目标方IP地址；所有主机都会记录下发送方的硬件地址</li><li><strong>ARP响应分组</strong>：发送方硬件地址 / 发送方IP地址 / 目标方硬件地址 / 目标方IP地址；是广播实现的一对一通信</li></ul></li><li>如果目的主机和源主机不在同一个局域网，发送主机获得的就不是真正目的主机的MAC地址，而是能通往目的主机的路由器的IP地址。此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或<strong>ARP代理（ARP Proxy）</strong>。</li></ul></li><li>为什么不使用硬件地址进行通信<ul><li>异构网络很多，互相通信需要进行复杂的地址转换</li><li>IP使得所有网络像连接在同一个网络一样，把脏活累活交给ARP去做</li></ul></li></ul><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p><img src="IMG_1554.PNG" alt="ip"></p><p>首部、数据</p><p>首部包括固定部分20字节，可选部分长度不定，总共不超过60字节</p><ul><li>版本 4位<ul><li>0100 IPv4   0110 IPv6</li></ul></li><li>首部长度 4位<ul><li>最大表示15个单位，一个单位4字节，所以首部最长60字节</li></ul></li><li>区分服务 8位</li><li>总长度 16位<ul><li>首部长度 + 数据长度</li><li>单位为字节，因此数据报最大长度为$2^{16} - 1 = 65535$字节</li><li>总长度不能超过MTU</li></ul></li><li>标识 16位<ul><li>长度超过MTU则需要分片</li><li>分片后标识来自同一个数据报</li></ul></li><li>标志 3位<ul><li>目前只有前两位有意义</li><li>最低位是MF（More Fragment），中间一位是DF（Don’t Fragment）<ul><li>MF=0 没有分片了</li><li>DF=0 允许分片</li></ul></li></ul></li><li>片偏移 13位<ul><li>表示某片在原分组中的相对位置</li><li>以8字节为偏移单位，需要乘八，也就是左移三位，正好补上标志部分三位的空缺</li></ul></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Page 0 to Page （）&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记-进程同步</title>
    <link href="http://ilern.github.io/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://ilern.github.io/2020/10/15/操作系统学习笔记-进程同步/</id>
    <published>2020-10-15T07:08:38.000Z</published>
    <updated>2020-10-15T10:29:31.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h2><h3 id="About-Critical-Section"><a href="#About-Critical-Section" class="headerlink" title="About Critical Section"></a>About Critical Section</h3><ul><li><p>An atomic action is required in a critical section.</p></li><li><p>When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</p></li><li><p>The critical section is <strong>not</strong> a public section. Each process has its own critical section.</p></li><li>Each process must request permission to enter its critical section. The section of code implementing this request is the <strong>entry section</strong>, the critical section may be followed by an <strong>exit section</strong></li></ul><p><img src="https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG" alt></p><a id="more"></a><h3 id="Solution-of-the-critical-section-problem"><a href="#Solution-of-the-critical-section-problem" class="headerlink" title="Solution of the critical-section problem"></a>Solution of the critical-section problem</h3><ul><li><p>Mutual exclusion 互斥</p><ul><li>If  process $p_i$ is executing its critical section, then no other process can be executing in their critical sections</li></ul></li><li><p>progress 进步？</p><ul><li>If no process is executing in its critical section and some processes with to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which  will enter its critical section next, and this selection cannot be postponed <strong>indefinitely</strong>.</li><li>如果没有进程在执行临界区并且某些进程想要执行他们的临界区，那么只有那些不在他们剩余区的进程可以参与决定谁来执行临界区的筛选，这个选择过程不会无限期推迟。</li></ul></li><li><p>Bounded waiting 有界等待</p><ul><li><p>There exists a bound on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.</p></li><li><pre class="mermaid">    gantt                section Figure1       请求进入临界区            :des1, 1d       等待          :des2, after des1, 3d       被授权进入临界区            :des3, after des2, 5d</pre></li><li><p>如上图，在等待的过程中其他进程被允许进入临界区的次数是有限的</p></li></ul></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p><strong>两个进程</strong>的同步算法，软件实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initicall turn = 0</span></span><br><span class="line"><span class="comment">// turn is a shared variable</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (turn != i); <span class="comment">// only turn == i can this process execute it's critical section</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">//reminder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Satisfies mutual exclusion, but not progress</p><p>机械的规定零号进程一号进程交替进行。</p><p>进程是否有进入临界区的 <strong>意愿</strong> ？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initial flag[0] = flag[1] = false;</span></span><br><span class="line"><span class="comment">//flag[i] == true -&gt; process i ready to enter critical section</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]); <span class="comment">// mutual exclusion</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>不满足 progress ，在<code>flag[i] = true</code>之后，切换到另一个进程<code>flag[j] = true</code>，此时两个进程都想进临界区，但是都在看对方，都不能进入临界区</p><h3 id="Peterson‘s-Solution"><a href="#Peterson‘s-Solution" class="headerlink" title="Peterson‘s Solution"></a>Peterson‘s Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share turn flag[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>最后执行turn等于谁，谁就进入临界区</p><h2 id="Synchronization-Hardware"><a href="#Synchronization-Hardware" class="headerlink" title="Synchronization Hardware"></a>Synchronization Hardware</h2><p>Based on <strong>locking</strong></p><ul><li>Uniprocessors<ul><li>同一时刻指运行一个进程</li><li>disable interrupts 把中断屏蔽即可</li></ul></li><li>special atomic hardware instructions 硬件提供特殊的原子指令<ul><li>原子指令执行期间不允许切换</li><li><code>test memory</code> 查看某内存单元的值</li><li><code>set value</code> 对某内存单元设置为1</li><li><code>swap</code> 交换两个内存单元的值</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    acquire lock</span><br><span class="line">        <span class="comment">//criticla section</span></span><br><span class="line">    release lock</span><br><span class="line">        <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="test-and-set-Instruction"><a href="#test-and-set-Instruction" class="headerlink" title="test_and_set Instruction"></a>test_and_set Instruction</h3><p>做成<strong>一条</strong>机器指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tar 看作一个锁，一堆人去抢这把锁</span></span><br><span class="line"><span class="function">boolean <span class="title">test_and_set</span><span class="params">(boolean *tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> rv = *tar;</span><br><span class="line">    *tar = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">//got the lock or not;</span></span><br><span class="line">    <span class="comment">//flase -&gt; 锁没被锁，自己锁了</span></span><br><span class="line">    <span class="comment">//true -&gt; 已经被锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这条指令加锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutux lock</span></span><br><span class="line"><span class="comment">//锁只是一个普通变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(test_and_set(&amp;lock));</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较倒霉的情况可能不满足有界等待</span></span><br><span class="line"><span class="comment">//几率小，当倒霉处理</span></span><br></pre></td></tr></table></figure></p><h3 id="compare-and-swap-Instruction"><a href="#compare-and-swap-Instruction" class="headerlink" title="compare_and_swap Instruction"></a>compare_and_swap Instruction</h3><p>和<code>test_and_set Instruction</code>做一样的事情，但是实际功能更强。</p><p>用牛刀杀鸡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *value;</span><br><span class="line">    <span class="keyword">if</span> (*value == expected) </span><br><span class="line">        *value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旧值和新值比较</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">//是0就设置为1</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h2><p>Software Tool</p><p>使用原子的<code>acquire()</code>和<code>release()</code>来申请、释放锁，不需要在意底层具体实现方式。</p><ul><li><p>CPU busy waiting 问题</p><ul><li>循环查看锁开没开</li><li>Spinlock 自旋锁</li><li>会浪费CPU的时间</li></ul></li><li><p>更好的办法</p><ul><li>锁可用获得锁</li><li>锁不可用进程挂起</li><li>释放锁时有进程挂起则挑一个唤醒</li><li>没有进程挂起直接释放</li></ul></li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p><p>Synchronization Tool that does not require busy waiting</p><ul><li><p>is an integer</p></li><li><p><code>wait()</code> P 减信号量 请求执行</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//busy wait</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>signal()</code> V 加信号量</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>某个资源的只能被有限的人使用，例如为了保证网络通畅，只允许五个人连接。</p><p>不局限于加锁解锁，可以有一定范围。</p><p>当信号量被限制到二元，则退化（？）为互斥锁。</p><p>生产者 / 消费者问题？</p><p>有界缓冲区问题？</p><p>哲学家就餐问题？如何把这些搞哲学的饿死。</p><p><strong>一个使用信号量解决问题的例子</strong></p><p><img src="1.JPG" alt="figure1"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-Critical-Section-Problem&quot;&gt;&lt;a href=&quot;#The-Critical-Section-Problem&quot; class=&quot;headerlink&quot; title=&quot;The Critical-Section Problem&quot;&gt;&lt;/a&gt;The Critical-Section Problem&lt;/h2&gt;&lt;h3 id=&quot;About-Critical-Section&quot;&gt;&lt;a href=&quot;#About-Critical-Section&quot; class=&quot;headerlink&quot; title=&quot;About Critical Section&quot;&gt;&lt;/a&gt;About Critical Section&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;An atomic action is required in a critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The critical section is &lt;strong&gt;not&lt;/strong&gt; a public section. Each process has its own critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Each process must request permission to enter its critical section. The section of code implementing this request is the &lt;strong&gt;entry section&lt;/strong&gt;, the critical section may be followed by an &lt;strong&gt;exit section&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://ilern.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程同步" scheme="http://ilern.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-数据链路层</title>
    <link href="http://ilern.github.io/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/10/15/计算机网络复习笔记-数据链路层/</id>
    <published>2020-10-15T06:55:25.000Z</published>
    <updated>2020-11-08T13:44:20.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>数据链路层的信道种类</p><ul><li>点对点信道<ul><li>一对一通信</li></ul></li><li>广播信道<ul><li>一对多</li><li>需要专门的协议</li></ul></li></ul></li><li><p>链路与数据链路</p><ul><li>链路指一条无源的点到点的线路</li><li>物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路</li></ul></li><li><p>数据链路层的传输单位是帧 Frame</p></li><li><p>数据链路层解决的三个基本问题</p><ul><li>封装成帧</li><li>透明传输</li><li>差错控制</li></ul></li></ul><a id="more"></a><h2 id="链路层的基本功能"><a href="#链路层的基本功能" class="headerlink" title="链路层的基本功能"></a>链路层的基本功能</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul><li>添加首部尾部进行帧定界 <code>SOH</code> Start_of_header <code>EOT</code> End_of_transmission</li><li>帧定界符是特殊的控制字符</li></ul><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul><li>透明就是不透明</li><li>透明传输使得不用关心下层的传输，所采用的设备只是一个通道的作用</li><li>当传输二进制文件中出现定界符序列时，在这个序列之前添加<code>ESC</code>进行转义</li><li>称为 字节填充 / 字符填充<ul><li>在前面的非归零反相编码 NRZI 中有提到比特位填充 <code>bit_stuffing</code></li></ul></li><li>先转义还是先封装?</li></ul><h3 id="差错控制-差错检测"><a href="#差错控制-差错检测" class="headerlink" title="差错控制 / 差错检测"></a>差错控制 / 差错检测</h3><ul><li>误码率 BER<ul><li>$P_e = \frac{N_e}{N}$</li><li>传错的除以总的</li></ul></li><li>噪声的类型<ul><li>热噪声<ul><li>时刻存在、强度低</li><li>高斯白噪声</li><li>引起随机差错</li></ul></li><li>冲击噪声<ul><li>外界电磁干扰引起、强度高</li><li>闪电</li><li>引起突发错</li></ul></li></ul></li><li>纠错码与检错码<ul><li>纠错码适用于错误出现多的情况，可以由接收方发现错误并纠正</li><li>检错码适用于错误出现较少的地方，例如有线网络，发现出错后不进行纠正，直接抛弃</li></ul></li><li>常用检错码<ul><li>奇偶校验<ul><li>最后添加一个校验位</li><li>统计数据码中1的个数</li></ul></li><li>循环冗余编码CRC<ul><li>有纠错能力，但是数据链路层只用它来检错</li></ul></li></ul></li></ul><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><ul><li>生成多项式<ul><li>除数，长度为生成多项式最高项的次数，翻译为二进制为多项式每一项的系数</li></ul></li><li>FCS<ul><li>帧检验序列</li><li>CRC是生成FCS的一种方法但不是唯一方法</li></ul></li><li>无差错接受<ul><li>凡是接受的帧，都可以以非常接近于1的概率认为它正确的</li><li>也有可能因为噪声，所有的位变成了0，但是概率非常小</li></ul></li></ul><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><ul><li>PPP 既能面向Bit也能面向字节 / 字符</li><li>点对点通信</li><li>只支持全双工</li><li>使用广域网进行串行通信</li></ul><h3 id="需要满足的要求"><a href="#需要满足的要求" class="headerlink" title="需要满足的要求"></a>需要满足的要求</h3><ul><li>简单</li><li>链路层功能<ul><li>封装成帧</li><li>透明性</li><li>差错检测</li></ul></li><li>对上与对下<ul><li>多种网络层协议</li><li>多种类型链路</li></ul></li><li>检测连接状态</li><li>最大传送单元<ul><li>MTU</li><li>不包含帧头帧尾</li><li>发送过程中逐步进行调整</li><li>高层协议根据链路层的MTU进行分片</li></ul></li><li>网络层地址协商</li><li>数据压缩协商</li></ul><h3 id="不需要的功能"><a href="#不需要的功能" class="headerlink" title="不需要的功能"></a>不需要的功能</h3><ul><li><p>纠错</p><ul><li>链路层不要求可靠性</li></ul></li><li><p>流量控制</p><ul><li>流量来自于端系统的进程，进程间通信由TCP协议负责</li></ul></li><li><p>序号</p><ul><li>PPP不保证可靠性</li><li>实际上链路层的传输本就很可靠</li></ul></li><li><p>多点链路</p><ul><li>PPP只支持点对点</li></ul></li><li><p>半双工 / 单工链路</p><p>PPP只支持全双工链路</p></li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>一个将IP数据报封装到串行链路的方法<ul><li>面向字符的异步链路</li><li>面向比特的同步链路</li></ul></li><li>链路控制协议 <code>LCP</code> Link Control Protocol<ul><li>与物理层交互</li></ul></li><li><strong>一套</strong>网络控制协议 <code>NCP</code> Network Control Protocol<ul><li>与网络层交互</li><li>每个协议支持一种不同的网络层协议</li></ul></li></ul><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><ul><li>首部<ul><li>定界符 / 定界字节序列　　0x7E</li><li>AC 固定的两个部分，但是说不准以后会有用</li><li>协议<ul><li>0x0021 信息部分为IP数据报</li><li>0xC021 信息部分位PPP链路控制数据</li><li>0x8021 信息部分位网络控制数据</li></ul></li></ul></li><li>信息部分<ul><li>IP数据报</li></ul></li><li>尾部<ul><li>CRC检验序列<ul><li>从AC开始到信息部分结束</li><li>万一以后AC部分有用呢</li></ul></li><li>定界符 / 定界字节序列        0x7E</li></ul></li></ul><h4 id="字节填充"><a href="#字节填充" class="headerlink" title="　字节填充"></a>　字节填充</h4><ul><li>出现控制字符时，前面添加转义字符0x7D，同时第六个bit取反</li></ul><h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><ul><li>SONET / SDH使用同步传输，同步传输中没有 <strong>字符</strong> 的概念</li><li>0x7E = 0111 1110</li><li>5个连续1之后插一个0，保证不出现连续6个1，就不会出现定界符</li></ul><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><ul><li>使用时钟信号线或前同步序列保证发送端与接收端的时钟保持同步</li><li>以数据帧位单位传输</li></ul><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><ul><li>以字符为单位传输</li><li>每个字符前添加起始位0，后面加停止位1，表示数据的开始和结束</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>连接从下往上建立，从上往下释放</p><ul><li>调制解调器建立物理连接</li><li>PC向路由器发送一系列的LCP分组 （0xC021）建立LCP连接</li><li>NCP给新接入的PC分配一个临时的IP地址</li><li>通信</li><li>NCP释放网络层链接，收回临时IP</li><li>LCP释放数据链路层连接</li><li>释放物理层链接</li></ul><h3 id="挑战握手认证协议-CHAP"><a href="#挑战握手认证协议-CHAP" class="headerlink" title="挑战握手认证协议 CHAP"></a>挑战握手认证协议 CHAP</h3><p>在初始链路建立时完成，也可以在链路建立后的任何时刻进行</p><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><ul><li><p>IEEE 局域网标准</p><ul><li>IEEE 802.3     CSMA/CD</li><li>IEEE 802.4     令牌总线</li><li>IEEE 802.5     令牌环</li></ul></li><li><p>局域网的特点</p><ul><li>网络为一个单位所拥有，地理范围和站点数目均有限</li></ul></li><li>局域网的拓扑结构<ul><li>环形    环形令牌网</li><li>总线 <ul><li>两端带有匹配电阻吸收电磁波信号的能量</li><li>CSMA/CD</li></ul></li><li>星形</li><li>树形</li></ul></li><li>共享信道<ul><li>静态划分   不能适用于网络的突发性</li><li>动态接入<ul><li>随机接入    需要解决冲突</li><li>受控接入</li></ul></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>使用<strong>曼彻斯特编码</strong>进行数据传输</p><ul><li>不需要尾部的定界符</li><li>可以在$1 \over 2$处不跳变</li></ul></li><li><p>数据链路层的子层</p><ul><li>LLC Logical Link Control<ul><li>面向上层，与传输媒体无关</li></ul></li><li>MAC Medium Access Control<ul><li>面向下层</li><li>数据帧真正完成封装的位置</li></ul></li><li>MAC 子层的功能<ul><li>数据真的封装/卸装</li><li>帧的寻址和识别</li><li>帧的接受和发送</li><li>链路的管理</li><li>帧的差错控制</li><li>仲裁介质的使用权</li></ul></li></ul></li><li>LLC 子层的功能<ul><li>识别网络层协议，进行封装，加上一个LLC报头</li><li>接收方可识别使用了何种局域网</li><li>以太网一统天下，LLC实际作用不大</li></ul></li></ul><h4 id="为什么说以太网很简便"><a href="#为什么说以太网很简便" class="headerlink" title="为什么说以太网很简便"></a>为什么说以太网很简便</h4><ul><li>无连接</li><li>不编号，不要求对方发回确认</li><li>提供不可靠的最大努力交付，高层发现丢失了一些数据帧并进行重传，但是以太网并不知道这是一个重传的帧，而是完全当作一个新的数据帧来发送</li></ul><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器既有链路层的功能，也有物理层的功能</p><ul><li>适配器的主要功能<ul><li>串行/并行转换</li><li>数据缓存</li><li>安装设备驱动程序（设备与CPU通信的媒介）</li><li>实现以太网协议</li></ul></li></ul><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><ul><li><p>CSMA/CD 是<strong>随机征用型</strong>的介质访问控制方法</p></li><li><p>载波监听 多点接入 with 冲突检测</p><ul><li>载波监听  每个站在发送数据前都要检测总线上是否有其他站在发信息</li><li>多点接入  多个站点连接在一根总线上</li><li>冲突检测  边发送数据边检测信道上的信号电压大小，当发现冲突时做出相应处理</li></ul></li><li><p>Carrier Sense Multiple Access with Collision Detection</p></li><li><p>以帧为单位传输</p><ul><li>存在 IFG Interframe Gap 帧间距</li><li>网络设备和组件在接受一个帧后，需要一段时间恢复为接受下一帧做准备</li><li>IFG 最小为96比特时间</li></ul></li></ul><h3 id="站模型"><a href="#站模型" class="headerlink" title="　站模型"></a>　站模型</h3><p>各个站点相互独立，以固定速率产生数据帧。某个站点一旦产生新帧，即使被阻塞，也不会有新的帧产生，直到发送完毕</p><h3 id="单信道假设"><a href="#单信道假设" class="headerlink" title="单信道假设"></a>单信道假设</h3><p>所有通信都是通过单信道进行，任何时刻仅允许一个站点发送，需要争用发送权</p><h3 id="冲突假设"><a href="#冲突假设" class="headerlink" title="冲突假设"></a>冲突假设</h3><p>若两帧同时发送，则产生冲突，所有站点都能检测冲突，冲突的帧必须重发</p><h3 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h3><p>帧可以在任意时刻发送</p><h3 id="侦听假设"><a href="#侦听假设" class="headerlink" title="　侦听假设"></a>　侦听假设</h3><p>所有站点都可以侦听到当前信道的状态，若忙则等待</p><p>但是当某个站监听到总线是空闲时，可能总线并不是真正空闲，因为信号的传播需要时间，也就是之前提到过的<strong>传播时延</strong></p><p>策略：</p><ul><li>非坚持     忙则不等，过会再来看</li><li>１坚持    一直等待，直到空闲</li><li>Ｐ坚持    以概率为P进行等待</li></ul><h3 id="传播时延对载波侦听的影响"><a href="#传播时延对载波侦听的影响" class="headerlink" title="传播时延对载波侦听的影响"></a>传播时延对载波侦听的影响</h3><p>A在 $t=0$ 时刻发送信号，B在$t = \tau - \delta$ 发送信号，两者信号在 $t = \tau - \frac{\delta}{2}$ 时刻碰撞，B在$t = \tau$时刻检测到碰撞，A在$t=2\tau-\delta$ 时刻检测到碰撞，$\tau$指传播时间。</p><p><img src="IMG_4731.PNG" alt="IMG_4731"></p><p>先发送的一方较后检测到冲突。</p><h3 id="CSMA-CD的重要特性"><a href="#CSMA-CD的重要特性" class="headerlink" title="CSMA/CD的重要特性"></a>CSMA/CD的重要特性</h3><ul><li>CSMA/CD不能进行全双工通信，只能进行半双工通信 （而PPP只支持全双工通信）</li><li>每个站在发送数据之后的一段时间内，存在着遭遇碰撞的可能性<ul><li>时间的从长短取决于发送方到接收方的距离</li></ul></li><li>发送的不确定性使得整个以太网的平均通信两远小于以太网的最高数据率<ul><li>以太网不能保证某一时间内一定能把自己的数据帧成功发出去</li></ul></li><li>因此以太网必须轻负载，百分之三十左右</li></ul><h3 id="关于碰撞"><a href="#关于碰撞" class="headerlink" title="关于碰撞"></a>关于碰撞</h3><h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><p>在发送数据后至多 $2\tau$ 时间可以知道是否发生冲突，这段时间称为<strong>争用期</strong>或<strong>碰撞窗口</strong>，经过这段时间后还没有检测到碰撞，则说明本次传输不会发生碰撞</p><ul><li>所有以太网取 $51.2 \mu s$ 作为争用期长度<ul><li>以太网的设计决定了最长的2RTT不会超过 $51.2 \mu s$ </li></ul></li><li>对于 10Mb/s 的以太网，争用期内可以发送 512bit 即 64 字节<ul><li>发生冲突一定是在前64字节以内</li><li>最短的有效帧长为64字节</li></ul></li><li>或者说争用期的长度是512比特时间</li></ul><h4 id="截断二进制指数类型退避算法"><a href="#截断二进制指数类型退避算法" class="headerlink" title="截断二进制指数类型退避算法"></a>截断二进制指数类型退避算法</h4><ul><li>碰撞之后退避一段时间再发送</li><li>基本退避时间是$ 2\tau $ （512比特时间），在此基础上乘以$[0, 1, \dots, (2^k - 1)]$中随机一个数，$k$是重传次数，最大为$10$</li><li>争用期的若干倍数</li><li>重传$16$次还是失败，直接丢弃</li><li>会出现<strong>捕获效应</strong>，越退越倒霉</li></ul><h4 id="碰撞发生后"><a href="#碰撞发生后" class="headerlink" title="碰撞发生后"></a>碰撞发生后</h4><ul><li>检测到碰撞立即停止发送数据，并发送干扰信号，让其他主机知道发生了碰撞</li></ul><p><img src="IMG_4734.PNG" alt="image-4734"></p><ul><li>时间的浪费</li></ul><p><img src="IMG_4735.PNG" alt="image-4735"></p><h3 id="整个发送过程"><a href="#整个发送过程" class="headerlink" title="整个发送过程"></a>整个发送过程</h3><p>准备发送</p><p>​    适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中，准备发送</p><p>检测信道</p><p>​    在96比特时间内（IFG 帧间距）没有检测到信道上有信号，就发送</p><p>发送</p><p>​    发送过程中持续检测信道，若检测到碰撞，就终止发送，并发送干扰信号</p><p>终止发送后</p><p>​    执行指数退避算法，等待$r$ 倍的512比特时间，继续检测信道</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>先听后说，边听边说</p><p>一旦冲突，立即停说</p><p>等待时机，然后再说</p><h2 id="使用广播信道的以太网"><a href="#使用广播信道的以太网" class="headerlink" title="使用广播信道的以太网"></a>使用广播信道的以太网</h2><h3 id="以太网物理设备的演进"><a href="#以太网物理设备的演进" class="headerlink" title="以太网物理设备的演进"></a>以太网物理设备的演进</h3><ul><li>粗同轴电缆       10BASE5<ul><li>10Mbit/s，基带信号，最大段长度500m</li><li>站与站之间大于等于2.5m，网络最大跨度2.5km</li><li>中继器：信号的整形与放大</li><li>收发器：发送、接收、冲突检测、电气隔离</li><li>粗缆以太网的冲突检测不靠网卡进行</li></ul></li><li><p>细同轴电缆       10BASE2</p><ul><li>10Mbit/s，基带信号，最大段长度约等于200m</li><li>没有外置收发器</li><li>冲突检测由网卡完成</li></ul></li><li><p>双绞线              10BASE-T</p><ul><li>使用RJ45连接器</li><li>所有站点与集线器相连接</li><li>集线器：信号放大与整形，是物理层设备</li><li>两个集线器连接时要使用交叉链接法</li><li>帧长度可变，最大1518个字节，其中18个字节的MAC头尾，1500个字节的IP数据报</li></ul></li><li>光纤                 10BASE-F</li></ul><h3 id="RJ45连接头"><a href="#RJ45连接头" class="headerlink" title="RJ45连接头"></a>RJ45连接头</h3><p>锁扣朝上，从左到右编号1-8</p><p><img src="IMG_4796.JPEG" alt="IMG-4976"></p><ul><li>为什么要两发两收<ul><li>传送的是差分信号，用两个信号的差值作为传输的信号，相当于放大，更容易识别</li></ul></li></ul><h3 id="集线器的特点"><a href="#集线器的特点" class="headerlink" title="集线器的特点"></a>集线器的特点</h3><ul><li>逻辑总线</li><li>多借口转发器</li><li>转发比特，不进行碰撞检测<ul><li>工作在物理层</li></ul></li></ul><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><ul><li><p>一些时间</p><ul><li>争用期长度为$2 \tau$，是RTT的两倍</li><li>帧长为$L$</li><li>数据发送率为$C$</li><li>帧的发送时间 / 发送时延 / 传输时延 为$\frac{L}{C} = T_0$</li></ul></li><li><p>发送一帧需要经过若干个争用期，然后经过发送时延和传输时延</p><p><img src="IMG_4795.PNG" alt="IMG-4795"></p></li><li><p>$a = \frac{\tau}{T_0}$，$a$小则说明信道利用率高，$a$大则说明每碰撞一次都会浪费许多信道资源</p></li><li><p>减小连线长度 / 增加帧长</p></li><li><p>理想情况下，极限信道利用率为，此时不发生碰撞</p><script type="math/tex; mode=display">S_{\text{max}} = \frac{T_0}{T_0 + \tau} = \frac{1}{1 + a}</script></li></ul><h2 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h2><ul><li>硬件地址 / 物理地址 / MAC地址</li><li>一个主机多个网卡的话就有多个MAC地址</li><li>MAC地址应当理解为某个接口的标识符</li><li>网卡使用MAC地址检查某个帧是不是发给自己</li></ul><h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><p>最常用的是以太网V2标准的格式，IEEE802.3的格式和V2相差无几，我们研究的重点是以太网的V2协议。</p><p><img src="IMG_4834.PNG" alt="img4834"></p><ul><li><p>类型字段用来表示上一层使用的是什么协议</p><ul><li>不一定是<strong>网络层</strong>，比如PPP协议，PPPoE</li></ul></li><li><p>为什么先是目的地址再是源地址</p><ul><li>方便解析，能快速判断是不是发给自己的</li></ul></li><li><p>在使用VLAN虚拟局域网的时候MAC帧的长度可能会超过1518</p><ul><li>1500字节的数据部分</li><li>目的地址6，源地址6，类型2，FCS 4</li></ul></li><li><p><code>0x0800</code>表示IP，<code>0x0806</code>表示ARP</p></li><li><p>最后的FCS校验全部的内容</p><ul><li>不包含帧定界符，因为使用曼彻斯特编码，时钟周期中间不跳变即标明发送结束，不需要帧定界符</li><li>不需要帧定界符也就不需要使用字节插入来实现透明传输</li></ul></li><li><p>当数据字段的长度小于46字节时，再数据字段后面加入整数字节的填充字段</p><ul><li>MAC层因为没有长度计数，所以MAC层并不知道有填充，填充也不发生在MAC层</li><li>填充发生在网络层或者有长度指征的层</li><li>例如IP协议有一个总长度字段，表示MAC层的真实数据字段</li></ul></li><li><p>如何计算传输效率</p><ul><li>$ \frac{X}{X + 18 + 8 + 12}$</li><li>18字节的控制信息，8字节的前同步码，12字节的帧间隔IFG<ul><li>前同步码是一串规律的01序列，用于告知接收方发送方的时钟序列，最后两个11表示准备发送</li><li>同步传输，所以需要前同步码</li></ul></li></ul></li><li><p>无效的MAC帧</p><ul><li>数据字段长度不在46 ~ 1500字节之间<ul><li>46 + 18 = 64，恰好是可以接受的最短帧长</li><li>参看 CSMA/CD  /  关于碰撞 / 争用期</li></ul></li><li>以太网对于无效的MAC帧直接丢弃，不负责重传，由更高层负责</li><li>无效帧的出现不一定因为发生了碰撞。例如断电。</li></ul></li></ul><h3 id="IEEE-802-3的MAC协议"><a href="#IEEE-802-3的MAC协议" class="headerlink" title="IEEE 802.3的MAC协议"></a>IEEE 802.3的MAC协议</h3><ul><li>区别仅在于，第三个字段是长度<strong>或</strong>类型。长度和类型只能有一个，大于<code>0x6000</code>时表示类型， 小于<code>0x6000</code>时表示长度</li><li>因为长度最大不会超过<code>0x6000</code></li><li>当实际长度与长度字段不同时被视为无效帧</li><li>强行让LLC发挥作用</li></ul><h3 id="无效的MAC帧"><a href="#无效的MAC帧" class="headerlink" title="无效的MAC帧"></a>无效的MAC帧</h3><ul><li>802.3协议中数据字段的长度与长度字段不一致</li><li>帧的长度不是整数个字节</li><li>FCS检测出错</li><li>数据字段的长度不在46 ~ 1500字节之间</li></ul><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><ul><li>使用多个集线器级联</li><li>把多个碰撞域合并成一个碰撞域<ul><li>Collision Domain</li><li>所有可能发生冲突的站点的集合</li><li>冲突域被看作物理层的感念</li></ul></li><li>缺点<ul><li>通信效率会下降，但是使得不同局域网可以通信，扩大了以太网覆盖的地理范围</li><li>总的吞吐量没有提高</li><li>数据率不同的碰撞域连接起来会使得较快的无法发挥出自己的吞吐量</li></ul></li></ul><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><ul><li><p>使用网桥 / 转发器</p><ul><li>根据MAC地址进行转发和过滤</li></ul></li><li><p>过滤通信量、增大吞吐量、划分冲突域 / 碰撞域</p></li><li><p>缺点</p><ul><li>需要存储转发，增加了时延</li><li>转发前执行CSMA/CD算法</li><li>没有流量控制，帧多的时候会导致缓存空间不够，发生帧丢失</li><li>不同MAC子层的网段桥接在一起时延更大</li><li>只适合用户数不太多，通信量不太大的局域网</li></ul></li></ul><h4 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h4><ul><li>广播域<ul><li>数据能广播到的范围，能收到同样广播的设备的集合</li><li>是链路层的概念（冲突域是物理层的概念）</li></ul></li><li>产生于网络拓扑的设计和连接问题</li></ul><h3 id="使用交换机扩展以太网"><a href="#使用交换机扩展以太网" class="headerlink" title="使用交换机扩展以太网"></a>使用交换机扩展以太网</h3><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>目前所有的标准网桥都必须支持透明网桥，源路由网桥为可选配置</p><h3 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h3><p><strong>透明网桥的特点</strong></p><ul><li>使用最多</li><li>“透明”，网桥对于站点来说是看不见的</li><li>即插即用，不需要人工配置转发表<ul><li>需要配置转发表的为静态网桥</li></ul></li><li>网桥的转发表不宜过大，有些旧的地址应该淘汰<ul><li>网络拓扑可能变化</li><li>可能由于更换网卡导致MAC地址变化</li><li>不是所有的站点总是接通电源</li><li>有的站点从不发送数据或者长时间不发送数据</li></ul></li></ul><p><strong>透明网桥的缺点</strong></p><ul><li>不能充分利用网络资源，尤其不能保证最佳路由（由于生成树算法导致相距很近的节点可能需要绕圈子）</li><li>为了防止广播风暴的产生，透明网桥只能使用生成树，不能保证每条路由最佳，也不能进行负载均衡</li></ul><h4 id="网桥自学习算法"><a href="#网桥自学习算法" class="headerlink" title="网桥自学习算法"></a>网桥自学习算法</h4><p>分为自学习和转发两个过程</p><ul><li>每一次转发都可以得知发送站相对于自己的<strong>方向</strong>（源地址、进入的接口、时间）<ul><li>如果之前没有与源地址匹配的项目就插入转发表，若有则更新转发表</li><li>但是帧从接口X进入网桥不代表帧发送站在X的网段上</li></ul></li><li>当转发表中无目的地址时无条件进行转发到所有其他接口，记录下发送站相对于自己的方向</li><li>当目的地址和源地址在网桥的同一方向时不需要转发，直接丢弃，转发表不变<ul><li>一个网桥丢弃帧不代表所有的网桥都会丢弃帧</li></ul></li><li>网桥的转发需要拆帧成帧，集线器转发只是整型、放大</li></ul><h4 id="透明网桥的生成树算法"><a href="#透明网桥的生成树算法" class="headerlink" title="透明网桥的生成树算法"></a>透明网桥的生成树算法</h4><ul><li>为了解决广播风暴的问题</li><li>当拓扑结构中存在环的时候求其中的生成树,消除图中的环路，从而保证两个站点之间只有一条路径。</li><li>最小序号网桥作为生成树的根</li><li>网桥为边，网段为节点</li></ul><h3 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h3><ul><li>发送帧时，详细路由信息放在帧的首部</li><li>发送数据帧之前，先发送<strong>发现帧</strong>，发现帧记录经过的路由，到达目的之后按照记住的路由返回</li><li>源站根据这些路由得到一个最佳路由进行发送</li><li>不再透明</li><li>发现帧还能够帮助源点确定整个网络可以通过的帧的最大长度</li><li>可以实现负载均衡</li><li>可以使用最佳路由</li></ul><h3 id="多接口网桥-以太网交换机"><a href="#多接口网桥-以太网交换机" class="headerlink" title="多接口网桥 / 以太网交换机"></a>多接口网桥 / 以太网交换机</h3><ul><li><p>以太网交换机实质上是一个多接口的网桥，交换机出现之后网桥很快被淘汰了</p><ul><li>Multiport Repeater = Hub</li><li>Multiport Bridge = Switch</li></ul></li><li><p>通常工作在链路层，常被称为第二层交换机</p></li><li><p>交换机本质上和网桥一样</p><ul><li>网桥传统上基于软件，交换机基于硬件<ul><li>由数据转发的逻辑部分和输入输出端口组成（input / output port）</li></ul></li><li>两者<strong>等效</strong>而非<strong>等价</strong></li><li>交换机的和网桥一样缩小了网络的冲突域，一个端口就是一个冲突域<ul><li>一个端口连接一个计算机时，仍采用CSMA/CD的控制方法</li><li>只要网络上的用户不同时访问一个接口，而且是全双工通信，就不会发生冲突</li></ul></li></ul></li><li><p>有的交换机还具有差错控制的功能</p></li><li><p>能够提高带宽</p><p><img src="daikuan.png" alt></p></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>收到一个包时可以知道源MAC的机器连在哪个端口的方向上<ul><li>之前有过这一项就更新，没有就添加</li></ul></li><li>转发包时在转发表中查找目的MAC地址<ul><li>如果有则直接复制到目的端口上</li><li>没有则泛洪到所有端口</li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>以太网交换机的每个接口都直接与主机或者另一个集线器相连</li><li>一般使用全双工的工作方式<ul><li>此时CSMA/CD的单信道假设不再成立</li></ul></li><li>能同时联通多对接口，每一对相互通信的主机都可以无碰撞的传输数据</li><li>和透明网桥一样，即插即用，使用自学习法逐步建立转发表</li><li>因为用硬件实现，转发速度较快</li></ul><h4 id="交换技术的种类"><a href="#交换技术的种类" class="headerlink" title="交换技术的种类"></a>交换技术的种类</h4><ul><li>直通方式<ul><li>只检查包头，把数据包转发到输出端口</li><li>转发速率高，但是会转发错误帧</li></ul></li><li>存储转发方式<ul><li>缓存数据包，进行CRC检验，过滤掉不正确的包</li><li>可以让错误包提前过滤掉，但是牺牲效率</li></ul></li><li>无碎片直通方式<ul><li>只检查数据包的长度够不够64字节，只去除无效帧</li><li>介于以上两者之间，比较平衡的方式</li></ul></li></ul><h2 id="虚拟局域网-VLAN"><a href="#虚拟局域网-VLAN" class="headerlink" title="虚拟局域网 VLAN"></a>虚拟局域网 VLAN</h2><p>由<code>IEEE 802.1Q</code>定义</p><ul><li>一些局域网网段构成的与物理位置无关的逻辑组，这些网段有某些共同的需求</li><li>每个VLAN的帧都有明确的标识符，标明这个帧属于哪个VLAN<ul><li>所以帧长会超过1518</li><li><img src="IMG_1543.PNG" alt="IMG_1543"></li></ul></li><li>虚拟局域网是局域网的一种服务，而非另一种新型的局域网</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>安全性</li><li>降低负载的相互影响</li><li>防止广播风暴</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>VLAN中的每一个站点都可以听到同一个VLAN上的其他站点发出的广播</li><li>不会产生广播风暴</li><li>需要路由器或者第三层交换机</li><li>VLAN的工作站可以在不同的局域网（网段）中，也可以不在同一楼中（地理位置）</li></ul><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><h4 id="根据端口来划分"><a href="#根据端口来划分" class="headerlink" title="根据端口来划分"></a>根据端口来划分</h4><ul><li>物理层</li><li>一个或多个交换机上的几个端口划分为一个逻辑组</li><li>一个集线器上的站点只能属于同一个VLAN</li></ul><h4 id="根据MAC地址来划分"><a href="#根据MAC地址来划分" class="headerlink" title="根据MAC地址来划分"></a>根据MAC地址来划分</h4><ul><li>数据链路层</li><li>可以实现同一广播域内站点的自由移动</li><li>但是需要对大量毫无规律的MAC地址进行操作</li></ul><h4 id="根据网路层来划分"><a href="#根据网路层来划分" class="headerlink" title="根据网路层来划分"></a>根据网路层来划分</h4><ul><li>网络层</li><li>按照站点的IP地址来定义广播域，形成虚拟IP子网</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据链路层的信道种类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点信道&lt;ul&gt;
&lt;li&gt;一对一通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广播信道&lt;ul&gt;
&lt;li&gt;一对多&lt;/li&gt;
&lt;li&gt;需要专门的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链路与数据链路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链路指一条无源的点到点的线路&lt;/li&gt;
&lt;li&gt;物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层的传输单位是帧 Frame&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层解决的三个基本问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装成帧&lt;/li&gt;
&lt;li&gt;透明传输&lt;/li&gt;
&lt;li&gt;差错控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习笔记</title>
    <link href="http://ilern.github.io/2020/02/22/learn_SQL/"/>
    <id>http://ilern.github.io/2020/02/22/learn_SQL/</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2020-02-22T14:14:41.501Z</updated>
    
    <content type="html"><![CDATA[<p>非常粗浅的SQL学习笔记，关于如何<strong>使用</strong>SQL。</p><p>笔记中使用开源的MySQL作为数据管理软件。</p><a id="more"></a><h2 id="MySQL-Client"><a href="#MySQL-Client" class="headerlink" title="MySQL Client"></a>MySQL Client</h2><p>安装好MySQL之后，除了服务器以外，还装上了一个客户端，对于数据库的操作都是由这个客户端提供的。客户端通过TCP连接服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接本地服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h &lt;IP&gt; -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接远程SQL服务器。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">-- 显示全部数据库</span><br><span class="line">CREATE DATABASES test;</span><br><span class="line">-- 创建数据库</span><br><span class="line">DROP DATABASES test;</span><br><span class="line">-- 删除数据库</span><br><span class="line">USE test;</span><br><span class="line">-- 切换到某个数据库</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">-- 显示表</span><br><span class="line">CREATE TABLE students</span><br><span class="line">-- 创建表</span><br><span class="line">DROP TABLE students</span><br><span class="line">-- 删除表</span><br><span class="line"></span><br><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br><span class="line">-- 修改列</span><br><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br><span class="line">-- 删除列</span><br></pre></td></tr></table></figure><p><code>ALTER</code>似乎是Alternate的意思，和键盘上的Alt键一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXIT</span><br><span class="line">-- 退出</span><br></pre></td></tr></table></figure><p>这些都是MySQL的操作，对于不同的数据库系统可能有不同的指令。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt;;</span><br><span class="line"><span class="comment">-- 列出某个表的所有行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出符合条件的所有行</span></span><br><span class="line"><span class="comment">-- 条件运算包括 &gt;= / &lt;= / = / &lt;&gt; / AND / OR / NOT 等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_columns&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出想要的列</span></span><br><span class="line"><span class="comment">-- 可以对列起一个别名方便表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt; </span><br><span class="line"><span class="keyword">WHERE</span> &lt;confition&gt; </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt; &lt;<span class="keyword">DESC</span>&gt;;</span><br><span class="line"><span class="comment">-- DESC可以降序排序，默认是升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;conition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_size_of_page&gt;</span><br><span class="line"><span class="keyword">OFFSET</span> &lt;number_of_offset&gt;;</span><br><span class="line"><span class="comment">-- 从&lt;number_of_offset&gt;开始分页显示，每页最多显示&lt;limit_size_of_page&gt;个</span></span><br><span class="line"><span class="comment">-- 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL内置聚合函数</span></span><br><span class="line">COUNT()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">SUM()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">MAX()</span><br><span class="line"><span class="comment">-- 计算某一列的最大值</span></span><br><span class="line">MIN()</span><br><span class="line"><span class="comment">-- 计算某一列的最小值</span></span><br><span class="line">AVG()</span><br><span class="line"><span class="comment">-- 计算某一列的平均值，该列必须为数值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;num_of_colmns&gt;;</span><br><span class="line"><span class="comment">-- 按照列中的值自动分别计算&lt;function&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接查询</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常粗浅的SQL学习笔记，关于如何&lt;strong&gt;使用&lt;/strong&gt;SQL。&lt;/p&gt;
&lt;p&gt;笔记中使用开源的MySQL作为数据管理软件。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://ilern.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://ilern.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>如何实现减法</title>
    <link href="http://ilern.github.io/2020/01/22/how_to_diff/"/>
    <id>http://ilern.github.io/2020/01/22/how_to_diff/</id>
    <published>2020-01-22T13:33:00.000Z</published>
    <updated>2020-03-11T00:08:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。</p><p>将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。</p><p>至此就实现了二进制加法。</p><p>每一个全加器只能计算<strong>一位</strong>二进制数，要进行多位二进制数的加法就需要串联多个全加器。</p><a id="more"></a><h2 id="大数减小数"><a href="#大数减小数" class="headerlink" title="大数减小数"></a>大数减小数</h2><p>对于减法而言，不存在进位，但是有借位。</p><p>为了避免借位，提出<strong>补数</strong>的概念</p><blockquote><p>对于一个 $k$ 进制数 $a$ ，从一串 $k$ 中（个数等于 $k$ 进制下 $a$ 的位数）减去 $a$ 得到的数，称为 $a$ 对 $k$ 的补数</p></blockquote><p>提出补数的好处是计算补数的过程不需要借位</p><p>当计算出补数之后，将补数与被减数<strong>相加</strong>，把结果加一，再减去$10^n$，$n$为$a$的位数。</p><p>为什么这样可行？举个例子</p><script type="math/tex; mode=display">\begin{align}   253 - 176 &= 253 - 176 + 1000 - 1000 \\   &= 253 - 176 + 999 + 1 - 1000  \\   &= 253 + (999 - 176) + 1 - 1000\\\end{align}</script><p>二进制的减法与之类似。</p><p>注意到现在式子中唯一的减法其实就是求这个数的补数。</p><p>对于一个二进制数，计算它的补数只需要对其按位取反，也就是它的<strong>反码</strong>(inverse)。</p><p>并且，对于最后一步减法，也是不必真的做的，最高位会自然溢出，作为进位被丢掉。</p><p>至此，大数减小数的减法就实现了。</p><h2 id="表示负数"><a href="#表示负数" class="headerlink" title="表示负数"></a>表示负数</h2><p>首先明确一点，计算机处理的位数是有限的，超过最高位的数将会溢出。</p><h2 id="小数减大数"><a href="#小数减大数" class="headerlink" title="小数减大数"></a>小数减大数</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。&lt;/p&gt;
&lt;p&gt;将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。&lt;/p&gt;
&lt;p&gt;至此就实现了二进制加法。&lt;/p&gt;
&lt;p&gt;每一个全加器只能计算&lt;strong&gt;一位&lt;/strong&gt;二进制数，要进行多位二进制数的加法就需要串联多个全加器。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="《编码》笔记" scheme="http://ilern.github.io/tags/%E3%80%8A%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业三 邮件服务器</title>
    <link href="http://ilern.github.io/2019/11/27/Computer-Networking-Lab-3/"/>
    <id>http://ilern.github.io/2019/11/27/Computer-Networking-Lab-3/</id>
    <published>2019-11-26T16:00:00.000Z</published>
    <updated>2019-11-27T14:52:36.345Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业三</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>通过完成本实验，您将更加了解SMTP协议。您还将学到使用Python实现标准协议的经验。</p><p>您的任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。您的客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>在某些情况下，接收邮件服务器可能会将您的电子邮件分类为垃圾邮件。当您查找从客户端发送的电子邮件时，请检查垃圾邮件文件夹。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于某些众所周知的原因，本实验不使用Google邮箱，而是使用QQ邮箱。</p><p>基本流程如下</p><ul><li>与QQ邮箱服务器（smtp.qq.com）建立TCP连接，这里为了简单起见，使用非SSL协议的25端口。其他邮件服务器见这篇文章：<a href="https://blog.csdn.net/qq_25046261/article/details/78982080" target="_blank" rel="noopener">常用的邮件服务器名称、地址及SSL/非SSL协议端口号</a>。成功建立连接之后，服务器会返回状态码220表示已就绪。</li><li>发送 HELO 命令，输入自己的账户，开始试图与服务器交互。</li><li>发送 AUTH LOGIN 命令，输入密码。这里的密码指的是<strong>邮件服务器提供的授权码</strong>，而不是平时在web端登录的密码。</li><li>上面提到的用户名和密码都是<strong>经过Base64加密后的结果</strong>。我在这一步卡了很久，最后发现原因是在网上找的Base64加密工具给出的结果是错的，换一个工具就好了。</li><li>登录成功后，服务器会返回状态码235表示成功。</li><li>发送 MAIL FROM 命令，表明发信人，应当与 HELO-AUTH 命令中验证的邮箱保持一致。成功后会收到 <code>250 OK</code>的回复。</li><li>发送 RCPT TO 命令，表明收信人。成功后会收到 <code>250 OK</code> 的回复。</li><li>发送 DATA 命令，表明自己要开始发送信息了。 服务器将返回状态码354 。</li><li>发送邮件内容，最开头要有<code>\r\n</code>，每条信息结尾也要有<code>\r\n</code>，最后要发送一个<code>\r\n.\r\n</code>表明邮件内容的结束。</li><li>发送 QUIT 命令，结束与邮件服务器的连接。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="https://s2.ax1x.com/2019/11/27/QC5J3R.png" alt="yh"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业三&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业二 UDP ping 程序</title>
    <link href="http://ilern.github.io/2019/11/16/Computer-Networking-Lab-2/"/>
    <id>http://ilern.github.io/2019/11/16/Computer-Networking-Lab-2/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2019-11-17T02:44:16.302Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业二</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>在这个编程作业中，你将用Python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序，然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第4章中学习ICMP）。此时我们将创建一个非标准（但简单）的基于UDP的ping程序。</p><p>你的ping程序经UDP向目标服务器发送10个ping报文，对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为1秒；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。</p><p>在此作业中，我们给出服务器的完整代码（在配套网站中可以找到。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以不受限制地从服务器代码中剪贴代码行。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>在服务端与客户端建立UDP连接</li><li>循环发送十条信息，在发出和接收的位置分别计时</li><li>每接收到一条回复，把两个时间相减得到RTT</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>在判断超时的时候，<code>socket</code>自带了一个时长限定，当超出这个时间之后会抛出<code>timeout</code>异常。</li><li><code>time.perf_counter()</code>是以秒为单位的计时。</li><li>服务端模拟丢包率为 $30 \%$ ，实际结果与其格外吻合。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>【客户端】<br><img src="https://s2.ax1x.com/2019/11/16/MBnItH.png" alt="cilent"></p><p>【服务端】<br><img src="https://s2.ax1x.com/2019/11/16/MBuShj.md.png" alt="server"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业二&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业一 Web服务器</title>
    <link href="http://ilern.github.io/2019/11/14/Computer-Networking-Lab-1/"/>
    <id>http://ilern.github.io/2019/11/14/Computer-Networking-Lab-1/</id>
    <published>2019-11-13T16:00:00.000Z</published>
    <updated>2019-11-16T12:50:04.105Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业一</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>实现一个最简单的Web服务器，它能够处理一个请求：</p><ul><li>当客户（浏览器）联系时创建一个连接Socket</li><li>从这个连接接收HTTP请求</li><li>解释该请求以确定所请求的特定文件</li><li>从服务器的文件系统获取该文件</li><li>创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行</li><li>经TCP连接向请求的浏览器发送响应。若服务器中不存在请求的文件是，返回一个<code>404 Not Found</code>的差错报文</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>HTTP建立在TCP之上，所以在服务端建立TCP Socket</li><li>HTTP响应报文的首部行需要手写，感觉有点奇怪</li><li>如果不用浏览器，也可以写一个客户端的程序来进行HTTP请求</li><li>对于浏览器，用<code>&lt;ip_address&gt;:&lt;port&gt;/&lt;file&gt;</code>来请求某个文件</li></ul><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="C:\Users\Taisi\Pictures\Saved Pictures\无标题.png" alt="pic"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业一&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配学习笔记</title>
    <link href="http://ilern.github.io/2019/11/06/BipartiteGraphLearn/"/>
    <id>http://ilern.github.io/2019/11/06/BipartiteGraphLearn/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2019-11-06T09:03:53.061Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul><li>二分图一定是一个无向图</li><li>若一个无向图中<strong>不存在</strong>长度为奇数的环，则这个图为二分图</li><li>二分图可以分成两个部分，每部分中的点之间没有边</li></ul><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><ul><li>对于一个二分图，从它的所有边中选出一些，使得任意两条边没有公共端点，这样的边的集合被称为二分图的<strong>匹配</strong></li><li>二分图的匹配并不是唯一的</li><li>在所有的匹配中含边数最多的那一个称为这个二分图的 <strong>最大匹配</strong></li></ul><h3 id="增广路定理"><a href="#增广路定理" class="headerlink" title="增广路定理"></a>增广路定理</h3><p>网络流问题中也存在（类似的）<strong>增广路</strong>的概念。</p><ul><li>对于一个二分图，如果存在一条连接两个非匹配点的路径，使得匹配边与非匹配边交替出现，则这个路径是已知匹配的 <strong>增广路</strong>。</li><li>对于一条增广路而言，如果将其中的匹配边与非匹配边身份互换，可得到一个更大的匹配。</li><li>由上述两条可知，找到最大匹配等价于此时二分图中不存在增广路。</li></ul><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>把二分图画成左边右边两个区域（黑点白点），两个区域中间有一些边，现在要在这些边里选择出一些，使形成一个最大匹配。</p><p>不妨以左边的点从上到下的顺序考虑</p><ul><li>对于左边的第<code>i</code>个点，遍历与之相邻的点<code>neighbor[i][j]</code>（一定在右侧）<ul><li>如果<code>neighbor[i][j]</code>还没有被匹配，那就把这两个点（暂时）匹配上，看左边的第<code>i+1</code>号点。</li><li>如果<code>neighbor[i][j]</code>已经被匹配过了，那就看看之前和<code>neighbor[i][j]</code>匹配的点还能不能匹配其他点（此时视角转换成<code>neighbor[i][j]</code>之前确定的那个匹配点（左边的点），递归进去）。<ul><li>如果<code>neighbor[i][j]</code>之前的匹配点可以换一个匹配对象，就换，把<code>neighbor[i][j]</code>留给现在考虑的<code>i</code>号点，不能换就算了，看<code>j+1</code>号点</li></ul></li><li>如果能找到一个合适的匹配点，就返回<code>true</code>，反之返回<code>false</code></li></ul></li></ul><p>这是一个类似于<code>dfs</code>的过程，被访问的点不应到再被访问一次，所以用一个<code>vis</code> 数组记录<code>dfs</code>过程中的访问情况，注意这里的<strong>访问情况</strong>和<strong>匹配情况</strong>的区别，代码中的<code>vis</code>是访问情况，<code>con_x</code> <code>con_y</code>是匹配情况。所以<code>vis</code>每看一个左边的点就要全部设置为未访问一次。</p><p>理解这个过程之后，发现真的很像相亲……</p><p>有点贪心的意思</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="HDU-2063-过山车"><a href="#HDU-2063-过山车" class="headerlink" title="HDU-2063 过山车"></a>HDU-2063 过山车</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> p[MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>], vis[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> con_x[MAXN * <span class="number">2</span>], con_y[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (con_y[i] == <span class="number">-1</span> || match(con_y[i])) &#123;</span><br><span class="line">                con_x[x] = i;</span><br><span class="line">                con_y[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;n, &amp;m) != EOF &amp;&amp; k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(con_x, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_x));</span><br><span class="line">        <span class="built_in">memset</span>(con_y, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_y));</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="literal">false</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> girl, boy;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girl, &amp;boy);</span><br><span class="line">            p[girl][boy + n] = p[boy + n][girl] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="http://ilern.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>manacher学习笔记</title>
    <link href="http://ilern.github.io/2019/11/04/manacher_learn/"/>
    <id>http://ilern.github.io/2019/11/04/manacher_learn/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2019-11-30T15:03:52.126Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="Manacher简介"><a href="#Manacher简介" class="headerlink" title="Manacher简介"></a>Manacher简介</h2><p>Manacher算法用于高效解决这样的问题：给定一个长度为 $n$ 的字符串，求其中以每个字符为中心的<strong>回文子串</strong>的长度。</p><h3 id="什么是回文串？"><a href="#什么是回文串？" class="headerlink" title="什么是回文串？"></a>什么是回文串？</h3><p>正着读和反着读都一样的字符串，例如<code>()()</code>不是一个回文串，而<code>())(</code>是一个回文串。</p><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><h3 id="最蠢的那种"><a href="#最蠢的那种" class="headerlink" title="最蠢的那种"></a>最蠢的那种</h3><p>$O(n^2)$ 枚举子串，$O(n)$ 判断是否为回文，总复杂度$O(n^3)$</p><h3 id="稍微好一点"><a href="#稍微好一点" class="headerlink" title="稍微好一点"></a>稍微好一点</h3><p>$O(n)$枚举中心，向两边尽量扩展，复杂度$O(n^2)$</p><h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher 利用了回文串具有的<strong>对称性</strong>来通过之前计算过的子串的信息优化对当前位置的计算。这一点和<a href="https://ilern.github.io/2019/09/26/KMP_learn/">KMP算法</a>可以说异曲同工。</p><p>首先明确最后要通过这个算法得到什么东西。一个数组<code>p</code>，其中<code>p[i]</code>表示以<code>i</code>为中心的最大回文半径。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>最后求出的<code>p</code>数组应当为</p><p><code>p = [1, 1, 2, 1, 4, 1    , 2, 1, 1]</code></p><p>这样知道了最大回文半径，也就能求出以每个字符为中心的最长回文子串长度。</p><p>但是这样的做法不够完善，例如对于<code>baaaab</code>这个字符串，本身是一个回文串，那么最长回文子串自然是它本身，但是按照<code>p</code>数组的定义，这个字符串对应的<code>p</code>应该是<code>[1, 1, 2, 2, 1, 1]</code>，而仅仅通过这个数组是求不出最长回文子串的。</p><p>问题就出在这个串的长度是偶数，在这个串中不存在一个<strong>中心</strong>作为这个子串的中心。</p><p>所以需要进行预处理来使得这个算法支持偶数长的子串。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>个人感觉这一步相当巧妙。</p><p>对于原串，我们在开头插入一个<code>$</code>，在每个字符前后都插入一个<code>#</code>。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>预处理之后结果为</p><p><code>s1 = &quot;$#c#a#b#a#d#a#b#a#e#&quot;</code></p><p>这里的<code>$</code>和<code>#</code>并不是一定用这两个字符，只要是不在原串中出现的字符都可以。</p><p>经过这样的预处理我们发现之前不存在对称中心的问题解决了，偶数长度的子串在新字符串中以<code>#</code>为对称中心，奇数长度的子串在新字符串中还是以原来的对称中心为对称中心，且原字符串的回文子串长度等于新字符串回文半径长度减一。</p><p>添加开头的<code>$</code>是为了更好判断边界，不添加也可以，但是在边界处理上会麻烦一些。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在第二个暴力算法中，还是以<code>s = &quot;cabadabae&quot;</code>为例，假如我们已经知道了以第三位为中心的最大回文半径（相当于知道了以第三位为中心的最长回文子串）和以第五位为中心的最大回文半径，那么在求以第七位为中心的最大回文半径的时候，由于回文串具有<strong>对称</strong>的特性，并且三和七<del>恰好</del>关于五对称，所以可以直接得到（部分）结果。</p><ul><li>以第三位为中心的最长回文子串 <code>c[aba]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[aba]e</code></li></ul><p>所以可以直接从长度为3开始拓展（因为目前为止更后面的信息还不知道）。</p><p>如果换成计算第六位的时候又是怎样的情况呢？六关于五的对称点为四。</p><ul><li>以第二位为中心的最长回文子串 <code>cab[a]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[a]bae</code></li></ul><p>长度只能为1。</p><p>不难发现，在已知当前最长的回文串是以五位中心之后，再往后的位置都可以直接由对称性来得到至少一部分信息。我们利用这些信息，就能很快求出所有的回文子串。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设置两个状态 <code>maxR</code> 和 <code>id</code>，分别表示当前已知的回文子串的最右边界和这个边界所对应的中心。</p><p>设<code>p[i]</code>表示第<code>i</code>个字符为中心时最大回文子串的长度，按照<code>i</code>从大到小的顺序从左向右计算。</p><p>对于每一个即将计算到的<code>i</code>，先计算出关于<code>id</code>的对称点<code>j = id * 2 - i</code>，然后分以下三种情况进行。</p><ul><li>若 $i &gt; maxR$，即这个点不在之前计算过的回文串中，此时我们并不能从之前的计算中获取有用的信息，只能令<code>p[i] = 1</code>，然后从这个位置开始向两边扩展，顺便更新 <code>maxR</code> 和 <code>id</code></li><li>若 $i \leq maxR$ 且 $i + p[j] &lt; maxR$ ​，此时有 <code>p[i] = p[j]</code>，如同上面的第二个例子。</li><li>若 $i \leq maxR$ 且 $i + p[j] \geq maxR$，此时已知的最长回文串覆盖了<code>i</code>这个位置但是没有覆盖<code>j</code>为中心的回文串，此时有<code>p[i] = maxR - i</code>。</li></ul><p>这样确定<code>p[i]</code>最小可能的值然后再尝试向两边扩展即可，其中第二种情况应该是无法继续扩展的。</p><blockquote><p>1、先对字符串进行预处理，两个字符之间加上特殊符号#</p><p>2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）</p><p>3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度</p><p>4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界</p><p>5、最后得到最长回文之后，去掉其中的特殊符号即可</p></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">P3805 【模板】manacher算法</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">11000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[MAXN * <span class="number">2</span> + <span class="number">10</span>], maxR = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"$"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">        ret += <span class="string">"#"</span>;</span><br><span class="line">        ret += c;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sp = preProcess(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; maxR) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = id * <span class="number">2</span> - i;</span><br><span class="line">            p[i] = min(p[j], maxR - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = i - p[i];</span><br><span class="line">        <span class="keyword">int</span> r = i + p[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sp[l] == sp[r]) &#123;</span><br><span class="line">            l--; r++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; maxR) &#123;</span><br><span class="line">                maxR = r;</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p[i] = r - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        maxx = max(maxx, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxx - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTE1ODkyNQ==&amp;mid=2649410225&amp;idx=1&amp;sn=ed045e8edc3c49a436a328e5f0f37a55&amp;chksm=f0b60f53c7c18645b4c04a69ad314723cce94ed56994d6f963c2275a2db8d85f973f15f508e4&amp;mpshare=1&amp;scene=23&amp;srcid=1001JCsBlpxgUWjgixasChNQ#rd" target="_blank" rel="noopener">【面试现场】如何找到字符串中的最长回文子串？</a></p><p><a href="https://oi.men.ci/manacher-notes/" target="_blank" rel="noopener">Manacher 学习笔记 - Menci</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://ilern.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记 - 文件操作</title>
    <link href="http://ilern.github.io/2019/10/30/filepython/"/>
    <id>http://ilern.github.io/2019/10/30/filepython/</id>
    <published>2019-10-29T16:00:00.000Z</published>
    <updated>2019-11-03T06:48:24.982Z</updated>
    
    <content type="html"><![CDATA[<p>真是令人迷惑</p><a id="more"></a><h3 id="何为文件"><a href="#何为文件" class="headerlink" title="何为文件"></a>何为文件</h3><p>文件可以看作数据的抽象和集合。是数据存储的一种形式，由二进制存储。</p><p><code>Linux</code>认为一切都是文件， 在<code>UNIX</code>系统中，一切资源都被看作是文件，包括硬件设备。<code>UNIX</code>系统把每个硬件都看成是一个文件，称之为<strong>设备文件</strong>。</p><h3 id="文件的类型-展示方式"><a href="#文件的类型-展示方式" class="headerlink" title="文件的类型 / 展示方式"></a>文件的类型 / 展示方式</h3><ul><li><p>文本文件</p><ul><li><p><strong>单一而特定</strong>的编码组成的文件， 例如<code>UTF-8</code>编码。</p></li><li><p>可以看作一个长的字符串。</p></li></ul></li><li><p>二进制文件</p><ul><li><p>直接由<strong>0和1</strong>构成的文件，没有统一的编码格式。一般这样的文件中的0和1是由某种预定的格式组合成的，因此形成了一些特定的文件类型，例如图片的 <code>.png</code>，视频的<code>.avi</code>。</p></li><li><p>这类文件的0和1之上没有统一的编码。</p></li></ul></li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>文件的操作通常遵循 “打开，操作，关闭” 的步骤，关系如下图所示</p><div id="sequence-0"></div><ul><li><p>文件的打开</p><ul><li><p><code>f = open(&lt;file_name&gt;, &lt;open_mode&gt;)</code></p></li><li><p>文件名可以使用相对路径也可以使用绝对路径</p></li><li><p>Python提供七种文件打开模式，与C类似</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">打开模式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center"><strong>默认</strong>打开模式，只读，若文件不存在则抛出异常</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">覆盖写，若不存在则创建，若存在则完全覆盖</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">创建写，若不存在则创建，若存在则抛出异常</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">追加写，若不存在则创建，若存在则在文件后追加</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">二进制打开</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">文本打开，<strong>默认</strong>方式</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">与前四种模式一同使用，在原本的基础上增加读写功能</td></tr></tbody></table></div><ul><li><p>默认的文件编码格式为<code>UTF-8</code>，要打开其他编码格式的文件要在打开文件时为<code>read</code>添加参数<code>encoding</code>表示要使用的编码方式。</p></li><li><p>如果编码方式不规范，<code>open</code>会抛出异常，遇到这种情况可以添加<code>errors</code>参数表示如何处理，最简单的方式就是直接忽略<code>error = &#39;ignore&#39;</code>。</p></li></ul><ul><li><p>文件的关闭</p><ul><li><code>f.close()</code>用来关闭文件，使文件回到存储状态。</li></ul></li><li><p>处理异常</p><p>由于在每次打开文件的时候都可能会产生异常，所以应该对异常采取适当的处理方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>因为每次都要<code>try-finally</code>，过于繁琐，Python提供了<code>with</code>语句来简单处理（不局限但普遍应用于文件操作）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using with statement </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_path'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file: </span><br><span class="line">    file.write(<span class="string">'hello world !'</span>)</span><br></pre></td></tr></table></figure><p>这样的写法不需要自己手动关闭文件，也不需要手动捕获异常。</p></li></ul><h3 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h3><ul><li>python提供三种文件读取的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.read()</code></td><td style="text-align:center">直接读入整个文件，存到字符串当中，对于大文件慎用</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.read(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline()</code></td><td style="text-align:center">读一行</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readlines()</code></td><td style="text-align:center">读入所有行，组织成一个列表</td></tr><tr><td style="text-align:center"><code>&lt;dile_object&gt;.readlines(hint)</code></td><td style="text-align:center">读入前<code>hint</code> 行，组织成一个列表</td></tr></tbody></table></div><ul><li><p>逐行遍历文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h3><p>想要写入文件，在打开文件时应该用<code>w</code> / <code>wb</code>形式</p><ul><li>python提供两种写文件的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.write(str)</code></td><td style="text-align:center">写字符串或文件流到文件中</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.writelines(list)</code></td><td style="text-align:center">把一个全为字符串的列表写到文件里，实际上是把列表中的字符串续到一起</td></tr></tbody></table></div><ul><li><p>文件指针</p><ul><li><p>不是C语言里的那种文件指针。</p></li><li><p>就像文本编辑器里的光标一样，表示当前写入的位置。</p></li><li><p>使用<code>&lt;file_project&gt;.seek()</code>来调整文件指针</p><ul><li><p><code>seek()</code>接受两个参数，第一个参数表示偏移量，第二个参数表示起点（0-从开头开始，1-从当前位置开始，2-从末尾开始）</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'hihi '</span>, <span class="string">'haha '</span>, <span class="string">'hoho '</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br><span class="line">    <span class="comment"># f.seek(0, 0)  #hihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(1, 0)  #ihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(2, 0)  #hi haha hoho</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 1)  #None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 2)  #None</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li><li><p>如果写入之后接着读取是什么都读不到的，因为文件指针默认从当前位置开始读，而刚写入之后文件指针的后面什么都没有，需要移动之后再输出</p></li></ul></li></ul></li></ul><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant 存储状态 as ffparticipant 占用状态 as kkff-->kk: a = open(, )kk-->ff: a.close()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是令人迷惑&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ilern.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP学习笔记</title>
    <link href="http://ilern.github.io/2019/09/26/KMP_learn/"/>
    <id>http://ilern.github.io/2019/09/26/KMP_learn/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-11-04T08:08:43.998Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="KMP简介"><a href="#KMP简介" class="headerlink" title="KMP简介"></a>KMP简介</h2><p>KMP算法用于高效解决这样的问题：给定一个有 $n$ 个字符的字符串 <code>txt</code> 和一个有 $m$ 个字符的字符串 <code>pat</code> （$n &gt; m$），找出 <code>txt</code> 中 <code>pat</code> 每次出现的位置 。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input : txt[] = &quot;THIS IS A TEST TEXT&quot;</span><br><span class="line">        pat[] = &quot;TEST&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 10</span><br></pre></td></tr></table></figure><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:  txt[] = &quot;AABAACAADAABAABA&quot;</span><br><span class="line">        pat[] = &quot;AABA&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 0</span><br><span class="line">        Pattern found at index 9</span><br><span class="line">        Pattern found at index 12</span><br></pre></td></tr></table></figure><h2 id="暴力匹配法"><a href="#暴力匹配法" class="headerlink" title="暴力匹配法"></a>暴力匹配法</h2><p>对于这个问题，最容易想到的方法就是一个位置一个位置尝试匹配，每次将模式串 <code>pat</code> 向后移动一位，就像一个滑动的窗口一样，每次比较 $m$ 个位置。</p><p>但是这个方法在很多匹配的字符后面跟着一个不匹配的字符的情况下表现不够好，最坏的情况复杂度会达到 $O(m(n-m+1))$ 。</p><p>比如说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAAAAAAAAAAAAAAB&quot;</span><br><span class="line">pat[] = &quot;AAAAB&quot;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;ABABABCABABABCABABABC&quot;</span><br><span class="line">pat[] = &quot;ABABAC&quot;</span><br></pre></td></tr></table></figure></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法最基本的想法就是：不论我们在哪里失配了（在某些字符匹配成功之后），我们都知道了接下来要尝试匹配的 <code>txt</code> 的子串的一部分信息，因为每次 <code>pat</code> 都只向右移动一个字符，所以我们可以利用这一点来减少不必要的匹配。</p><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>第一次匹配是成功的，接下来 <code>pat</code> 串会向右移动一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>在暴力匹配算法中，我们会从 <code>txt</code> 的第二个位置，<code>pat</code>  的第一个位置开始尝试匹配，但是实际上我们只需要看<code>txt</code> 的第五个位置和 <code>pat</code> 的第四个位置是不是相同的就可以了，因为我们知道前三个字符一定会匹配。</p><p>为了做到这一点，我们需要进行一些预处理。</p><p>我们定义一个列表<code>lps[]</code>（<code>lps</code> 是 <strong>longest proper prefix which is also suffix</strong> 的缩写），<code>lps[i]</code>表示<code>pat</code> 中<code>[0, i]</code>这个子串中即是前缀又是后缀的最长的子串（不包括<code>[0, i]</code>这个子串本身）</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [0, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3]</span><br></pre></td></tr></table></figure><p>在有了<code>lps</code>数组之后，就可以进行我们的KMP算法了：</p><ul><li>我们用 <code>i</code> 来指示 <code>txt</code> 中当前考虑的元素的下标，<code>j</code>来指示 <code>pat</code> 中当前考虑元素的下标</li><li>匹配从<code>i = 0</code>，<code>j = 0</code> 开始，当 <code>txt[i] == pat[j]</code> 时，<code>i++; j++</code>，此时这个位置是匹配的</li><li>当<code>txt[i] != pat[j]</code>即这个位置不匹配的时候<ul><li>既然能进行到这一步，说明<code>pat</code>的<code>[0, j - 1]</code>中的每个位置和<code>txt</code>的<code>[i - j, i - 1]</code>中的每个位置都是匹配的</li><li>我们还知道<code>lps[j - 1]</code>表示<code>pat</code> 中<code>[0, j - 1]</code>这个子串中即是前缀又是后缀的最长的子串</li><li>基于以上两点，我们发现在<code>pat</code>向右移动一位准备开始下一次匹配的时候，<code>pat</code>的前<code>lps[j - 1]</code>个字符是不需要匹配的（一定可以匹配成功），<code>j</code>重置为<code>lps[j - 1]</code></li></ul></li></ul><p>简言之，以图中的例子来说，在 <code>i</code> 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串<code>i</code>之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p><img src="https://pic4.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg" alt="来自知乎">，</p><h3 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>直到<code>i = 4, j = 4</code>为止都是匹配的，此时一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code>，也就是说，在下一次匹配中，<code>pat</code> 的前三个字符都不必进行匹配（一定可以匹配成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 4, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>此时<code>i = 5, j = 4</code>，又一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =   &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[3 - 1] = lps[2] = 2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 2</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =    &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[2 - 1] = lps[1] = 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =     &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[1 - 1] = lps[0] = 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =      &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，但是此时<code>j = 0</code>，故<code>i++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 6, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =       &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>$\dots$</p><p>重复上述过程，直到<code>i = n</code>，算法结束。</p><h3 id="lps的计算"><a href="#lps的计算" class="headerlink" title="lps的计算"></a>lps的计算</h3><p>现在，问题只剩下如何求得<code>lps</code>这个列表了。</p><p>求解<code>lps</code>的过程可以看作模式串自己与自己匹配的过程，对于每个位置（除了0位置，0位置永远为0）都与自己从头开始匹配，能匹配的最大长度就是<code>lps</code>。</p><p>实现中用<code>len</code>记录当前匹配到的最大长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> txt[MAXN], pat[MAXN];</span><br><span class="line"><span class="keyword">int</span> lps[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> txt[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txt[i] == pat[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == lenB) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - j + <span class="number">1</span>);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcLps</span><span class="params">(<span class="keyword">int</span> lps[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenPat = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenPat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            lps[len] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[len] == pat[i]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                lps[i] = len;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    lps[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> len = lps[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, txt, pat);</span><br><span class="line">    calcLps(lps, pat);</span><br><span class="line">    KMP(txt, pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, lps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" target="_blank" rel="noopener">KMP Algorithm for Pattern Searching</a></p><p><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://ilern.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 3</title>
    <link href="http://ilern.github.io/2019/08/08/acmsummer_33/"/>
    <id>http://ilern.github.io/2019/08/08/acmsummer_33/</id>
    <published>2019-08-08T08:37:23.000Z</published>
    <updated>2019-08-08T12:46:02.633Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题限时训练一</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316474#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组限时训练1</a></p><a id="more"></a><h2 id="HDU-4217-Data-Structure-树状数组区间第k小-二分"><a href="#HDU-4217-Data-Structure-树状数组区间第k小-二分" class="headerlink" title="HDU 4217 Data Structure? - 树状数组区间第k小 + 二分"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4217" target="_blank" rel="noopener">HDU 4217 Data Structure? - 树状数组区间第k小 + 二分</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>在一个含有$1 \cdots n$的序列中，每次找到第 $k_i$ 小的数，并把它删除，每组数据，输出一个整数，表示删除元素的总和。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>发现一个数的排名只受它的位置之前被删除的数的个数影响，删除比它大的数不影响它的排名，这样问题就转化为了前缀和，可以用树状数组维护，对于要求排名 $k_i$ 的数，只会位于 $[k_i, n]$ 这个区间中，在这个区间二分找到将要被删除的那个数，计入答案即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">262144</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index]++;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf("[%d %d]", l, r);</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tmp = mid - bit.query(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> del = find(x, n, x);</span><br><span class="line"></span><br><span class="line">            ans += del;</span><br><span class="line">            bit.modify(del);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZOJ-1610-Count-the-Colors-区间染色"><a href="#ZOJ-1610-Count-the-Colors-区间染色" class="headerlink" title="ZOJ 1610 Count the Colors - 区间染色"></a><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1610" target="_blank" rel="noopener">ZOJ 1610 Count the Colors - 区间染色</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>对线段染色，后染上去的会覆盖前染上的，问完成染色后每种颜色各有多少段</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>线段树维护区间当前的颜色，对于每次修改，下放标记然后修改子树。</p><p>每组数据只有一次查询，在所有修改都结束之后记录下每个叶节点的颜色，把连续的相同颜色  都算成一段，统计即可</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        color = <span class="number">-1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) color = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color != <span class="number">-1</span>) &#123;</span><br><span class="line">            lc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line">            rc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;color = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), color);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, mid), r, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) v.push_back(<span class="keyword">this</span>-&gt;color);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;query(l, <span class="built_in">std</span>::min(r, mid), v);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegtree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegtree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegtree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, MAXN);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line"></span><br><span class="line">            root-&gt;modify(l, r, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        root-&gt;query(<span class="number">0</span>, MAXN, v);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt; v.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i + j] != v[i]) &#123;</span><br><span class="line">                    cnt[v[i]]++;</span><br><span class="line">                    i += j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, cnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        deleteSegtree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题限时训练一&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316474#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 1+2</title>
    <link href="http://ilern.github.io/2019/08/06/acmsummer_312/"/>
    <id>http://ilern.github.io/2019/08/06/acmsummer_312/</id>
    <published>2019-08-06T08:37:23.000Z</published>
    <updated>2019-08-08T13:22:59.897Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316346" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/316349" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练2</a></p><a id="more"></a><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Ultra-QuickSort-树状数组求逆序对-离散化"><a href="#C-Ultra-QuickSort-树状数组求逆序对-离散化" class="headerlink" title="C - Ultra-QuickSort - 树状数组求逆序对 + 离散化"></a><a href="https://cn.vjudge.net/contest/316346#problem/C" target="_blank" rel="noopener">C - Ultra-QuickSort - 树状数组求逆序对 + 离散化</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列，求对于升序排序的逆序对个数</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>树状数组求逆序对的模板题。</p><p>树状数组可以处理的问题是前缀和，对于某个元素来说，升序排序的逆序对的个数就是位置在它后面数值比他小的数的个数，这个就是一个前缀和的问题了。</p><p>对于每个元素，记录他的值和他的位置，按照从数值小到大的顺序排序去重完成离散化之后，把原数组从后往前的每个元素在排序好的数组中找到位置，用树状数组维护这个位置数组，这个位置的前缀和就是这个数逆序数，在找到的位置处加一。</p><p>例如 </p><script type="math/tex; mode=display">a = [9, 1, 0, 5, 4] \\a' = [0, 1, 5, 4, 9]\\</script><p>从后往前遍历 <code>a</code> 数组，</p><p>首先找到 $4$ ，在 <code>a&#39;</code> 数组中查找发现 $4$ 在第 $4$ 个位置，在树状数组中查询 $4$ 这个位置，发现前缀为 $0$ ，也就是 $4$ 后面数值比他小的数的个数为 $0$ ，也就是 $4$ 对于逆序数的贡献为 $0$，接下来在树状数组中把 $4$ 这个位置加一，</p><p>接下来找到 $5$ , 在 <code>a&#39;</code> 数组中查找发现 $5$ 在第 $3$ 个位置，在树状数组中查询 $3$ 这个位置，发现前缀为 $1$ ，也就是之前插入的 $4$，这说明 $5$ 后面数值比他小的数的个数为 $1$，也就是 $5$ 对于逆序数的贡献为 $1$，接下来在树状数组中把 $3$ 这个位置加一，</p><p>以此类推，最后的结果就是逆序对的总数。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    Bit(<span class="keyword">int</span> size) : size(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        bit.size = n;</span><br><span class="line">        <span class="built_in">memset</span>(bit.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit.a));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            v.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator newEnd = <span class="built_in">std</span>::unique(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">std</span>::lower_bound(v.begin(), newEnd, a[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">            ans += bit.query(index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            bit.modify(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理"><a href="#E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理" class="headerlink" title="E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3333" target="_blank" rel="noopener">E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列和若干询问，对于每个询问给出区间中不重复的元素的和</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>单独的一棵线段树/树状数组不能维护所有区间的不重复元素和，需要主席树等数据结构，这里的做法是离线处理每个查询。</p><p>把所有询问存下来，按照右端点从小到大排序，从小到大依次处理每个询问，对于一个新的询问，考察比上一个询问扩展出来的部分是否有之前出现过的元素，如果有就把之前的元素删除，把最近的加入，这样就保证了每个元素在每个询问中只出现一次，且是所有出现中最右边的那个。</p><p>更新完之后就可以用树状数组查询了。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        bit.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        bit.size = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            v.push_back(Query(l, r, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= it-&gt;r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.count(a[i])) bit.modify(mp[a[i]], -a[i]);</span><br><span class="line"></span><br><span class="line">                bit.modify(i, a[i]);</span><br><span class="line">                mp[a[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(<span class="built_in">std</span>::make_pair(it-&gt;id, bit.query(it-&gt;r) - bit.query(it-&gt;l - <span class="number">1</span>)));</span><br><span class="line">            l = it-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理"><a href="#F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理" class="headerlink" title="F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener">F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理</a></h2><h3 id="【题目大意】-2"><a href="#【题目大意】-2" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>马里奥吃金币，马里奥有在每个区间里有一个跳跃高度，只能吃到小于等于这个高度的硬币，给出若干组询问，问某个区间中能吃到多少金币。</p><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>离线处理所有询问，把每个点和每个询问都按照高度从小到大排序，排序后从小到大考察每个询问。</p><p>利用树状数组前缀求和的特点，只需要设置一个变量表示现在到了哪个金币，如果这个金币的高度小于当前询问的高度，就加入到树状数组当中，因为询问高度是单调增的，所以在前面的询问中加入的点仍然满足后面询问的条件，这样就只需要用树状数组维护一下区间和了。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; qs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i].h);</span><br><span class="line">            num[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;qs[i].l, &amp;qs[i].r, &amp;qs[i].h);</span><br><span class="line">            qs[i].l++;</span><br><span class="line">            qs[i].r++;</span><br><span class="line"></span><br><span class="line">            qs[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(qs, qs + m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt;= n &amp;&amp; num[cnt].h &lt;= qs[i].h) &#123;</span><br><span class="line">                bit.modify(num[cnt++].id, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[qs[i].id] = bit.query(qs[i].r) - bit.query(qs[i].l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="C-An-easy-problem-线段树维护区间乘积"><a href="#C-An-easy-problem-线段树维护区间乘积" class="headerlink" title="C - An easy problem - 线段树维护区间乘积"></a><a href="https://cn.vjudge.net/contest/316349#problem/C" target="_blank" rel="noopener">C - An easy problem - 线段树维护区间乘积</a></h2><h3 id="【题目大意】-3"><a href="#【题目大意】-3" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>令$x = 1$，给出两种操作</p><ul><li>操作<code>(1, a)</code>表示令 $x = a \cdot x$ </li><li>操作<code>(2, i)</code>表示令 $x = \frac{x}{a[i]}$，其中 $a[i]$ 表示第 $i$ 个一号操作中的<code>a</code>。</li></ul><p>问经过若干次操作之后 $x$ 的值是多少。</p><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>看上去维护一个数的更改，和线段树没有什么关系，其实把所有的一操作看作一个序列，问题就变成了维护区间乘积，二操作相当于把序列中的某个位置改成 $1$ ，这样就可以用线段树维护单点修改和区间乘积了。</p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> data;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="number">1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = (lc-&gt;data % mod * rc-&gt;data % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line">            <span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r)) % mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r) % mod) % mod;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;q, &amp;mod);</span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, q);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) root-&gt;modify(i, x);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) root-&gt;modify(x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;query(<span class="number">0</span>, q));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-HDU-2795-Billboard-线段树变形"><a href="#G-HDU-2795-Billboard-线段树变形" class="headerlink" title="G - HDU 2795 -Billboard - 线段树变形"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2795" target="_blank" rel="noopener">G - HDU 2795 -Billboard - 线段树变形</a></h2><h3 id="【题目大意】-4"><a href="#【题目大意】-4" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一个广告牌，有很多人往上贴广告，每个广告占一个单位高度，若干单位长度，广告优先往上边贴，同样高度情况下优先往左边贴，如果没有空间贴，就不贴。</p><p>对于每一张广告，询问它被贴在哪一行。</p><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题的修改的基本单位是行，以行为单位划分区间，想象把广告牌逆时针旋转九十度，建立线段树。</p><p>线段树维护每个区间中剩余空间的最大值，如果我们想贴一张新的海报上去，先与线段树的根节点值比较，如果大于根节点的值，说明所有行都没有空间贴这张新的海报；如果小于，就再与左右节点比较，以此类推，直到找到能贴的位置，注意要先和左子树比较再和右子树比较，因为要求尽量贴得高，旋转之后就是尽量贴得左。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = w;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="built_in">std</span>::max(lc-&gt;data, rc-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", this-&gt;l, this-&gt;r);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data = SegmentTree::w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int query(int l, int r) &#123;</span></span><br><span class="line">    <span class="comment">//     if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return this-&gt;data;</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         int ans = INT_MIN;</span></span><br><span class="line">    <span class="comment">//         if (l &lt; mid) ans = std::max(ans, query(l, std::min(r, mid)));</span></span><br><span class="line">    <span class="comment">//         if (r &gt; mid) ans = std::max(ans, query(std::max(l, mid), r));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         return ans;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data -= delta;</span><br><span class="line">            <span class="comment">// if (ans &lt;  this-&gt;id) ans = this-&gt;id;</span></span><br><span class="line">            ans = <span class="keyword">this</span>-&gt;id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lc-&gt;data &gt;= delta) lc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rc-&gt;data &gt;= delta) rc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d %d], data = %d\n"</span>, <span class="keyword">this</span>-&gt;l, <span class="keyword">this</span>-&gt;r, <span class="keyword">this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (lc) lc-&gt;print();</span><br><span class="line">        <span class="keyword">if</span> (rc) rc-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SegmentTree::w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree::w = w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int m = h;</span></span><br><span class="line">        <span class="comment">// if (h &gt; n) m = n;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">200000</span>) h = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("m = %d\n", m);</span></span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, h);</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", root-&gt;l, root-&gt;r);</span></span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("root-&gt;data = %d\n", root-&gt;data);</span></span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;modify(x) != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316346&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 4</title>
    <link href="http://ilern.github.io/2019/08/04/acmsummer_24/"/>
    <id>http://ilern.github.io/2019/08/04/acmsummer_24/</id>
    <published>2019-08-04T08:37:23.000Z</published>
    <updated>2019-08-02T11:11:40.382Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练二，题目多为思维题，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/314478#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练二，题目多为思维题，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/314478#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 3</title>
    <link href="http://ilern.github.io/2019/08/01/acmsummer_23/"/>
    <id>http://ilern.github.io/2019/08/01/acmsummer_23/</id>
    <published>2019-08-01T08:37:23.000Z</published>
    <updated>2019-08-02T08:53:43.242Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练一，题目简单且友好，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314466#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练1</a></p><a id="more"></a><h2 id="D-D1-Add-on-a-Tree"><a href="#D-D1-Add-on-a-Tree" class="headerlink" title="D - D1. Add on a Tree"></a><a href="https://cn.vjudge.net/contest/314466#problem/D" target="_blank" rel="noopener">D - D1. Add on a Tree</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一棵树，在这棵树上有这样的操作：选择两个叶节点，将连接他们的路径上的边全部加上某个<strong>实数</strong> 。</p><p>问是否任意的边权都能通过这种方法构造出来。</p><p><img src="https://vj.ti12z.cn/534562b9f71c214456d4ad6501057031?v=1564228755" alt="NO"></p><p>这棵树不满足条件</p><p><img src="https://vj.ti12z.cn/c3350c6775c16b2e8fc87ea1963db02a?v=1564228755" alt="YES"></p><p>这棵树满足条件</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始以为是 <code>LCA</code> 结果是普通的思维题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-B-Letters-Shop-二分查找"><a href="#G-B-Letters-Shop-二分查找" class="headerlink" title="G - B. Letters Shop - 二分查找"></a><a href="https://cn.vjudge.net/contest/314466#problem/G" target="_blank" rel="noopener">G - B. Letters Shop - 二分查找</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 $S$ ，从中取前缀组合成新的字符串，给出目标字符串，输出最小需要的前缀的长度，数据保证目标串一定可以由 $S$ 的前缀的字符重新组合而成。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不关心目标串中字符出现的顺序，只要前缀中相应字符的数目多于目标串中该字符数目即可，先预处理出每个前缀中的每个字母的个数，对于每个目标串，统计其中各个字母的个数，与每个前缀比较，满足条件即可。</p><p>朴素的线性比较会<code>TLE</code>，改成二分查找即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>][s[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">        a[i][s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line">        fill(b, b + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s1) &#123;</span><br><span class="line">            b[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[mid][k] &lt; b[k]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; l + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-B-Yet-Another-Crosses-Problem-模拟"><a href="#H-B-Yet-Another-Crosses-Problem-模拟" class="headerlink" title="H - B. Yet Another Crosses Problem - 模拟"></a><a href="https://cn.vjudge.net/contest/314466#problem/H" target="_blank" rel="noopener">H - B. Yet Another Crosses Problem - 模拟</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一些方格图，<br><img src="https://vj.ti12z.cn/b3bf19b1108c5f82bd973def2f3b1a20?v=1564477339" alt="pic1"></p><p><img src="https://vj.ti12z.cn/0f6acf44abaaaf4dade9e99d5c3067c9?v=1564477339" alt="pic2"></p><p>现在需要把一些白格子染成黑色，使得图里存在至少一个<code>cross</code>（如pic2）。</p><p>问最少染几个白格子。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>之前在cf上遇到了这题，当时没做出来。</p><p>其实很简单，要构成<code>cross</code>必须至少有一整行和一整列都是黑色的，那就把每行每列有多少黑色统计出来，枚举每种行列的组合，找出一个黑色数目最多的，把剩下的染上就行了。</p><p>但是有一个问题是，行数和列数的最大值都很大，开二维数组是开不下的。注意到虽然 $n, m$ 都很大，但是 $n \cdot m$ 是不大的，所以用 <code>std::string</code> 数组比较好</p><p>深夜果然容易神志不清。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row[MAXN], col[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'*'</span>) row[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'*'</span>) col[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, row[i] + col[j] - (s[i][j] == <span class="string">'*'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n + m - <span class="number">1</span> - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练一，题目简单且友好，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314466#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 1+2</title>
    <link href="http://ilern.github.io/2019/07/31/acmsummer_212/"/>
    <id>http://ilern.github.io/2019/07/31/acmsummer_212/</id>
    <published>2019-07-31T08:37:23.000Z</published>
    <updated>2019-08-03T13:51:31.826Z</updated>
    
    <content type="html"><![CDATA[<p>基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314459" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/314460" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练2</a></p><a id="more"></a><h1 id="新的邻接表写法"><a href="#新的邻接表写法" class="headerlink" title="新的邻接表写法"></a>新的邻接表写法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dfn, degree;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), degree(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v]));</span><br><span class="line">    nodes[v].edges.push_back(Edge(&amp;nodes[v], &amp;nodes[u]));</span><br><span class="line"></span><br><span class="line">    nodes[u].degree++;</span><br><span class="line">    nodes[v].degree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的好处是多组数据初始化的时候边的删除很方便，尤其相对于之前的版本来说。</p><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Skiing-最短路"><a href="#C-Skiing-最短路" class="headerlink" title="C - Skiing - 最短路"></a><a href="https://cn.vjudge.net/contest/314459#problem/C" target="_blank" rel="noopener">C - Skiing - 最短路</a></h2><h2 id="F-Sorting-It-All-Out-拓扑排序"><a href="#F-Sorting-It-All-Out-拓扑排序" class="headerlink" title="F - Sorting It All Out - 拓扑排序"></a><a href="https://cn.vjudge.net/contest/314459#problem/F" target="_blank" rel="noopener">F - Sorting It All Out - 拓扑排序</a></h2><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="D-Caterpillar-DFS"><a href="#D-Caterpillar-DFS" class="headerlink" title="D - Caterpillar - DFS"></a><a href="https://cn.vjudge.net/contest/314460#problem/D" target="_blank" rel="noopener">D - Caterpillar - DFS</a></h2><h2 id="E-昂贵的聘礼"><a href="#E-昂贵的聘礼" class="headerlink" title="E - 昂贵的聘礼 "></a><a href="https://cn.vjudge.net/contest/314460#problem/E" target="_blank" rel="noopener">E - 昂贵的聘礼 </a></h2><h2 id="F-最短路径问题-最短路"><a href="#F-最短路径问题-最短路" class="headerlink" title="F - 最短路径问题 - 最短路"></a><a href="https://cn.vjudge.net/contest/314460#problem/F" target="_blank" rel="noopener">F - 最短路径问题 - 最短路</a></h2><h2 id="K-Highways"><a href="#K-Highways" class="headerlink" title="K - Highways "></a><a href="https://cn.vjudge.net/contest/314460#problem/K" target="_blank" rel="noopener">K - Highways </a></h2><h2 id="L-Truck-History"><a href="#L-Truck-History" class="headerlink" title="L - Truck History "></a><a href="https://cn.vjudge.net/contest/314460#problem/L" target="_blank" rel="noopener">L - Truck History </a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>差分约束系统学习笔记</title>
    <link href="http://ilern.github.io/2019/07/30/difference_constraints/"/>
    <id>http://ilern.github.io/2019/07/30/difference_constraints/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:38:45.435Z</updated>
    
    <content type="html"><![CDATA[<p>数学问题转化到图论上解决，有点巧妙。</p><a id="more"></a><p>差分约束系统是一种特殊的 $N$ 元一次不等式组。包含 $N$ 个变量，$M$ 个约束条件，每个约束条件都是以差分的形式给出，形如 $X_i - X_j \leq c_k$。</p><p>现在要求 $X_i$ 的一组解，使得所有不等式成立。</p><p>对于这样的问题，有一个统一的转化方法：</p><ul><li>把不等式表示成 $X_i - X_j \leq c_k$ 的形式，</li><li>把每个变量 $X_i$ 看作 <strong>有向图</strong> 中的一个结点 $i$，把每个约束条件 $X_i - X_j \leq c_k$ 看作从 $i$ 到 $j$ 连一条长度为 $c_k$ 的有向边，</li><li>注意到此时建立的图不一定联通，需要添加一个超级源点，从 $0$ 号结点向每个点连一条边权为$0$ 的边。</li><li>用 <strong>spfa</strong> 求出 $0$ 号点到各个点的最短路，如果最短路存在，那么每个点的 <code>dis</code> 值就是原不等式组的一组解。</li><li>如果有负环，则解不存在，为了解决负环的问题，只能用 <strong>spfa</strong> 来求最短路。</li></ul><p>为什么这样是对的？看上去毫不相干的不等式怎么和最短路怎么联系起来的呢？<br><del>其实不知道也没关系</del></p><p><a href="https://blog.csdn.net/PleasantlY1/article/details/82775505" target="_blank" rel="noopener">有空就学</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数学问题转化到图论上解决，有点巧妙。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
</feed>
