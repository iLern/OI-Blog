<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iLern&#39;s Blog</title>
  
  <subtitle>Do what you love, love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ilern.github.io/"/>
  <updated>2020-10-15T07:11:50.993Z</updated>
  <id>http://ilern.github.io/</id>
  
  <author>
    <name>iLern</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统学习笔记-进程同步</title>
    <link href="http://ilern.github.io/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://ilern.github.io/2020/10/15/操作系统学习笔记-进程同步/</id>
    <published>2020-10-15T07:08:38.000Z</published>
    <updated>2020-10-15T07:11:50.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h2><h3 id="About-Critical-Section"><a href="#About-Critical-Section" class="headerlink" title="About Critical Section"></a>About Critical Section</h3><ul><li><p>An atomic action is required in a critical section.</p></li><li><p>When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.</p></li><li><p>The critical section is <strong>not</strong> a public section. Each process has its own critical section.</p></li><li>Each process must request permission to enter its critical section. The section of code implementing this request is the <strong>entry section</strong>, the critical section may be followed by an <strong>exit section</strong></li></ul><p><img src="https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG" alt></p><a id="more"></a><h3 id="Solution-of-the-critical-section-problem"><a href="#Solution-of-the-critical-section-problem" class="headerlink" title="Solution of the critical-section problem"></a>Solution of the critical-section problem</h3><ul><li><p>Mutual exclusion 互斥</p><ul><li>If  process $p_i$ is executing its critical section, then no other process can be executing in their critical sections</li></ul></li><li><p>progress 进步？</p><ul><li>If no process is executing in its critical section and some processes with to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which  will enter its critical section next, and this selection cannot be postponed <strong>indefinitely</strong>.</li><li>如果没有进程在执行临界区并且某些进程想要执行他们的临界区，那么只有那些不在他们剩余区的进程可以参与决定谁来执行临界区的筛选，这个选择过程不会无限期推迟。</li></ul></li><li><p>Bounded waiting 有界等待</p><ul><li><p>There exists a bound on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gantt         </span><br><span class="line">       section Figure1</span><br><span class="line">       请求进入临界区            :des1, 1d</span><br><span class="line">       等待          :des2, after des1, 3d</span><br><span class="line">       被授权进入临界区            :des3, after des2, 5d</span><br></pre></td></tr></table></figure></li><li><p>如上图，在等待的过程中其他进程被允许进入临界区的次数是有限的</p></li></ul></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p><strong>两个进程</strong>的同步算法，软件实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initicall turn = 0</span></span><br><span class="line"><span class="comment">// turn is a shared variable</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (turn != i); <span class="comment">// only turn == i can this process execute it's critical section</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">//reminder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Satisfies mutual exclusion, but not progress</p><p>机械的规定零号进程一号进程交替进行。</p><p>进程是否有进入临界区的 <strong>意愿</strong> ？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initial flag[0] = flag[1] = false;</span></span><br><span class="line"><span class="comment">//flag[i] == true -&gt; process i ready to enter critical section</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag[j]); <span class="comment">// mutual exclusion</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>不满足 progress ，在<code>flag[i] = true</code>之后，切换到另一个进程<code>flag[j] = true</code>，此时两个进程都想进临界区，但是都在看对方，都不能进入临界区</p><h3 id="Peterson‘s-Solution"><a href="#Peterson‘s-Solution" class="headerlink" title="Peterson‘s Solution"></a>Peterson‘s Solution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//share turn flag[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j);</span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>最后执行turn等于谁，谁就进入临界区</p><h2 id="Synchronization-Hardware"><a href="#Synchronization-Hardware" class="headerlink" title="Synchronization Hardware"></a>Synchronization Hardware</h2><p>Based on <strong>locking</strong></p><ul><li>Uniprocessors<ul><li>同一时刻指运行一个进程</li><li>disable interrupts 把中断屏蔽即可</li></ul></li><li>special atomic hardware instructions 硬件提供特殊的原子指令<ul><li>原子指令执行期间不允许切换</li><li><code>test memory</code> 查看某内存单元的值</li><li><code>set value</code> 对某内存单元设置为1</li><li><code>swap</code> 交换两个内存单元的值</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    acquire lock</span><br><span class="line">        <span class="comment">//criticla section</span></span><br><span class="line">    release lock</span><br><span class="line">        <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="test-and-set-Instruction"><a href="#test-and-set-Instruction" class="headerlink" title="test_and_set Instruction"></a>test_and_set Instruction</h3><p>做成<strong>一条</strong>机器指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tar 看作一个锁，一堆人去抢这把锁</span></span><br><span class="line"><span class="function">boolean <span class="title">test_and_set</span><span class="params">(boolean *tar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> rv = *tar;</span><br><span class="line">    *tar = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv; <span class="comment">//got the lock or not;</span></span><br><span class="line">    <span class="comment">//flase -&gt; 锁没被锁，自己锁了</span></span><br><span class="line">    <span class="comment">//true -&gt; 已经被锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这条指令加锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutux lock</span></span><br><span class="line"><span class="comment">//锁只是一个普通变量</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(test_and_set(&amp;lock));</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="comment">//比较倒霉的情况可能不满足有界等待</span></span><br><span class="line"><span class="comment">//几率小，当倒霉处理</span></span><br></pre></td></tr></table></figure></p><h3 id="compare-and-swap-Instruction"><a href="#compare-and-swap-Instruction" class="headerlink" title="compare_and_swap Instruction"></a>compare_and_swap Instruction</h3><p>和<code>test_and_set Instruction</code>做一样的事情，但是实际功能更强。</p><p>用牛刀杀鸡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *value;</span><br><span class="line">    <span class="keyword">if</span> (*value == expected) </span><br><span class="line">        *value = new_value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//旧值和新值比较</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">//是0就设置为1</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="comment">//critical section</span></span><br><span class="line">    lock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h2><p>Software Tool</p><p>使用原子的<code>acquire()</code>和<code>release()</code>来申请、释放锁，不需要在意底层具体实现方式。</p><ul><li><p>CPU busy waiting 问题</p><ul><li>循环查看锁开没开</li><li>Spinlock 自旋锁</li><li>会浪费CPU的时间</li></ul></li><li><p>更好的办法</p><ul><li>锁可用获得锁</li><li>锁不可用进程挂起</li><li>释放锁时有进程挂起则挑一个唤醒</li><li>没有进程挂起直接释放</li></ul></li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p><p>Synchronization Tool that does not require busy waiting</p><ul><li><p>is an integer</p></li><li><p><code>wait()</code> P 减信号量 请求执行</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//busy wait</span></span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>signal()</code> V 加信号量</p><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S) &#123;</span><br><span class="line">S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>某个资源的只能被有限的人使用，例如为了保证网络通畅，只允许五个人连接。</p><p>不局限于加锁解锁，可以有一定范围。</p><p>当信号量被限制到二元，则退化（？）为互斥锁。</p><p>生产者 / 消费者问题？</p><p>有界缓冲区问题？</p><p>哲学家就餐问题？如何把这些搞哲学的饿死。</p><p><strong>一个使用信号量解决问题的例子</strong></p><p><img src="E:\tencentFile\MobileFile\IMG_4619.JPG" alt="IMG_4619"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-Critical-Section-Problem&quot;&gt;&lt;a href=&quot;#The-Critical-Section-Problem&quot; class=&quot;headerlink&quot; title=&quot;The Critical-Section Problem&quot;&gt;&lt;/a&gt;The Critical-Section Problem&lt;/h2&gt;&lt;h3 id=&quot;About-Critical-Section&quot;&gt;&lt;a href=&quot;#About-Critical-Section&quot; class=&quot;headerlink&quot; title=&quot;About Critical Section&quot;&gt;&lt;/a&gt;About Critical Section&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;An atomic action is required in a critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When one process is executing in its critical section, no other process is to be allowed to execute in its critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The critical section is &lt;strong&gt;not&lt;/strong&gt; a public section. Each process has its own critical section.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Each process must request permission to enter its critical section. The section of code implementing this request is the &lt;strong&gt;entry section&lt;/strong&gt;, the critical section may be followed by an &lt;strong&gt;exit section&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tutorialspoint.com/assets/questions/media/12659/Critical%20Section.PNG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="进程同步" scheme="http://ilern.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记-数据链路层</title>
    <link href="http://ilern.github.io/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://ilern.github.io/2020/10/15/计算机网络复习笔记-数据链路层/</id>
    <published>2020-10-15T06:55:25.000Z</published>
    <updated>2020-10-15T07:01:40.237Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>数据链路层的信道种类</p><ul><li>点对点信道<ul><li>一对一通信</li></ul></li><li>广播信道<ul><li>一对多</li><li>需要专门的协议</li></ul></li></ul></li><li><p>链路与数据链路</p><ul><li>链路指一条无源的点到点的线路</li><li>物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路</li></ul></li><li><p>数据链路层的传输单位是帧 Frame</p></li><li><p>数据链路层解决的三个基本问题</p><ul><li>封装成帧</li><li>透明传输</li><li>差错控制</li></ul></li></ul><a id="more"></a><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><ul><li>添加首部尾部进行帧定界 <code>SOH</code> Start_of_header <code>EOT</code> End_of_transmission</li><li>帧定界符是特殊的控制字符</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><ul><li>透明就是不透明</li><li>透明传输使得不用关心下层的传输，所采用的设备只是一个通道的作用</li><li>当传输二进制文件中出现定界符序列时，在这个序列之前添加<code>ESC</code>进行转义</li><li>称为 字节填充 / 字符填充<ul><li>在前面的非归零反相编码 NRZI 中有提到比特位填充 <code>bit_stuffing</code></li></ul></li><li>先转义还是先封装?</li></ul><h2 id="差错控制-差错检测"><a href="#差错控制-差错检测" class="headerlink" title="差错控制 / 差错检测"></a>差错控制 / 差错检测</h2><ul><li>误码率 BER<ul><li>$P_e = \frac{N_e}{N}$</li><li>传错的除以总的</li></ul></li><li>噪声的类型<ul><li>热噪声<ul><li>时刻存在、强度低</li><li>高斯白噪声</li><li>引起随机差错</li></ul></li><li>冲击噪声<ul><li>外界电磁干扰引起、强度高</li><li>闪电</li><li>引起突发错</li></ul></li></ul></li><li>纠错码与检错码<ul><li>纠错码适用于错误出现多的情况，可以由接收方发现错误并纠正</li><li>检错码适用于错误出现较少的地方，例如有线网络，发现出错后不进行纠正，直接抛弃</li></ul></li><li>常用检错码<ul><li>奇偶校验<ul><li>最后添加一个校验位</li><li>统计数据码中1的个数</li></ul></li><li>循环冗余编码CRC<ul><li>有纠错能力，但是数据链路层只用它来检错</li></ul></li></ul></li></ul><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><ul><li>生成多项式<ul><li>除数，长度为生成多项式最高项的次数，翻译为二进制为多项式每一项的系数</li></ul></li><li>FCS<ul><li>帧检验序列</li><li>CRC是生成FCS的一种方法但不是唯一方法</li></ul></li><li>无差错接受<ul><li>凡是接受的帧，都可以以非常接近于1的概率认为它正确的</li><li>也有可能因为噪声，所有的位变成了0，但是概率非常小</li></ul></li></ul><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><ul><li>PPP 既能面向Bit也能面向字节 / 字符</li><li>点对点通信</li><li>只支持全双工</li><li>使用广域网进行串行通信</li></ul><h3 id="需要满足的要求"><a href="#需要满足的要求" class="headerlink" title="需要满足的要求"></a>需要满足的要求</h3><ul><li>简单</li><li>链路层功能<ul><li>封装成帧</li><li>透明性</li><li>差错检测</li></ul></li><li>对上与对下<ul><li>多种网络层协议</li><li>多种类型链路</li></ul></li><li>检测连接状态</li><li>最大传送单元<ul><li>MTU</li><li>不包含帧头帧尾</li><li>发送过程中逐步进行调整</li><li>高层协议根据链路层的MTU进行分片</li></ul></li><li>网络层地址协商</li><li>数据压缩协商</li></ul><h3 id="不需要的功能"><a href="#不需要的功能" class="headerlink" title="不需要的功能"></a>不需要的功能</h3><ul><li><p>纠错</p><ul><li>链路层不要求可靠性</li></ul></li><li><p>流量控制</p><ul><li>流量来自于端系统的进程，进程间通信由TCP协议负责</li></ul></li><li><p>序号</p><ul><li>PPP不保证可靠性</li><li>实际上链路层的传输本就很可靠</li></ul></li><li><p>多点链路</p><ul><li>PPP只支持点对点</li></ul></li><li><p>半双工 / 单工链路</p><p>PPP只支持全双工链路</p></li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>一个将IP数据报封装到串行链路的方法<ul><li>面向字符的异步链路</li><li>面向比特的同步链路</li></ul></li><li>链路控制协议 <code>LCP</code> Link Control Protocol<ul><li>与物理层交互</li></ul></li><li><strong>一套</strong>网络控制协议 <code>NCP</code> Network Control Protocol<ul><li>与网络层交互</li><li>每个协议支持一种不同的网络层协议</li></ul></li></ul><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><ul><li>首部<ul><li>定界符 / 定界字节序列　　0x7E</li><li>AC 固定的两个部分，但是说不准以后会有用</li><li>协议<ul><li>0x0021 信息部分为IP数据报</li><li>0xC021 信息部分位PPP链路控制数据</li><li>0x8021 信息部分位网络控制数据</li></ul></li></ul></li><li>信息部分<ul><li>IP数据报</li></ul></li><li>尾部<ul><li>CRC检验序列<ul><li>从AC开始到信息部分结束</li><li>万一以后AC部分有用呢</li></ul></li><li>定界符 / 定界字节序列        0x7E</li></ul></li></ul><h4 id="字节填充"><a href="#字节填充" class="headerlink" title="　字节填充"></a>　字节填充</h4><ul><li>出现控制字符时，前面添加转义字符0x7D，同时第六个bit取反</li></ul><h4 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h4><ul><li>SONET / SDH使用同步传输，同步传输中没有 <strong>字符</strong> 的概念</li><li>0x7E = 0111 1110</li><li>5个连续1之后插一个0，保证不出现连续6个1，就不会出现定界符</li></ul><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><ul><li>使用时钟信号线或前同步序列保证发送端与接收端的时钟保持同步</li><li>以数据帧位单位传输</li></ul><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><ul><li>以字符为单位传输</li><li>每个字符前添加起始位0，后面加停止位1，表示数据的开始和结束</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>连接从下往上建立，从上往下释放</p><ul><li>调制解调器建立物理连接</li><li>PC向路由器发送一系列的LCP分组 （0xC021）建立LCP连接</li><li>NCP给新接入的PC分配一个临时的IP地址</li><li>通信</li><li>NCP释放网络层链接，收回临时IP</li><li>LCP释放数据链路层连接</li><li>释放物理层链接</li></ul><h3 id="挑战握手认证协议-CHAP"><a href="#挑战握手认证协议-CHAP" class="headerlink" title="挑战握手认证协议 CHAP"></a>挑战握手认证协议 CHAP</h3><p>在初始链路建立时完成，也可以在链路建立后的任何时</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据链路层的信道种类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点信道&lt;ul&gt;
&lt;li&gt;一对一通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广播信道&lt;ul&gt;
&lt;li&gt;一对多&lt;/li&gt;
&lt;li&gt;需要专门的协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链路与数据链路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链路指一条无源的点到点的线路&lt;/li&gt;
&lt;li&gt;物理线路加上通信协议 / 实现通信协议的软硬件就形成了数据链路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层的传输单位是帧 Frame&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据链路层解决的三个基本问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装成帧&lt;/li&gt;
&lt;li&gt;透明传输&lt;/li&gt;
&lt;li&gt;差错控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习笔记</title>
    <link href="http://ilern.github.io/2020/02/22/learn_SQL/"/>
    <id>http://ilern.github.io/2020/02/22/learn_SQL/</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2020-02-22T14:14:41.501Z</updated>
    
    <content type="html"><![CDATA[<p>非常粗浅的SQL学习笔记，关于如何<strong>使用</strong>SQL。</p><p>笔记中使用开源的MySQL作为数据管理软件。</p><a id="more"></a><h2 id="MySQL-Client"><a href="#MySQL-Client" class="headerlink" title="MySQL Client"></a>MySQL Client</h2><p>安装好MySQL之后，除了服务器以外，还装上了一个客户端，对于数据库的操作都是由这个客户端提供的。客户端通过TCP连接服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接本地服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h &lt;IP&gt; -p</span><br></pre></td></tr></table></figure><p>输入密码之后连接远程SQL服务器。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">-- 显示全部数据库</span><br><span class="line">CREATE DATABASES test;</span><br><span class="line">-- 创建数据库</span><br><span class="line">DROP DATABASES test;</span><br><span class="line">-- 删除数据库</span><br><span class="line">USE test;</span><br><span class="line">-- 切换到某个数据库</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">-- 显示表</span><br><span class="line">CREATE TABLE students</span><br><span class="line">-- 创建表</span><br><span class="line">DROP TABLE students</span><br><span class="line">-- 删除表</span><br><span class="line"></span><br><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br><span class="line">-- 添加列</span><br><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br><span class="line">-- 修改列</span><br><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br><span class="line">-- 删除列</span><br></pre></td></tr></table></figure><p><code>ALTER</code>似乎是Alternate的意思，和键盘上的Alt键一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXIT</span><br><span class="line">-- 退出</span><br></pre></td></tr></table></figure><p>这些都是MySQL的操作，对于不同的数据库系统可能有不同的指令。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt;;</span><br><span class="line"><span class="comment">-- 列出某个表的所有行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出符合条件的所有行</span></span><br><span class="line"><span class="comment">-- 条件运算包括 &gt;= / &lt;= / = / &lt;&gt; / AND / OR / NOT 等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_columns&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">WHERE</span> &lt;condition&gt;;</span><br><span class="line"><span class="comment">-- 列出想要的列</span></span><br><span class="line"><span class="comment">-- 可以对列起一个别名方便表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt; </span><br><span class="line"><span class="keyword">WHERE</span> &lt;confition&gt; </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt; &lt;<span class="keyword">DESC</span>&gt;;</span><br><span class="line"><span class="comment">-- DESC可以降序排序，默认是升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;name_of_colmns&gt; </span><br><span class="line"><span class="keyword">FROM</span> &lt;name_of_table&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;conition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;name_of_colmns&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_size_of_page&gt;</span><br><span class="line"><span class="keyword">OFFSET</span> &lt;number_of_offset&gt;;</span><br><span class="line"><span class="comment">-- 从&lt;number_of_offset&gt;开始分页显示，每页最多显示&lt;limit_size_of_page&gt;个</span></span><br><span class="line"><span class="comment">-- 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL内置聚合函数</span></span><br><span class="line">COUNT()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">SUM()</span><br><span class="line"><span class="comment">-- 计算某一列的合计值，该列必须为数值类型</span></span><br><span class="line">MAX()</span><br><span class="line"><span class="comment">-- 计算某一列的最大值</span></span><br><span class="line">MIN()</span><br><span class="line"><span class="comment">-- 计算某一列的最小值</span></span><br><span class="line">AVG()</span><br><span class="line"><span class="comment">-- 计算某一列的平均值，该列必须为数值类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> &lt;<span class="keyword">function</span>&gt; <span class="keyword">FROM</span> &lt;name_of_table&gt; <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;num_of_colmns&gt;;</span><br><span class="line"><span class="comment">-- 按照列中的值自动分别计算&lt;function&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接查询</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常粗浅的SQL学习笔记，关于如何&lt;strong&gt;使用&lt;/strong&gt;SQL。&lt;/p&gt;
&lt;p&gt;笔记中使用开源的MySQL作为数据管理软件。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://ilern.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://ilern.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>如何实现减法</title>
    <link href="http://ilern.github.io/2020/01/22/how_to_diff/"/>
    <id>http://ilern.github.io/2020/01/22/how_to_diff/</id>
    <published>2020-01-22T13:33:00.000Z</published>
    <updated>2020-03-11T00:08:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。</p><p>将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。</p><p>至此就实现了二进制加法。</p><p>每一个全加器只能计算<strong>一位</strong>二进制数，要进行多位二进制数的加法就需要串联多个全加器。</p><a id="more"></a><h2 id="大数减小数"><a href="#大数减小数" class="headerlink" title="大数减小数"></a>大数减小数</h2><p>对于减法而言，不存在进位，但是有借位。</p><p>为了避免借位，提出<strong>补数</strong>的概念</p><blockquote><p>对于一个 $k$ 进制数 $a$ ，从一串 $k$ 中（个数等于 $k$ 进制下 $a$ 的位数）减去 $a$ 得到的数，称为 $a$ 对 $k$ 的补数</p></blockquote><p>提出补数的好处是计算补数的过程不需要借位</p><p>当计算出补数之后，将补数与被减数<strong>相加</strong>，把结果加一，再减去$10^n$，$n$为$a$的位数。</p><p>为什么这样可行？举个例子</p><script type="math/tex; mode=display">\begin{align}   253 - 176 &= 253 - 176 + 1000 - 1000 \\   &= 253 - 176 + 999 + 1 - 1000  \\   &= 253 + (999 - 176) + 1 - 1000\\\end{align}</script><p>二进制的减法与之类似。</p><p>注意到现在式子中唯一的减法其实就是求这个数的补数。</p><p>对于一个二进制数，计算它的补数只需要对其按位取反，也就是它的<strong>反码</strong>(inverse)。</p><p>并且，对于最后一步减法，也是不必真的做的，最高位会自然溢出，作为进位被丢掉。</p><p>至此，大数减小数的减法就实现了。</p><h2 id="表示负数"><a href="#表示负数" class="headerlink" title="表示负数"></a>表示负数</h2><p>首先明确一点，计算机处理的位数是有限的，超过最高位的数将会溢出。</p><h2 id="小数减大数"><a href="#小数减大数" class="headerlink" title="小数减大数"></a>小数减大数</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个半加器，我们用一个异或门表示加和输出，一个与门表示进位输出，可以实现两个二进制数中一位的加法。&lt;/p&gt;
&lt;p&gt;将和与前一位运算的进位通过一个半加器连接在一起就构成了全加器。&lt;/p&gt;
&lt;p&gt;至此就实现了二进制加法。&lt;/p&gt;
&lt;p&gt;每一个全加器只能计算&lt;strong&gt;一位&lt;/strong&gt;二进制数，要进行多位二进制数的加法就需要串联多个全加器。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="《编码》笔记" scheme="http://ilern.github.io/tags/%E3%80%8A%E7%BC%96%E7%A0%81%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业三 邮件服务器</title>
    <link href="http://ilern.github.io/2019/11/27/Computer-Networking-Lab-3/"/>
    <id>http://ilern.github.io/2019/11/27/Computer-Networking-Lab-3/</id>
    <published>2019-11-26T16:00:00.000Z</published>
    <updated>2019-11-27T14:52:36.345Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业三</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>通过完成本实验，您将更加了解SMTP协议。您还将学到使用Python实现标准协议的经验。</p><p>您的任务是开发一个简单的邮件客户端，将邮件发送给任意收件人。您的客户端将需要连接到邮件服务器，使用SMTP协议与邮件服务器进行对话，并向邮件服务器发送电子邮件。 Python提供了一个名为smtplib的模块，它内置了使用SMTP协议发送邮件的方法。但是我们不会在本实验中使用此模块，因为它隐藏了SMTP和套接字编程的细节。</p><p>为了限制垃圾邮件，一些邮件服务器不接受来源随意的TCP连接。对于下面所述的实验，您可能需要尝试连接到您的大学邮件服务器和流行的Webmail服务器（如AOL邮件服务器）。您也可以尝试从您的家和您的大学校园进行连接。</p><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>在某些情况下，接收邮件服务器可能会将您的电子邮件分类为垃圾邮件。当您查找从客户端发送的电子邮件时，请检查垃圾邮件文件夹。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于某些众所周知的原因，本实验不使用Google邮箱，而是使用QQ邮箱。</p><p>基本流程如下</p><ul><li>与QQ邮箱服务器（smtp.qq.com）建立TCP连接，这里为了简单起见，使用非SSL协议的25端口。其他邮件服务器见这篇文章：<a href="https://blog.csdn.net/qq_25046261/article/details/78982080" target="_blank" rel="noopener">常用的邮件服务器名称、地址及SSL/非SSL协议端口号</a>。成功建立连接之后，服务器会返回状态码220表示已就绪。</li><li>发送 HELO 命令，输入自己的账户，开始试图与服务器交互。</li><li>发送 AUTH LOGIN 命令，输入密码。这里的密码指的是<strong>邮件服务器提供的授权码</strong>，而不是平时在web端登录的密码。</li><li>上面提到的用户名和密码都是<strong>经过Base64加密后的结果</strong>。我在这一步卡了很久，最后发现原因是在网上找的Base64加密工具给出的结果是错的，换一个工具就好了。</li><li>登录成功后，服务器会返回状态码235表示成功。</li><li>发送 MAIL FROM 命令，表明发信人，应当与 HELO-AUTH 命令中验证的邮箱保持一致。成功后会收到 <code>250 OK</code>的回复。</li><li>发送 RCPT TO 命令，表明收信人。成功后会收到 <code>250 OK</code> 的回复。</li><li>发送 DATA 命令，表明自己要开始发送信息了。 服务器将返回状态码354 。</li><li>发送邮件内容，最开头要有<code>\r\n</code>，每条信息结尾也要有<code>\r\n</code>，最后要发送一个<code>\r\n.\r\n</code>表明邮件内容的结束。</li><li>发送 QUIT 命令，结束与邮件服务器的连接。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><img src="https://s2.ax1x.com/2019/11/27/QC5J3R.png" alt="yh"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业三&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业二 UDP ping 程序</title>
    <link href="http://ilern.github.io/2019/11/16/Computer-Networking-Lab-2/"/>
    <id>http://ilern.github.io/2019/11/16/Computer-Networking-Lab-2/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2019-11-17T02:44:16.302Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业二</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>在这个编程作业中，你将用Python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序，然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第4章中学习ICMP）。此时我们将创建一个非标准（但简单）的基于UDP的ping程序。</p><p>你的ping程序经UDP向目标服务器发送10个ping报文，对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为1秒；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。</p><p>在此作业中，我们给出服务器的完整代码（在配套网站中可以找到。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以不受限制地从服务器代码中剪贴代码行。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>在服务端与客户端建立UDP连接</li><li>循环发送十条信息，在发出和接收的位置分别计时</li><li>每接收到一条回复，把两个时间相减得到RTT</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>在判断超时的时候，<code>socket</code>自带了一个时长限定，当超出这个时间之后会抛出<code>timeout</code>异常。</li><li><code>time.perf_counter()</code>是以秒为单位的计时。</li><li>服务端模拟丢包率为 $30 \%$ ，实际结果与其格外吻合。</li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>【客户端】<br><img src="https://s2.ax1x.com/2019/11/16/MBnItH.png" alt="cilent"></p><p>【服务端】<br><img src="https://s2.ax1x.com/2019/11/16/MBuShj.md.png" alt="server"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业二&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title> 《计算机网络-自顶向下方法》 编程作业一 Web服务器</title>
    <link href="http://ilern.github.io/2019/11/14/Computer-Networking-Lab-1/"/>
    <id>http://ilern.github.io/2019/11/14/Computer-Networking-Lab-1/</id>
    <published>2019-11-13T16:00:00.000Z</published>
    <updated>2019-11-16T12:50:04.105Z</updated>
    
    <content type="html"><![CDATA[<p>《计算机网络-自顶向下方法》 Socket编程作业一</p><a id="more"></a><p>本作业完整代码可在我的这个<a href="https://github.com/iLern/Computer-Networking-Lab" target="_blank" rel="noopener">Github仓库</a>中找到。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>实现一个最简单的Web服务器，它能够处理一个请求：</p><ul><li>当客户（浏览器）联系时创建一个连接Socket</li><li>从这个连接接收HTTP请求</li><li>解释该请求以确定所请求的特定文件</li><li>从服务器的文件系统获取该文件</li><li>创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行</li><li>经TCP连接向请求的浏览器发送响应。若服务器中不存在请求的文件是，返回一个<code>404 Not Found</code>的差错报文</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>HTTP建立在TCP之上，所以在服务端建立TCP Socket</li><li>HTTP响应报文的首部行需要手写，感觉有点奇怪</li><li>如果不用浏览器，也可以写一个客户端的程序来进行HTTP请求</li><li>对于浏览器，用<code>&lt;ip_address&gt;:&lt;port&gt;/&lt;file&gt;</code>来请求某个文件</li></ul><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="C:\Users\Taisi\Pictures\Saved Pictures\无标题.png" alt="pic"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《计算机网络-自顶向下方法》 Socket编程作业一&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://ilern.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web" scheme="http://ilern.github.io/tags/Web/"/>
    
      <category term="网络" scheme="http://ilern.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配学习笔记</title>
    <link href="http://ilern.github.io/2019/11/06/BipartiteGraphLearn/"/>
    <id>http://ilern.github.io/2019/11/06/BipartiteGraphLearn/</id>
    <published>2019-11-05T16:00:00.000Z</published>
    <updated>2019-11-06T09:03:53.061Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul><li>二分图一定是一个无向图</li><li>若一个无向图中<strong>不存在</strong>长度为奇数的环，则这个图为二分图</li><li>二分图可以分成两个部分，每部分中的点之间没有边</li></ul><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><ul><li>对于一个二分图，从它的所有边中选出一些，使得任意两条边没有公共端点，这样的边的集合被称为二分图的<strong>匹配</strong></li><li>二分图的匹配并不是唯一的</li><li>在所有的匹配中含边数最多的那一个称为这个二分图的 <strong>最大匹配</strong></li></ul><h3 id="增广路定理"><a href="#增广路定理" class="headerlink" title="增广路定理"></a>增广路定理</h3><p>网络流问题中也存在（类似的）<strong>增广路</strong>的概念。</p><ul><li>对于一个二分图，如果存在一条连接两个非匹配点的路径，使得匹配边与非匹配边交替出现，则这个路径是已知匹配的 <strong>增广路</strong>。</li><li>对于一条增广路而言，如果将其中的匹配边与非匹配边身份互换，可得到一个更大的匹配。</li><li>由上述两条可知，找到最大匹配等价于此时二分图中不存在增广路。</li></ul><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>把二分图画成左边右边两个区域（黑点白点），两个区域中间有一些边，现在要在这些边里选择出一些，使形成一个最大匹配。</p><p>不妨以左边的点从上到下的顺序考虑</p><ul><li>对于左边的第<code>i</code>个点，遍历与之相邻的点<code>neighbor[i][j]</code>（一定在右侧）<ul><li>如果<code>neighbor[i][j]</code>还没有被匹配，那就把这两个点（暂时）匹配上，看左边的第<code>i+1</code>号点。</li><li>如果<code>neighbor[i][j]</code>已经被匹配过了，那就看看之前和<code>neighbor[i][j]</code>匹配的点还能不能匹配其他点（此时视角转换成<code>neighbor[i][j]</code>之前确定的那个匹配点（左边的点），递归进去）。<ul><li>如果<code>neighbor[i][j]</code>之前的匹配点可以换一个匹配对象，就换，把<code>neighbor[i][j]</code>留给现在考虑的<code>i</code>号点，不能换就算了，看<code>j+1</code>号点</li></ul></li><li>如果能找到一个合适的匹配点，就返回<code>true</code>，反之返回<code>false</code></li></ul></li></ul><p>这是一个类似于<code>dfs</code>的过程，被访问的点不应到再被访问一次，所以用一个<code>vis</code> 数组记录<code>dfs</code>过程中的访问情况，注意这里的<strong>访问情况</strong>和<strong>匹配情况</strong>的区别，代码中的<code>vis</code>是访问情况，<code>con_x</code> <code>con_y</code>是匹配情况。所以<code>vis</code>每看一个左边的点就要全部设置为未访问一次。</p><p>理解这个过程之后，发现真的很像相亲……</p><p>有点贪心的意思</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="HDU-2063-过山车"><a href="#HDU-2063-过山车" class="headerlink" title="HDU-2063 过山车"></a>HDU-2063 过山车</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> p[MAXN * <span class="number">2</span>][MAXN * <span class="number">2</span>], vis[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> con_x[MAXN * <span class="number">2</span>], con_y[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (con_y[i] == <span class="number">-1</span> || match(con_y[i])) &#123;</span><br><span class="line">                con_x[x] = i;</span><br><span class="line">                con_y[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;n, &amp;m) != EOF &amp;&amp; k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(con_x, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_x));</span><br><span class="line">        <span class="built_in">memset</span>(con_y, <span class="number">-1</span>, <span class="keyword">sizeof</span>(con_y));</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="literal">false</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> girl, boy;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;girl, &amp;boy);</span><br><span class="line">            p[girl][boy + n] = p[boy + n][girl] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (match(i)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="http://ilern.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>manacher学习笔记</title>
    <link href="http://ilern.github.io/2019/11/04/manacher_learn/"/>
    <id>http://ilern.github.io/2019/11/04/manacher_learn/</id>
    <published>2019-11-03T16:00:00.000Z</published>
    <updated>2019-11-30T15:03:52.126Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="Manacher简介"><a href="#Manacher简介" class="headerlink" title="Manacher简介"></a>Manacher简介</h2><p>Manacher算法用于高效解决这样的问题：给定一个长度为 $n$ 的字符串，求其中以每个字符为中心的<strong>回文子串</strong>的长度。</p><h3 id="什么是回文串？"><a href="#什么是回文串？" class="headerlink" title="什么是回文串？"></a>什么是回文串？</h3><p>正着读和反着读都一样的字符串，例如<code>()()</code>不是一个回文串，而<code>())(</code>是一个回文串。</p><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><h3 id="最蠢的那种"><a href="#最蠢的那种" class="headerlink" title="最蠢的那种"></a>最蠢的那种</h3><p>$O(n^2)$ 枚举子串，$O(n)$ 判断是否为回文，总复杂度$O(n^3)$</p><h3 id="稍微好一点"><a href="#稍微好一点" class="headerlink" title="稍微好一点"></a>稍微好一点</h3><p>$O(n)$枚举中心，向两边尽量扩展，复杂度$O(n^2)$</p><h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>Manacher 利用了回文串具有的<strong>对称性</strong>来通过之前计算过的子串的信息优化对当前位置的计算。这一点和<a href="https://ilern.github.io/2019/09/26/KMP_learn/">KMP算法</a>可以说异曲同工。</p><p>首先明确最后要通过这个算法得到什么东西。一个数组<code>p</code>，其中<code>p[i]</code>表示以<code>i</code>为中心的最大回文半径。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>最后求出的<code>p</code>数组应当为</p><p><code>p = [1, 1, 2, 1, 4, 1    , 2, 1, 1]</code></p><p>这样知道了最大回文半径，也就能求出以每个字符为中心的最长回文子串长度。</p><p>但是这样的做法不够完善，例如对于<code>baaaab</code>这个字符串，本身是一个回文串，那么最长回文子串自然是它本身，但是按照<code>p</code>数组的定义，这个字符串对应的<code>p</code>应该是<code>[1, 1, 2, 2, 1, 1]</code>，而仅仅通过这个数组是求不出最长回文子串的。</p><p>问题就出在这个串的长度是偶数，在这个串中不存在一个<strong>中心</strong>作为这个子串的中心。</p><p>所以需要进行预处理来使得这个算法支持偶数长的子串。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>个人感觉这一步相当巧妙。</p><p>对于原串，我们在开头插入一个<code>$</code>，在每个字符前后都插入一个<code>#</code>。</p><p>例如，对于字符串</p><p><code>s = &quot;cabadabae&quot;</code></p><p>预处理之后结果为</p><p><code>s1 = &quot;$#c#a#b#a#d#a#b#a#e#&quot;</code></p><p>这里的<code>$</code>和<code>#</code>并不是一定用这两个字符，只要是不在原串中出现的字符都可以。</p><p>经过这样的预处理我们发现之前不存在对称中心的问题解决了，偶数长度的子串在新字符串中以<code>#</code>为对称中心，奇数长度的子串在新字符串中还是以原来的对称中心为对称中心，且原字符串的回文子串长度等于新字符串回文半径长度减一。</p><p>添加开头的<code>$</code>是为了更好判断边界，不添加也可以，但是在边界处理上会麻烦一些。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在第二个暴力算法中，还是以<code>s = &quot;cabadabae&quot;</code>为例，假如我们已经知道了以第三位为中心的最大回文半径（相当于知道了以第三位为中心的最长回文子串）和以第五位为中心的最大回文半径，那么在求以第七位为中心的最大回文半径的时候，由于回文串具有<strong>对称</strong>的特性，并且三和七<del>恰好</del>关于五对称，所以可以直接得到（部分）结果。</p><ul><li>以第三位为中心的最长回文子串 <code>c[aba]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[aba]e</code></li></ul><p>所以可以直接从长度为3开始拓展（因为目前为止更后面的信息还不知道）。</p><p>如果换成计算第六位的时候又是怎样的情况呢？六关于五的对称点为四。</p><ul><li>以第二位为中心的最长回文子串 <code>cab[a]dabae</code></li><li>以第五位为中心的最长回文子串 <code>c[abadaba]e</code></li><li>以第七位为中心的最长回文子串 <code>cabad[a]bae</code></li></ul><p>长度只能为1。</p><p>不难发现，在已知当前最长的回文串是以五位中心之后，再往后的位置都可以直接由对称性来得到至少一部分信息。我们利用这些信息，就能很快求出所有的回文子串。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设置两个状态 <code>maxR</code> 和 <code>id</code>，分别表示当前已知的回文子串的最右边界和这个边界所对应的中心。</p><p>设<code>p[i]</code>表示第<code>i</code>个字符为中心时最大回文子串的长度，按照<code>i</code>从大到小的顺序从左向右计算。</p><p>对于每一个即将计算到的<code>i</code>，先计算出关于<code>id</code>的对称点<code>j = id * 2 - i</code>，然后分以下三种情况进行。</p><ul><li>若 $i &gt; maxR$，即这个点不在之前计算过的回文串中，此时我们并不能从之前的计算中获取有用的信息，只能令<code>p[i] = 1</code>，然后从这个位置开始向两边扩展，顺便更新 <code>maxR</code> 和 <code>id</code></li><li>若 $i \leq maxR$ 且 $i + p[j] &lt; maxR$ ​，此时有 <code>p[i] = p[j]</code>，如同上面的第二个例子。</li><li>若 $i \leq maxR$ 且 $i + p[j] \geq maxR$，此时已知的最长回文串覆盖了<code>i</code>这个位置但是没有覆盖<code>j</code>为中心的回文串，此时有<code>p[i] = maxR - i</code>。</li></ul><p>这样确定<code>p[i]</code>最小可能的值然后再尝试向两边扩展即可，其中第二种情况应该是无法继续扩展的。</p><blockquote><p>1、先对字符串进行预处理，两个字符之间加上特殊符号#</p><p>2、然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）</p><p>3、每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度</p><p>4、判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界</p><p>5、最后得到最长回文之后，去掉其中的特殊符号即可</p></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">P3805 【模板】manacher算法</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">11000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[MAXN * <span class="number">2</span> + <span class="number">10</span>], maxR = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">"$"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">        ret += <span class="string">"#"</span>;</span><br><span class="line">        ret += c;</span><br><span class="line">    &#125;</span><br><span class="line">    ret += <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sp = preProcess(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; maxR) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = id * <span class="number">2</span> - i;</span><br><span class="line">            p[i] = min(p[j], maxR - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = i - p[i];</span><br><span class="line">        <span class="keyword">int</span> r = i + p[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sp[l] == sp[r]) &#123;</span><br><span class="line">            l--; r++;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; maxR) &#123;</span><br><span class="line">                maxR = r;</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p[i] = r - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sp.length(); i++) &#123;</span><br><span class="line">        maxx = max(maxx, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxx - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTE1ODkyNQ==&amp;mid=2649410225&amp;idx=1&amp;sn=ed045e8edc3c49a436a328e5f0f37a55&amp;chksm=f0b60f53c7c18645b4c04a69ad314723cce94ed56994d6f963c2275a2db8d85f973f15f508e4&amp;mpshare=1&amp;scene=23&amp;srcid=1001JCsBlpxgUWjgixasChNQ#rd" target="_blank" rel="noopener">【面试现场】如何找到字符串中的最长回文子串？</a></p><p><a href="https://oi.men.ci/manacher-notes/" target="_blank" rel="noopener">Manacher 学习笔记 - Menci</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://ilern.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记 - 文件操作</title>
    <link href="http://ilern.github.io/2019/10/30/filepython/"/>
    <id>http://ilern.github.io/2019/10/30/filepython/</id>
    <published>2019-10-29T16:00:00.000Z</published>
    <updated>2019-11-03T06:48:24.982Z</updated>
    
    <content type="html"><![CDATA[<p>真是令人迷惑</p><a id="more"></a><h3 id="何为文件"><a href="#何为文件" class="headerlink" title="何为文件"></a>何为文件</h3><p>文件可以看作数据的抽象和集合。是数据存储的一种形式，由二进制存储。</p><p><code>Linux</code>认为一切都是文件， 在<code>UNIX</code>系统中，一切资源都被看作是文件，包括硬件设备。<code>UNIX</code>系统把每个硬件都看成是一个文件，称之为<strong>设备文件</strong>。</p><h3 id="文件的类型-展示方式"><a href="#文件的类型-展示方式" class="headerlink" title="文件的类型 / 展示方式"></a>文件的类型 / 展示方式</h3><ul><li><p>文本文件</p><ul><li><p><strong>单一而特定</strong>的编码组成的文件， 例如<code>UTF-8</code>编码。</p></li><li><p>可以看作一个长的字符串。</p></li></ul></li><li><p>二进制文件</p><ul><li><p>直接由<strong>0和1</strong>构成的文件，没有统一的编码格式。一般这样的文件中的0和1是由某种预定的格式组合成的，因此形成了一些特定的文件类型，例如图片的 <code>.png</code>，视频的<code>.avi</code>。</p></li><li><p>这类文件的0和1之上没有统一的编码。</p></li></ul></li></ul><h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>文件的操作通常遵循 “打开，操作，关闭” 的步骤，关系如下图所示</p><div id="sequence-0"></div><ul><li><p>文件的打开</p><ul><li><p><code>f = open(&lt;file_name&gt;, &lt;open_mode&gt;)</code></p></li><li><p>文件名可以使用相对路径也可以使用绝对路径</p></li><li><p>Python提供七种文件打开模式，与C类似</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">打开模式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center"><strong>默认</strong>打开模式，只读，若文件不存在则抛出异常</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">覆盖写，若不存在则创建，若存在则完全覆盖</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">创建写，若不存在则创建，若存在则抛出异常</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">追加写，若不存在则创建，若存在则在文件后追加</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">二进制打开</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">文本打开，<strong>默认</strong>方式</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">与前四种模式一同使用，在原本的基础上增加读写功能</td></tr></tbody></table></div><ul><li><p>默认的文件编码格式为<code>UTF-8</code>，要打开其他编码格式的文件要在打开文件时为<code>read</code>添加参数<code>encoding</code>表示要使用的编码方式。</p></li><li><p>如果编码方式不规范，<code>open</code>会抛出异常，遇到这种情况可以添加<code>errors</code>参数表示如何处理，最简单的方式就是直接忽略<code>error = &#39;ignore&#39;</code>。</p></li></ul><ul><li><p>文件的关闭</p><ul><li><code>f.close()</code>用来关闭文件，使文件回到存储状态。</li></ul></li><li><p>处理异常</p><p>由于在每次打开文件的时候都可能会产生异常，所以应该对异常采取适当的处理方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>因为每次都要<code>try-finally</code>，过于繁琐，Python提供了<code>with</code>语句来简单处理（不局限但普遍应用于文件操作）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># using with statement </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file_path'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file: </span><br><span class="line">    file.write(<span class="string">'hello world !'</span>)</span><br></pre></td></tr></table></figure><p>这样的写法不需要自己手动关闭文件，也不需要手动捕获异常。</p></li></ul><h3 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h3><ul><li>python提供三种文件读取的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.read()</code></td><td style="text-align:center">直接读入整个文件，存到字符串当中，对于大文件慎用</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.read(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline()</code></td><td style="text-align:center">读一行</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readline(size)</code></td><td style="text-align:center">读前<code>size</code>个字符的内容</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.readlines()</code></td><td style="text-align:center">读入所有行，组织成一个列表</td></tr><tr><td style="text-align:center"><code>&lt;dile_object&gt;.readlines(hint)</code></td><td style="text-align:center">读入前<code>hint</code> 行，组织成一个列表</td></tr></tbody></table></div><ul><li><p>逐行遍历文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h3><p>想要写入文件，在打开文件时应该用<code>w</code> / <code>wb</code>形式</p><ul><li>python提供两种写文件的方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;file_object&gt;.write(str)</code></td><td style="text-align:center">写字符串或文件流到文件中</td></tr><tr><td style="text-align:center"><code>&lt;file_object&gt;.writelines(list)</code></td><td style="text-align:center">把一个全为字符串的列表写到文件里，实际上是把列表中的字符串续到一起</td></tr></tbody></table></div><ul><li><p>文件指针</p><ul><li><p>不是C语言里的那种文件指针。</p></li><li><p>就像文本编辑器里的光标一样，表示当前写入的位置。</p></li><li><p>使用<code>&lt;file_project&gt;.seek()</code>来调整文件指针</p><ul><li><p><code>seek()</code>接受两个参数，第一个参数表示偏移量，第二个参数表示起点（0-从开头开始，1-从当前位置开始，2-从末尾开始）</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'hihi '</span>, <span class="string">'haha '</span>, <span class="string">'hoho '</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br><span class="line">    <span class="comment"># f.seek(0, 0)  #hihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(1, 0)  #ihi haha hoho</span></span><br><span class="line">    <span class="comment"># f.seek(2, 0)  #hi haha hoho</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 1)  #None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># f.seek(0, 2)  #None</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> f:</span><br><span class="line">        print(lines)</span><br></pre></td></tr></table></figure></li><li><p>如果写入之后接着读取是什么都读不到的，因为文件指针默认从当前位置开始读，而刚写入之后文件指针的后面什么都没有，需要移动之后再输出</p></li></ul></li></ul></li></ul><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">participant 存储状态 as ffparticipant 占用状态 as kkff-->kk: a = open(, )kk-->ff: a.close()</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是令人迷惑&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://ilern.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP学习笔记</title>
    <link href="http://ilern.github.io/2019/09/26/KMP_learn/"/>
    <id>http://ilern.github.io/2019/09/26/KMP_learn/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-11-04T08:08:43.998Z</updated>
    
    <content type="html"><![CDATA[<p>学了好几次才学会</p><a id="more"></a><h2 id="KMP简介"><a href="#KMP简介" class="headerlink" title="KMP简介"></a>KMP简介</h2><p>KMP算法用于高效解决这样的问题：给定一个有 $n$ 个字符的字符串 <code>txt</code> 和一个有 $m$ 个字符的字符串 <code>pat</code> （$n &gt; m$），找出 <code>txt</code> 中 <code>pat</code> 每次出现的位置 。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input : txt[] = &quot;THIS IS A TEST TEXT&quot;</span><br><span class="line">        pat[] = &quot;TEST&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 10</span><br></pre></td></tr></table></figure><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:  txt[] = &quot;AABAACAADAABAABA&quot;</span><br><span class="line">        pat[] = &quot;AABA&quot;</span><br><span class="line"></span><br><span class="line">Output: Pattern found at index 0</span><br><span class="line">        Pattern found at index 9</span><br><span class="line">        Pattern found at index 12</span><br></pre></td></tr></table></figure><h2 id="暴力匹配法"><a href="#暴力匹配法" class="headerlink" title="暴力匹配法"></a>暴力匹配法</h2><p>对于这个问题，最容易想到的方法就是一个位置一个位置尝试匹配，每次将模式串 <code>pat</code> 向后移动一位，就像一个滑动的窗口一样，每次比较 $m$ 个位置。</p><p>但是这个方法在很多匹配的字符后面跟着一个不匹配的字符的情况下表现不够好，最坏的情况复杂度会达到 $O(m(n-m+1))$ 。</p><p>比如说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAAAAAAAAAAAAAAB&quot;</span><br><span class="line">pat[] = &quot;AAAAB&quot;</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;ABABABCABABABCABABABC&quot;</span><br><span class="line">pat[] = &quot;ABABAC&quot;</span><br></pre></td></tr></table></figure></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法最基本的想法就是：不论我们在哪里失配了（在某些字符匹配成功之后），我们都知道了接下来要尝试匹配的 <code>txt</code> 的子串的一部分信息，因为每次 <code>pat</code> 都只向右移动一个字符，所以我们可以利用这一点来减少不必要的匹配。</p><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>第一次匹配是成功的，接下来 <code>pat</code> 串会向右移动一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br></pre></td></tr></table></figure><p>在暴力匹配算法中，我们会从 <code>txt</code> 的第二个位置，<code>pat</code>  的第一个位置开始尝试匹配，但是实际上我们只需要看<code>txt</code> 的第五个位置和 <code>pat</code> 的第四个位置是不是相同的就可以了，因为我们知道前三个字符一定会匹配。</p><p>为了做到这一点，我们需要进行一些预处理。</p><p>我们定义一个列表<code>lps[]</code>（<code>lps</code> 是 <strong>longest proper prefix which is also suffix</strong> 的缩写），<code>lps[i]</code>表示<code>pat</code> 中<code>[0, i]</code>这个子串中即是前缀又是后缀的最长的子串（不包括<code>[0, i]</code>这个子串本身）</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 3]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [0, 0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [0, 1, 2, 0, 1, 2, 3]</span><br></pre></td></tr></table></figure><p>在有了<code>lps</code>数组之后，就可以进行我们的KMP算法了：</p><ul><li>我们用 <code>i</code> 来指示 <code>txt</code> 中当前考虑的元素的下标，<code>j</code>来指示 <code>pat</code> 中当前考虑元素的下标</li><li>匹配从<code>i = 0</code>，<code>j = 0</code> 开始，当 <code>txt[i] == pat[j]</code> 时，<code>i++; j++</code>，此时这个位置是匹配的</li><li>当<code>txt[i] != pat[j]</code>即这个位置不匹配的时候<ul><li>既然能进行到这一步，说明<code>pat</code>的<code>[0, j - 1]</code>中的每个位置和<code>txt</code>的<code>[i - j, i - 1]</code>中的每个位置都是匹配的</li><li>我们还知道<code>lps[j - 1]</code>表示<code>pat</code> 中<code>[0, j - 1]</code>这个子串中即是前缀又是后缀的最长的子串</li><li>基于以上两点，我们发现在<code>pat</code>向右移动一位准备开始下一次匹配的时候，<code>pat</code>的前<code>lps[j - 1]</code>个字符是不需要匹配的（一定可以匹配成功），<code>j</code>重置为<code>lps[j - 1]</code></li></ul></li></ul><p>简言之，以图中的例子来说，在 <code>i</code> 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串<code>i</code>之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p><p><img src="https://pic4.zhimg.com/50/v2-03a0d005badd0b8e7116d8d07947681c_hd.jpg" alt="来自知乎">，</p><h3 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] = &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>直到<code>i = 4, j = 4</code>为止都是匹配的，此时一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code>，也就是说，在下一次匹配中，<code>pat</code> 的前三个字符都不必进行匹配（一定可以匹配成功）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 4, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =  &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>此时<code>i = 5, j = 4</code>，又一轮匹配结束，<code>j</code>被重置为<code>lps[j - 1] = lps[4 - 1] = lps[3] = 3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 3</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =   &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[3 - 1] = lps[2] = 2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 2</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =    &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[2 - 1] = lps[1] = 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 1</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =     &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，<code>j</code>被重置为<code>lps[j - 1] = lps[1 - 1] = lps[0] = 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 5, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =      &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>不匹配，这轮匹配终止，但是此时<code>j = 0</code>，故<code>i++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 6, j = 0</span><br><span class="line">txt[] = &quot;AAAAABAAABA&quot; </span><br><span class="line">pat[] =       &quot;AAAA&quot;</span><br><span class="line">lps[] = &#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>匹配，<code>i++; j++</code></p><p>$\dots$</p><p>重复上述过程，直到<code>i = n</code>，算法结束。</p><h3 id="lps的计算"><a href="#lps的计算" class="headerlink" title="lps的计算"></a>lps的计算</h3><p>现在，问题只剩下如何求得<code>lps</code>这个列表了。</p><p>求解<code>lps</code>的过程可以看作模式串自己与自己匹配的过程，对于每个位置（除了0位置，0位置永远为0）都与自己从头开始匹配，能匹配的最大长度就是<code>lps</code>。</p><p>实现中用<code>len</code>记录当前匹配到的最大长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> txt[MAXN], pat[MAXN];</span><br><span class="line"><span class="keyword">int</span> lps[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> txt[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenA) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txt[i] == pat[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == lenB) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - j + <span class="number">1</span>);</span><br><span class="line">            j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcLps</span><span class="params">(<span class="keyword">int</span> lps[], <span class="keyword">char</span> pat[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenPat = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lenPat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            lps[len] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[len] == pat[i]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                lps[i] = len;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    lps[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> len = lps[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, txt, pat);</span><br><span class="line">    calcLps(lps, pat);</span><br><span class="line">    KMP(txt, pat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(pat);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, lps[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" target="_blank" rel="noopener">KMP Algorithm for Pattern Searching</a></p><p><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">如何更好的理解和掌握 KMP 算法? - 海纳的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了好几次才学会&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://ilern.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 3</title>
    <link href="http://ilern.github.io/2019/08/08/acmsummer_33/"/>
    <id>http://ilern.github.io/2019/08/08/acmsummer_33/</id>
    <published>2019-08-08T08:37:23.000Z</published>
    <updated>2019-08-08T12:46:02.633Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题限时训练一</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316474#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组限时训练1</a></p><a id="more"></a><h2 id="HDU-4217-Data-Structure-树状数组区间第k小-二分"><a href="#HDU-4217-Data-Structure-树状数组区间第k小-二分" class="headerlink" title="HDU 4217 Data Structure? - 树状数组区间第k小 + 二分"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4217" target="_blank" rel="noopener">HDU 4217 Data Structure? - 树状数组区间第k小 + 二分</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>在一个含有$1 \cdots n$的序列中，每次找到第 $k_i$ 小的数，并把它删除，每组数据，输出一个整数，表示删除元素的总和。</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>发现一个数的排名只受它的位置之前被删除的数的个数影响，删除比它大的数不影响它的排名，这样问题就转化为了前缀和，可以用树状数组维护，对于要求排名 $k_i$ 的数，只会位于 $[k_i, n]$ 这个区间中，在这个区间二分找到将要被删除的那个数，计入答案即可。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">262144</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index]++;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf("[%d %d]", l, r);</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        tmp = mid - bit.query(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> del = find(x, n, x);</span><br><span class="line"></span><br><span class="line">            ans += del;</span><br><span class="line">            bit.modify(del);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cnt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZOJ-1610-Count-the-Colors-区间染色"><a href="#ZOJ-1610-Count-the-Colors-区间染色" class="headerlink" title="ZOJ 1610 Count the Colors - 区间染色"></a><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1610" target="_blank" rel="noopener">ZOJ 1610 Count the Colors - 区间染色</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>对线段染色，后染上去的会覆盖前染上的，问完成染色后每种颜色各有多少段</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>线段树维护区间当前的颜色，对于每次修改，下放标记然后修改子树。</p><p>每组数据只有一次查询，在所有修改都结束之后记录下每个叶节点的颜色，把连续的相同颜色  都算成一段，统计即可</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">8000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        color = <span class="number">-1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) color = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="keyword">new</span> SegmentTree(l, mid); lc-&gt;build();</span><br><span class="line">            rc = <span class="keyword">new</span> SegmentTree(mid, r); rc-&gt;build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color != <span class="number">-1</span>) &#123;</span><br><span class="line">            lc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line">            rc-&gt;color = <span class="keyword">this</span>-&gt;color;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;color = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;modify(l, <span class="built_in">std</span>::min(mid, r), color);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;modify(<span class="built_in">std</span>::max(l, mid), r, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) v.push_back(<span class="keyword">this</span>-&gt;color);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pushDown();</span><br><span class="line">            <span class="keyword">if</span> (l &lt; mid) lc-&gt;query(l, <span class="built_in">std</span>::min(r, mid), v);</span><br><span class="line">            <span class="keyword">if</span> (r &gt; mid) rc-&gt;query(<span class="built_in">std</span>::max(l, mid), r, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegtree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegtree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegtree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, MAXN);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line"></span><br><span class="line">            root-&gt;modify(l, r, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        root-&gt;query(<span class="number">0</span>, MAXN, v);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt; v.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i + j] != v[i]) &#123;</span><br><span class="line">                    cnt[v[i]]++;</span><br><span class="line">                    i += j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, cnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        deleteSegtree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题限时训练一&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316474#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 3 - 1+2</title>
    <link href="http://ilern.github.io/2019/08/06/acmsummer_312/"/>
    <id>http://ilern.github.io/2019/08/06/acmsummer_312/</id>
    <published>2019-08-06T08:37:23.000Z</published>
    <updated>2019-08-08T13:22:59.897Z</updated>
    
    <content type="html"><![CDATA[<p>线段树与树状数组专题</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/316346" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/316349" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第3周_线段树、树状数组专题训练2</a></p><a id="more"></a><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Ultra-QuickSort-树状数组求逆序对-离散化"><a href="#C-Ultra-QuickSort-树状数组求逆序对-离散化" class="headerlink" title="C - Ultra-QuickSort - 树状数组求逆序对 + 离散化"></a><a href="https://cn.vjudge.net/contest/316346#problem/C" target="_blank" rel="noopener">C - Ultra-QuickSort - 树状数组求逆序对 + 离散化</a></h2><h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列，求对于升序排序的逆序对个数</p><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>树状数组求逆序对的模板题。</p><p>树状数组可以处理的问题是前缀和，对于某个元素来说，升序排序的逆序对的个数就是位置在它后面数值比他小的数的个数，这个就是一个前缀和的问题了。</p><p>对于每个元素，记录他的值和他的位置，按照从数值小到大的顺序排序去重完成离散化之后，把原数组从后往前的每个元素在排序好的数组中找到位置，用树状数组维护这个位置数组，这个位置的前缀和就是这个数逆序数，在找到的位置处加一。</p><p>例如 </p><script type="math/tex; mode=display">a = [9, 1, 0, 5, 4] \\a' = [0, 1, 5, 4, 9]\\</script><p>从后往前遍历 <code>a</code> 数组，</p><p>首先找到 $4$ ，在 <code>a&#39;</code> 数组中查找发现 $4$ 在第 $4$ 个位置，在树状数组中查询 $4$ 这个位置，发现前缀为 $0$ ，也就是 $4$ 后面数值比他小的数的个数为 $0$ ，也就是 $4$ 对于逆序数的贡献为 $0$，接下来在树状数组中把 $4$ 这个位置加一，</p><p>接下来找到 $5$ , 在 <code>a&#39;</code> 数组中查找发现 $5$ 在第 $3$ 个位置，在树状数组中查询 $3$ 这个位置，发现前缀为 $1$ ，也就是之前插入的 $4$，这说明 $5$ 后面数值比他小的数的个数为 $1$，也就是 $5$ 对于逆序数的贡献为 $1$，接下来在树状数组中把 $3$ 这个位置加一，</p><p>以此类推，最后的结果就是逆序对的总数。</p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    Bit(<span class="keyword">int</span> size) : size(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        bit.size = n;</span><br><span class="line">        <span class="built_in">memset</span>(bit.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit.a));</span><br><span class="line">        v.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">            v.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator newEnd = <span class="built_in">std</span>::unique(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">std</span>::lower_bound(v.begin(), newEnd, a[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">            ans += bit.query(index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            bit.modify(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理"><a href="#E-HDU-3333-Turing-Tree-树状数组求区间不重复元素和-离线处理" class="headerlink" title="E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3333" target="_blank" rel="noopener">E - HDU 3333 Turing Tree - 树状数组求区间不重复元素和 + 离线处理</a></h2><h3 id="【题目大意】-1"><a href="#【题目大意】-1" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>给定一个序列和若干询问，对于每个询问给出区间中不重复的元素的和</p><h3 id="【题解】-1"><a href="#【题解】-1" class="headerlink" title="【题解】"></a>【题解】</h3><p>单独的一棵线段树/树状数组不能维护所有区间的不重复元素和，需要主席树等数据结构，这里的做法是离线处理每个查询。</p><p>把所有询问存下来，按照右端点从小到大排序，从小到大依次处理每个询问，对于一个新的询问，考察比上一个询问扩展出来的部分是否有之前出现过的元素，如果有就把之前的元素删除，把最近的加入，这样就保证了每个元素在每个询问中只出现一次，且是所有出现中最右边的那个。</p><p>更新完之后就可以用树状数组查询了。</p><h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; a.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        bit.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        bit.size = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">            v.push_back(Query(l, r, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Query&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= it-&gt;r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mp.count(a[i])) bit.modify(mp[a[i]], -a[i]);</span><br><span class="line"></span><br><span class="line">                bit.modify(i, a[i]);</span><br><span class="line">                mp[a[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(<span class="built_in">std</span>::make_pair(it-&gt;id, bit.query(it-&gt;r) - bit.query(it-&gt;l - <span class="number">1</span>)));</span><br><span class="line">            l = it-&gt;r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt;::iterator it = ans.begin(); it != ans.end(); it++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理"><a href="#F-HDU-4417-Super-Mario-树状数组求区间不大于某数的数个数-离线处理" class="headerlink" title="F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener">F - HDU 4417 Super Mario  - 树状数组求区间不大于某数的数个数 + 离线处理</a></h2><h3 id="【题目大意】-2"><a href="#【题目大意】-2" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>马里奥吃金币，马里奥有在每个区间里有一个跳跃高度，只能吃到小于等于这个高度的硬币，给出若干组询问，问某个区间中能吃到多少金币。</p><h3 id="【题解】-2"><a href="#【题解】-2" class="headerlink" title="【题解】"></a>【题解】</h3><p>离线处理所有询问，把每个点和每个询问都按照高度从小到大排序，排序后从小到大考察每个询问。</p><p>利用树状数组前缀求和的特点，只需要设置一个变量表示现在到了哪个金币，如果这个金币的高度小于当前询问的高度，就加入到树状数组当中，因为询问高度是单调增的，所以在前面的询问中加入的点仍然满足后面询问的条件，这样就只需要用树状数组维护一下区间和了。</p><h3 id="【代码】-2"><a href="#【代码】-2" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Query &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; qs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[MAXN];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    Bit() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= size) &#123;</span><br><span class="line">            a[index] += delta;</span><br><span class="line">            index += lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans += a[index];</span><br><span class="line">            index -= lowBit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        bit.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i].h);</span><br><span class="line">            num[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;qs[i].l, &amp;qs[i].r, &amp;qs[i].h);</span><br><span class="line">            qs[i].l++;</span><br><span class="line">            qs[i].r++;</span><br><span class="line"></span><br><span class="line">            qs[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(qs, qs + m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt;= n &amp;&amp; num[cnt].h &lt;= qs[i].h) &#123;</span><br><span class="line">                bit.modify(num[cnt++].id, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans[qs[i].id] = bit.query(qs[i].r) - bit.query(qs[i].l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="C-An-easy-problem-线段树维护区间乘积"><a href="#C-An-easy-problem-线段树维护区间乘积" class="headerlink" title="C - An easy problem - 线段树维护区间乘积"></a><a href="https://cn.vjudge.net/contest/316349#problem/C" target="_blank" rel="noopener">C - An easy problem - 线段树维护区间乘积</a></h2><h3 id="【题目大意】-3"><a href="#【题目大意】-3" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>令$x = 1$，给出两种操作</p><ul><li>操作<code>(1, a)</code>表示令 $x = a \cdot x$ </li><li>操作<code>(2, i)</code>表示令 $x = \frac{x}{a[i]}$，其中 $a[i]$ 表示第 $i$ 个一号操作中的<code>a</code>。</li></ul><p>问经过若干次操作之后 $x$ 的值是多少。</p><h3 id="【题解】-3"><a href="#【题解】-3" class="headerlink" title="【题解】"></a>【题解】</h3><p>看上去维护一个数的更改，和线段树没有什么关系，其实把所有的一操作看作一个序列，问题就变成了维护区间乘积，二操作相当于把序列中的某个位置改成 $1$ ，这样就可以用线段树维护单点修改和区间乘积了。</p><h3 id="【代码】-3"><a href="#【代码】-3" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> data;</span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="number">1</span>;</span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = (lc-&gt;data % mod * rc-&gt;data % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) data = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mid) lc-&gt;modify(index, delta);</span><br><span class="line">            <span class="keyword">else</span> rc-&gt;modify(index, delta);</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">this</span>-&gt;l &amp;&amp; r == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> data;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * lc-&gt;query(l, <span class="built_in">std</span>::min(<span class="keyword">this</span>-&gt;mid, r)) % mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="keyword">this</span>-&gt;mid) ans = (ans % mod * rc-&gt;query(<span class="built_in">std</span>::max(<span class="keyword">this</span>-&gt;mid, l), r) % mod) % mod;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line"></span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;q, &amp;mod);</span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, q);</span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) root-&gt;modify(i, x);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) root-&gt;modify(x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;query(<span class="number">0</span>, q));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-HDU-2795-Billboard-线段树变形"><a href="#G-HDU-2795-Billboard-线段树变形" class="headerlink" title="G - HDU 2795 -Billboard - 线段树变形"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2795" target="_blank" rel="noopener">G - HDU 2795 -Billboard - 线段树变形</a></h2><h3 id="【题目大意】-4"><a href="#【题目大意】-4" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一个广告牌，有很多人往上贴广告，每个广告占一个单位高度，若干单位长度，广告优先往上边贴，同样高度情况下优先往左边贴，如果没有空间贴，就不贴。</p><p>对于每一张广告，询问它被贴在哪一行。</p><h3 id="【题解】-4"><a href="#【题解】-4" class="headerlink" title="【题解】"></a>【题解】</h3><p>这题的修改的基本单位是行，以行为单位划分区间，想象把广告牌逆时针旋转九十度，建立线段树。</p><p>线段树维护每个区间中剩余空间的最大值，如果我们想贴一张新的海报上去，先与线段树的根节点值比较，如果大于根节点的值，说明所有行都没有空间贴这张新的海报；如果小于，就再与左右节点比较，以此类推，直到找到能贴的位置，注意要先和左子树比较再和右子树比较，因为要求尽量贴得高，旋转之后就是尽量贴得左。</p><h3 id="【代码】-4"><a href="#【代码】-4" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    SegmentTree *lc, *rc;</span><br><span class="line"></span><br><span class="line">    SegmentTree(<span class="keyword">int</span> l, <span class="keyword">int</span> r) : l(l), r(r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        data = w;</span><br><span class="line">        id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        lc = rc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="built_in">std</span>::max(lc-&gt;data, rc-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", this-&gt;l, this-&gt;r);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data = SegmentTree::w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (lc = <span class="keyword">new</span> SegmentTree(l, mid))-&gt;build();</span><br><span class="line">            (rc = <span class="keyword">new</span> SegmentTree(mid, r))-&gt;build();</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int query(int l, int r) &#123;</span></span><br><span class="line">    <span class="comment">//     if (this-&gt;l == l &amp;&amp; this-&gt;r == r) return this-&gt;data;</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         int ans = INT_MIN;</span></span><br><span class="line">    <span class="comment">//         if (l &lt; mid) ans = std::max(ans, query(l, std::min(r, mid)));</span></span><br><span class="line">    <span class="comment">//         if (r &gt; mid) ans = std::max(ans, query(std::max(l, mid), r));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//         return ans;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data -= delta;</span><br><span class="line">            <span class="comment">// if (ans &lt;  this-&gt;id) ans = this-&gt;id;</span></span><br><span class="line">            ans = <span class="keyword">this</span>-&gt;id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lc-&gt;data &gt;= delta) lc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rc-&gt;data &gt;= delta) rc-&gt;modify(delta);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            update();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d %d], data = %d\n"</span>, <span class="keyword">this</span>-&gt;l, <span class="keyword">this</span>-&gt;r, <span class="keyword">this</span>-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (lc) lc-&gt;print();</span><br><span class="line">        <span class="keyword">if</span> (rc) rc-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SegmentTree::w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSegTree</span><span class="params">(SegmentTree *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;lc) deleteSegTree(node-&gt;lc);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;rc) deleteSegTree(node-&gt;rc);</span><br><span class="line">    node-&gt;~SegmentTree();</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    node = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h, w, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;h, &amp;w, &amp;n) != EOF) &#123;</span><br><span class="line">        SegmentTree::w = w;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int m = h;</span></span><br><span class="line">        <span class="comment">// if (h &gt; n) m = n;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">200000</span>) h = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("m = %d\n", m);</span></span><br><span class="line"></span><br><span class="line">        SegmentTree *root = <span class="keyword">new</span> SegmentTree(<span class="number">0</span>, h);</span><br><span class="line">        <span class="comment">// printf("[%d %d]\n", root-&gt;l, root-&gt;r);</span></span><br><span class="line">        root-&gt;build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// printf("root-&gt;data = %d\n", root-&gt;data);</span></span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;modify(x) != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="comment">// root-&gt;print();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteSegTree(root);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树与树状数组专题&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316346&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/316349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第3周_线段树、树状数组专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 4</title>
    <link href="http://ilern.github.io/2019/08/04/acmsummer_24/"/>
    <id>http://ilern.github.io/2019/08/04/acmsummer_24/</id>
    <published>2019-08-04T08:37:23.000Z</published>
    <updated>2019-08-02T11:11:40.382Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练二，题目多为思维题，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/314478#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练二，题目多为思维题，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/314478#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 3</title>
    <link href="http://ilern.github.io/2019/08/01/acmsummer_23/"/>
    <id>http://ilern.github.io/2019/08/01/acmsummer_23/</id>
    <published>2019-08-01T08:37:23.000Z</published>
    <updated>2019-08-02T08:53:43.242Z</updated>
    
    <content type="html"><![CDATA[<p>第二周限时训练一，题目简单且友好，不全和图论有关</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314466#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_限时训练1</a></p><a id="more"></a><h2 id="D-D1-Add-on-a-Tree"><a href="#D-D1-Add-on-a-Tree" class="headerlink" title="D - D1. Add on a Tree"></a><a href="https://cn.vjudge.net/contest/314466#problem/D" target="_blank" rel="noopener">D - D1. Add on a Tree</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一棵树，在这棵树上有这样的操作：选择两个叶节点，将连接他们的路径上的边全部加上某个<strong>实数</strong> 。</p><p>问是否任意的边权都能通过这种方法构造出来。</p><p><img src="https://vj.ti12z.cn/534562b9f71c214456d4ad6501057031?v=1564228755" alt="NO"></p><p>这棵树不满足条件</p><p><img src="https://vj.ti12z.cn/c3350c6775c16b2e8fc87ea1963db02a?v=1564228755" alt="YES"></p><p>这棵树满足条件</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始以为是 <code>LCA</code> 结果是普通的思维题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">        degree[u]++;</span><br><span class="line">        degree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-B-Letters-Shop-二分查找"><a href="#G-B-Letters-Shop-二分查找" class="headerlink" title="G - B. Letters Shop - 二分查找"></a><a href="https://cn.vjudge.net/contest/314466#problem/G" target="_blank" rel="noopener">G - B. Letters Shop - 二分查找</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个字符串 $S$ ，从中取前缀组合成新的字符串，给出目标字符串，输出最小需要的前缀的长度，数据保证目标串一定可以由 $S$ 的前缀的字符重新组合而成。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不关心目标串中字符出现的顺序，只要前缀中相应字符的数目多于目标串中该字符数目即可，先预处理出每个前缀中的每个字母的个数，对于每个目标串，统计其中各个字母的个数，与每个前缀比较，满足条件即可。</p><p>朴素的线性比较会<code>TLE</code>，改成二分查找即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>][s[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) a[i][j] = a[i - <span class="number">1</span>][j];</span><br><span class="line">        a[i][s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line">        fill(b, b + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: s1) &#123;</span><br><span class="line">            b[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[mid][k] &lt; b[k]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; l + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-B-Yet-Another-Crosses-Problem-模拟"><a href="#H-B-Yet-Another-Crosses-Problem-模拟" class="headerlink" title="H - B. Yet Another Crosses Problem - 模拟"></a><a href="https://cn.vjudge.net/contest/314466#problem/H" target="_blank" rel="noopener">H - B. Yet Another Crosses Problem - 模拟</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一些方格图，<br><img src="https://vj.ti12z.cn/b3bf19b1108c5f82bd973def2f3b1a20?v=1564477339" alt="pic1"></p><p><img src="https://vj.ti12z.cn/0f6acf44abaaaf4dade9e99d5c3067c9?v=1564477339" alt="pic2"></p><p>现在需要把一些白格子染成黑色，使得图里存在至少一个<code>cross</code>（如pic2）。</p><p>问最少染几个白格子。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>之前在cf上遇到了这题，当时没做出来。</p><p>其实很简单，要构成<code>cross</code>必须至少有一整行和一整列都是黑色的，那就把每行每列有多少黑色统计出来，枚举每种行列的组合，找出一个黑色数目最多的，把剩下的染上就行了。</p><p>但是有一个问题是，行数和列数的最大值都很大，开二维数组是开不下的。注意到虽然 $n, m$ 都很大，但是 $n \cdot m$ 是不大的，所以用 <code>std::string</code> 数组比较好</p><p>深夜果然容易神志不清。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row[MAXN], col[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'*'</span>) row[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'*'</span>) col[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, row[i] + col[j] - (s[i][j] == <span class="string">'*'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n + m - <span class="number">1</span> - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二周限时训练一，题目简单且友好，不全和图论有关&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314466#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 2 - 1+2</title>
    <link href="http://ilern.github.io/2019/07/31/acmsummer_212/"/>
    <id>http://ilern.github.io/2019/07/31/acmsummer_212/</id>
    <published>2019-07-31T08:37:23.000Z</published>
    <updated>2019-08-03T13:51:31.826Z</updated>
    
    <content type="html"><![CDATA[<p>基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。</p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/314459" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练1</a></p><p><a href="https://cn.vjudge.net/contest/314460" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第2周_专题训练2</a></p><a id="more"></a><h1 id="新的邻接表写法"><a href="#新的邻接表写法" class="headerlink" title="新的邻接表写法"></a>新的邻接表写法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dfn, degree;</span><br><span class="line"></span><br><span class="line">    Node() : dfn(<span class="number">0</span>), degree(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to) : fr(fr), to(to) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v]));</span><br><span class="line">    nodes[v].edges.push_back(Edge(&amp;nodes[v], &amp;nodes[u]));</span><br><span class="line"></span><br><span class="line">    nodes[u].degree++;</span><br><span class="line">    nodes[v].degree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大的好处是多组数据初始化的时候边的删除很方便，尤其相对于之前的版本来说。</p><h1 id="专题一"><a href="#专题一" class="headerlink" title="专题一"></a>专题一</h1><h2 id="C-Skiing-最短路"><a href="#C-Skiing-最短路" class="headerlink" title="C - Skiing - 最短路"></a><a href="https://cn.vjudge.net/contest/314459#problem/C" target="_blank" rel="noopener">C - Skiing - 最短路</a></h2><h2 id="F-Sorting-It-All-Out-拓扑排序"><a href="#F-Sorting-It-All-Out-拓扑排序" class="headerlink" title="F - Sorting It All Out - 拓扑排序"></a><a href="https://cn.vjudge.net/contest/314459#problem/F" target="_blank" rel="noopener">F - Sorting It All Out - 拓扑排序</a></h2><h1 id="专题二"><a href="#专题二" class="headerlink" title="专题二"></a>专题二</h1><h2 id="D-Caterpillar-DFS"><a href="#D-Caterpillar-DFS" class="headerlink" title="D - Caterpillar - DFS"></a><a href="https://cn.vjudge.net/contest/314460#problem/D" target="_blank" rel="noopener">D - Caterpillar - DFS</a></h2><h2 id="E-昂贵的聘礼"><a href="#E-昂贵的聘礼" class="headerlink" title="E - 昂贵的聘礼 "></a><a href="https://cn.vjudge.net/contest/314460#problem/E" target="_blank" rel="noopener">E - 昂贵的聘礼 </a></h2><h2 id="F-最短路径问题-最短路"><a href="#F-最短路径问题-最短路" class="headerlink" title="F - 最短路径问题 - 最短路"></a><a href="https://cn.vjudge.net/contest/314460#problem/F" target="_blank" rel="noopener">F - 最短路径问题 - 最短路</a></h2><h2 id="K-Highways"><a href="#K-Highways" class="headerlink" title="K - Highways "></a><a href="https://cn.vjudge.net/contest/314460#problem/K" target="_blank" rel="noopener">K - Highways </a></h2><h2 id="L-Truck-History"><a href="#L-Truck-History" class="headerlink" title="L - Truck History "></a><a href="https://cn.vjudge.net/contest/314460#problem/L" target="_blank" rel="noopener">L - Truck History </a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础图论专题一二，题目大同小异，从中挑一些不那么裸的题。&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/314460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第2周_专题训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>[Poj 3169] Layout - 差分约束 + spfa</title>
    <link href="http://ilern.github.io/2019/07/30/poj_3169/"/>
    <id>http://ilern.github.io/2019/07/30/poj_3169/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:51:45.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目大意】"><a href="#【题目大意】" class="headerlink" title="【题目大意】"></a>【题目大意】</h3><p>有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。</p><a id="more"></a><h3 id="【题解】"><a href="#【题解】" class="headerlink" title="【题解】"></a>【题解】</h3><p>遇到这题才去学的<a href="https://ilern.github.io/2019/07/30/difference_constraints/">差分约束系统</a>。</p><p>明显题目中给出了关于两元素差的不等式，是差分约束的模型，转化成标准的模式 $a - b \leq c$，建图之后<code>SPFA</code>求出最短路即可，答案为<code>nodes[n].dis</code>。 </p><h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="keyword">int</span> dis, times;</span><br><span class="line">    <span class="keyword">bool</span> inQue;</span><br><span class="line"></span><br><span class="line">    Node() : dis(INT_MAX), times(<span class="number">0</span>), inQue(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Node *fr, *to;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    Edge(Node *fr, Node *to, <span class="keyword">int</span> w) : fr(fr), to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    nodes[u].edges.push_back(Edge(&amp;nodes[u], &amp;nodes[v], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(Node *x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    x-&gt;dis = <span class="number">0</span>;</span><br><span class="line">    x-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">    x-&gt;times++;</span><br><span class="line">    q.push(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *v = q.front();</span><br><span class="line">        v-&gt;inQue = <span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt;::iterator it = v-&gt;edges.begin(); it != v-&gt;edges.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;to-&gt;dis &gt; v-&gt;dis + it-&gt;w) &#123;</span><br><span class="line">                it-&gt;to-&gt;dis = v-&gt;dis + it-&gt;w;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!it-&gt;to-&gt;inQue) &#123;</span><br><span class="line">                    it-&gt;to-&gt;inQue = <span class="literal">true</span>;</span><br><span class="line">                    it-&gt;to-&gt;times++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;to-&gt;times &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    q.push(it-&gt;to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ml, md;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;ml, &amp;md);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u &lt; v) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, -w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; n; i++) addEdge(i, i + 1, 0);</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) addEdge(0, i, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!spfa(nodes + <span class="number">1</span>, n)) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[n].dis == INT_MAX) <span class="built_in">printf</span>(<span class="string">"-2"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[n].dis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目大意】&quot;&gt;&lt;a href=&quot;#【题目大意】&quot; class=&quot;headerlink&quot; title=&quot;【题目大意】&quot;&gt;&lt;/a&gt;【题目大意】&lt;/h3&gt;&lt;p&gt;有一些牛，关系好的两头牛希望彼此距离不大于某个数，关系不好的两头牛希望彼此距离不小于某个数，求奶牛 $1$ 和奶牛 $N$ 之间的最大可能距离。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="差分约束" scheme="http://ilern.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>差分约束系统学习笔记</title>
    <link href="http://ilern.github.io/2019/07/30/difference_constraints/"/>
    <id>http://ilern.github.io/2019/07/30/difference_constraints/</id>
    <published>2019-07-30T15:37:23.000Z</published>
    <updated>2019-07-30T11:38:45.435Z</updated>
    
    <content type="html"><![CDATA[<p>数学问题转化到图论上解决，有点巧妙。</p><a id="more"></a><p>差分约束系统是一种特殊的 $N$ 元一次不等式组。包含 $N$ 个变量，$M$ 个约束条件，每个约束条件都是以差分的形式给出，形如 $X_i - X_j \leq c_k$。</p><p>现在要求 $X_i$ 的一组解，使得所有不等式成立。</p><p>对于这样的问题，有一个统一的转化方法：</p><ul><li>把不等式表示成 $X_i - X_j \leq c_k$ 的形式，</li><li>把每个变量 $X_i$ 看作 <strong>有向图</strong> 中的一个结点 $i$，把每个约束条件 $X_i - X_j \leq c_k$ 看作从 $i$ 到 $j$ 连一条长度为 $c_k$ 的有向边，</li><li>注意到此时建立的图不一定联通，需要添加一个超级源点，从 $0$ 号结点向每个点连一条边权为$0$ 的边。</li><li>用 <strong>spfa</strong> 求出 $0$ 号点到各个点的最短路，如果最短路存在，那么每个点的 <code>dis</code> 值就是原不等式组的一组解。</li><li>如果有负环，则解不存在，为了解决负环的问题，只能用 <strong>spfa</strong> 来求最短路。</li></ul><p>为什么这样是对的？看上去毫不相干的不等式怎么和最短路怎么联系起来的呢？<br><del>其实不知道也没关系</del></p><p><a href="https://blog.csdn.net/PleasantlY1/article/details/82775505" target="_blank" rel="noopener">有空就学</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数学问题转化到图论上解决，有点巧妙。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://ilern.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-4</title>
    <link href="http://ilern.github.io/2019/07/27/acmsummer_14/"/>
    <id>http://ilern.github.io/2019/07/27/acmsummer_14/</id>
    <published>2019-07-27T15:37:23.000Z</published>
    <updated>2019-07-30T10:15:32.607Z</updated>
    
    <content type="html"><![CDATA[<p>第一周限时训练二</p><p><img src="https://s2.ax1x.com/2019/07/30/eJG8hT.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://vjudge.net/contest/312636" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练2</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周限时训练二&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/30/eJG8hT.png&quot; alt=&quot;rank&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/312636&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt;限时训练2&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ACM集训队暑假训练 1-3</title>
    <link href="http://ilern.github.io/2019/07/26/acmsummer_13/"/>
    <id>http://ilern.github.io/2019/07/26/acmsummer_13/</id>
    <published>2019-07-26T15:37:23.000Z</published>
    <updated>2019-07-30T10:07:52.832Z</updated>
    
    <content type="html"><![CDATA[<p>第一周限时训练一</p><p><img src="https://s2.ax1x.com/2019/07/27/euRsht.png" alt="rank"></p><h3 id="【链接】"><a href="#【链接】" class="headerlink" title="【链接】"></a>【链接】</h3><p><a href="https://cn.vjudge.net/contest/312627#overview" target="_blank" rel="noopener">QDU<em>ACM集训队_18级暑假训练</em>第一周<em>复习专题</em>限时训练1</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一周限时训练一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/27/euRsht.png&quot; alt=&quot;rank&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;【链接】&quot;&gt;&lt;a href=&quot;#【链接】&quot; class=&quot;headerlink&quot; title=&quot;【链接】&quot;&gt;&lt;/a&gt;【链接】&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vjudge.net/contest/312627#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QDU&lt;em&gt;ACM集训队_18级暑假训练&lt;/em&gt;第一周&lt;em&gt;复习专题&lt;/em&gt;限时训练1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ilern.github.io/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ilern.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://ilern.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
